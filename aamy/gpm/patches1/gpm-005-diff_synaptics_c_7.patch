--- /home/pebl/synaptics.c_nico	Sun Jun  2 01:39:19 2002
+++ synaptics.c	Sun Jun  2 01:42:48 2002
@@ -74,7 +74,7 @@
 **        mouse. When putting the finger at the right edge, a movement up or
 **        down translates to wheel movement. Taking the finger to the
 **        top/button edge keeps the wheel turning.  Lift the finger again to
-**        operate normally again.
+**        operate normally again. Another option is to do a toss scrolling.
 **
 **  Stick attached to a synaptic touchpad (aka styk)
 **        Some touchpads have a stick "attached", so they share the same port.
@@ -84,10 +84,12 @@
 **        will be reported as left button.
 **
 **  4 Way button attached to a touchpad
-**        Likewise some touchpads have a round button giving the choises of four
-**        way to press the button. The packet is nearly identical to the stick,
-**        turn off the stick if you have this button. This is no longer needed.
-**        The button can act as a mouse or as buttons.
+**        Likewise some touchpads have a round button giving the choices of
+**        four way to press the button. The packet is nearly identical to the
+**        stick, turn off the stick if you have this button. This is no longer
+**        needed.  The button can act as a mouse or as buttons which can be
+**        changed on the fly. The buttons can be configured just as the
+**        touchpads corners.
 **
 **  Four buttons to work
 **        Some touchpads have 4 buttons. Only 3 was read and the last was set to 
@@ -158,11 +160,11 @@
 **   - Allow normal taps in unused corners. 
 **   - Better detection of spontaneous reseting touchpad.
 **   - Implement resend command for serial connection.
-**   - Add toss scrolling with speed parameter.
 **   - Only start scrolling if mostly vertical movement.
 **   - Disable/enable command for serial touchpad.
-**   - Do something about the extended packets in gerenal code but is ps2 only.
 **   - Clean up the mess about extended packets with pressure 0.
+**   - source splitting of normal touchpad functions and synaptic specific and
+**     add other touchpads.
 */
 
 
@@ -286,6 +288,10 @@
 #define RIGHT_EDGE          0x02
 #define TOP_EDGE            0x04
 #define BOTTOM_EDGE         0x08
+#define UP_BUTTON           0x01
+#define DOWN_BUTTON         0x02
+#define LEFT_BUTTON         0x04
+#define RIGHT_BUTTON        0x08
 #define UPPER_LEFT_CORNER   (LEFT_EDGE  | TOP_EDGE)
 #define LOWER_LEFT_CORNER   (LEFT_EDGE  | BOTTOM_EDGE)
 #define UPPER_RIGHT_CORNER  (RIGHT_EDGE | TOP_EDGE)
@@ -312,6 +318,7 @@
                                                /* speed of edge motion     */
 static int pressure_speed_enabled      = 1;  /* does pressure control   C*/
                                                  /* speed in non edges       */
+static int tap_hold_edge_motion_enabled = 1; /* Enable edge motion while holding a tap  C*/
 
 /* pressure induced speed related configuration constants */
 static int   low_speed_pressure      = 60;                                /*C*/
@@ -354,26 +361,28 @@
 
 
 /* mixed configurations */
-static int   touch_pad_enabled       = 1; /* Disable the touch pad, see corner action turn_on_off. C*/
+static int   touchpad_enabled        = 1; /* Disable the touch pad, see corner action turn_on_off. C*/
 static int   stick_enabled           = 1; /* Some machines have a touchpad and a stick on
                                            * same device port. The stick will be ignored in
                                            * absolute mode, this option try to recognize
                                            * it's packets.                                         C*/
-static int   stick_pressure_enabled  = 1; /* A (hard) press on the stick is reported as left click C*/
-static int   four_way_button_enabled = 1; /* Round button giving 4 choises on some toucpads        C*/
+static int   stick_pressure_enabled  = 0; /* A (hard) press on the stick is reported as left click C*/
+static int   four_way_button_enabled = 1; /* Round button giving 4 choices on some touchpads        C*/
 static int   four_way_button_is_mouse= 1; /* Is the button: 4 buttons or does it moves the mouse.  C*/
 static int   scrolling_enabled       = 1; /* Simulate wheel mouse in at the right edge             C*/
 static int   scrolling_edge          = RIGHT_EDGE; /* Which edge is a the scrolling edge           C*/
-static int   scrolling_speed         = 4; /* less is faster, 0 fastest */
+static int   scrolling_speed         = 10;/* less is faster, 1 fastest  */
+static float scrolling_button_factor = 0.5; /* How fast should a button/corner tap scroll, higher faster C*/
 static int   auto_scrolling_enabled  = 1; /* Moving to the upper/lower edge keeps scrolling up/downC*/
-static int   reset_on_error_enabled  = 0; /* If a packet does not comform to any absolute protocol 
+static int   auto_scrolling_factor   = 2.0; /* How fast should autoscrolling be                   C*/
+static int   reset_on_error_enabled  = 0; /* If a packet does not conform to any absolute protocol 
 					   * should we reset the touchpad? This is wrong, because we
 					   * should rather find out why it does that in first place.
 					   * Do not turn it on per default.                         */
 
 
 /*
-** Types for describing corner actions.  When adding a new action, place it as
+** Types for describing actions.  When adding a new action, place it as
 ** the last item. It will break old configurefiles otherwise.
 */
 typedef enum {
@@ -387,16 +396,18 @@
   Turn_On_Off_Action,
   Debug_On_Off_Action,
   Reset_Touchpad_Action,
-  Toggle_Four_Way_Button_Action
+  Toggle_Four_Way_Button_Action,
+  Toggle_Stick_Pressure_Action,
+  Toggle_Scrolling_Action
 } action_type;
 
 
 typedef struct {
-  int         corner_mask;
+  int         action_mask;
   action_type action;
-} corner_action_type;
+} touchpad_action_type;
 
-static corner_action_type corner_actions [] = {
+static touchpad_action_type corner_actions [] = {
   { UPPER_LEFT_CORNER,  No_Action },
   { LOWER_LEFT_CORNER,  No_Action },
   { UPPER_RIGHT_CORNER, Middle_Button_Action },
@@ -404,6 +415,15 @@
   { 0,                  No_Action } /* stop flag value */
 };
 
+
+static touchpad_action_type four_button_action [] = {
+  { UP_BUTTON,          Up_Button_Action },
+  { DOWN_BUTTON,        Down_Button_Action },
+  { LEFT_BUTTON,        Middle_Button_Action },
+  { RIGHT_BUTTON,       Fourth_Button_Action },
+  { 0,                  No_Action } /* stop flag value */
+};
+
 /*
 ** These types are used to read the configuration data from the config file.
 */
@@ -411,7 +431,7 @@
   Integer_Param,
   Float_Param,
   Flag_Param,
-  Corner_Param
+  Action_Param
 } param_type_type;
 
 typedef struct {
@@ -422,7 +442,7 @@
     int   *int_p;
     float *float_p;
     int   *flag_p;
-    corner_action_type *corner_p;
+    touchpad_action_type *corner_p;
   } addr;
 } param_data_type;
 
@@ -435,6 +455,8 @@
   { "pressure_speed_enabled",     Flag_Param,    {&pressure_speed_enabled     }},
   { "tossing_enabled",            Flag_Param,    {&tossing_enabled            }},
   { "does_toss_use_static_speed", Flag_Param,    {&does_toss_use_static_speed }},
+  { "tap_hold_edge_motion_enabled",Flag_Param,   {&tap_hold_edge_motion_enabled}},
+  
   /* pressure induced speed related configuration parameters */		     
   { "low_pressure",               Integer_Param, {&low_speed_pressure         }},
   { "speed_up_pressure",          Integer_Param, {&speed_up_pressure          }},
@@ -454,10 +476,15 @@
   { "y_max_center",               Integer_Param, {&y_max_center               }},
   { "edge_speed",                 Integer_Param, {&edge_speed                 }},
   /* corner tap actions */			 			     
-  { "upper_left_action",          Corner_Param,  {&corner_actions [0]         }},
-  { "lower_left_action",          Corner_Param,  {&corner_actions [1]         }},
-  { "upper_right_action",         Corner_Param,  {&corner_actions [2]         }},
-  { "lower_right_action",         Corner_Param,  {&corner_actions [3]         }},
+  { "upper_left_action",          Action_Param,  {&corner_actions [0]         }},
+  { "lower_left_action",          Action_Param,  {&corner_actions [1]         }},
+  { "upper_right_action",         Action_Param,  {&corner_actions [2]         }},
+  { "lower_right_action",         Action_Param,  {&corner_actions [3]         }},
+  /* 4 way button actions */
+  { "up_button_action",           Action_Param,  {&four_button_action [0]     }},
+  { "down_button_action",         Action_Param,  {&four_button_action [1]     }},
+  { "left_button_action",         Action_Param,  {&four_button_action [2]     }},
+  { "right_button_action",        Action_Param,  {&four_button_action [3]     }},
   /* use wmode */				 			     
   { "wmode_enabled",		  Flag_Param,	 {&wmode_enabled	      }},
   { "drag_lock_enabled",	  Flag_Param,	 {&drag_lock_enabled	      }},
@@ -475,15 +502,17 @@
   { "multi_finger_stop_enabled",  Flag_Param,    {&multi_finger_stop_enabled  }},
   { "multi_finger_stop_delay",    Integer_Param, {&multi_finger_stop_delay    }},
   /* Additional options*/
-  { "touch_pad_enabled",	  Flag_Param,    {&touch_pad_enabled	      }},
+  { "touchpad_enabled", 	  Flag_Param,    {&touchpad_enabled	      }},
   { "stick_enabled",	          Flag_Param,    {&stick_enabled	      }},
   { "stick_pressure_enabled",     Flag_Param,    {&stick_pressure_enabled     }},
   { "four_way_button_enabled",    Flag_Param,    {&four_way_button_enabled    }},
   { "four_way_button_is_mouse",   Flag_Param,    {&four_way_button_is_mouse   }},
   { "scrolling_enabled",	  Flag_Param,    {&scrolling_enabled	      }},
+  { "auto_scrolling_enabled",	  Flag_Param,    {&auto_scrolling_enabled     }},
   { "scrolling_edge",	          Integer_Param, {&scrolling_edge	      }},
   { "scrolling_speed",	          Integer_Param, {&scrolling_speed	      }},
-  { "auto_scrolling_enabled",	  Flag_Param,    {&auto_scrolling_enabled     }},
+  { "scrolling_button_factor",    Float_Param,   {&scrolling_button_factor    }},
+  { "auto_scrolling_factor",      Float_Param,   {&auto_scrolling_factor      }},
   /* end of list */				 			     
   { NULL,                         Flag_Param,    {NULL                        }}
 };
@@ -499,7 +528,7 @@
   int info_minor;
 } info_type;
 
-info_type         ident;
+static info_type ident;
 
 /*
 ** The information returned in the model ID packet.
@@ -527,7 +556,7 @@
   int info_geometry; 
 } model_id_type; 
 
-model_id_type     model;
+static model_id_type model;
 
 /*
 ** The sensor types as of STIG 2.5
@@ -612,7 +641,7 @@
   { "SubMini",   122, 167, 32.8, 18.2 },
 };
 
-sensor_info_type *sensor;
+static sensor_info_type *sensor;
 
 /*
 ** The information returned in the extended capability packet.
@@ -635,7 +664,7 @@
   int cap_palm_detect; 
 } ext_cap_type;
 
-ext_cap_type capabilities;
+static ext_cap_type capabilities;
 
 /*
 ** The information in the mode byte.
@@ -678,7 +707,7 @@
   int w;
 } report_type;
 
-report_type   report;
+static report_type last_report,report;
 
 /*
 ** A location record.
@@ -713,8 +742,6 @@
 static int           tap_upper_limit_packet;
 
 /* toss status information */
-static int           last_fingers = 0;
-static int           last_gesture = 0;
 static int           is_tossing = 0;
 static int           was_tossing = 0;
 static int           min_toss_dist__2;
@@ -727,7 +754,6 @@
 
 
 /* Multi finger information */
-static int           last_pressure = 0;
 static int           was_fingers = 0;
 static int           multi_finger_stop_timer = 0;
 static int           multi_finger_reset_timer;
@@ -737,9 +763,10 @@
 
 
 /* Scrolling information */
-static int           is_scrolling = 0;
+static int           is_scrolling = 0;            /* Scrolling using touchpad edge*/
+static int           is_always_scrolling = 0;     /* Only report scrolling, no mouse movement */
 static int           scrolling_speed_timer = 0;
-
+static int           scrolling_amount_left = 0;   /* Tells how much to scroll up or down */
 
 
 
@@ -751,6 +778,68 @@
 **
 ****************************************************************************/
 
+/*
+** Dump the report data for debugging.
+**
+** Because the synaptics sends (trivial) data in one second after last touch,
+** which makes reading the debug data harder, only dump the report if it is different 
+** than the previously dumped.
+*/
+static void tp_dump_report_data (report_type report,
+				 int edges,
+				 Gpm_Event* state) 
+{
+  static report_type  last_report_reported;
+  static unsigned int times_report_repeated = 0;
+
+
+  report.left   |= state->buttons & GPM_B_LEFT;
+  report.right  |= state->buttons & GPM_B_RIGHT;
+  report.middle |= state->buttons & GPM_B_MIDDLE;
+
+  if (memcmp(&report,&last_report_reported,sizeof(report_type)) == 0){
+    times_report_repeated++;
+    return;
+  }
+
+  /* Was the last report repeated ? */
+  if(times_report_repeated > 0){
+    gpm_report (GPM_PR_DEBUG,"\rSynps2: Last report reported %d times\n",times_report_repeated); 
+    times_report_repeated = 0;
+  }
+
+  last_report_reported = report;
+
+  gpm_report (GPM_PR_DEBUG,
+	      "\rSynps2: %c%c%c%c%c  %4dx%-4d %3d %2d %d  %c%c%c%c  %c%c    %3d%3d %d    %8d %8d %c",
+	      report.fingers ? 'f' : '-',  
+	      report.gesture ? 'g' : '-',
+	      
+	      report.left    ? 'l' : '-',
+	      report.middle  ? 'm' : '-',  
+	      report.right   ? 'r' : '-',
+	      
+	      report.x, report.y, report.pressure,
+	      report.w,was_fingers, 
+	      
+	      edges & LEFT_EDGE   ? 'l' : '-',
+	      edges & RIGHT_EDGE  ? 'r' : '-',
+	      edges & BOTTOM_EDGE ? 'b' : '-',
+	      edges & TOP_EDGE    ? 't' : '-',
+	      
+	      report.gesture && !report.fingers ? 't' : '-',
+	      report.gesture && report.fingers  ? 'd' : '-',
+	      
+	      state->dx,state->dy,state->buttons,
+
+
+	      multi_finger_pressure,multi_finger_xy,
+	      (multi_finger_pressure>4500 && multi_finger_xy>50000? 'f':' '));
+
+}
+
+
+
 /* Get model name, STIG page 11 */
 static char *syn_model_name (int sensor) 
 {
@@ -764,7 +853,7 @@
 /* convert the model id from bits to values 
 *  STIG page 11 
 */
-void extract_model_id_info (int model_int, model_id_type *model) 
+static void syn_extract_model_id_info (int model_int, model_id_type *model) 
 {
   model->info_rot180     = check_bits (model_int,  INFO_ROT180_BITS);
   model->info_portrait   = check_bits (model_int,  INFO_PORTRAIT_BITS);
@@ -793,7 +882,8 @@
 /* Translate the reported data of extended capabilities STIG page 15.  If the
  extended bit is not set it should be assumed that neither of the other
  capabilities is available.*/
-void extract_extended_capabilities(int ext_cap_int, ext_cap_type *cap){
+static void syn_extract_extended_capabilities(int ext_cap_int, ext_cap_type *cap)
+{
 
 # ifdef DEBUG  
   gpm_report(GPM_PR_INFO,"Synaptics Touchpad Capabilities: %02X",ext_cap_int);
@@ -824,7 +914,7 @@
 /*
 ** Check for edges.
 */
-static int syn_edges (location_type loc) 
+static int tp_edges (location_type loc) 
 {
   int edges = 0;
  
@@ -844,68 +934,104 @@
 }
 
 
+/**
+ ** Handle scrolling. The wheel is way too fast to be usefull, so only report
+ ** every scrolling_speed. This function is also called when scrolling is done by
+ ** buttons, which is why DOWN and UP must be removed in the case of not scrolling.
+ */
+
+static void tp_handle_scrolling(Gpm_Event *state)
+{
+  /* Limit the amount of scrolling, so that we do not overrun. */
+  if ( scrolling_amount_left >  256*20 )
+    scrolling_amount_left = 256*20;
+
+  if ( scrolling_amount_left < -256*20 )
+    scrolling_amount_left = -256*20;
+
+  
+  if (scrolling_amount_left > scrolling_speed){
+    scrolling_amount_left -= scrolling_speed;
+    state->buttons |= GPM_B_DOWN;
+  }else if (scrolling_amount_left < -scrolling_speed){
+    scrolling_amount_left += scrolling_speed;
+    state->buttons |= GPM_B_UP;
+  }else {
+    state->buttons &= ~(GPM_B_DOWN | GPM_B_UP);
+  }
+    
+}
+
+
 /*
-** process_corner_taps. 
+** process_action
 **
-** last_corner_action holds the last action because then the second "tap" in
-** Tap hold and two taps do not to be at the corner, we just repeat the
-** action. This function is only called the at the first gesture report; at
-** consecutive gestures, the buttons are repeated other place. Action that
-** should not be repeated should report GPM_B_NONE.
+** Do the action and return a button state for a given action list and mask.
+** Actions that should not be repeated should report GPM_B_NONE (when holding
+** down a button).
 */
-void process_corner_taps (Gpm_Event *state, report_type report) 
+
+static int tp_process_action(touchpad_action_type *action_list, int mask)
 {
   int i = 0;
+  int status = GPM_B_NONE;
 
-  if (corner_taps_enabled && report.gesture &&
-      (is_corner (was_edges) || last_corner_action != GPM_B_NONE)) {
-    last_corner_action = GPM_B_NONE;
-
-    gpm_report (GPM_PR_DEBUG,"\rSynps2: Corner action"); 
+  if (mask == 0){
+    return GPM_B_NONE;
+  }
 
-    while (corner_actions [i].corner_mask) {
-      if (check_bits (was_edges, corner_actions [i].corner_mask)) {
-	switch (corner_actions [i].action) {
+  while (action_list [i].action_mask) {
+    if (check_bits (mask, action_list [i].action_mask)) {
+      switch (action_list [i].action) {
 	case Left_Button_Action:
-	  last_corner_action = GPM_B_LEFT;
+	status |= GPM_B_LEFT;
 	  break;
 	case Middle_Button_Action:
-	  last_corner_action = GPM_B_MIDDLE;
+	status |= GPM_B_MIDDLE;
 	  break;
 	case Right_Button_Action:
-	  last_corner_action = GPM_B_RIGHT;
+	status |= GPM_B_RIGHT;
 	  break;
 	case Fourth_Button_Action:
-	  last_corner_action = GPM_B_FOURTH;
+	status |= GPM_B_FOURTH;
 	  break;
         case Up_Button_Action:
-          last_corner_action = GPM_B_UP;
+	scrolling_amount_left += scrolling_button_factor * scrolling_speed;
+	status = GPM_B_UP;
           break;
         case Down_Button_Action:
-          last_corner_action = GPM_B_DOWN;
+	scrolling_amount_left -= scrolling_button_factor * scrolling_speed;
+	status = GPM_B_DOWN;
           break;
 	case Turn_On_Off_Action:
-	  touch_pad_enabled = !touch_pad_enabled;
-	  last_corner_action = GPM_B_NONE;
+	touchpad_enabled = !touchpad_enabled;
+	status = GPM_B_NONE;
 	  break;
 	case Debug_On_Off_Action:
 #         ifdef DEBUG_SYNAPTIC
 	    debug_syn_to_stderr = !debug_syn_to_stderr;
 #         endif
-	  last_corner_action = GPM_B_NONE;
+	status = GPM_B_NONE;
 	  break;
 	case Reset_Touchpad_Action:
 	  syn_ps2_reset(which_mouse->fd);
 	  syn_ps2_absolute_mode(which_mouse->fd);
-	  last_corner_action = GPM_B_NONE;
+	status = GPM_B_NONE;
 	  break;
 	case Toggle_Four_Way_Button_Action:
 	  four_way_button_is_mouse = !four_way_button_is_mouse;
-	  last_corner_action = GPM_B_NONE;
+	status = GPM_B_NONE;
+	break;
+      case Toggle_Stick_Pressure_Action:
+	stick_pressure_enabled = !stick_pressure_enabled;
+	status = GPM_B_NONE;
 	  break;
+      case Toggle_Scrolling_Action:
+	is_always_scrolling = !is_always_scrolling;
+	status = GPM_B_NONE;
 	case No_Action:
 	default:
-	  last_corner_action = GPM_B_NONE;
+	status = GPM_B_NONE;
 	  break;
 	}
       }
@@ -913,93 +1039,54 @@
       i++;
     }
 
-    state->buttons |= last_corner_action;
-  } else {
-    last_corner_action = GPM_B_NONE;
-  }
+  return status;
 }
 
+
 /*
-** Dump the report data for debugging.
+** process_corner_taps. 
 **
-** Because the synaptics sends (trivial) data in one second after last touch,
-** which makes reading the debug data harder, only dump the report if it is different 
-** than the previously dumped.
+** last_corner_action holds the last action because then the second "tap" in
+** Tap hold and two taps do not have to be at the corner, we just repeat the
+** action. This function is only called the at the first gesture report; at
+** consecutive gestures, the buttons are repeated other place. Action that
+** should not be repeated should report GPM_B_NONE.
 */
-static void dump_report_data (report_type report,
-			      int edges,
-			      Gpm_Event* state) 
+static void tp_process_corner_taps (Gpm_Event *state, report_type report) 
 {
-  static report_type  last_report;
-  static unsigned int times_report_repeated = 0;
-
+  if (corner_taps_enabled && report.gesture &&
+      (is_corner (was_edges) || last_corner_action != GPM_B_NONE)) {
 
-  report.left   |= state->buttons & GPM_B_LEFT;
-  report.right  |= state->buttons & GPM_B_RIGHT;
-  report.middle |= state->buttons & GPM_B_MIDDLE;
+    gpm_report (GPM_PR_DEBUG,"\rTouchpad: Corner action"); 
+    last_corner_action = tp_process_action(corner_actions,was_edges);
 
-  if (memcmp(&report,&last_report,sizeof(report_type)) == 0){
-    times_report_repeated++;
-    return;
-  }
-
-  /* Was the last report repeated ? */
-  if(times_report_repeated > 0){
-    gpm_report (GPM_PR_DEBUG,"\rSynps2: Last report reported %d times\n",times_report_repeated); 
-    times_report_repeated = 0;
+    state->buttons |= last_corner_action;
+  } else {
+    last_corner_action = GPM_B_NONE;
   }
-
-  last_report = report;
-
-  gpm_report (GPM_PR_DEBUG,
-	      "\rSynps2: %c%c%c%c%c  %4dx%-4d %3d %2d %d  %c%c%c%c  %c%c    %3d%3d %d    %8d %8d %c",
-	      report.fingers ? 'f' : '-',  
-	      report.gesture ? 'g' : '-',
-	      
-	      report.left    ? 'l' : '-',
-	      report.middle  ? 'm' : '-',  
-	      report.right   ? 'r' : '-',
-	      
-	      report.x, report.y, report.pressure,
-	      report.w,was_fingers, 
-	      
-	      edges & LEFT_EDGE   ? 'l' : '-',
-	      edges & RIGHT_EDGE  ? 'r' : '-',
-	      edges & BOTTOM_EDGE ? 'b' : '-',
-	      edges & TOP_EDGE    ? 't' : '-',
-	      
-	      report.gesture && !report.fingers ? 't' : '-',
-	      report.gesture && report.fingers  ? 'd' : '-',
-	      
-	      state->dx,state->dy,state->buttons,
-
-
-	      multi_finger_pressure,multi_finger_xy,
-	      (multi_finger_pressure>4500 && multi_finger_xy>50000? 'f':' '));
-
 }
 
 
-/**
-** Preprocess the report even before doing wmode stuff.
-** Is always called directly after the conversion to check the data received.
-** return 0 if it is reasonable, 1 if there is something wrong.
+
+/*
+** syn_ps2_process_extended_packets
 **
-** Checks for correct data package, palm on the pad, number of fingers.
+** The internal synaptics ps2 touchpads can have extra devices attached (stick,
+** 4 way button) to them, and they reports there state as special embedded
+** packets. These attached devices are handled here.
+**
+** The function returns 1 if it does not make sense to continue normal touchpad
+** processing, 0 otherwise.
 **            
+** I dont think that the external touchpads (serial) can have the same devices
+** attached.  This code should be moved to ps2 specific part, but it is easy to
+** have it here.
 */
 
-static int syn_preprocess_report ( unsigned char *data, 
+static int syn_ps2_process_extended_packets( unsigned char *data, 
 				   report_type *report,
-				   Gpm_Event *state){
-
-  static int fake_extra_finger;
-  static int was_fake_pressure;
-
-  /* initialize the state */
-  state->buttons = 0;
-  state->dx      = 0;
-  state->dy      = 0;
+					     Gpm_Event *state)
+{
 
   /* Sanity check of data. */
   if (report->pressure == 0 && (report->x != 0 || report->y != 0) ){
@@ -1011,7 +1098,7 @@
     /* Allow some simultaneously uses: tap hold on touchpad, then extended movement. */
     state->buttons |= last_state.buttons;
 
-    /* Stick invarient bits (I hope). See absolute packets */
+    /* Stick invariant bits (I hope). See absolute packets */
     /* Stick pressed: The stick do only generates one packet, so double tap is
      * a problem; squeezing in a non-clicked state. It is probably not a real
      * problem, as it is hard not to move the stick a little between pressing,
@@ -1074,16 +1161,20 @@
 	}else{ 
 	  /* Report buttons */
 	  if (report->x & 1) /* UP */
-	    state->buttons |= GPM_B_UP;
+	    state->buttons |= tp_process_action(four_button_action,UP_BUTTON);
 	  if (report->y & 1) /* DOWN */
-	    state->buttons |= GPM_B_DOWN;
+	    state->buttons |= tp_process_action(four_button_action,DOWN_BUTTON);
 	  if (report->x & 2) /* LEFT */
-	    state->buttons |= GPM_B_MIDDLE;
+	    state->buttons |= tp_process_action(four_button_action,LEFT_BUTTON);
 	  if (report->y & 2) /* RIGHT */
-	    state->buttons |= GPM_B_FOURTH;
+	    state->buttons |= tp_process_action(four_button_action,RIGHT_BUTTON);
 	}
       }
 
+      if ( scrolling_amount_left != 0 ){
+	tp_handle_scrolling(state);
+      }
+
       return 1;
     } 
 
@@ -1094,6 +1185,25 @@
     return 1;
   }
 
+  return 0;
+}
+
+/**
+** Preprocess the report even before doing wmode stuff.
+** Is always called directly after the conversion to check the data received.
+** return 0 if it is reasonable, 1 if there is something wrong.
+**
+** Checks for correct data package, palm on the pad, number of fingers.
+**            
+*/
+
+static int tp_preprocess_report ( report_type *report,
+				  Gpm_Event *state)
+{
+
+  static int fake_extra_finger;
+  static int was_fake_pressure;
+
   /* Check whether there is a palm on the pad */
   /* STIG page 9: Values of w, vary from pad to pad. It is not precise when pressure is small < 25.
    * 4-7  finger of normal width
@@ -1143,9 +1253,9 @@
         multi_finger_xy = 0;
 #     endif
     }else
-      if (report->fingers + fake_extra_finger == last_fingers){
+      if (report->fingers + fake_extra_finger == last_report.fingers){
 
-	multi_finger_pressure = sqr(report->pressure) - sqr(last_pressure);
+	multi_finger_pressure = sqr(report->pressure) - sqr(last_report.pressure);
 	multi_finger_xy = (sqr(last_locs [mod4 (packet_num - 1)].x - report->x) +
 			   sqr(last_locs [mod4 (packet_num - 1)].y - report->y) );
 
@@ -1160,7 +1270,7 @@
 	    was_fake_pressure =  report->pressure;
 
 	}/* Check for third finger. */
-	else if(last_pressure > 180 && (report->fingers + fake_extra_finger) == 2 &&
+	else if(last_report.pressure  > 180  && (report->fingers + fake_extra_finger) == 2 &&
 		 multi_finger_pressure > 4500 && multi_finger_xy > 2*sqr((double)tap_range)){
 	  fake_extra_finger = 2;
 	  was_fake_pressure = report->pressure;
@@ -1171,7 +1281,7 @@
 
 	} else if(multi_finger_pressure < -5000 && multi_finger_xy > 2*sqr((double)tap_range)){
 	  /* Probably missed a placed multi finger, as this is one removed! */
-	  last_fingers ++;
+	  last_report.fingers ++;
 	}
       }
     
@@ -1184,8 +1294,8 @@
   if (multi_finger_stop_enabled){
 
     /* Is a finger added or removed since last packet? */
-    if( (report->fingers > 1 && report->fingers > last_fingers) ||
-	(last_fingers    > 1 && report->fingers < last_fingers) ){
+    if( (report->fingers     > 1 && report->fingers > last_report.fingers) ||
+	(last_report.fingers > 1 && report->fingers < last_report.fingers) ){
 
       /* Updating the timer right after another added/removed finger,
        * would make the undo moving become redo, so dont.*/
@@ -1194,8 +1304,8 @@
 
 #     ifdef DEBUG_MULTI_FINGER
       gpm_report (GPM_PR_DEBUG,"%s multi finger %d %d %d",
-		  report->fingers > last_fingers ? "Add":"Remove",
-		  last_fingers,report->fingers,fake_extra_finger);
+		  report->fingers > last_report.fingers ? "Add":"Remove",
+		  last_report.fingers,report->fingers,fake_extra_finger);
 #     endif
       
     } /* Should be tested last, because of undo moving when removing fingers. */
@@ -1243,7 +1353,7 @@
 
 
 /** 
-** syn_process_wmode_report
+** tp_process_wmode_report
 ** Process the report from a wmode enabled device.  No gesture calculation is
 ** done by the device in wmode, so the find tap and drag hold and tap hold gestures.
 **
@@ -1314,7 +1424,8 @@
 */
 
 
-static void syn_process_wmode_report (report_type *report) {
+static void tp_process_wmode_report (report_type *report) 
+{
   static int finger_on_pad_timer = 0;
   static int time_to_forget_tap = 0;
   static int gesture_delay = 0;
@@ -1389,7 +1500,7 @@
 
 
 /*
-** syn_process_report
+** tp_process_report
 **
 ** Process the touchpad report. Do tossing mechanism, edge mechanism (edge
 ** extension, corner taps), speed pressure.
@@ -1412,7 +1523,7 @@
 ** 
 **
 */
-static void syn_process_report (Gpm_Event *state,
+static void tp_process_report (Gpm_Event *state,
 				report_type report) 
 {
   location_type loc;
@@ -1425,7 +1536,7 @@
   /* extract location and edges */
   loc.x = report.x;
   loc.y = report.y;
-  edges = syn_edges (loc);
+  edges = tp_edges (loc);
 
 
   if (report.fingers > 0) {
@@ -1438,7 +1549,7 @@
       is_tossing  = 0;
       
       /* if we start tossing then this is from where */
-      if (last_fingers == 0) {
+      if (last_report.fingers == 0) {
 	touch_loc = loc;
       }
     }
@@ -1453,26 +1564,28 @@
 
       /* Is this start of scrolling? */
       if (scrolling_enabled && !is_scrolling)
-	is_scrolling  = ((edges & scrolling_edge)  &&
+	is_scrolling  = ((edges & scrolling_edge)  && /* Note: only one &! */
 			 !was_non_edge         && /* Must start at edge */
-			 !last_gesture         && /* No consecutive tap */
+			 !last_report.gesture  && /* No consecutive tap */
 			 (!corner_taps_enabled || /* Corner disabled or */
 			  !is_corner (edges)));   /* no corner          */
 
 
       /* 
-      ** if edge motion is enabled, only activate if we moved into the edge or
-      ** if not using the corners.  Dont activate right away after a gesture
-      ** from a corner tap. No harm is done if activated when scrolling (as
-      ** long as the scrolling edge is vertical).
+      ** 1) if edge motion is enabled, only activate if we moved into the edge or
+      ** if not using the corners taps.  Dont activate right away after a gesture
+      ** from a corner tap. 2) No harm is done if activated when scrolling (as
+      ** long as the scrolling edge is vertical). 3)If user is tap holding (then
+      ** he cannot lift the finger and hit the touchpad boarder).
       */
-      edge_motion_on = (edges  &&
-			((auto_scrolling_enabled && is_scrolling) ||
-			 (edge_motion_enabled   &&
+
+      edge_motion_on  = (edges && edge_motion_enabled &&
 			  (was_non_edge         || 
 			   !corner_taps_enabled ||
-			   (!is_corner(edges) && !last_gesture)))));
-
+			  (!is_corner(edges) && !last_report.gesture)));
+      edge_motion_on |= (edges && auto_scrolling_enabled && is_scrolling);
+      edge_motion_on |= (edges && tap_hold_edge_motion_enabled && last_report.gesture && 
+			 was_non_edge);
 
 
       /* compute the speed factor based on pressure */
@@ -1492,6 +1605,10 @@
 			       pressure_speed_factor :
 			       standard_speed_factor);
       
+      if ( auto_scrolling_enabled && is_scrolling ){
+	edge_speed_factor *= 1.0 + auto_scrolling_factor; 
+      }
+
 
       /* Calculate dx and dy depending on whether we are at an edge */
 
@@ -1565,32 +1682,23 @@
     packet_num = 0;
   }
 
-  /* if we are scrolling then stop moving and report wheel.
-  *  The wheel is way too fast to be usefull, so only report every 
-  *  scrolling_speed. */
-  if (scrolling_enabled && is_scrolling){
-    if (scrolling_speed_timer > 0){
-      scrolling_speed_timer--;
-    }else{
-      scrolling_speed_timer = scrolling_speed;
 
-      if (state->dy > 0)
-	state->buttons |= GPM_B_DOWN;
-      else if (state->dy < 0)
-	state->buttons |= GPM_B_UP;
+  /* if we are tossing then apply the toss speed */
+  if (tossing_enabled && is_tossing) {
+    state->dx = toss_speed.x;
+    state->dy = toss_speed.y;
     }
 
+
+  /* if we are scrolling then stop moving and report wheel amount. */
+  if ((scrolling_enabled && is_scrolling) ||
+      is_always_scrolling){
+    scrolling_amount_left += state->dy;
     state->dx = 0;
     state->dy = 0;
   }
 
 
-  /* if we are tossing then apply the toss speed */
-  if (tossing_enabled && is_tossing) {
-    state->dx = toss_speed.x;
-    state->dy = toss_speed.y;
-  }
-  
   /* check for (corner)buttons if we didn't just complete a toss or is scrolling */
   if (!is_tossing && !was_tossing && !is_scrolling) {
     /*
@@ -1602,7 +1710,7 @@
 	!report.left && !report.right && !report.middle && !report.fourth &&
 	!report.up && !report.down ) {
       state->buttons = GPM_B_NONE;
-    } else if (last_gesture) {
+    } else if (last_report.gesture) {
       state->buttons = last_state.buttons;
     } else {
       if (report.left)   state->buttons |= GPM_B_LEFT;
@@ -1631,10 +1739,15 @@
 
       }
 
-      process_corner_taps (state, report);
+      tp_process_corner_taps (state, report);
     }
   }
 
+  /* Is there any amount of scrolling left?  Should be checked after corner actions. */
+  if (scrolling_amount_left != 0){
+    tp_handle_scrolling(state);
+  }
+
 
   was_tossing  = was_tossing && toss_timer;
   if (was_tossing)
@@ -1642,22 +1755,19 @@
 
 
   /* remember the last state of the finger for toss processing */
-  last_fingers  = report.fingers;
-  last_gesture  = report.gesture;
-  last_pressure = report.pressure; 
-
+  last_report   = report;
   last_state    = *state;
 
   /* Dont do anything if the pad is not enabled, but after corner actions are
    * done so it can be turn on again. */
-  if (!touch_pad_enabled){
+  if (!touchpad_enabled){
     state->buttons = GPM_B_NONE;
     state->dx      = 0;
     state->dy      = 0;
   }
 
 #if DEBUG_REPORTS
-  dump_report_data (report, edges, state);
+  tp_dump_report_data (report, edges, state);
 #endif
 
 }
@@ -1669,16 +1779,25 @@
 ** Read the configuration data from the global config file
 ** SYSCONFDIR "/gpm-syn.conf".
 */
-void syn_read_config_file () 
+void tp_read_config_file (char* config_filename) 
 {
   char line [80];
   char *token;
   char *end_ptr;
   int param;
   FILE *config;
+  char full_filename[100];
+  int  status;
+
+  status = snprintf(full_filename,100,SYSCONFDIR "/%s",config_filename);
+  if (status < 0) {
+    gpm_report (GPM_PR_WARN,"Too long path for configure file: %s", config_filename); 
+    return;
+  }
+
 
-  if ( !(config = fopen (SYSCONFDIR "/gpm-syn.conf", "r")) ) {
-    gpm_report (GPM_PR_WARN,"Failed to open configfile: %s", SYSCONFDIR "/gpm-syn.conf");    
+  if ( !(config = fopen (full_filename, "r")) ) {
+    gpm_report (GPM_PR_WARN,"Failed to open configfile: %s", full_filename);    
   }else{
     while (fgets (line, 80, config)) {
       if (line [0] == '[') {
@@ -1739,7 +1858,7 @@
 #             endif
 	      break;
 
-	    case Corner_Param:
+	    case Action_Param:
 	      param_data [param].addr.corner_p->action = strtol (token,
 								 &end_ptr, 0);
 	      if (end_ptr == token)
@@ -1776,7 +1895,7 @@
   gpm_report (GPM_PR_INFO, "     Firmware version %d.%d\n",
 	      ident.info_major, ident.info_minor);
 
-  syn_read_config_file ();
+  tp_read_config_file ("gpm-syn.conf");
 
   /* Save important information */
   x_per_mm = sensor->x_per_mm;
@@ -1837,7 +1956,7 @@
 
 
 
-static unsigned char hextoint (unsigned char byte1,
+static unsigned char tp_hextoint (unsigned char byte1,
 			       unsigned char byte2) 
 {
   unsigned char bytes [3];
@@ -1850,7 +1969,7 @@
   return result;
 }
 
-static void ser_flush_input (int fd) 
+static void tp_serial_flush_input (int fd) 
 {
   struct timeval tv;
   fd_set rfds;
@@ -1878,7 +1997,7 @@
   }
 }
 
-static void ser_read (int fd,
+static void tp_serial_read (int fd,
 		      unsigned char *bytes,
 		      int count) 
 {
@@ -1906,15 +2025,15 @@
   }
 }
 
-/* use the Synaptics extended serial syntax to write a command */
-static void ser_send_cmd(int fd,
+/* Write a string of commands */
+static void tp_serial_send_cmd(int fd,
 			 unsigned char *cmd) 
 {
   unsigned char junk [15];
 
-  ser_flush_input (fd);
+  tp_serial_flush_input (fd);
   write (fd, cmd, strlen (cmd));
-  ser_read (fd, junk, strlen (cmd));
+  tp_serial_read (fd, junk, strlen (cmd));
 #if DEBUG_FLUSH
   junk [strlen (cmd)] = '\0';
   gpm_report (GPM_PR_DEBUG,"serial tossing: %s", junk);
@@ -1922,7 +2041,7 @@
 }
 
 /* write 'mode' to a serial touchpad, STIG 58 */
-static void syn_set_serial_mode (int fd,
+static void syn_serial_set_mode (int fd,
 				 unsigned char mode) 
 {
   unsigned char bytes [15];
@@ -1931,17 +2050,17 @@
 #if DEBUG_SENT_DATA
   gpm_report (GPM_PR_DEBUG,"modes: %s", bytes);
 #endif
-  ser_send_cmd (fd, bytes);
+  tp_serial_send_cmd (fd, bytes);
 }
 
 /* read the identification from the serial touchpad, STIG 57*/
-static void syn_read_serial_ident (int fd,
+static void syn_serial_read_ident (int fd,
 				   info_type *info) 
 {
   unsigned char bytes [5];
 
-  ser_send_cmd (fd, "%A");
-  ser_read (fd, bytes, 4);
+  tp_serial_send_cmd (fd, "%A");
+  tp_serial_read (fd, bytes, 4);
 
 #if DEBUG_SENT_DATA
   bytes [4] = '\0';
@@ -1966,7 +2085,7 @@
 
 
 /* read the model_id from the serial touchpad (in ps/2 format) */
-static void syn_read_serial_model_id (int fd,
+static void syn_serial_read_model_id (int fd,
 				      model_id_type *model) 
 {
   unsigned char bytes [7];
@@ -1981,13 +2100,13 @@
    */
   if ( (ident.info_major >= 4) ||
        (ident.info_major == 3 && ident.info_minor >= 2)){
-    ser_send_cmd (fd, "%D");
-    ser_read (fd, bytes, 6);
+    tp_serial_send_cmd (fd, "%D");
+    tp_serial_read (fd, bytes, 6);
 
     /* reformat the data */
-    model_int = ((hextoint (bytes [0], bytes [1]) << 16) |
-		 (hextoint (bytes [2], bytes [3]) << 8) |
-		 (hextoint (bytes [4], bytes [5])));
+    model_int = ((tp_hextoint (bytes [0], bytes [1]) << 16) |
+		 (tp_hextoint (bytes [2], bytes [3]) << 8) |
+		 (tp_hextoint (bytes [4], bytes [5])));
     
 #   if DEBUG_SENT_DATA
       bytes [6] = '\0';
@@ -1998,19 +2117,19 @@
     model_int = 0;
   }
 
-  extract_model_id_info (model_int, model);
+  syn_extract_model_id_info (model_int, model);
 }
 
 
 /* read the mode bytes and capabilities from the serial touchpad, STIG 57 */
-static void syn_read_serial_cap (int fd,
+static void syn_serial_read_cap (int fd,
 				 ext_cap_type *cap) 
 {
   unsigned char bytes [8];
   int cap_int = 0;
 
-  ser_send_cmd (fd, "%B");
-  ser_read (fd, bytes, 8);
+  tp_serial_send_cmd (fd, "%B");
+  tp_serial_read (fd, bytes, 8);
 
 #if DEBUG_SENT_DATA
   bytes [7] = '\0';
@@ -2019,14 +2138,14 @@
 
   if (ident.info_major >= 4){
     if (bytes [0] == '3' && bytes [0] == 'B'){
-      cap_int = ((hextoint (bytes [4], bytes [5]) << 8) |
-		 (hextoint (bytes [6], bytes [7])));
+      cap_int = ((tp_hextoint (bytes [4], bytes [5]) << 8) |
+		 (tp_hextoint (bytes [6], bytes [7])));
     }else{
       gpm_report (GPM_PR_ERR,"PS/2 serial device doesn't appear to be a synaptics touchpad\n");
     }    
   }
 
-  extract_extended_capabilities(cap_int,cap);
+  syn_extract_extended_capabilities(cap_int,cap);
 }
 
 
@@ -2071,7 +2190,7 @@
 #define PS2_ERROR         0xFC      /* Error, after a reset,resend or disconnect*/
 #define PS2_ACK           0xFA      /* Command acknowledge */
 #define PS2_READY         0xAA      /* Send after a calibration or ERROR */
-#define PS2_MOUSE_IDCODE  0x00      /* Identification code (meaning mouse) sent after a PS_READY */
+#define PS2_MOUSE_IDCODE  0x00      /* Identification code (meaning mouse) sent after a PS2_READY */
 
 
 /* Additional synaptic commands*/
@@ -2079,7 +2198,7 @@
 #define PS2_SYN_INERT     0xE6      /* This ps2 command is ignored by synaptics */
 #define PS2_SYN_SET_MODE1 0x0A      /* Set the mode byte 1 instead of sample rate (used after a sample rate cmd) */
 #define PS2_SYN_SET_MODE2 0x14      /* Set the mode byte 2 instead of sample rate (used after a sample rate cmd).
-				     * All other sample rate gives undefined behavior (used to adresse 4 byte mode)*/
+				     * All other sample rate gives undefined behavior (used to address 4 byte mode)*/
 #define PS2_SYN_STATUS_OK 0x47      /* Special synaptics Status report is recognized */
 
 
@@ -2098,7 +2217,7 @@
 typedef unsigned char byte;
 
 /* read a byte from the ps/2 port */
-static byte ps2_getbyte(int fd) 
+static byte tp_ps2_getbyte(int fd) 
 {
   byte b;
 
@@ -2108,7 +2227,7 @@
 
 
 /* write a byte to the ps/2 port, handling ACK and resend.*/
-static void ps2_putbyte(int fd,
+static void tp_ps2_putbyte(int fd,
 			byte b) 
 {
   byte ack;
@@ -2128,42 +2247,50 @@
 * either  PS2_SAMPLE_RATE or PS2_STATUS_REQ. It is hinted to send an inert command
 * first so not having five or more PS2_SYN_CMD by coincident.
 */
-static void ps2_send_cmd(int fd,
+static void syn_ps2_send_cmd(int fd,
 			 byte cmd) 
 {
   int i;
 
   /* initialize with 'inert' command */
-  ps2_putbyte(fd, PS2_SYN_INERT);
+  tp_ps2_putbyte(fd, PS2_SYN_INERT);
   for (i=0; i<4; i++) {
-    ps2_putbyte(fd, PS2_SYN_CMD);
-    ps2_putbyte(fd, (cmd>>6)&0x3);
+    tp_ps2_putbyte(fd, PS2_SYN_CMD);
+    tp_ps2_putbyte(fd, (cmd>>6)&0x3);
     cmd<<=2;
   }
 }
 
+#if 0
+
 /* write 'cmd' to mode byte 1.
  * This function is not used. 
  * Code 0x0A is unknown to me, maybe used in older synaptics?
+ *
+ * This is used for some old 2 byte control synaptics. The function is not
+ * used, and is probably leftover from mixing with Van der Plas code.
  */
-static void ps2_set_mode1(int fd,
+static void syn_ps2_set_mode1(int fd,
 			  byte cmd) 
 {
-  ps2_send_cmd(fd, cmd);
-  ps2_putbyte(fd, PS2_SAMPLE_RATE);
-  ps2_putbyte(fd, PS2_SYN_SET_MODE1);
+  syn_ps2_send_cmd(fd, cmd);
+  tp_ps2_putbyte(fd, PS2_SAMPLE_RATE);
+  tp_ps2_putbyte(fd, PS2_SYN_SET_MODE1);
 }
 
+#endif
+
+
 /* write 'cmd' to mode byte 2 
  * See ps2_send_cmd. PS2_SR_SET_MODE stores the touchpad mode encoded in the 
  * four PS2_SYN_CMD commands
  */
-static void ps2_set_mode2(int fd,
+static void syn_ps2_set_mode2(int fd,
 			  byte cmd) 
 {
-  ps2_send_cmd(fd, cmd);
-  ps2_putbyte(fd, PS2_SAMPLE_RATE);
-  ps2_putbyte(fd, PS2_SYN_SET_MODE2);
+  syn_ps2_send_cmd(fd, cmd);
+  tp_ps2_putbyte(fd, PS2_SAMPLE_RATE);
+  tp_ps2_putbyte(fd, PS2_SYN_SET_MODE2);
 }
 
 
@@ -2172,38 +2299,41 @@
 *  Special status request for synaptics is given after a cmd.
 *  Byte b is PS2_SYN_STATUS_OK to recognize a synaptics
 */
-static void ps2_status_rqst(int fd,
+static void syn_ps2_status_rqst(int fd,
 			    byte cmd,
 			    byte *bytes) 
 {
-  ps2_send_cmd(fd, cmd);
-  ps2_putbyte(fd, PS2_STATUS_REQ);
-  bytes [0]=ps2_getbyte(fd);
-  bytes [1]=ps2_getbyte(fd);
-  bytes [2]=ps2_getbyte(fd);
+  syn_ps2_send_cmd(fd, cmd);
+  tp_ps2_putbyte(fd, PS2_STATUS_REQ);
+  bytes [0]=tp_ps2_getbyte(fd);
+  bytes [1]=tp_ps2_getbyte(fd);
+  bytes [2]=tp_ps2_getbyte(fd);
 }
 
 
+#if 0
+
 /* read the modes from the touchpad (in ps/2 format) */
-static void syn_read_ps2_modes (int fd) 
+static void syn_ps2_read_modes (int fd) 
 {
   unsigned char bytes [3];
 
-  ps2_status_rqst (fd, PS2_SYN_CMD_MODES, bytes);
+  syn_ps2_status_rqst (fd, PS2_SYN_CMD_MODES, bytes);
 # ifdef DEBUG
   gpm_report (GPM_PR_INFO,"Synaptic PS/2 touchpad modes: %02X", bytes [2]);
 # endif
 }
 
+#endif
 
 
 /* read the identification from the ps2 touchpad */
-static void syn_read_ps2_ident (int fd,
+static void syn_ps2_read_ident (int fd,
 				info_type *info) 
 {
   byte bytes [3];
 
-  ps2_status_rqst (fd, PS2_SYN_CMD_IDENTIFY, bytes);
+  syn_ps2_status_rqst (fd, PS2_SYN_CMD_IDENTIFY, bytes);
   if (bytes [1] != PS2_SYN_STATUS_OK) {
     gpm_report (GPM_PR_ERR,"PS/2 device doesn't appear to be a synaptics touchpad\n");
     info->info_minor      = 0;
@@ -2219,30 +2349,30 @@
 
 
 /* read the model_id from the ps2 touchpad */
-static void syn_read_ps2_model_id (int fd,
+static void syn_ps2_read_model_id (int fd,
 				   model_id_type *model) 
 {
   unsigned char bytes [3];
   int model_int;
 
-  ps2_status_rqst (fd, PS2_SYN_CMD_MODEL_ID, bytes);
+  syn_ps2_status_rqst (fd, PS2_SYN_CMD_MODEL_ID, bytes);
   model_int = ((bytes [0] << 16) |
 	       (bytes [1] << 8)  |
 	       (bytes [2]));
-  extract_model_id_info (model_int, model);
+  syn_extract_model_id_info (model_int, model);
 }
 
 
 
 
 /* read the extended capability from the ps2 touchpad, STIG page 15 */
-static void syn_read_ps2_cap (int fd,
+static void syn_ps2_read_cap (int fd,
                               ext_cap_type *cap)
 {
   unsigned char bytes [3];
   int ext_cap_int;
 
-  ps2_status_rqst (fd, PS2_SYN_CMD_CAPABILITIES, bytes);
+  syn_ps2_status_rqst (fd, PS2_SYN_CMD_CAPABILITIES, bytes);
 
   if (bytes [1] != PS2_SYN_STATUS_OK) {
     gpm_report (GPM_PR_ERR,"PS/2 device doesn't appear to be a synaptics touchpad\n");
@@ -2251.15 +2381.15 @@
     ext_cap_int = bytes[0] << 8 | bytes[2];
   }
 
-  extract_extended_capabilities(ext_cap_int, cap);
+  syn_extract_extended_capabilities(ext_cap_int, cap);
 }
 
 
 
 /*
- * syn_ps2_disable_data
+ * ps2_disable_data
  *
- * Disable data reporting (streaming), and flush eventuel old packets. As the
+ * Disable data reporting (streaming), and flush eventual old packets. As the
  * kernel keeps a queue of received data from the touchpad, the next byte we
  * read could be old data and not the ack to our command or request.  Disable
  * data should always be called before sending commands or request to the
@@ -2268,7 +2398,7 @@
  * Note that this is a general ps2 command which should not be in this file,
  * but in mice.c.
  */
-static void syn_ps2_disable_data (int fd) 
+static void tp_ps2_disable_data (int fd) 
 {
   struct timeval tv;
   fd_set rfds;
@@ -2288,7 +2418,7 @@
   while (select (fd+1, &rfds, NULL, NULL, &tv) == 1) {
     read (fd, &status, 1);
 #if DEBUG_RESET
-    gpm_report (GPM_PR_INFO,"synps2 disable data flush: %02X", status);
+    gpm_report (GPM_PR_INFO,"PS/2 touchpad disable data flush: %02X", status);
 #endif
     FD_ZERO(&rfds);
     FD_SET (fd, &rfds);
@@ -2302,56 +2432,56 @@
 
 
 /* 
- * syn_ps2_enable_data
+ * ps2_enable_data
  *
  * Enable data after a disable data command. Should have called the disable data
- * before callling this function.
+ * before calling this function.
  */
 
-static void syn_ps2_enable_data(int fd)
+static void tp_ps2_enable_data(int fd)
 {  
-  ps2_putbyte(fd,PS2_ENABLE_DATA);
+  tp_ps2_putbyte(fd,PS2_ENABLE_DATA);
 
 }
 
 
 /* 
- * syn_ps2_send_reset
+ * ps2_send_reset
  *
  * Send reset command and absorb additional READY, IDCODE from the
- * touchpad. Should have called the disable data before callling this function.
- * Synaptics garanties allways to return PS2_READY. STIG page 31 and 48.
+ * touchpad. Should have called the disable data before calling this function.
+ * Synaptics garanties always to return PS2_READY. STIG page 31 and 48.
  */
 
-static void syn_ps2_send_reset(int fd)
+static void tp_ps2_send_reset(int fd)
 {
   byte status,id_code = PS2_MOUSE_IDCODE;
   byte reset_cmd = PS2_RESET;
   
   /* Send reset command. */
   write(fd,&reset_cmd,1);
-  status = ps2_getbyte(fd);
+  status = tp_ps2_getbyte(fd);
 
   /* Sometimes the touchpad sends additional ready,idcode before ack the reset command.
    * I dont know why! */
   while (status == PS2_READY){
-    gpm_report(GPM_PR_INFO,"Synaptic PS2 Touchpad sending additional READY, ID CODE.\n");
-    id_code = ps2_getbyte(fd);
-    status  = ps2_getbyte(fd);
+    gpm_report(GPM_PR_INFO,"PS/2 Touchpad sending additional READY, ID CODE.\n");
+    id_code = tp_ps2_getbyte(fd);
+    status  = tp_ps2_getbyte(fd);
   }
 
   if (status != PS2_ACK || id_code != PS2_MOUSE_IDCODE){
-    gpm_report(GPM_PR_ERR,"Sending reset command to Synaptics PS/2 TouchPad failed: No ACK, got %02X.\n",status);
+    gpm_report(GPM_PR_ERR,"Sending reset command to PS/2 TouchPad failed: No ACK, got %02X.\n",status);
   }
     
   /* Wait 750 ms to recalibrate. */
   usleep(7500);
 
-  if ( (status  = ps2_getbyte(fd)) != PS2_READY ){
-    gpm_report(GPM_PR_ERR,"Reseting Synaptics PS/2 TouchPad failed: No READY, got %02X.\n",status);
+  if ( (status  = tp_ps2_getbyte(fd)) != PS2_READY ){
+    gpm_report(GPM_PR_ERR,"Reseting PS/2 TouchPad failed: No READY, got %02X.\n",status);
   }
-  if ( (id_code = ps2_getbyte(fd)) != PS2_MOUSE_IDCODE){
-    gpm_report(GPM_PR_ERR,"Reseting Synaptics PS/2 TouchPad failed: Wrong ID, got %02X.\n",id_code);
+  if ( (id_code = tp_ps2_getbyte(fd)) != PS2_MOUSE_IDCODE){
+    gpm_report(GPM_PR_ERR,"Reseting PS/2 TouchPad failed: Wrong ID, got %02X.\n",id_code);
   }
 
 }
@@ -2367,7 +2497,7 @@
 static void syn_ps2_absolute_mode(int fd)
 {
   /* select 6 byte packet, high packet rate, no-sleep */
-  ps2_set_mode2 (fd, (ABSOLUTE_MODE    |
+  syn_ps2_set_mode2 (fd, (ABSOLUTE_MODE    |
 		      HIGH_REPORT_RATE |
 		      PS2_NO_SLEEP     |
 		      (stick_enabled ? STICK_ENABLED : STICK_DISABLE) |
@@ -2397,7 +2527,7 @@
  */
 
 
-static void syn_translate_serial_data (unsigned char *data,
+static void syn_serial_translate_data (unsigned char *data,
 					 report_type *report) 
 {
   report->gesture  = check_bits (data [0], 0x10);
@@ -2433,7 +2563,7 @@
  * sec after last touch.
  */
 
-static void syn_translate_ps2_error(unsigned char *data,
+static void syn_ps2_translate_error(unsigned char *data,
 				    report_type *report)
 {
   gpm_report(GPM_PR_WARN,"Unrecognized Synaptic PS/2 Touchpad packet: %02X %02X %02X %02X %02X %02X",
@@ -2488,7 +2618,7 @@
  */
 
 /* Translate the reported data into a record for processing */
-static void syn_translate_ps2_data (unsigned char *data,
+static void syn_ps2_translate_data (unsigned char *data,
 				    report_type *report) 
 {
   
@@ -2535,7 +2665,7 @@
     report->w        = 0;
     
   } else { 
-    syn_translate_ps2_error(data,report);
+    syn_ps2_translate_error(data,report);
   }
 }
 
@@ -2552,7 +2682,7 @@
  *
  */
 
-static void syn_translate_ps2_wmode_data (unsigned char *data,
+static void syn_ps2_translate_wmode_data (unsigned char *data,
 					    report_type *report) 
 {
   /* Check that it is an absolute packet */
@@ -2579,7 +2709,7 @@
 
 
   } else { 
-    syn_translate_ps2_error(data,report);
+    syn_ps2_translate_error(data,report);
   }
 }
 
@@ -2598,13 +2728,18 @@
 void syn_process_serial_data (Gpm_Event *state,
 			      unsigned char *data) 
 {
-  syn_translate_serial_data (data, &report);
-  if (syn_preprocess_report(data,&report,state)) return;
+  /* initialize the state */
+  state->buttons = 0;
+  state->dx      = 0;
+  state->dy      = 0;
+
+  syn_serial_translate_data (data, &report);
+  if (tp_preprocess_report(&report,state)) return;
   if (wmode_enabled){
-    syn_process_wmode_report(&report);    
+    tp_process_wmode_report(&report);    
   }    
 
-  syn_process_report (state, report);
+  tp_process_report (state, report);
 }
 
 
@@ -2619,7 +2754,7 @@
 {
   gpm_report (GPM_PR_INFO,"Reseting Synaptic Serial Touchpad.");
 
-  syn_set_serial_mode (fd, (RELATIVE_MODE    |
+  syn_serial_set_mode (fd, (RELATIVE_MODE    |
 			    HIGH_REPORT_RATE |
 			    USE_9600_BAUD    |
 			    NORMAL_REPORT    |
@@ -2640,9 +2775,9 @@
 
   gpm_report(GPM_PR_DEBUG,"Initializing Synaptics Serial TouchPad");
 
-  syn_read_serial_ident (fd, &ident);
-  syn_read_serial_model_id (fd, &model);
-  syn_read_serial_cap(fd, &capabilities);
+  syn_serial_read_ident (fd, &ident);
+  syn_serial_read_model_id (fd, &model);
+  syn_serial_read_cap(fd, &capabilities);
 
   syn_process_config (ident, model);
 
@@ -2658,7 +2793,7 @@
     wmode_enabled = 0;
   }
 
-  syn_set_serial_mode (fd, (ABSOLUTE_MODE    |
+  syn_serial_set_mode (fd, (ABSOLUTE_MODE    |
 			    HIGH_REPORT_RATE |
 			    USE_9600_BAUD    |
 			    (model.info_new_abs ? EXTENDED_REPORT : NORMAL_REPORT) |
@@ -2678,16 +2813,23 @@
 {
   /*   gpm_report(GPM_PR_DEBUG,"Data %02x %02x %02x %02x %02x %02x",data[0],data[1],data[2],data[3],data[4],data[5]); */
 
+  /* initialize the state */
+  state->buttons = 0;
+  state->dx      = 0;
+  state->dy      = 0;
+
+
   if (wmode_enabled) {
-    syn_translate_ps2_wmode_data (data, &report);
-    if (syn_preprocess_report(data,&report,state)) return;
-    syn_process_wmode_report(&report);
+    syn_ps2_translate_wmode_data (data, &report);
+    if (syn_ps2_process_extended_packets(data,&report,state)) return;      
+    if (tp_preprocess_report(&report,state)) return;
+    tp_process_wmode_report(&report);
   }else {
-    syn_translate_ps2_data (data, &report);
-    if (syn_preprocess_report(data,&report,state)) return;
+    syn_ps2_translate_data (data, &report);
+    if (tp_preprocess_report(&report,state)) return;
   }
 
-  syn_process_report (state, report);
+  tp_process_report (state, report);
 }
 
 
@@ -2704,9 +2846,9 @@
   gpm_report (GPM_PR_INFO,"Reseting Synaptic PS/2 Touchpad.");
 
   /* Stop incoming motion data (of whatever kind absolute/relative). */
-  syn_ps2_disable_data(fd);
-  syn_ps2_send_reset(fd);
-  syn_ps2_enable_data(fd);
+  tp_ps2_disable_data(fd);
+  tp_ps2_send_reset(fd);
+  tp_ps2_enable_data(fd);
 
 }
 
@@ -2723,16 +2865,16 @@
 
   gpm_report(GPM_PR_DEBUG,"Initializing Synaptics PS/2 TouchPad");
 
-  syn_ps2_disable_data(fd);
+  tp_ps2_disable_data(fd);
 
-  syn_read_ps2_ident    (fd, &ident);
-  syn_read_ps2_model_id (fd, &model);
-  syn_read_ps2_cap      (fd, &capabilities);
+  tp_ps2_send_reset(fd);
+
+  syn_ps2_read_ident    (fd, &ident);
+  syn_ps2_read_model_id (fd, &model);
+  syn_ps2_read_cap      (fd, &capabilities);
 
   syn_process_config (ident, model);
   syn_ps2_absolute_mode(fd);
 
-  syn_ps2_enable_data(fd);
+  tp_ps2_enable_data(fd);
 }
-
-
