From 6dccdff010fa3c07c396374db33bc708bac6e490 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Fri, 16 Dec 2016 23:23:13 +0100
Subject: [PATCH 1/5] Linux: Add P1010 patch

---
 .../linux/patches/default/linux-999-drm-p010.patch | 33 ++++++++++++++++++++++
 1 file changed, 33 insertions(+)
 create mode 100644 packages/linux/patches/default/linux-999-drm-p010.patch

diff --git a/packages/linux/patches/default/linux-999-drm-p010.patch b/packages/linux/patches/default/linux-999-drm-p010.patch
new file mode 100644
index 0000000..9278a5c
--- /dev/null
+++ b/packages/linux/patches/default/linux-999-drm-p010.patch
@@ -0,0 +1,33 @@
+From a01aa22c071fb1632f6dc11c219653501692f651 Mon Sep 17 00:00:00 2001
+From: fritsch <peter.fruehberger@gmail.com>
+Date: Fri, 16 Dec 2016 22:28:32 +0100
+Subject: [PATCH] DRM: Update FOURCC to get p1010 support
+
+---
+ include/uapi/drm/drm_fourcc.h | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/include/uapi/drm/drm_fourcc.h b/include/uapi/drm/drm_fourcc.h
+index a5890bf..e6ab638 100644
+--- a/include/uapi/drm/drm_fourcc.h
++++ b/include/uapi/drm/drm_fourcc.h
+@@ -41,10 +41,16 @@ extern "C" {
+ /* 8 bpp Red */
+ #define DRM_FORMAT_R8		fourcc_code('R', '8', ' ', ' ') /* [7:0] R */
+ 
++/* 16 bpp Red */
++#define DRM_FORMAT_R16		fourcc_code('R', '1', '6', ' ') /* [15:0] R */
++
+ /* 16 bpp RG */
+ #define DRM_FORMAT_RG88		fourcc_code('R', 'G', '8', '8') /* [15:0] R:G 8:8 little endian */
+ #define DRM_FORMAT_GR88		fourcc_code('G', 'R', '8', '8') /* [15:0] G:R 8:8 little endian */
+ 
++/* 32 bpp GR */
++#define DRM_FORMAT_GR16		fourcc_code('G', 'R', '1', '6') /* [31:0] G:R 16:16 little endian */
++
+ /* 8 bpp RGB */
+ #define DRM_FORMAT_RGB332	fourcc_code('R', 'G', 'B', '8') /* [7:0] R:G:B 3:3:2 */
+ #define DRM_FORMAT_BGR233	fourcc_code('B', 'G', 'R', '8') /* [7:0] B:G:R 2:3:3 */
+-- 
+2.7.4
+

From d36d68f8ca0c748de52ec3d98c6ba80aa3346e3d Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Fri, 16 Dec 2016 23:23:29 +0100
Subject: [PATCH 2/5] Mesa: Add P1010 patch

---
 packages/graphics/mesa/patches/mesa-01-p1010.patch | 107 +++++++++++++++++++++
 1 file changed, 107 insertions(+)
 create mode 100644 packages/graphics/mesa/patches/mesa-01-p1010.patch

diff --git a/packages/graphics/mesa/patches/mesa-01-p1010.patch b/packages/graphics/mesa/patches/mesa-01-p1010.patch
new file mode 100644
index 0000000..08d7229
--- /dev/null
+++ b/packages/graphics/mesa/patches/mesa-01-p1010.patch
@@ -0,0 +1,107 @@
+From bf5b0777036083f8a1e311a2067b5f37929a6e22 Mon Sep 17 00:00:00 2001
+From: Rainer Hochecker <fernetmenta@online.de>
+Date: Fri, 16 Dec 2016 21:16:26 +0100
+Subject: [PATCH] dri: allow 16bit R/GR images to be exported via drm buffers
+
+This allows eglCreateImageKHR to access P010 surfaces created by vaapi
+
+patch for drm, fourcc:
+http://paste.ubuntu.com/23638632/
+
+Signed-off-by: Rainer Hochecker <fernetmenta@online.de>
+---
+ include/GL/internal/dri_interface.h      |  4 ++++
+ src/egl/drivers/dri2/egl_dri2.c          | 10 ++++++++++
+ src/mesa/drivers/dri/common/dri_util.c   |  4 ++++
+ src/mesa/drivers/dri/i965/intel_screen.c |  6 ++++++
+ 4 files changed, 24 insertions(+)
+
+diff --git a/include/GL/internal/dri_interface.h b/include/GL/internal/dri_interface.h
+index d0b1bc6..933277e 100644
+--- a/include/GL/internal/dri_interface.h
++++ b/include/GL/internal/dri_interface.h
+@@ -1121,6 +1121,8 @@ struct __DRIdri2ExtensionRec {
+ #define __DRI_IMAGE_FORMAT_XRGB2101010  0x1009
+ #define __DRI_IMAGE_FORMAT_ARGB2101010  0x100a
+ #define __DRI_IMAGE_FORMAT_SARGB8       0x100b
++#define __DRI_IMAGE_FORMAT_R16          0x100c
++#define __DRI_IMAGE_FORMAT_GR16         0x100d
+ 
+ #define __DRI_IMAGE_USE_SHARE		0x0001
+ #define __DRI_IMAGE_USE_SCANOUT		0x0002
+@@ -1148,6 +1150,8 @@ struct __DRIdri2ExtensionRec {
+ 
+ #define __DRI_IMAGE_FOURCC_R8		0x20203852
+ #define __DRI_IMAGE_FOURCC_GR88		0x38385247
++#define __DRI_IMAGE_FOURCC_R16		0x20363152
++#define __DRI_IMAGE_FOURCC_GR16		0x36315247
+ #define __DRI_IMAGE_FOURCC_RGB565	0x36314752
+ #define __DRI_IMAGE_FOURCC_ARGB8888	0x34325241
+ #define __DRI_IMAGE_FOURCC_XRGB8888	0x34325258
+diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
+index f18e9fb..f4ed022 100644
+--- a/src/egl/drivers/dri2/egl_dri2.c
++++ b/src/egl/drivers/dri2/egl_dri2.c
+@@ -75,6 +75,14 @@
+ #define DRM_FORMAT_GR88          fourcc_code('G', 'R', '8', '8') /* [15:0] G:R 8:8 little endian */
+ #endif
+ 
++#ifndef DRM_FORMAT_R16
++#define DRM_FORMAT_R16           fourcc_code('R', '1', '6', ' ') /* [15:0] R 16 little endian */
++#endif
++
++#ifndef DRM_FORMAT_GR16
++#define DRM_FORMAT_GR16          fourcc_code('G', 'R', '1', '6') /* [31:0] R:G 16:16 little endian */
++#endif
++
+ const __DRIuseInvalidateExtension use_invalidate = {
+    .base = { __DRI_USE_INVALIDATE, 1 }
+ };
+@@ -1951,6 +1959,8 @@ dri2_check_dma_buf_format(const _EGLImageAttribs *attrs)
+    case DRM_FORMAT_R8:
+    case DRM_FORMAT_RG88:
+    case DRM_FORMAT_GR88:
++   case DRM_FORMAT_R16:
++   case DRM_FORMAT_GR16:
+    case DRM_FORMAT_RGB332:
+    case DRM_FORMAT_BGR233:
+    case DRM_FORMAT_XRGB4444:
+diff --git a/src/mesa/drivers/dri/common/dri_util.c b/src/mesa/drivers/dri/common/dri_util.c
+index 3b81799..c275c07 100644
+--- a/src/mesa/drivers/dri/common/dri_util.c
++++ b/src/mesa/drivers/dri/common/dri_util.c
+@@ -877,8 +877,12 @@ driImageFormatToGLFormat(uint32_t image_format)
+       return MESA_FORMAT_R8G8B8X8_UNORM;
+    case __DRI_IMAGE_FORMAT_R8:
+       return MESA_FORMAT_R_UNORM8;
++   case __DRI_IMAGE_FORMAT_R16:
++      return MESA_FORMAT_R_UNORM16;
+    case __DRI_IMAGE_FORMAT_GR88:
+       return MESA_FORMAT_R8G8_UNORM;
++   case __DRI_IMAGE_FORMAT_GR16:
++      return MESA_FORMAT_R16G16_UNORM;
+    case __DRI_IMAGE_FORMAT_SARGB8:
+       return MESA_FORMAT_B8G8R8A8_SRGB;
+    case __DRI_IMAGE_FORMAT_NONE:
+diff --git a/src/mesa/drivers/dri/i965/intel_screen.c b/src/mesa/drivers/dri/i965/intel_screen.c
+index e1c3c19..b3700c6 100644
+--- a/src/mesa/drivers/dri/i965/intel_screen.c
++++ b/src/mesa/drivers/dri/i965/intel_screen.c
+@@ -236,9 +236,15 @@ static struct intel_image_format intel_image_formats[] = {
+    { __DRI_IMAGE_FOURCC_R8, __DRI_IMAGE_COMPONENTS_R, 1,
+      { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 }, } },
+ 
++   { __DRI_IMAGE_FOURCC_R16, __DRI_IMAGE_COMPONENTS_R, 1,
++     { { 0, 0, 0, __DRI_IMAGE_FORMAT_R16, 1 }, } },
++
+    { __DRI_IMAGE_FOURCC_GR88, __DRI_IMAGE_COMPONENTS_RG, 1,
+      { { 0, 0, 0, __DRI_IMAGE_FORMAT_GR88, 2 }, } },
+ 
++   { __DRI_IMAGE_FOURCC_GR16, __DRI_IMAGE_COMPONENTS_RG, 1,
++     { { 0, 0, 0, __DRI_IMAGE_FORMAT_GR16, 2 }, } },
++
+    { __DRI_IMAGE_FOURCC_YUV410, __DRI_IMAGE_COMPONENTS_Y_U_V, 3,
+      { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },
+        { 1, 2, 2, __DRI_IMAGE_FORMAT_R8, 1 },
+-- 
+2.9.3

From 471dbb9240a69b894ef39d19d92ff53e347b0a15 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Fri, 16 Dec 2016 23:20:50 +0100
Subject: [PATCH 3/5] Kodi: Backport VAAPI hevc10 bit from fernet

---
 .../kodi/patches/kodi-999.98-vaapi-hevc10.patch    | 168 +++++++++++++++++++++
 .../kodi/patches/kodi-999.99-vaapi-hevc10.patch    |  31 ++++
 2 files changed, 199 insertions(+)
 create mode 100644 packages/mediacenter/kodi/patches/kodi-999.98-vaapi-hevc10.patch
 create mode 100644 packages/mediacenter/kodi/patches/kodi-999.99-vaapi-hevc10.patch

diff --git a/packages/mediacenter/kodi/patches/kodi-999.98-vaapi-hevc10.patch b/packages/mediacenter/kodi/patches/kodi-999.98-vaapi-hevc10.patch
new file mode 100644
index 0000000..7df7261
--- /dev/null
+++ b/packages/mediacenter/kodi/patches/kodi-999.98-vaapi-hevc10.patch
@@ -0,0 +1,168 @@
+From ee41bc539fa4dd1f69ddc1f5ca98d26371b483cc Mon Sep 17 00:00:00 2001
+From: Rainer Hochecker <fernetmenta@online.de>
+Date: Fri, 16 Dec 2016 17:34:06 +0100
+Subject: [PATCH] vaapi: hevc 10bit
+
+---
+ xbmc/cores/VideoPlayer/DVDCodecs/Video/VAAPI.cpp | 102 +++++++++++++++++++++--
+ 1 file changed, 95 insertions(+), 7 deletions(-)
+
+diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/VAAPI.cpp
+index 84743be..b085b8d 100644
+--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/VAAPI.cpp
++++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/VAAPI.cpp
+@@ -559,8 +559,8 @@ bool CDecoder::Open(AVCodecContext* avctx, AVCodecContext* mainctx, const enum A
+   if (!CVAAPIContext::EnsureContext(&m_vaapiConfig.context, this))
+     return false;
+ 
+-  if(avctx->coded_width  == 0
+-  || avctx->coded_height == 0)
++  if(avctx->coded_width  == 0 ||
++     avctx->coded_height == 0)
+   {
+     CLog::Log(LOGWARNING,"VAAPI::Open: no width/height available, can't init");
+     return false;
+@@ -617,7 +617,12 @@ bool CDecoder::Open(AVCodecContext* avctx, AVCodecContext* mainctx, const enum A
+     }
+     case AV_CODEC_ID_HEVC:
+     {
+-      profile = VAProfileHEVCMain;
++      if (avctx->profile == FF_PROFILE_HEVC_MAIN_10)
++        profile = VAProfileHEVCMain10;
++      else if (avctx->profile == FF_PROFILE_HEVC_MAIN)
++        profile = VAProfileHEVCMain;
++      else
++        profile = VAProfileNone;
+       if (!m_vaapiConfig.context->SupportsProfile(profile))
+         return false;
+       break;
+@@ -647,7 +652,7 @@ bool CDecoder::Open(AVCodecContext* avctx, AVCodecContext* mainctx, const enum A
+ 
+   m_vaapiConfig.profile = profile;
+   m_vaapiConfig.attrib = m_vaapiConfig.context->GetAttrib(profile);
+-  if ((m_vaapiConfig.attrib.value & VA_RT_FORMAT_YUV420) == 0)
++  if ((m_vaapiConfig.attrib.value & (VA_RT_FORMAT_YUV420 | VA_RT_FORMAT_YUV420_10BPP)) == 0)
+   {
+     CLog::Log(LOGERROR, "VAAPI - invalid yuv format %x", m_vaapiConfig.attrib.value);
+     return false;
+@@ -1071,7 +1076,7 @@ bool CDecoder::ConfigVAAPI()
+ 
+   m_vaapiConfig.dpy = m_vaapiConfig.context->GetDisplay();
+   m_vaapiConfig.attrib = m_vaapiConfig.context->GetAttrib(m_vaapiConfig.profile);
+-  if ((m_vaapiConfig.attrib.value & VA_RT_FORMAT_YUV420) == 0)
++  if ((m_vaapiConfig.attrib.value & (VA_RT_FORMAT_YUV420 | VA_RT_FORMAT_YUV420_10BPP)) == 0)
+   {
+     CLog::Log(LOGERROR, "VAAPI - invalid yuv format %x", m_vaapiConfig.attrib.value);
+     return false;
+@@ -1084,9 +1089,12 @@ bool CDecoder::ConfigVAAPI()
+ 
+   // create surfaces
+   VASurfaceID surfaces[32];
++  unsigned int format = VA_RT_FORMAT_YUV420;
++  if (m_vaapiConfig.profile == VAProfileHEVCMain10)
++    format = VA_RT_FORMAT_YUV420_10BPP;
+   int nb_surfaces = m_vaapiConfig.maxReferences;
+   if (!CheckSuccess(vaCreateSurfaces(m_vaapiConfig.dpy,
+-                                     VA_RT_FORMAT_YUV420,
++                                     format,
+                                      m_vaapiConfig.surfaceWidth,
+                                      m_vaapiConfig.surfaceHeight,
+                                      surfaces,
+@@ -1361,6 +1369,83 @@ bool CVaapiRenderPicture::GLMapSurface()
+ 
+       break;
+     }
++    case VA_FOURCC('P','0','1','0'):
++    {
++      attrib = attribs;
++      *attrib++ = EGL_LINUX_DRM_FOURCC_EXT;
++      *attrib++ = fourcc_code('R', '1', '6', ' ');
++      *attrib++ = EGL_WIDTH;
++      *attrib++ = glInterop.vaImage.width;
++      *attrib++ = EGL_HEIGHT;
++      *attrib++ = glInterop.vaImage.height;
++      *attrib++ = EGL_DMA_BUF_PLANE0_FD_EXT;
++      *attrib++ = (intptr_t)glInterop.vBufInfo.handle;
++      *attrib++ = EGL_DMA_BUF_PLANE0_OFFSET_EXT;
++      *attrib++ = glInterop.vaImage.offsets[0];
++      *attrib++ = EGL_DMA_BUF_PLANE0_PITCH_EXT;
++      *attrib++ = glInterop.vaImage.pitches[0];
++      *attrib++ = EGL_NONE;
++      glInterop.eglImageY = glInterop.eglCreateImageKHR(glInterop.eglDisplay,
++                                          EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, (EGLClientBuffer)NULL,
++                                          attribs);
++      if (!glInterop.eglImageY)
++      {
++        EGLint err = eglGetError();
++        CLog::Log(LOGERROR, "failed to import VA buffer NV12 into EGL image: %d", err);
++        return false;
++      }
++
++      attrib = attribs;
++      *attrib++ = EGL_LINUX_DRM_FOURCC_EXT;
++      *attrib++ = fourcc_code('G', 'R', '1', '6');
++      *attrib++ = EGL_WIDTH;
++      *attrib++ = (glInterop.vaImage.width + 1) >> 1;
++      *attrib++ = EGL_HEIGHT;
++      *attrib++ = (glInterop.vaImage.height + 1) >> 1;
++      *attrib++ = EGL_DMA_BUF_PLANE0_FD_EXT;
++      *attrib++ = (intptr_t)glInterop.vBufInfo.handle;
++      *attrib++ = EGL_DMA_BUF_PLANE0_OFFSET_EXT;
++      *attrib++ = glInterop.vaImage.offsets[1];
++      *attrib++ = EGL_DMA_BUF_PLANE0_PITCH_EXT;
++      *attrib++ = glInterop.vaImage.pitches[1];
++      *attrib++ = EGL_NONE;
++      glInterop.eglImageVU = glInterop.eglCreateImageKHR(glInterop.eglDisplay,
++                                          EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, (EGLClientBuffer)NULL,
++                                          attribs);
++      if (!glInterop.eglImageVU)
++      {
++        EGLint err = eglGetError();
++        CLog::Log(LOGERROR, "failed to import VA buffer NV12 into EGL image: %d", err);
++        return false;
++      }
++
++      GLint format;
++
++      glGenTextures(1, &textureY);
++      glEnable(glInterop.textureTarget);
++      glBindTexture(glInterop.textureTarget, textureY);
++      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
++      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
++      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
++      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
++      glInterop.glEGLImageTargetTexture2DOES(glInterop.textureTarget, glInterop.eglImageY);
++      glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT, &format);
++
++      glGenTextures(1, &textureVU);
++      glEnable(glInterop.textureTarget);
++      glBindTexture(glInterop.textureTarget, textureVU);
++      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
++      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
++      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
++      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
++      glInterop.glEGLImageTargetTexture2DOES(glInterop.textureTarget, glInterop.eglImageVU);
++      glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT, &format);
++
++      glBindTexture(glInterop.textureTarget, 0);
++      glDisable(glInterop.textureTarget);
++
++      break;
++    }
+     case VA_FOURCC('B','G','R','A'):
+     {
+       attrib = attribs;
+@@ -2605,9 +2690,12 @@ bool CVppPostproc::PreInit(CVaapiConfig &config, SDiMethods *methods)
+ 
+   // create surfaces
+   VASurfaceID surfaces[32];
++  unsigned int format = VA_RT_FORMAT_YUV420;
++  if (m_config.profile == VAProfileHEVCMain10)
++    format = VA_RT_FORMAT_YUV420_10BPP;
+   int nb_surfaces = NUM_RENDER_PICS;
+   if (!CheckSuccess(vaCreateSurfaces(m_config.dpy,
+-                                     VA_RT_FORMAT_YUV420,
++                                     format,
+                                      m_config.surfaceWidth,
+                                      m_config.surfaceHeight,
+                                      surfaces,
diff --git a/packages/mediacenter/kodi/patches/kodi-999.99-vaapi-hevc10.patch b/packages/mediacenter/kodi/patches/kodi-999.99-vaapi-hevc10.patch
new file mode 100644
index 0000000..15720ca
--- /dev/null
+++ b/packages/mediacenter/kodi/patches/kodi-999.99-vaapi-hevc10.patch
@@ -0,0 +1,31 @@
+From 443901836f27239982f4b1bdbe52832c637c7992 Mon Sep 17 00:00:00 2001
+From: fritsch <peter.fruehberger@gmail.com>
+Date: Fri, 16 Dec 2016 19:08:36 +0100
+Subject: [PATCH] VAAPI: Fix log message
+
+---
+ xbmc/cores/VideoPlayer/DVDCodecs/Video/VAAPI.cpp | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/VAAPI.cpp
+index b085b8d..2a12a41 100644
+--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/VAAPI.cpp
++++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/VAAPI.cpp
+@@ -1391,7 +1391,7 @@ bool CVaapiRenderPicture::GLMapSurface()
+       if (!glInterop.eglImageY)
+       {
+         EGLint err = eglGetError();
+-        CLog::Log(LOGERROR, "failed to import VA buffer NV12 into EGL image: %d", err);
++        CLog::Log(LOGERROR, "failed to import VA buffer P010 into EGL image: %d", err);
+         return false;
+       }
+ 
+@@ -1415,7 +1415,7 @@ bool CVaapiRenderPicture::GLMapSurface()
+       if (!glInterop.eglImageVU)
+       {
+         EGLint err = eglGetError();
+-        CLog::Log(LOGERROR, "failed to import VA buffer NV12 into EGL image: %d", err);
++        CLog::Log(LOGERROR, "failed to import VA buffer P010 into EGL image: %d", err);
+         return false;
+       }
+ 

From 3b86ba7c57a82efb194fc54a83a91dc919c4d4eb Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Sat, 17 Dec 2016 11:27:35 +0100
Subject: [PATCH 4/5] FFmpeg: Backport HEVC-10 bit enable patch

---
 .../patches/ffmpeg-99.999-backport-hevc10bit.patch | 25 ++++++++++++++++++++++
 1 file changed, 25 insertions(+)
 create mode 100644 packages/multimedia/ffmpeg/patches/ffmpeg-99.999-backport-hevc10bit.patch

diff --git a/packages/multimedia/ffmpeg/patches/ffmpeg-99.999-backport-hevc10bit.patch b/packages/multimedia/ffmpeg/patches/ffmpeg-99.999-backport-hevc10bit.patch
new file mode 100644
index 0000000..9058c95
--- /dev/null
+++ b/packages/multimedia/ffmpeg/patches/ffmpeg-99.999-backport-hevc10bit.patch
@@ -0,0 +1,25 @@
+From fb37da37ac1e17f643269ea5bad5bee7e79dcb3a Mon Sep 17 00:00:00 2001
+From: Jean-Yves Simon <lethalwp@gmail.com>
+Date: Tue, 9 Aug 2016 17:15:30 +0200
+Subject: [PATCH] avcodec/hevc: Add YUV420P10 to vaapi hardware decode -
+ permits hardware decoding of HEVC Main 10 on AMD RX 480
+
+Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>
+---
+ libavcodec/hevc.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index cb1263c..764e093 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -370,6 +370,9 @@ static int set_sps(HEVCContext *s, const HEVCSPS *sps, enum AVPixelFormat pix_fm
+ #if CONFIG_HEVC_D3D11VA_HWACCEL
+         *fmt++ = AV_PIX_FMT_D3D11VA_VLD;
+ #endif
++#if CONFIG_HEVC_VAAPI_HWACCEL
++        *fmt++ = AV_PIX_FMT_VAAPI;
++#endif
+         break;
+     }
+ 

From ee6936e5f2ef35d6d272dc6a25f382be14b71fe0 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Sat, 17 Dec 2016 16:10:48 +0100
Subject: [PATCH 5/5] kodi: don't use hq scaling when involving sizes > 2560 we
 are too slow

---
 .../kodi/patches/kodi-999.999-hqscaling.patch      | 32 ++++++++++++++++++++++
 1 file changed, 32 insertions(+)
 create mode 100644 packages/mediacenter/kodi/patches/kodi-999.999-hqscaling.patch

diff --git a/packages/mediacenter/kodi/patches/kodi-999.999-hqscaling.patch b/packages/mediacenter/kodi/patches/kodi-999.999-hqscaling.patch
new file mode 100644
index 0000000..5052c2b
--- /dev/null
+++ b/packages/mediacenter/kodi/patches/kodi-999.999-hqscaling.patch
@@ -0,0 +1,32 @@
+From 4e356d49fc5955fcf9ea8b14d9be22af4edd5b39 Mon Sep 17 00:00:00 2001
+From: fritsch <Peter.Fruehberger@gmail.com>
+Date: Sat, 17 Dec 2016 16:06:31 +0100
+Subject: [PATCH] LinuxRendererGL: Don't use hq scalers when coping with sizes
+ > 2560 (we are too slow)
+
+---
+ xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp
+index 4e785f7..0ee1666 100644
+--- a/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp
++++ b/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp
+@@ -2501,6 +2501,14 @@ bool CLinuxRendererGL::Supports(ESCALINGMETHOD method)
+     float scaleX = fabs(((float)m_sourceWidth - m_destRect.Width())/m_sourceWidth)*100;
+     float scaleY = fabs(((float)m_sourceHeight - m_destRect.Height())/m_sourceHeight)*100;
+     int minScale = CSettings::GetInstance().GetInt(CSettings::SETTING_VIDEOPLAYER_HQSCALERS);
++    // Don't use hq scalers if source width is larger than 2560 pixels
++    if (m_sourceWidth > 2560)
++      return false;
++
++    // Don't use hq scalers if we try to upscale to something > 2560
++    if (m_destRect.Width() > 2560)
++      return false;
++
+     if (scaleX < minScale && scaleY < minScale)
+       return false;
+ 
+-- 
+2.7.4
+
