diff --git a/bfd/ChangeLog b/bfd/ChangeLog
index 85c6a817e5..903c64569f 100644
--- a/bfd/ChangeLog
+++ b/bfd/ChangeLog
@@ -1,3 +1,101 @@
+2017-05-01  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>
+
+	PR ld/21404
+	* elf32-avr.c (avr_should_move_sym): New function.
+	(avr_should_reduce_sym_size): Likewise.
+	(avr_should_increase_sym_size): Likewise.
+	(elf32_avr_relax_delete_bytes): Adjust symbol values
+	and sizes by calling new functions.
+
+2017-05-01  Palmer Dabbelt  <palmer@dabbelt.com>
+
+	* config.bfd (riscv32-*): Enable rv64.
+
+2017-04-03  Palmer Dabbelt  <palmer@dabbelt.com>
+
+	* elfnn-riscv.c (GP_NAME): Delete.
+	(riscv_global_pointer_value): Change GP_NAME to RISCV_GP_SYMBOL.
+	(_bfd_riscv_relax_lui): Likewise.
+
+2017-01-17  Kuan-Lin Chen  <kuanlinchentw@gmail.com>
+
+	* elfnn-riscv.c (riscv_elf_object_p): New function.
+
+2017-04-26  Maciej W. Rozycki  <macro@imgtec.com>
+
+	PR ld/21334
+	* elf-bfd.h (elf_backend_data): Add `always_renumber_dynsyms'
+	member.
+	* elfxx-target.h [!elf_backend_always_renumber_dynsyms]
+	(elf_backend_always_renumber_dynsyms): Define.
+	(elfNN_bed): Initialize `always_renumber_dynsyms' member.
+	* elfxx-mips.h (elf_backend_always_renumber_dynsyms): Define.
+	* elflink.c (bfd_elf_size_dynsym_hash_dynstr): Also call
+	`_bfd_elf_link_renumber_dynsyms' if the backend has requested
+	it.
+	(elf_gc_sweep): Likewise.
+
+2017-04-26  Maciej W. Rozycki  <macro@imgtec.com>
+
+	* elflink.c (elf_gc_sweep): Only call
+	`_bfd_elf_link_renumber_dynsyms' if dynamic sections have been
+	created.
+
+2017-04-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/21425
+	* elf32-i386.c (ELF_MAXPAGESIZE): Set to 0x1000 for VxWorks.
+
+2017-03-28  Hans-Peter Nilsson  <hp@axis.com>
+
+	PR ld/16044
+	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Adjust BFD_ASSERT
+	to handle a local symbol with a hash-symbol-entry; without PLT.
+	Add BFD_ASSERT for an incidental case with GOT entry present.
+	(cris_elf_check_relocs): Increment PLT refcount only if the symbol
+	isn't forced-or-set local.
+
+2017-04-13  Alan Modra  <amodra@gmail.com>
+
+	* elf32-arm.c (arm_type_of_stub): Supply missing args to "long
+	branch veneers" error.  Fix double space and format message.
+	* elf32-avr.c (avr_add_stub): Do not pass NULL as %B arg.
+	* elf64-ppc.c (tocsave_find): Supply missing %B arg.
+
+2017-04-10  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/19579
+	PR ld/21306
+	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Check
+	ELF_COMMON_DEF_P for common symbols.
+	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
+	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
+	* elflink.c (_bfd_elf_merge_symbol): Revert commits
+	202ac193bbbecc96a4978d1ac3d17148253f9b01 and
+	07492f668d2173da7a2bda3707ff0985e0f460b6.
+
+2017-03-07  Alan Modra  <amodra@gmail.com>
+
+	PR 21224
+	PR 20519
+	* elf64-ppc.c (ppc64_elf_relocate_section): Add missing
+	dyn_relocs check.
+
+2017-03-07  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-03-02  Alan Modra  <amodra@gmail.com>
+	* elf32-ppc.c (ppc_elf_vle_split16): Correct insn mask typo.
+
+2017-03-02  Tristan Gingold  <gingold@adacore.com>
+
+	* version.m4: Bump version to 2.28.0
+	* configure: Regenerate.
+
+2017-03-02  Tristan Gingold  <gingold@adacore.com>
+
+	* development.sh: Set development to true.
+
 2017-03-02  Tristan Gingold  <gingold@adacore.com>
 
 	* version.m4: Bump version to 2.28
diff --git a/bfd/config.bfd b/bfd/config.bfd
index 1b28016b91..c0312162db 100644
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -1439,10 +1439,9 @@ case "${targ}" in
 #ifdef BFD64
   riscv32-*-*)
     targ_defvec=riscv_elf32_vec
-    targ_selvecs="riscv_elf32_vec"
+    targ_selvecs="riscv_elf32_vec riscv_elf64_vec"
     want64=true
     ;;
-
   riscv64-*-*)
     targ_defvec=riscv_elf64_vec
     targ_selvecs="riscv_elf32_vec riscv_elf64_vec"
diff --git a/bfd/configure b/bfd/configure
index 97693870c4..f30bfabef3 100755
--- a/bfd/configure
+++ b/bfd/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.64 for bfd 2.28.
+# Generated by GNU Autoconf 2.64 for bfd 2.28.0.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
@@ -556,8 +556,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='bfd'
 PACKAGE_TARNAME='bfd'
-PACKAGE_VERSION='2.28'
-PACKAGE_STRING='bfd 2.28'
+PACKAGE_VERSION='2.28.0'
+PACKAGE_STRING='bfd 2.28.0'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
@@ -1354,7 +1354,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures bfd 2.28 to adapt to many kinds of systems.
+\`configure' configures bfd 2.28.0 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1425,7 +1425,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of bfd 2.28:";;
+     short | recursive ) echo "Configuration of bfd 2.28.0:";;
    esac
   cat <<\_ACEOF
 
@@ -1546,7 +1546,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-bfd configure 2.28
+bfd configure 2.28.0
 generated by GNU Autoconf 2.64
 
 Copyright (C) 2009 Free Software Foundation, Inc.
@@ -2188,7 +2188,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by bfd $as_me 2.28, which was
+It was created by bfd $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   $ $0 $@
@@ -3997,7 +3997,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='bfd'
- VERSION='2.28'
+ VERSION='2.28.0'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -16613,7 +16613,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by bfd $as_me 2.28, which was
+This file was extended by bfd $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -16677,7 +16677,7 @@ Report bugs to the package provider."
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-bfd config.status 2.28
+bfd config.status 2.28.0
 configured by $0, generated by GNU Autoconf 2.64,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
diff --git a/bfd/development.sh b/bfd/development.sh
index b001a888ea..cd31410a8e 100644
--- a/bfd/development.sh
+++ b/bfd/development.sh
@@ -16,4 +16,4 @@
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 # Controls whether to enable development-mode features by default.
-development=false
+development=true
diff --git a/bfd/elf-bfd.h b/bfd/elf-bfd.h
index 5de9ab6ca6..dc4bd87f89 100644
--- a/bfd/elf-bfd.h
+++ b/bfd/elf-bfd.h
@@ -1478,6 +1478,10 @@ struct elf_backend_data
   /* Address of protected data defined in the shared library may be
      external, i.e., due to copy relocation.   */
   unsigned extern_protected_data : 1;
+
+  /* True if `_bfd_elf_link_renumber_dynsyms' must be called even for
+     static binaries.  */
+  unsigned always_renumber_dynsyms : 1;
 };
 
 /* Information about reloc sections associated with a bfd_elf_section_data
diff --git a/bfd/elf32-arm.c b/bfd/elf32-arm.c
index 0a785951dc..e04caef5ac 100644
--- a/bfd/elf32-arm.c
+++ b/bfd/elf32-arm.c
@@ -4024,10 +4024,12 @@ arm_type_of_stub (struct bfd_link_info *info,
 	      if (!thumb_only)
 		{
 		  if (input_sec->flags & SEC_ELF_PURECODE)
-		    _bfd_error_handler (_("\
-%B(%A): warning: long branch  veneers used in section with SHF_ARM_PURECODE section \
-attribute is only supported for M-profile targets that implement the movw instruction."),
-					input_sec);
+		    _bfd_error_handler
+		      (_("%B(%A): warning: long branch veneers used in"
+			 " section with SHF_ARM_PURECODE section"
+			 " attribute is only supported for M-profile"
+			 " targets that implement the movw instruction."),
+		       input_bfd, input_sec);
 
 		  stub_type = (bfd_link_pic (info) | globals->pic_veneer)
 		    /* PIC stubs.  */
@@ -4056,10 +4058,12 @@ attribute is only supported for M-profile targets that implement the movw instru
 		  else
 		    {
 		      if (input_sec->flags & SEC_ELF_PURECODE)
-			_bfd_error_handler (_("\
-%B(%A): warning: long branch  veneers used in section with SHF_ARM_PURECODE section \
-attribute is only supported for M-profile targets that implement the movw instruction."),
-					    input_sec);
+			_bfd_error_handler
+			  (_("%B(%A): warning: long branch veneers used in"
+			     " section with SHF_ARM_PURECODE section"
+			     " attribute is only supported for M-profile"
+			     " targets that implement the movw instruction."),
+			   input_bfd, input_sec);
 
 		      stub_type = (bfd_link_pic (info) | globals->pic_veneer)
 			/* PIC stub.  */
@@ -4073,13 +4077,12 @@ attribute is only supported for M-profile targets that implement the movw instru
 	  else
 	    {
 	      if (input_sec->flags & SEC_ELF_PURECODE)
-		_bfd_error_handler (_("%B(%s): warning: long branch "
-				      " veneers used in section with "
-				      "SHF_ARM_PURECODE section "
-				      "attribute is only supported"
-				      " for M-profile targets that "
-				      "implement the movw "
-				      "instruction."));
+		_bfd_error_handler
+		  (_("%B(%A): warning: long branch veneers used in"
+		     " section with SHF_ARM_PURECODE section"
+		     " attribute is only supported" " for M-profile"
+		     " targets that implement the movw instruction."),
+		   input_bfd, input_sec);
 
 	      /* Thumb to arm.  */
 	      if (sym_sec != NULL
@@ -4126,13 +4129,12 @@ attribute is only supported for M-profile targets that implement the movw instru
 	   || r_type == R_ARM_TLS_CALL)
     {
       if (input_sec->flags & SEC_ELF_PURECODE)
-	_bfd_error_handler (_("%B(%s): warning: long branch "
-			      " veneers used in section with "
-			      "SHF_ARM_PURECODE section "
-			      "attribute is only supported"
-			      " for M-profile targets that "
-			      "implement the movw "
-			      "instruction."));
+	_bfd_error_handler
+	  (_("%B(%A): warning: long branch veneers used in"
+	     " section with SHF_ARM_PURECODE section"
+	     " attribute is only supported for M-profile"
+	     " targets that implement the movw instruction."),
+	   input_bfd, input_sec);
       if (branch_type == ST_BRANCH_TO_THUMB)
 	{
 	  /* Arm to thumb.  */
diff --git a/bfd/elf32-avr.c b/bfd/elf32-avr.c
index 56b143d414..f140aa7ed4 100644
--- a/bfd/elf32-avr.c
+++ b/bfd/elf32-avr.c
@@ -1854,6 +1854,40 @@ elf32_avr_adjust_reloc_if_spans_insn (bfd *abfd,
     }
 }
 
+static bfd_boolean
+avr_should_move_sym (symvalue symval,
+                     bfd_vma start,
+                     bfd_vma end,
+                     bfd_boolean did_pad)
+{
+  bfd_boolean sym_within_boundary =
+          did_pad ? symval < end : symval <= end;
+  return (symval > start && sym_within_boundary);
+}
+
+static bfd_boolean
+avr_should_reduce_sym_size (symvalue symval,
+                            symvalue symend,
+                            bfd_vma start,
+                            bfd_vma end,
+                            bfd_boolean did_pad)
+{
+  bfd_boolean sym_end_within_boundary =
+          did_pad ? symend < end : symend <= end;
+  return (symval <= start && symend > start && sym_end_within_boundary);
+}
+
+static bfd_boolean
+avr_should_increase_sym_size (symvalue symval,
+                              symvalue symend,
+                              bfd_vma start,
+                              bfd_vma end,
+                              bfd_boolean did_pad)
+{
+  return avr_should_move_sym (symval, start, end, did_pad)
+          && symend >= end && did_pad;
+}
+
 /* Delete some bytes from a section while changing the size of an instruction.
    The parameter "addr" denotes the section-relative offset pointing just
    behind the shrinked instruction. "addr+count" point at the first
@@ -1875,13 +1909,14 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
   Elf_Internal_Rela *irel, *irelend;
   Elf_Internal_Sym *isym;
   Elf_Internal_Sym *isymbuf = NULL;
-  bfd_vma toaddr, reloc_toaddr;
+  bfd_vma toaddr;
   struct elf_link_hash_entry **sym_hashes;
   struct elf_link_hash_entry **end_hashes;
   unsigned int symcount;
   struct avr_relax_info *relax_info;
   struct avr_property_record *prop_record = NULL;
   bfd_boolean did_shrink = FALSE;
+  bfd_boolean did_pad = FALSE;
 
   symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
   sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
@@ -1912,17 +1947,6 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
         }
     }
 
-  /* We need to look at all relocs with offsets less than toaddr. prop
-     records handling adjusts toaddr downwards to avoid moving syms at the
-     address of the property record, but all relocs with offsets between addr
-     and the current value of toaddr need to have their offsets adjusted.
-     Assume addr = 0, toaddr = 4 and count = 2. After prop records handling,
-     toaddr becomes 2, but relocs with offsets 2 and 3 still need to be
-     adjusted (to 0 and 1 respectively), as the first 2 bytes are now gone.
-     So record the current value of toaddr here, and use it when adjusting
-     reloc offsets. */
-  reloc_toaddr = toaddr;
-
   irel = elf_section_data (sec)->relocs;
   irelend = irel + sec->reloc_count;
 
@@ -1962,10 +1986,7 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
          to remember we didn't delete anything i.e. don't set did_shrink,
          so that we don't corrupt reloc offsets or symbol values.*/
       memset (contents + toaddr - count, fill, count);
-
-      /* Adjust the TOADDR to avoid moving symbols located at the address
-         of the property record, which has not moved.  */
-      toaddr -= count;
+      did_pad = TRUE;
     }
 
   if (!did_shrink)
@@ -1981,7 +2002,7 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
 
       /* Get the new reloc address.  */
       if ((irel->r_offset > addr
-           && irel->r_offset < reloc_toaddr))
+           && irel->r_offset < toaddr))
         {
           if (debug_relax)
             printf ("Relocation at address 0x%x needs to be moved.\n"
@@ -2059,7 +2080,7 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
                  {
                    /* If there is an alignment boundary, we only need to
                       adjust addends that end up below the boundary. */
-                   bfd_vma shrink_boundary = (reloc_toaddr
+                   bfd_vma shrink_boundary = (toaddr
                                               + sec->output_section->vma
                                               + sec->output_offset);
 
@@ -2102,12 +2123,10 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
 	{
 	  if (isym->st_shndx == sec_shndx)
             {
-	      if (isym->st_value > addr
-                  && isym->st_value <= toaddr)
-                isym->st_value -= count;
-
-              if (isym->st_value <= addr
-                  && isym->st_value + isym->st_size > addr)
+              symvalue symval = isym->st_value;
+              symvalue symend = symval + isym->st_size;
+              if (avr_should_reduce_sym_size (symval, symend,
+                                      addr, toaddr, did_pad))
                 {
                   /* If this assert fires then we have a symbol that ends
                      part way through an instruction.  Does that make
@@ -2115,6 +2134,12 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
                   BFD_ASSERT (isym->st_value + isym->st_size >= addr + count);
                   isym->st_size -= count;
                 }
+              else if (avr_should_increase_sym_size (symval, symend,
+                                      addr, toaddr, did_pad))
+                isym->st_size += count;
+
+              if (avr_should_move_sym (symval, addr, toaddr, did_pad))
+                isym->st_value -= count;
             }
 	}
     }
@@ -2131,20 +2156,24 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
            || sym_hash->root.type == bfd_link_hash_defweak)
           && sym_hash->root.u.def.section == sec)
         {
-          if (sym_hash->root.u.def.value > addr
-              && sym_hash->root.u.def.value <= toaddr)
-            sym_hash->root.u.def.value -= count;
+          symvalue symval = sym_hash->root.u.def.value;
+          symvalue symend = symval + sym_hash->size;
 
-          if (sym_hash->root.u.def.value <= addr
-              && (sym_hash->root.u.def.value + sym_hash->size > addr))
+          if (avr_should_reduce_sym_size (symval, symend,
+                                  addr, toaddr, did_pad))
             {
               /* If this assert fires then we have a symbol that ends
                  part way through an instruction.  Does that make
                  sense?  */
-              BFD_ASSERT (sym_hash->root.u.def.value + sym_hash->size
-                          >= addr + count);
+              BFD_ASSERT (symend >= addr + count);
               sym_hash->size -= count;
             }
+          else if (avr_should_increase_sym_size (symval, symend,
+                                  addr, toaddr, did_pad))
+              sym_hash->size += count;
+
+          if (avr_should_move_sym (symval, addr, toaddr, did_pad))
+            sym_hash->root.u.def.value -= count;
         }
     }
 
@@ -3284,8 +3313,7 @@ avr_add_stub (const char *stub_name,
   if (hsh == NULL)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: cannot create stub entry %s"),
-			  NULL, stub_name);
+      _bfd_error_handler (_("cannot create stub entry %s"), stub_name);
       return NULL;
     }
 
diff --git a/bfd/elf32-cris.c b/bfd/elf32-cris.c
index 97b8cc3eb8..d4bbcebecc 100644
--- a/bfd/elf32-cris.c
+++ b/bfd/elf32-cris.c
@@ -2714,8 +2714,9 @@ elf_cris_adjust_gotplt_to_got (struct elf_cris_link_hash_entry *h, void * p)
   struct bfd_link_info *info = (struct bfd_link_info *) p;
 
   /* A GOTPLT reloc, when activated, is supposed to be included into
-     the PLT refcount.  */
+     the PLT refcount, when the symbol isn't set-or-forced local.  */
   BFD_ASSERT (h->gotplt_refcount == 0
+	      || h->root.plt.refcount == -1
 	      || h->gotplt_refcount <= h->root.plt.refcount);
 
   /* If nobody wanted a GOTPLT with this symbol, we're done.  */
@@ -2741,6 +2742,7 @@ elf_cris_adjust_gotplt_to_got (struct elf_cris_link_hash_entry *h, void * p)
       srelgot = elf_hash_table (info)->srelgot;
 
       /* Put accurate refcounts there.  */
+      BFD_ASSERT (h->root.got.refcount >= 0);
       h->root.got.refcount += h->gotplt_refcount;
       h->reg_got_refcount = h->gotplt_refcount;
 
@@ -3476,7 +3478,10 @@ cris_elf_check_relocs (bfd *abfd,
 	    continue;
 
 	  h->needs_plt = 1;
-	  h->plt.refcount++;
+
+	  /* If the symbol is forced local, the refcount is unavailable.  */
+	  if (h->plt.refcount != -1)
+	    h->plt.refcount++;
 	  break;
 
 	case R_CRIS_8:
diff --git a/bfd/elf32-i386.c b/bfd/elf32-i386.c
index 24beba3e1d..f570253ee3 100644
--- a/bfd/elf32-i386.c
+++ b/bfd/elf32-i386.c
@@ -6576,6 +6576,8 @@ elf32_i386_nacl_elf_object_p (bfd *abfd)
 #undef	TARGET_LITTLE_NAME
 #define TARGET_LITTLE_NAME		"elf32-i386-vxworks"
 #undef	ELF_OSABI
+#undef	ELF_MAXPAGESIZE
+#define ELF_MAXPAGESIZE			0x1000
 #undef	elf_backend_plt_alignment
 #define elf_backend_plt_alignment	4
 
diff --git a/bfd/elf32-ppc.c b/bfd/elf32-ppc.c
index 0f3eb68d35..10caa8a95b 100644
--- a/bfd/elf32-ppc.c
+++ b/bfd/elf32-ppc.c
@@ -4921,7 +4921,7 @@ ppc_elf_vle_split16 (bfd *input_bfd,
   unsigned int insn, opcode, top5;
 
   insn = bfd_get_32 (input_bfd, loc);
-  opcode = insn & 0xf300f800;
+  opcode = insn & 0xfc00f800;
   if (opcode == E_OR2I_INSN
       || opcode == E_AND2I_DOT_INSN
       || opcode == E_OR2IS_INSN
diff --git a/bfd/elf32-s390.c b/bfd/elf32-s390.c
index fd1bc13d5c..ddb6f5b255 100644
--- a/bfd/elf32-s390.c
+++ b/bfd/elf32-s390.c
@@ -3785,7 +3785,7 @@ elf_s390_finish_dynamic_symbol (bfd *output_bfd,
 	     RELATIVE reloc.  The entry in the global offset table
 	     will already have been initialized in the
 	     relocate_section function.  */
-	  if (!h->def_regular)
+	  if (!(h->def_regular || ELF_COMMON_DEF_P (h)))
 	    return FALSE;
 	  BFD_ASSERT((h->got.offset & 1) != 0);
 	  rela.r_info = ELF32_R_INFO (0, R_390_RELATIVE);
diff --git a/bfd/elf64-ppc.c b/bfd/elf64-ppc.c
index e7d4792245..765bc6b2d8 100644
--- a/bfd/elf64-ppc.c
+++ b/bfd/elf64-ppc.c
@@ -7627,7 +7627,7 @@ tocsave_find (struct ppc_link_hash_table *htab,
   if (ent.sec == NULL || ent.sec->output_section == NULL)
     {
       _bfd_error_handler
-	(_("%B: undefined symbol on R_PPC64_TOCSAVE relocation"));
+	(_("%B: undefined symbol on R_PPC64_TOCSAVE relocation"), ibfd);
       return NULL;
     }
 
@@ -14798,8 +14798,10 @@ ppc64_elf_relocate_section (bfd *output_bfd,
 	    break;
 
 	  if (bfd_link_pic (info)
-	      ? ((h != NULL && pc_dynrelocs (h))
-		 || must_be_dyn_reloc (info, r_type))
+	      ? ((h == NULL
+		  || h->dyn_relocs != NULL)
+		 && ((h != NULL && pc_dynrelocs (h))
+		     || must_be_dyn_reloc (info, r_type)))
 	      : (h != NULL
 		 ? h->dyn_relocs != NULL
 		 : ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC))
diff --git a/bfd/elf64-s390.c b/bfd/elf64-s390.c
index b5fd05f263..fbbf8d6e1d 100644
--- a/bfd/elf64-s390.c
+++ b/bfd/elf64-s390.c
@@ -3582,7 +3582,7 @@ elf_s390_finish_dynamic_symbol (bfd *output_bfd,
 	     RELATIVE reloc.  The entry in the global offset table
 	     will already have been initialized in the
 	     relocate_section function.  */
-	  if (!h->def_regular)
+	  if (!(h->def_regular || ELF_COMMON_DEF_P (h)))
 	    return FALSE;
 	  BFD_ASSERT((h->got.offset & 1) != 0);
 	  rela.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
diff --git a/bfd/elf64-x86-64.c b/bfd/elf64-x86-64.c
index e0e6c16fcd..e363eafc02 100644
--- a/bfd/elf64-x86-64.c
+++ b/bfd/elf64-x86-64.c
@@ -4926,7 +4926,8 @@ do_ifunc_pointer:
 		{
 		  /* Symbol is referenced locally.  Make sure it is
 		     defined locally or for a branch.  */
-		  fail = !h->def_regular && !branch;
+		  fail = (!(h->def_regular || ELF_COMMON_DEF_P (h))
+			  && !branch);
 		}
 	      else if (!(bfd_link_pie (info)
 			 && (h->needs_copy || eh->needs_copy)))
diff --git a/bfd/elflink.c b/bfd/elflink.c
index 69b66f2831..cd03a13757 100644
--- a/bfd/elflink.c
+++ b/bfd/elflink.c
@@ -1543,16 +1543,13 @@ _bfd_elf_merge_symbol (bfd *abfd,
      represent variables; this can cause confusion in principle, but
      any such confusion would seem to indicate an erroneous program or
      shared library.  We also permit a common symbol in a regular
-     object to override a weak symbol in a shared object.  A common
-     symbol in executable also overrides a symbol in a shared object.  */
+     object to override a weak symbol in a shared object.  */
 
   if (newdyn
       && newdef
       && (olddef
 	  || (h->root.type == bfd_link_hash_common
-	      && (newweak
-		  || newfunc
-		  || (!olddyn && bfd_link_executable (info))))))
+	      && (newweak || newfunc))))
     {
       *override = TRUE;
       newdef = FALSE;
@@ -6710,6 +6707,8 @@ bfd_boolean
 bfd_elf_size_dynsym_hash_dynstr (bfd *output_bfd, struct bfd_link_info *info)
 {
   const struct elf_backend_data *bed;
+  unsigned long section_sym_count;
+  bfd_size_type dynsymcount;
 
   if (!is_elf_hash_table (info->hash))
     return TRUE;
@@ -6717,24 +6716,30 @@ bfd_elf_size_dynsym_hash_dynstr (bfd *output_bfd, struct bfd_link_info *info)
   bed = get_elf_backend_data (output_bfd);
   (*bed->elf_backend_init_index_section) (output_bfd, info);
 
+  /* Assign dynsym indices.  In a shared library we generate a section
+     symbol for each output section, which come first.  Next come all
+     of the back-end allocated local dynamic syms, followed by the rest
+     of the global symbols.
+
+     This is usually not needed for static binaries, however backends
+     can request to always do it, e.g. the MIPS backend uses dynamic
+     symbol counts to lay out GOT, which will be produced in the
+     presence of GOT relocations even in static binaries (holding fixed
+     data in that case, to satisfy those relocations).  */
+
+  if (elf_hash_table (info)->dynamic_sections_created
+      || bed->always_renumber_dynsyms)
+    dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info,
+						  &section_sym_count);
+
   if (elf_hash_table (info)->dynamic_sections_created)
     {
       bfd *dynobj;
       asection *s;
-      bfd_size_type dynsymcount;
-      unsigned long section_sym_count;
       unsigned int dtagcount;
 
       dynobj = elf_hash_table (info)->dynobj;
 
-      /* Assign dynsym indicies.  In a shared library we generate a
-	 section symbol for each output section, which come first.
-	 Next come all of the back-end allocated local dynamic syms,
-	 followed by the rest of the global symbols.  */
-
-      dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info,
-						    &section_sym_count);
-
       /* Work out the size of the symbol version section.  */
       s = bfd_get_linker_section (dynobj, ".gnu.version");
       BFD_ASSERT (s != NULL);
@@ -12986,7 +12991,12 @@ elf_gc_sweep (bfd *abfd, struct bfd_link_info *info)
   elf_link_hash_traverse (elf_hash_table (info), elf_gc_sweep_symbol,
 			  &sweep_info);
 
-  _bfd_elf_link_renumber_dynsyms (abfd, info, &section_sym_count);
+  /* We need to reassign dynsym indices now that symbols may have
+     been removed.  See the call in `bfd_elf_size_dynsym_hash_dynstr'
+     for the details of the conditions used here.  */
+  if (elf_hash_table (info)->dynamic_sections_created
+      || bed->always_renumber_dynsyms)
+    _bfd_elf_link_renumber_dynsyms (abfd, info, &section_sym_count);
   return TRUE;
 }
 
diff --git a/bfd/elfnn-riscv.c b/bfd/elfnn-riscv.c
index ff25ebd32e..3c04507623 100644
--- a/bfd/elfnn-riscv.c
+++ b/bfd/elfnn-riscv.c
@@ -52,10 +52,6 @@
 #define ELF_MAXPAGESIZE			0x1000
 #define ELF_COMMONPAGESIZE		0x1000
 
-/* The global pointer's symbol name.  */
-
-#define GP_NAME "__global_pointer$"
-
 /* The RISC-V linker needs to keep track of the number of relocs that it
    decides to copy as dynamic relocs in check_relocs for each symbol.
    This is so that it can later discard them if they are found to be
@@ -1467,7 +1463,7 @@ riscv_global_pointer_value (struct bfd_link_info *info)
 {
   struct bfd_link_hash_entry *h;
 
-  h = bfd_link_hash_lookup (info->hash, GP_NAME, FALSE, FALSE, TRUE);
+  h = bfd_link_hash_lookup (info->hash, RISCV_GP_SYMBOL, FALSE, FALSE, TRUE);
   if (h == NULL || h->type != bfd_link_hash_defined)
     return 0;
 
@@ -2818,7 +2814,8 @@ _bfd_riscv_relax_lui (bfd *abfd,
       /* If gp and the symbol are in the same output section, then
 	 consider only that section's alignment.  */
       struct bfd_link_hash_entry *h =
-	bfd_link_hash_lookup (link_info->hash, GP_NAME, FALSE, FALSE, TRUE);
+	bfd_link_hash_lookup (link_info->hash, RISCV_GP_SYMBOL, FALSE, FALSE,
+			      TRUE);
       if (h->u.def.section->output_section == sym_sec->output_section)
 	max_alignment = (bfd_vma) 1 << sym_sec->output_section->alignment_power;
     }
@@ -3205,6 +3202,19 @@ riscv_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
   return TRUE;
 }
 
+/* Set the right mach type.  */
+static bfd_boolean
+riscv_elf_object_p (bfd *abfd)
+{
+  /* There are only two mach types in RISCV currently.  */
+  if (strcmp (abfd->xvec->name, "elf32-littleriscv") == 0)
+    bfd_default_set_arch_mach (abfd, bfd_arch_riscv, bfd_mach_riscv32);
+  else
+    bfd_default_set_arch_mach (abfd, bfd_arch_riscv, bfd_mach_riscv64);
+
+  return TRUE;
+}
+
 
 #define TARGET_LITTLE_SYM		riscv_elfNN_vec
 #define TARGET_LITTLE_NAME		"elfNN-littleriscv"
@@ -3230,6 +3240,7 @@ riscv_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
 #define elf_backend_plt_sym_val		     riscv_elf_plt_sym_val
 #define elf_backend_grok_prstatus            riscv_elf_grok_prstatus
 #define elf_backend_grok_psinfo              riscv_elf_grok_psinfo
+#define elf_backend_object_p                 riscv_elf_object_p
 #define elf_info_to_howto_rel		     NULL
 #define elf_info_to_howto		     riscv_info_to_howto_rela
 #define bfd_elfNN_bfd_relax_section	     _bfd_riscv_relax_section
diff --git a/bfd/elfxx-mips.h b/bfd/elfxx-mips.h
index fa5b5d2de9..274129b2e5 100644
--- a/bfd/elfxx-mips.h
+++ b/bfd/elfxx-mips.h
@@ -196,3 +196,4 @@ literal_reloc_p (int r_type)
 #define elf_backend_post_process_headers _bfd_mips_post_process_headers
 #define elf_backend_compact_eh_encoding _bfd_mips_elf_compact_eh_encoding
 #define elf_backend_cant_unwind_opcode _bfd_mips_elf_cant_unwind_opcode
+#define elf_backend_always_renumber_dynsyms TRUE
diff --git a/bfd/elfxx-target.h b/bfd/elfxx-target.h
index d063fb7f1b..d07600c15d 100644
--- a/bfd/elfxx-target.h
+++ b/bfd/elfxx-target.h
@@ -126,6 +126,9 @@
 #ifndef elf_backend_extern_protected_data
 #define elf_backend_extern_protected_data 0
 #endif
+#ifndef elf_backend_always_renumber_dynsyms
+#define elf_backend_always_renumber_dynsyms FALSE
+#endif
 #ifndef elf_backend_stack_align
 #define elf_backend_stack_align 16
 #endif
@@ -866,7 +869,8 @@ static struct elf_backend_data elfNN_bed =
   elf_backend_no_page_alias,
   elf_backend_default_execstack,
   elf_backend_caches_rawsize,
-  elf_backend_extern_protected_data
+  elf_backend_extern_protected_data,
+  elf_backend_always_renumber_dynsyms
 };
 
 /* Forward declaration for use when initialising alternative_target field.  */
diff --git a/bfd/version.h b/bfd/version.h
index eda06e4ac6..2d278ade4a 100644
--- a/bfd/version.h
+++ b/bfd/version.h
@@ -1,4 +1,4 @@
-#define BFD_VERSION_DATE 20170302
+#define BFD_VERSION_DATE 20170602
 #define BFD_VERSION @bfd_version@
 #define BFD_VERSION_STRING  @bfd_version_package@ @bfd_version_string@
 #define REPORT_BUGS_TO @report_bugs_to@
diff --git a/bfd/version.m4 b/bfd/version.m4
index 0cfca2dda8..8bde21ee1c 100644
--- a/bfd/version.m4
+++ b/bfd/version.m4
@@ -1 +1 @@
-m4_define([BFD_VERSION], [2.28])
+m4_define([BFD_VERSION], [2.28.0])
diff --git a/binutils/ChangeLog b/binutils/ChangeLog
index aa17468ffb..431822add9 100644
--- a/binutils/ChangeLog
+++ b/binutils/ChangeLog
@@ -1,3 +1,15 @@
+2017-05-18  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-01-10  Nick Clifton  <nickc@redhat.com>
+	PR 21034
+	* stabs.c (parse_stab_members): Fix thinko checking for g++
+	version 1 stabs information.
+
+2017-03-02  Tristan Gingold  <gingold@adacore.com>
+
+	* configure: Regenerate.
+
 2017-03-02  Tristan Gingold  <gingold@adacore.com>
 
 	* configure: Regenerate.
diff --git a/binutils/configure b/binutils/configure
index baddf348d0..82119efe72 100755
--- a/binutils/configure
+++ b/binutils/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.64 for binutils 2.28.
+# Generated by GNU Autoconf 2.64 for binutils 2.28.0.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
@@ -556,8 +556,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='binutils'
 PACKAGE_TARNAME='binutils'
-PACKAGE_VERSION='2.28'
-PACKAGE_STRING='binutils 2.28'
+PACKAGE_VERSION='2.28.0'
+PACKAGE_STRING='binutils 2.28.0'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
@@ -1338,7 +1338,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures binutils 2.28 to adapt to many kinds of systems.
+\`configure' configures binutils 2.28.0 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1409,7 +1409,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of binutils 2.28:";;
+     short | recursive ) echo "Configuration of binutils 2.28.0:";;
    esac
   cat <<\_ACEOF
 
@@ -1530,7 +1530,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-binutils configure 2.28
+binutils configure 2.28.0
 generated by GNU Autoconf 2.64
 
 Copyright (C) 2009 Free Software Foundation, Inc.
@@ -2172,7 +2172,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by binutils $as_me 2.28, which was
+It was created by binutils $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   $ $0 $@
@@ -3981,7 +3981,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='binutils'
- VERSION='2.28'
+ VERSION='2.28.0'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -15223,7 +15223,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by binutils $as_me 2.28, which was
+This file was extended by binutils $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -15287,7 +15287,7 @@ Report bugs to the package provider."
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-binutils config.status 2.28
+binutils config.status 2.28.0
 configured by $0, generated by GNU Autoconf 2.64,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
diff --git a/binutils/stabs.c b/binutils/stabs.c
index f5c5d2d8e0..d3fc4afe24 100644
--- a/binutils/stabs.c
+++ b/binutils/stabs.c
@@ -2702,7 +2702,7 @@ parse_stab_members (void *dhandle, struct stab_handle *info,
 	      ++*pp;
 	      voffset &= 0x7fffffff;
 
-	      if (**pp == ';' || *pp == '\0')
+	      if (**pp == ';' || **pp == '\0')
 		{
 		  /* Must be g++ version 1.  */
 		  context = DEBUG_TYPE_NULL;
diff --git a/gas/ChangeLog b/gas/ChangeLog
index 8a586ad7a0..d6ab8a1e34 100644
--- a/gas/ChangeLog
+++ b/gas/ChangeLog
@@ -1,3 +1,72 @@
+2017-04-03  Palmer Dabbelt  <palmer@dabbelt.com>
+
+	* config/tc-riscv.c (riscv_clear_subsets): Cast argument to free to
+	avoid const warnings.
+
+2017-03-30  Palmer Dabbelt  <palmer@dabbelt.com>
+
+	* config/tc-riscv.c (riscv_clear_subsets): New function.
+	(riscv_add_subset): Call riscv_clear_subsets and riscv_set_rvc to
+	clear RVC when it's been previously set.
+
+2017-03-21  Palmer Dabbbelt  <palmer@dabbelt.com>
+
+	* config/tc-riscv.c (md_show_usage): Remove defuct -m32, -m64,
+	-msoft-float, -mhard-float, -mno-rvc, and -mrvc options; and don't
+	print an invalid default ISA string.
+	* doc/c-riscv.texi (OPTIONS): Add -fpic and -fno-pic options.
+
+2017-03-14  Kito Cheng  <kito.cheng@gmail.com>
+
+	* config/tc-riscv.c (validate_riscv_insn): Add 'o' RVC immediate
+	encoding format, which can accept 0-valued immediates.
+	(riscv_ip): Likewise.
+
+2017-03-02  Kuan-Lin Chen  <rufus@andestech.com>
+
+	* config/tc-riscv.h (HWARD2_USE_FIXED_ADVANCE_PC): New define.
+
+2017-03-02  Kuan-Lin Chen  <rufus@andestech.com>
+
+	* config/tc-riscv.c (md_apply_fix): Set fx_frag and
+	fx_next->fx_frag for CFA_advance_loc relocations.
+
+2017-03-02  Kuan-Lin Chen  <rufus@andestech.com>
+
+	* config/tc-riscv.c (md_apply_fix): Compute the correct offsets
+	for CFA relocations.
+
+2017-03-27  Alan Modra  <amodra@gmail.com>
+
+	PR 21303
+	* testsuite/gas/ppc/pr21303.d,
+	* testsuite/gas/ppc/pr21303.s: New test
+	* testsuite/gas/ppc/ppc.exp: Run it.
+
+2017-03-21  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2017-03-21  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/tc-s390.c (s390_parse_cpu): Remove S390_INSTR_FLAG_VX2
+	from cpu_table.  Remove vx2, and novx2 from cpu_flags.
+
+2017-03-08  Peter Bergner <bergner@vnet.ibm.com>
+
+	* testsuite/gas/ppc/altivec2.d (as): Use the -mpower8 option.
+	(objdump): Use the -Mpower8 option.
+
+2017-03-08  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Apply from master.
+	2017-03-08  Peter Bergner  <bergner@vnet.ibm.com>
+	* testsuite/gas/ppc/power9.d <lnia> New test.
+	* testsuite/gas/ppc/power9.s: Likewise.
+
+2017-03-02  Tristan Gingold  <gingold@adacore.com>
+
+	* configure: Regenerate.
+
 2017-03-02  Tristan Gingold  <gingold@adacore.com>
 
 	* configure: Regenerate.
diff --git a/gas/config/tc-riscv.c b/gas/config/tc-riscv.c
index ec5b0bb036..88457c6fd4 100644
--- a/gas/config/tc-riscv.c
+++ b/gas/config/tc-riscv.c
@@ -121,6 +121,18 @@ riscv_subset_supports (const char *feature)
 }
 
 static void
+riscv_clear_subsets (void)
+{
+  while (riscv_subsets != NULL)
+    {
+      struct riscv_subset *next = riscv_subsets->next;
+      free ((void *) riscv_subsets->name);
+      free (riscv_subsets);
+      riscv_subsets = next;
+    }
+}
+
+static void
 riscv_add_subset (const char *subset)
 {
   struct riscv_subset *s = xmalloc (sizeof *s);
@@ -139,6 +151,8 @@ riscv_set_arch (const char *s)
   const char *extension = NULL;
   const char *p = s;
 
+  riscv_clear_subsets();
+
   if (strncmp (p, "rv32", 4) == 0)
     {
       xlen = 32;
@@ -500,6 +514,7 @@ validate_riscv_insn (const struct riscv_opcode *opc)
 	  case 'c': break; /* RS1, constrained to equal sp */
 	  case 'i': used_bits |= ENCODE_RVC_SIMM3(-1U); break;
 	  case 'j': used_bits |= ENCODE_RVC_IMM (-1U); break;
+	  case 'o': used_bits |= ENCODE_RVC_IMM (-1U); break;
 	  case 'k': used_bits |= ENCODE_RVC_LW_IMM (-1U); break;
 	  case 'l': used_bits |= ENCODE_RVC_LD_IMM (-1U); break;
 	  case 'm': used_bits |= ENCODE_RVC_LWSP_IMM (-1U); break;
@@ -1321,6 +1336,13 @@ rvc_imm_done:
 		  ip->insn_opcode |=
 		    ENCODE_RVC_LDSP_IMM (imm_expr->X_add_number);
 		  goto rvc_imm_done;
+		case 'o':
+		  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)
+		      || imm_expr->X_op != O_constant
+		      || !VALID_RVC_IMM (imm_expr->X_add_number))
+		    break;
+		  ip->insn_opcode |= ENCODE_RVC_IMM (imm_expr->X_add_number);
+		  goto rvc_imm_done;
 		case 'K':
 		  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)
 		      || imm_expr->X_op != O_constant
@@ -1794,6 +1816,7 @@ riscv_after_parse_args (void)
     riscv_set_arch (xlen == 64 ? "rv64g" : "rv32g");
 
   /* Add the RVC extension, regardless of -march, to support .option rvc.  */
+  riscv_set_rvc (FALSE);
   if (riscv_subset_supports ("c"))
     riscv_set_rvc (TRUE);
   else
@@ -1837,6 +1860,7 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
   unsigned int subtype;
   bfd_byte *buf = (bfd_byte *) (fixP->fx_frag->fr_literal + fixP->fx_where);
   bfd_boolean relaxable = FALSE;
+  offsetT loc;
 
   /* Remember value for tc_gen_reloc.  */
   fixP->fx_addnumber = *valP;
@@ -1922,30 +1946,31 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
 
 	    case BFD_RELOC_RISCV_CFA:
 	      /* Load the byte to get the subtype.  */
-	      subtype = bfd_get_8 (NULL, &fixP->fx_frag->fr_literal[fixP->fx_where]);
+	      subtype = bfd_get_8 (NULL, &((fragS *) (fixP->fx_frag->fr_opcode))->fr_literal[fixP->fx_where]);
+	      loc = fixP->fx_frag->fr_fix - (subtype & 7);
 	      switch (subtype)
 		{
 		case DW_CFA_advance_loc1:
-		  fixP->fx_where++;
-		  fixP->fx_next->fx_where++;
+		  fixP->fx_where = loc + 1;
+		  fixP->fx_next->fx_where = loc + 1;
 		  fixP->fx_r_type = BFD_RELOC_RISCV_SET8;
 		  fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_SUB8;
 		  break;
 
 		case DW_CFA_advance_loc2:
 		  fixP->fx_size = 2;
-		  fixP->fx_where++;
 		  fixP->fx_next->fx_size = 2;
-		  fixP->fx_next->fx_where++;
+		  fixP->fx_where = loc + 1;
+		  fixP->fx_next->fx_where = loc + 1;
 		  fixP->fx_r_type = BFD_RELOC_RISCV_SET16;
 		  fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_SUB16;
 		  break;
 
 		case DW_CFA_advance_loc4:
 		  fixP->fx_size = 4;
-		  fixP->fx_where++;
 		  fixP->fx_next->fx_size = 4;
-		  fixP->fx_next->fx_where++;
+		  fixP->fx_where = loc;
+		  fixP->fx_next->fx_where = loc;
 		  fixP->fx_r_type = BFD_RELOC_RISCV_SET32;
 		  fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_SUB32;
 		  break;
@@ -1954,6 +1979,8 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
 		  if (subtype < 0x80 && (subtype & 0x40))
 		    {
 		      /* DW_CFA_advance_loc */
+		      fixP->fx_frag = (fragS *) fixP->fx_frag->fr_opcode;
+		      fixP->fx_next->fx_frag = fixP->fx_frag;
 		      fixP->fx_r_type = BFD_RELOC_RISCV_SET6;
 		      fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_SUB6;
 		    }
@@ -2069,7 +2096,6 @@ riscv_pre_output_hook (void)
 	  {
 	    if (frag->fr_type == rs_cfa)
 	      {
-		fragS *loc4_frag;
 		expressionS exp;
 
 		symbolS *add_symbol = frag->fr_symbol->sy_value.X_add_symbol;
@@ -2080,8 +2106,7 @@ riscv_pre_output_hook (void)
 		exp.X_add_number = 0;
 		exp.X_op_symbol = op_symbol;
 
-		loc4_frag = (fragS *) frag->fr_opcode;
-		fix_new_exp (loc4_frag, (int) frag->fr_offset, 1, &exp, 0,
+		fix_new_exp (frag, (int) frag->fr_offset, 1, &exp, 0,
 			     BFD_RELOC_RISCV_CFA);
 	      }
 	  }
@@ -2455,15 +2480,10 @@ md_show_usage (FILE *stream)
 {
   fprintf (stream, _("\
 RISC-V options:\n\
-  -m32           assemble RV32 code\n\
-  -m64           assemble RV64 code (default)\n\
   -fpic          generate position-independent code\n\
   -fno-pic       don't generate position-independent code (default)\n\
-  -msoft-float   don't use F registers for floating-point values\n\
-  -mhard-float   use F registers for floating-point values (default)\n\
-  -mno-rvc       disable the C extension for compressed instructions (default)\n\
-  -mrvc          enable the C extension for compressed instructions\n\
-  -march=ISA     set the RISC-V architecture, RV64IMAFD by default\n\
+  -march=ISA     set the RISC-V architecture\n\
+  -mabi=ABI      set the RISC-V ABI\n\
 "));
 }
 
diff --git a/gas/config/tc-riscv.h b/gas/config/tc-riscv.h
index ae8d60eb21..e92b3879a9 100644
--- a/gas/config/tc-riscv.h
+++ b/gas/config/tc-riscv.h
@@ -112,4 +112,7 @@ extern int tc_riscv_regname_to_dw2regnum (char *);
 #define elf_tc_final_processing riscv_elf_final_processing
 extern void riscv_elf_final_processing (void);
 
+/* Adjust debug_line after relaxation.  */
+#define DWARF2_USE_FIXED_ADVANCE_PC 1
+
 #endif /* TC_RISCV */
diff --git a/gas/config/tc-s390.c b/gas/config/tc-s390.c
index 7c8087e009..dccbe2c945 100644
--- a/gas/config/tc-s390.c
+++ b/gas/config/tc-s390.c
@@ -291,7 +291,7 @@ s390_parse_cpu (const char *         arg,
     { STRING_COMMA_LEN ("z13"), STRING_COMMA_LEN ("arch11"),
       S390_INSTR_FLAG_HTM | S390_INSTR_FLAG_VX },
     { STRING_COMMA_LEN ("arch12"), STRING_COMMA_LEN (""),
-      S390_INSTR_FLAG_HTM | S390_INSTR_FLAG_VX | S390_INSTR_FLAG_VX2 }
+      S390_INSTR_FLAG_HTM | S390_INSTR_FLAG_VX }
   };
   static struct
   {
@@ -303,9 +303,7 @@ s390_parse_cpu (const char *         arg,
     { "htm",   S390_INSTR_FLAG_HTM, TRUE },
     { "nohtm", S390_INSTR_FLAG_HTM, FALSE },
     { "vx",    S390_INSTR_FLAG_VX, TRUE },
-    { "novx",  S390_INSTR_FLAG_VX, FALSE },
-    { "vx2",    S390_INSTR_FLAG_VX2, TRUE },
-    { "novx2",  S390_INSTR_FLAG_VX2, FALSE }
+    { "novx",  S390_INSTR_FLAG_VX, FALSE }
   };
   unsigned int icpu;
   char *ilp_bak;
diff --git a/gas/configure b/gas/configure
index ce7091e33b..e574cb8514 100755
--- a/gas/configure
+++ b/gas/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.64 for gas 2.28.
+# Generated by GNU Autoconf 2.64 for gas 2.28.0.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
@@ -556,8 +556,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='gas'
 PACKAGE_TARNAME='gas'
-PACKAGE_VERSION='2.28'
-PACKAGE_STRING='gas 2.28'
+PACKAGE_VERSION='2.28.0'
+PACKAGE_STRING='gas 2.28.0'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
@@ -1330,7 +1330,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures gas 2.28 to adapt to many kinds of systems.
+\`configure' configures gas 2.28.0 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1401,7 +1401,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of gas 2.28:";;
+     short | recursive ) echo "Configuration of gas 2.28.0:";;
    esac
   cat <<\_ACEOF
 
@@ -1523,7 +1523,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-gas configure 2.28
+gas configure 2.28.0
 generated by GNU Autoconf 2.64
 
 Copyright (C) 2009 Free Software Foundation, Inc.
@@ -1933,7 +1933,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by gas $as_me 2.28, which was
+It was created by gas $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   $ $0 $@
@@ -3742,7 +3742,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='gas'
- VERSION='2.28'
+ VERSION='2.28.0'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -15212,7 +15212,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by gas $as_me 2.28, which was
+This file was extended by gas $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -15276,7 +15276,7 @@ Report bugs to the package provider."
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-gas config.status 2.28
+gas config.status 2.28.0
 configured by $0, generated by GNU Autoconf 2.64,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
diff --git a/gas/doc/c-riscv.texi b/gas/doc/c-riscv.texi
index 0fa1b58356..2efba4b5cb 100644
--- a/gas/doc/c-riscv.texi
+++ b/gas/doc/c-riscv.texi
@@ -26,6 +26,14 @@ The following table lists all availiable RISC-V specific options
 @c man begin OPTIONS
 @table @gcctabopt
 
+@cindex @samp{-fpic} option, RISC-V
+@item -fpic
+Generate position-independent code
+
+@cindex @samp{-fno-pic} option, RISC-V
+@item -fno-pic
+Don't generate position-independent code (default)
+
 @cindex @samp{-march=ISA} option, RISC-V
 @item -march=ISA
 Select the base isa, as specified by ISA.  For example -march=rv32ima.
diff --git a/gas/testsuite/gas/ppc/altivec2.d b/gas/testsuite/gas/ppc/altivec2.d
index fc10fb5a2e..26f9afa9a8 100644
--- a/gas/testsuite/gas/ppc/altivec2.d
+++ b/gas/testsuite/gas/ppc/altivec2.d
@@ -1,5 +1,5 @@
-#as: -maltivec
-#objdump: -dr -Maltivec
+#as: -mpower8
+#objdump: -dr -Mpower8
 #name: Altivec ISA 2.07 instructions
 
 .*
diff --git a/gas/testsuite/gas/ppc/power9.d b/gas/testsuite/gas/ppc/power9.d
index 9ba53d0679..a67898ff3a 100644
--- a/gas/testsuite/gas/ppc/power9.d
+++ b/gas/testsuite/gas/ppc/power9.d
@@ -312,8 +312,9 @@ Disassembly of section \.text:
 .*:	(f1 31 9d 6f|6f 9d 31 f1) 	xscvdphp vs41,vs51
 .*:	(f1 58 a7 6f|6f a7 58 f1) 	xvcvhpsp vs42,vs52
 .*:	(f1 79 af 6f|6f af 79 f1) 	xvcvsphp vs43,vs53
-.*:	(4c 60 00 04|04 00 60 4c) 	addpcis r3,0
-.*:	(4c 60 00 04|04 00 60 4c) 	addpcis r3,0
+.*:	(4c 60 00 04|04 00 60 4c) 	lnia    r3
+.*:	(4c 60 00 04|04 00 60 4c) 	lnia    r3
+.*:	(4c 60 00 04|04 00 60 4c) 	lnia    r3
 .*:	(4c 80 00 05|05 00 80 4c) 	addpcis r4,1
 .*:	(4c 80 00 05|05 00 80 4c) 	addpcis r4,1
 .*:	(4c bf ff c4|c4 ff bf 4c) 	addpcis r5,-2
diff --git a/gas/testsuite/gas/ppc/power9.s b/gas/testsuite/gas/ppc/power9.s
index 27f1122018..4e3530fba9 100644
--- a/gas/testsuite/gas/ppc/power9.s
+++ b/gas/testsuite/gas/ppc/power9.s
@@ -303,6 +303,7 @@ power9:
 	xscvdphp    41,51
 	xvcvhpsp    42,52
 	xvcvsphp    43,53
+	lnia        3
 	addpcis     3,0
 	subpcis     3,0
 	addpcis     4,1
diff --git a/gas/testsuite/gas/ppc/ppc.exp b/gas/testsuite/gas/ppc/ppc.exp
index 86db4553df..55367adc08 100644
--- a/gas/testsuite/gas/ppc/ppc.exp
+++ b/gas/testsuite/gas/ppc/ppc.exp
@@ -50,6 +50,7 @@ if { [istarget powerpc*-*-*] } then {
 	run_dump_test "common"
 	run_dump_test "476"
 	run_dump_test "a2"
+	run_dump_test "pr21303"
 	if { ![istarget powerpc*le-*-*] } then {
 	    run_dump_test "vle"
 	    run_dump_test "vle-reloc"
diff --git a/gas/testsuite/gas/ppc/pr21303.d b/gas/testsuite/gas/ppc/pr21303.d
new file mode 100644
index 0000000000..64761a4d5d
--- /dev/null
+++ b/gas/testsuite/gas/ppc/pr21303.d
@@ -0,0 +1,12 @@
+#objdump: -d -Me200z4
+#as: -a32 -mbig -me200z4
+
+.*
+
+Disassembly of section \.text:
+
+0+ <\.text>:
+   0:	70 00 00 00 	e_li    r0,0
+   4:	7c 01 14 04 	lbdcbx  r0,r1,r2
+   8:	7c 01 14 44 	lhdcbx  r0,r1,r2
+   c:	7c 01 14 84 	lwdcbx  r0,r1,r2
diff --git a/gas/testsuite/gas/ppc/pr21303.s b/gas/testsuite/gas/ppc/pr21303.s
new file mode 100644
index 0000000000..890ba94b08
--- /dev/null
+++ b/gas/testsuite/gas/ppc/pr21303.s
@@ -0,0 +1,5 @@
+ .text
+ e_li 0, 0
+ lbdcbx 0, 1, 2
+ lhdcbx 0, 1, 2
+ lwdcbx 0, 1, 2
diff --git a/gold/ChangeLog b/gold/ChangeLog
index d598386fd7..eaf30d3913 100644
--- a/gold/ChangeLog
+++ b/gold/ChangeLog
@@ -1,3 +1,11 @@
+2017-05-13  James Clarke  <jrtc27@jrtc27.com>
+
+	PR gold/21444
+	* gold.cc (Target_sparc::Relocate::relocate_tls): Local
+	variables are final for position-independent executables. This
+	has to be consistent with Target_sparc::Scan::local otherwise
+	they will disagree as to whether local-exec is used.
+
 2017-02-22  Alan Modra  <amodra@gmail.com>
 
 	* powerpc.cc (Target_powerpc::make_iplt_section): Check that
diff --git a/gold/sparc.cc b/gold/sparc.cc
index a9cb93adda..54c7c33498 100644
--- a/gold/sparc.cc
+++ b/gold/sparc.cc
@@ -3730,7 +3730,7 @@ Target_sparc<size, big_endian>::Relocate::relocate_tls(
 
   const bool is_final =
     (gsym == NULL
-     ? !parameters->options().output_is_position_independent()
+     ? !parameters->options().shared()
      : gsym->final_value_is_known());
   const tls::Tls_optimization optimized_type
       = optimize_tls_reloc(is_final, r_type);
diff --git a/gprof/ChangeLog b/gprof/ChangeLog
index cc57e0d872..0c25d519d6 100644
--- a/gprof/ChangeLog
+++ b/gprof/ChangeLog
@@ -2,6 +2,10 @@
 
 	* configure: Regenerate.
 
+2017-03-02  Tristan Gingold  <gingold@adacore.com>
+
+	* configure: Regenerate.
+
 2017-01-02  Alan Modra  <amodra@gmail.com>
 
 	Update year range in copyright notice of all files.
diff --git a/gprof/configure b/gprof/configure
index 43e0dac041..9e6b8f3525 100755
--- a/gprof/configure
+++ b/gprof/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.64 for gprof 2.28.
+# Generated by GNU Autoconf 2.64 for gprof 2.28.0.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
@@ -556,8 +556,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='gprof'
 PACKAGE_TARNAME='gprof'
-PACKAGE_VERSION='2.28'
-PACKAGE_STRING='gprof 2.28'
+PACKAGE_VERSION='2.28.0'
+PACKAGE_STRING='gprof 2.28.0'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
@@ -1302,7 +1302,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures gprof 2.28 to adapt to many kinds of systems.
+\`configure' configures gprof 2.28.0 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1373,7 +1373,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of gprof 2.28:";;
+     short | recursive ) echo "Configuration of gprof 2.28.0:";;
    esac
   cat <<\_ACEOF
 
@@ -1479,7 +1479,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-gprof configure 2.28
+gprof configure 2.28.0
 generated by GNU Autoconf 2.64
 
 Copyright (C) 2009 Free Software Foundation, Inc.
@@ -1844,7 +1844,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by gprof $as_me 2.28, which was
+It was created by gprof $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   $ $0 $@
@@ -3653,7 +3653,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='gprof'
- VERSION='2.28'
+ VERSION='2.28.0'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -12787,7 +12787,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by gprof $as_me 2.28, which was
+This file was extended by gprof $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -12851,7 +12851,7 @@ Report bugs to the package provider."
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-gprof config.status 2.28
+gprof config.status 2.28.0
 configured by $0, generated by GNU Autoconf 2.64,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
diff --git a/include/ChangeLog b/include/ChangeLog
index af39f333d4..dddecfb49b 100644
--- a/include/ChangeLog
+++ b/include/ChangeLog
@@ -1,3 +1,58 @@
+2017-04-03  Palmer Dabbelt  <palmer@dabbelt.com>
+
+	* elf/riscv.h (RISCV_GP_SYMBOL): New define.
+
+2017-03-27  Andrew Waterman  <andrew@sifive.com>
+
+	* opcode/riscv-opc.h (CSR_PMPCFG0): New define.
+	(CSR_PMPCFG1): Likewise.
+	(CSR_PMPCFG2): Likewise.
+	(CSR_PMPCFG3): Likewise.
+	(CSR_PMPADDR0): Likewise.
+	(CSR_PMPADDR1): Likewise.
+	(CSR_PMPADDR2): Likewise.
+	(CSR_PMPADDR3): Likewise.
+	(CSR_PMPADDR4): Likewise.
+	(CSR_PMPADDR5): Likewise.
+	(CSR_PMPADDR6): Likewise.
+	(CSR_PMPADDR7): Likewise.
+	(CSR_PMPADDR8): Likewise.
+	(CSR_PMPADDR9): Likewise.
+	(CSR_PMPADDR10): Likewise.
+	(CSR_PMPADDR11): Likewise.
+	(CSR_PMPADDR12): Likewise.
+	(CSR_PMPADDR13): Likewise.
+	(CSR_PMPADDR14): Likewise.
+	(CSR_PMPADDR15): Likewise.
+	(pmpcfg0): Declare register.
+	(pmpcfg1): Likewise.
+	(pmpcfg2): Likewise.
+	(pmpcfg3): Likewise.
+	(pmpaddr0): Likewise.
+	(pmpaddr1): Likewise.
+	(pmpaddr2): Likewise.
+	(pmpaddr3): Likewise.
+	(pmpaddr4): Likewise.
+	(pmpaddr5): Likewise.
+	(pmpaddr6): Likewise.
+	(pmpaddr7): Likewise.
+	(pmpaddr8): Likewise.
+	(pmpaddr9): Likewise.
+	(pmpaddr10): Likewise.
+	(pmpaddr11): Likewise.
+	(pmpaddr12): Likewise.
+	(pmpaddr13): Likewise.
+	(pmpaddr14): Likewise.
+	(pmpaddr15): Likewise.
+
+2017-03-21  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2017-03-21  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* opcode/s390.h (S390_INSTR_FLAG_VX2): Remove.
+	(S390_INSTR_FLAG_FACILITY_MASK): Adjust value.
+
 2017-02-28  Alan Modra  <amodra@gmail.com>
 
 	* elf/ppc64.h (R_PPC64_16DX_HA): New.  Expand fake reloc comment.
diff --git a/include/elf/riscv.h b/include/elf/riscv.h
index 526bc11f15..daa4463926 100644
--- a/include/elf/riscv.h
+++ b/include/elf/riscv.h
@@ -109,4 +109,7 @@ END_RELOC_NUMBERS (R_RISCV_max)
 /* File uses the quad-float ABI.  */
 #define EF_RISCV_FLOAT_ABI_QUAD 0x0006
 
+/* The name of the global pointer symbol.  */
+#define RISCV_GP_SYMBOL "__global_pointer$"
+
 #endif /* _ELF_RISCV_H */
diff --git a/include/opcode/riscv-opc.h b/include/opcode/riscv-opc.h
index 9269c6be93..f80037b8f0 100644
--- a/include/opcode/riscv-opc.h
+++ b/include/opcode/riscv-opc.h
@@ -556,6 +556,26 @@
 #define CSR_MCAUSE 0x342
 #define CSR_MBADADDR 0x343
 #define CSR_MIP 0x344
+#define CSR_PMPCFG0 0x3a0
+#define CSR_PMPCFG1 0x3a1
+#define CSR_PMPCFG2 0x3a2
+#define CSR_PMPCFG3 0x3a3
+#define CSR_PMPADDR0 0x3b0
+#define CSR_PMPADDR1 0x3b1
+#define CSR_PMPADDR2 0x3b2
+#define CSR_PMPADDR3 0x3b3
+#define CSR_PMPADDR4 0x3b4
+#define CSR_PMPADDR5 0x3b5
+#define CSR_PMPADDR6 0x3b6
+#define CSR_PMPADDR7 0x3b7
+#define CSR_PMPADDR8 0x3b8
+#define CSR_PMPADDR9 0x3b9
+#define CSR_PMPADDR10 0x3ba
+#define CSR_PMPADDR11 0x3bb
+#define CSR_PMPADDR12 0x3bc
+#define CSR_PMPADDR13 0x3bd
+#define CSR_PMPADDR14 0x3be
+#define CSR_PMPADDR15 0x3bf
 #define CSR_TSELECT 0x7a0
 #define CSR_TDATA1 0x7a1
 #define CSR_TDATA2 0x7a2
@@ -1014,6 +1034,26 @@ DECLARE_CSR(mepc, CSR_MEPC)
 DECLARE_CSR(mcause, CSR_MCAUSE)
 DECLARE_CSR(mbadaddr, CSR_MBADADDR)
 DECLARE_CSR(mip, CSR_MIP)
+DECLARE_CSR(pmpcfg0, CSR_PMPCFG0)
+DECLARE_CSR(pmpcfg1, CSR_PMPCFG1)
+DECLARE_CSR(pmpcfg2, CSR_PMPCFG2)
+DECLARE_CSR(pmpcfg3, CSR_PMPCFG3)
+DECLARE_CSR(pmpaddr0, CSR_PMPADDR0)
+DECLARE_CSR(pmpaddr1, CSR_PMPADDR1)
+DECLARE_CSR(pmpaddr2, CSR_PMPADDR2)
+DECLARE_CSR(pmpaddr3, CSR_PMPADDR3)
+DECLARE_CSR(pmpaddr4, CSR_PMPADDR4)
+DECLARE_CSR(pmpaddr5, CSR_PMPADDR5)
+DECLARE_CSR(pmpaddr6, CSR_PMPADDR6)
+DECLARE_CSR(pmpaddr7, CSR_PMPADDR7)
+DECLARE_CSR(pmpaddr8, CSR_PMPADDR8)
+DECLARE_CSR(pmpaddr9, CSR_PMPADDR9)
+DECLARE_CSR(pmpaddr10, CSR_PMPADDR10)
+DECLARE_CSR(pmpaddr11, CSR_PMPADDR11)
+DECLARE_CSR(pmpaddr12, CSR_PMPADDR12)
+DECLARE_CSR(pmpaddr13, CSR_PMPADDR13)
+DECLARE_CSR(pmpaddr14, CSR_PMPADDR14)
+DECLARE_CSR(pmpaddr15, CSR_PMPADDR15)
 DECLARE_CSR(tselect, CSR_TSELECT)
 DECLARE_CSR(tdata1, CSR_TDATA1)
 DECLARE_CSR(tdata2, CSR_TDATA2)
diff --git a/include/opcode/s390.h b/include/opcode/s390.h
index 7ce5616841..2e07664425 100644
--- a/include/opcode/s390.h
+++ b/include/opcode/s390.h
@@ -51,8 +51,7 @@ enum s390_opcode_cpu_val
 
 #define S390_INSTR_FLAG_HTM 0x2
 #define S390_INSTR_FLAG_VX 0x4
-#define S390_INSTR_FLAG_VX2 0x8
-#define S390_INSTR_FLAG_FACILITY_MASK 0xe
+#define S390_INSTR_FLAG_FACILITY_MASK 0x6
 
 /* The opcode table is an array of struct s390_opcode.  */
 
diff --git a/ld/ChangeLog b/ld/ChangeLog
index ba7d1d4ce1..c3bdcbaf1d 100644
--- a/ld/ChangeLog
+++ b/ld/ChangeLog
@@ -1,3 +1,65 @@
+2017-05-31  Alan Modra  <amodra@gmail.com>
+
+	* emultempl/ppc64elf.em (plt-static-chain help): Fix quoting.
+
+2017-05-18  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-03-13  Alexey Neyman  <stilor@att.net>
+	* emulparams/elf32ppccommon.sh (LIBPATH_SUFFIX): Set from target
+	cpu, not host.
+
+2017-04-28  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>
+
+	PR ld/21404
+	* testsuite/ld-avr/pr21404-1.d: New test.
+	* testsuite/ld-avr/pr21404-1.s: New test.
+	* testsuite/ld-avr/pr21404-2.d: New test.
+	* testsuite/ld-avr/pr21404-2.s: New test.
+	* testsuite/ld-avr/pr21404-3.d: New test.
+	* testsuite/ld-avr/pr21404-3.s: New test.
+	* testsuite/ld-avr/pr21404-4.d: New test.
+	* testsuite/ld-avr/pr21404-4.s: New test.
+	* testsuite/ld-avr/pr21404-5.d: New test.
+	* testsuite/ld-avr/pr21404-5.s: New test.
+	* testsuite/ld-avr/pr21404-6.d: New test.
+	* testsuite/ld-avr/pr21404-6.s: New test.
+	* testsuite/ld-avr/pr21404-7.d: New test.
+	* testsuite/ld-avr/pr21404-7.s: New test.
+	* testsuite/ld-avr/pr21404-8.d: New test.
+	* testsuite/ld-avr/pr21404-8.s: New test.
+
+2017-04-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/20815
+	* testsuite/ld-i386/vxworks2.sd: Add space for program headers.
+
+2017-03-28  Hans-Peter Nilsson  <hp@axis.com>
+
+	PR ld/16044
+	* testsuite/ld-cris/pr16044.d, testsuite/ld-cris/dso-1c.s,
+	testsuite/ld-cris/dso-2b.s, testsuite/ld-cris/dso-4.s: New test.
+
+2017-04-10  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/19579
+	PR ld/21306
+	* testsuite/ld-elf/pr19579a.c (main): Updated.
+
+2017-04-05  Maciej W. Rozycki  <macro@imgtec.com>
+
+	PR ld/21233
+	* ldlang.c (insert_undefined): Set `mark' for ELF symbols.
+
+2017-03-07  Alan Modra  <amodra@gmail.com>
+
+	* ldlang.c (open_input_bfds): Check that lang_assignment_statement
+	is not an assert before referencing defsym.
+
+2017-03-02  Tristan Gingold  <gingold@adacore.com>
+
+	* configure: Regenerate.
+
 2017-03-02  Tristan Gingold  <gingold@adacore.com>
 
 	* configure: Regenerate.
diff --git a/ld/configure b/ld/configure
index 36af9695b1..a16c6db059 100755
--- a/ld/configure
+++ b/ld/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.64 for ld 2.28.
+# Generated by GNU Autoconf 2.64 for ld 2.28.0.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
@@ -556,8 +556,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='ld'
 PACKAGE_TARNAME='ld'
-PACKAGE_VERSION='2.28'
-PACKAGE_STRING='ld 2.28'
+PACKAGE_VERSION='2.28.0'
+PACKAGE_STRING='ld 2.28.0'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
@@ -1354,7 +1354,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures ld 2.28 to adapt to many kinds of systems.
+\`configure' configures ld 2.28.0 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1425,7 +1425,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of ld 2.28:";;
+     short | recursive ) echo "Configuration of ld 2.28.0:";;
    esac
   cat <<\_ACEOF
 
@@ -1550,7 +1550,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-ld configure 2.28
+ld configure 2.28.0
 generated by GNU Autoconf 2.64
 
 Copyright (C) 2009 Free Software Foundation, Inc.
@@ -2259,7 +2259,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by ld $as_me 2.28, which was
+It was created by ld $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   $ $0 $@
@@ -4069,7 +4069,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='ld'
- VERSION='2.28'
+ VERSION='2.28.0'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -17813,7 +17813,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by ld $as_me 2.28, which was
+This file was extended by ld $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -17877,7 +17877,7 @@ Report bugs to the package provider."
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-ld config.status 2.28
+ld config.status 2.28.0
 configured by $0, generated by GNU Autoconf 2.64,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
diff --git a/ld/emulparams/elf32ppccommon.sh b/ld/emulparams/elf32ppccommon.sh
index 1f54ef8056..d00cf68d89 100644
--- a/ld/emulparams/elf32ppccommon.sh
+++ b/ld/emulparams/elf32ppccommon.sh
@@ -44,11 +44,11 @@ fi
 
 # Look for 64 bit target libraries in /lib64, /usr/lib64 etc., first.
 # Similarly, look for 32 bit libraries in /lib32, /usr/lib32 etc.
-case "$host":"$EMULATION_NAME" in
-  *le-*:*64lppc*) LIBPATH_SUFFIX=64 ;;
-  *le-*:*32lppc*) LIBPATH_SUFFIX=32 ;;
-  *le-*:*64*) LIBPATH_SUFFIX=64be ;;
-  *le-*:*32*) LIBPATH_SUFFIX=32be ;;
+case `echo "$target" | sed -e 's/-.*//'`:"$EMULATION_NAME" in
+  *le:*64lppc*) LIBPATH_SUFFIX=64 ;;
+  *le:*32lppc*) LIBPATH_SUFFIX=32 ;;
+  *le:*64*) LIBPATH_SUFFIX=64be ;;
+  *le:*32*) LIBPATH_SUFFIX=32be ;;
   *:*64lppc*) LIBPATH_SUFFIX=64le ;;
   *:*32lppc*) LIBPATH_SUFFIX=32le ;;
   *:*64*) LIBPATH_SUFFIX=64 ;;
diff --git a/ld/emultempl/ppc64elf.em b/ld/emultempl/ppc64elf.em
index 9e5f24041a..f1d5274620 100644
--- a/ld/emultempl/ppc64elf.em
+++ b/ld/emultempl/ppc64elf.em
@@ -742,10 +742,10 @@ PARSE_AND_LIST_OPTIONS=${PARSE_AND_LIST_OPTIONS}'
                                 choose suitable defaults.\n"
 		   ));
   fprintf (file, _("\
-  --plt-static-chain          PLT call stubs should load r11.${DEFAULT_PLT_STATIC_CHAIN- (default)}\n"
+  --plt-static-chain          PLT call stubs should load r11.'${DEFAULT_PLT_STATIC_CHAIN- (default)}'\n"
 		   ));
   fprintf (file, _("\
-  --no-plt-static-chain       PLT call stubs should not load r11.${DEFAULT_PLT_STATIC_CHAIN+ (default)}\n"
+  --no-plt-static-chain       PLT call stubs should not load r11.'${DEFAULT_PLT_STATIC_CHAIN+ (default)}'\n"
 		   ));
   fprintf (file, _("\
   --plt-thread-safe           PLT call stubs with load-load barrier.\n"
diff --git a/ld/ldlang.c b/ld/ldlang.c
index dafc3489fd..a8ff0a413e 100644
--- a/ld/ldlang.c
+++ b/ld/ldlang.c
@@ -3377,7 +3377,8 @@ open_input_bfds (lang_statement_union_type *s, enum open_bfd_mode mode)
 #endif
 	  break;
 	case lang_assignment_statement_enum:
-	  if (s->assignment_statement.exp->assign.defsym)
+	  if (s->assignment_statement.exp->type.node_class != etree_assert
+	      && s->assignment_statement.exp->assign.defsym)
 	    /* This is from a --defsym on the command line.  */
 	    exp_fold_tree_no_dot (s->assignment_statement.exp);
 	  break;
@@ -3431,6 +3432,8 @@ insert_undefined (const char *name)
     {
       h->type = bfd_link_hash_undefined;
       h->u.undef.abfd = NULL;
+      if (is_elf_hash_table (link_info.hash))
+	((struct elf_link_hash_entry *) h)->mark = 1;
       bfd_link_add_undef (link_info.hash, h);
     }
 }
diff --git a/ld/testsuite/ld-avr/pr21404-1.d b/ld/testsuite/ld-avr/pr21404-1.d
new file mode 100644
index 0000000000..fc7103fc9f
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-1.d
@@ -0,0 +1,12 @@
+#name: AVR symbol size adjustment with non zero symbol value
+#as: -mmcu=avrxmega2 -mlink-relax
+#ld:  -mavrxmega2 --relax
+#source: pr21404-1.s
+#nm: -n -S
+#target: avr-*-*
+
+#...
+00000000 00000004 T main
+#...
+00000002 00000002 T nonzero_sym
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-1.s b/ld/testsuite/ld-avr/pr21404-1.s
new file mode 100644
index 0000000000..66ddb7d4a3
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-1.s
@@ -0,0 +1,11 @@
+    .file "pr21404-1.s"
+.section	.text,"ax",@progbits
+.global nonzero_sym
+.global main
+main:
+L1:
+    jmp  L1
+nonzero_sym:
+    nop
+.size main, .-main
+.size nonzero_sym, .-nonzero_sym
diff --git a/ld/testsuite/ld-avr/pr21404-2.d b/ld/testsuite/ld-avr/pr21404-2.d
new file mode 100644
index 0000000000..e85735cd7d
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-2.d
@@ -0,0 +1,16 @@
+#name: AVR symbol size adjustment across alignment boundary
+#as: -mmcu=avrxmega2 -mlink-relax
+#ld:  -mavrxmega2 --relax
+#source: pr21404-2.s
+#nm: -n -S
+#target: avr-*-*
+
+#...
+00000000 00000006 T main
+00000000 00000004 T size_after_align
+00000000 00000004 T size_before_align
+#...
+00000002 00000002 T nonzero_sym_after_align
+00000002 00000004 T nonzero_sym_after_end
+00000002 00000002 T nonzero_sym_before_align
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-2.s b/ld/testsuite/ld-avr/pr21404-2.s
new file mode 100644
index 0000000000..e1da1ae4b3
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-2.s
@@ -0,0 +1,25 @@
+    .file "pr21404.s"
+.section	.text,"ax",@progbits
+.global size_before_align
+.global size_after_align
+.global main
+.global nonzero_sym_before_align
+.global nonzero_sym_after_align
+.global nonzero_sym_after_end
+main:
+size_before_align:
+size_after_align:
+L1:
+    jmp  L1
+nonzero_sym_before_align:
+nonzero_sym_after_align:
+nonzero_sym_after_end:
+    jmp  L1
+.size size_before_align, .-size_before_align
+.size nonzero_sym_before_align, .-nonzero_sym_before_align
+    .p2align 1
+.size size_after_align, .-size_after_align
+.size nonzero_sym_after_align, .-nonzero_sym_after_align
+.word L1
+.size main, .-main
+.size nonzero_sym_after_end, .-nonzero_sym_after_end
diff --git a/ld/testsuite/ld-avr/pr21404-3.d b/ld/testsuite/ld-avr/pr21404-3.d
new file mode 100644
index 0000000000..145b48fff2
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-3.d
@@ -0,0 +1,10 @@
+#name: AVR symbol value adjustment with non zero symbol value
+#as: -mmcu=avrxmega2 -mlink-relax
+#ld:  -mavrxmega2 --relax
+#source: pr21404-3.s
+#nm: -n -S
+#target: avr-*-*
+
+#...
+00000006 T nonzero_sym
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-3.s b/ld/testsuite/ld-avr/pr21404-3.s
new file mode 100644
index 0000000000..d62ecd99ed
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-3.s
@@ -0,0 +1,10 @@
+    .file "pr21404-3.s"
+.section	.text,"ax",@progbits
+.global nonzero_sym
+L1:
+    jmp  L1
+    jmp  L1
+    jmp L1
+    .p2align 1
+nonzero_sym:
+    jmp L1
diff --git a/ld/testsuite/ld-avr/pr21404-4.d b/ld/testsuite/ld-avr/pr21404-4.d
new file mode 100644
index 0000000000..b80dfcffbe
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-4.d
@@ -0,0 +1,10 @@
+#name: AVR symbol size increase for alignment
+#as: -mmcu=avrxmega2 -mlink-relax
+#ld:  -mavrxmega2 --relax
+#source: pr21404-4.s
+#nm: -n -S
+#target: avr-*-*
+
+#...
+00000002 00000006 T nonzero_sym
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-4.s b/ld/testsuite/ld-avr/pr21404-4.s
new file mode 100644
index 0000000000..3e957bb43b
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-4.s
@@ -0,0 +1,10 @@
+    .file "pr21404-4.s"
+.section	.text,"ax",@progbits
+.global nonzero_sym
+L1:
+    jmp  L1
+nonzero_sym:
+    nop
+    nop
+    .p2align 2
+.size nonzero_sym, .-nonzero_sym
diff --git a/ld/testsuite/ld-avr/pr21404-5.d b/ld/testsuite/ld-avr/pr21404-5.d
new file mode 100644
index 0000000000..519c50fdd6
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-5.d
@@ -0,0 +1,11 @@
+#name: AVR local symbol size adjustment with non zero symbol value
+#as: -mmcu=avrxmega2 -mlink-relax
+#ld:  -mavrxmega2 --relax
+#source: pr21404-5.s
+#nm: -n -S
+#target: avr-*-*
+
+#...
+00000000 00000004 t _main
+00000002 00000002 t _nonzero_sym
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-5.s b/ld/testsuite/ld-avr/pr21404-5.s
new file mode 100644
index 0000000000..ccf2394e0e
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-5.s
@@ -0,0 +1,9 @@
+    .file "pr21404-1.s"
+.section	.text,"ax",@progbits
+_main:
+L1:
+    jmp  L1
+_nonzero_sym:
+    nop
+.size _main, .-_main
+.size _nonzero_sym, .-_nonzero_sym
diff --git a/ld/testsuite/ld-avr/pr21404-6.d b/ld/testsuite/ld-avr/pr21404-6.d
new file mode 100644
index 0000000000..784fc7c326
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-6.d
@@ -0,0 +1,16 @@
+#name: AVR local symbol size adjustment across alignment boundary
+#as: -mmcu=avrxmega2 -mlink-relax
+#ld:  -mavrxmega2 --relax
+#source: pr21404-6.s
+#nm: -n -S
+#target: avr-*-*
+
+#...
+00000000 00000006 t main
+00000000 00000004 t size_after_align
+00000000 00000004 t size_before_align
+#...
+00000002 00000002 t nonzero_sym_after_align
+00000002 00000004 t nonzero_sym_after_end
+00000002 00000002 t nonzero_sym_before_align
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-6.s b/ld/testsuite/ld-avr/pr21404-6.s
new file mode 100644
index 0000000000..36f2301ba8
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-6.s
@@ -0,0 +1,19 @@
+    .file "pr21404-6.s"
+.section	.text,"ax",@progbits
+main:
+size_before_align:
+size_after_align:
+L1:
+    jmp  L1
+nonzero_sym_before_align:
+nonzero_sym_after_align:
+nonzero_sym_after_end:
+    jmp  L1
+.size size_before_align, .-size_before_align
+.size nonzero_sym_before_align, .-nonzero_sym_before_align
+    .p2align 1
+.size size_after_align, .-size_after_align
+.size nonzero_sym_after_align, .-nonzero_sym_after_align
+.word L1
+.size main, .-main
+.size nonzero_sym_after_end, .-nonzero_sym_after_end
diff --git a/ld/testsuite/ld-avr/pr21404-7.d b/ld/testsuite/ld-avr/pr21404-7.d
new file mode 100644
index 0000000000..1360acb3e5
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-7.d
@@ -0,0 +1,10 @@
+#name: AVR local symbol value adjustment with non zero symbol value
+#as: -mmcu=avrxmega2 -mlink-relax
+#ld:  -mavrxmega2 --relax
+#source: pr21404-7.s
+#nm: -n -S
+#target: avr-*-*
+
+#...
+00000006 t nonzero_sym
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-7.s b/ld/testsuite/ld-avr/pr21404-7.s
new file mode 100644
index 0000000000..b7e4e354dd
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-7.s
@@ -0,0 +1,9 @@
+    .file "pr21404-7.s"
+.section	.text,"ax",@progbits
+L1:
+    jmp  L1
+    jmp  L1
+    jmp L1
+    .p2align 1
+nonzero_sym:
+    jmp L1
diff --git a/ld/testsuite/ld-avr/pr21404-8.d b/ld/testsuite/ld-avr/pr21404-8.d
new file mode 100644
index 0000000000..d70ba8fc3a
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-8.d
@@ -0,0 +1,10 @@
+#name: AVR local symbol size increase for alignment
+#as: -mmcu=avrxmega2 -mlink-relax
+#ld:  -mavrxmega2 --relax
+#source: pr21404-8.s
+#nm: -n -S
+#target: avr-*-*
+
+#...
+00000002 00000006 t nonzero_sym
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-8.s b/ld/testsuite/ld-avr/pr21404-8.s
new file mode 100644
index 0000000000..6b00df541a
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-8.s
@@ -0,0 +1,9 @@
+    .file "pr21404-8.s"
+.section	.text,"ax",@progbits
+L1:
+    jmp  L1
+nonzero_sym:
+    nop
+    nop
+    .p2align 2
+.size nonzero_sym, .-nonzero_sym
diff --git a/ld/testsuite/ld-cris/dso-1c.s b/ld/testsuite/ld-cris/dso-1c.s
new file mode 100644
index 0000000000..92ad4ee082
--- /dev/null
+++ b/ld/testsuite/ld-cris/dso-1c.s
@@ -0,0 +1,2 @@
+	.include "dso-1.s"
+	.hidden dsofn
diff --git a/ld/testsuite/ld-cris/dso-2b.s b/ld/testsuite/ld-cris/dso-2b.s
new file mode 100644
index 0000000000..f1fbf14780
--- /dev/null
+++ b/ld/testsuite/ld-cris/dso-2b.s
@@ -0,0 +1,2 @@
+	.include "dso-2.s"
+	.hidden dsofn
diff --git a/ld/testsuite/ld-cris/dso-4.s b/ld/testsuite/ld-cris/dso-4.s
new file mode 100644
index 0000000000..767a0d8226
--- /dev/null
+++ b/ld/testsuite/ld-cris/dso-4.s
@@ -0,0 +1,6 @@
+	.text
+	.global	export_2
+	.type	export_2,@function
+export_2:
+	.hidden dsofn
+	move.d dsofn:GOTOFF,$r4
diff --git a/ld/testsuite/ld-cris/pr16044.d b/ld/testsuite/ld-cris/pr16044.d
new file mode 100644
index 0000000000..e5d373df8f
--- /dev/null
+++ b/ld/testsuite/ld-cris/pr16044.d
@@ -0,0 +1,43 @@
+#source: dso-4.s
+#source: dso-2b.s
+#source: dso-1c.s
+#as: --pic --no-underscore --em=criself -I$srcdir/$subdir
+#ld: --shared -m crislinux
+#readelf: -s -r
+
+# PR 16044 is about a (compile-time-non-local) hidden function symbol,
+# entered as an undef reference with a R_CRIS_32_PLT_GOTREL relocation
+# referring to a hidden symbol, later defined.  Here, we invalidly
+# incremented the h->plt.refcount (from -1) as part of that relocation
+# processing.  There are some PLTGOT relocations.  As there are no
+# circumstances requiring a PLT entry for this symbol, its PLT entry
+# can be eliminated and the PLTGOT relocations can be made to a static
+# element in the GOT, relocated with the absolute-to-relative
+# R_CRIS_RELATIVE relocation without symbol lookup.  As part of
+# eliminating unneeded PLT entries (and PLTGOT to "static" GOT
+# elimination), a later pass noticed the inconsistency through an
+# assert.
+#
+# The key points in this dump that may need future adjustments are the
+# single dynamic relocation, that the dsofn symbol it points to, is
+# local, its absence from the dynamic symbol table and that the
+# relocation and symbol values match.
+
+Relocation section '\.rela\.dyn' at offset 0x[0-9a-f]+ contains 1 entries:
+ Offset[ 	]+Info[ 	]+Type[ 	]+Sym\.Value  Sym\. Name \+ Addend
+[0-9a-f]+  0+[0-9a-f]+ R_CRIS_RELATIVE[ 	]+184
+
+Symbol table '\.dynsym' contains 7 entries:
+ +Num: +Value +Size +Type +Bind +Vis +Ndx +Name
+ +0: 0+ +0 +NOTYPE +LOCAL +DEFAULT +UND 
+ +1: [0-9a-f]+ +0 +SECTION +LOCAL +DEFAULT +5 
+ +2: [0-9a-f]+ +0 +FUNC +GLOBAL +DEFAULT +5 export_1
+ +3: [0-9a-f]+ +0 +NOTYPE +GLOBAL +DEFAULT +7 __bss_start
+ +4: [0-9a-f]+ +0 +NOTYPE +GLOBAL +DEFAULT +7 _edata
+ +5: [0-9a-f]+ +0 +NOTYPE +GLOBAL +DEFAULT +7 _end
+ +6: [0-9a-f]+ +0 +FUNC +GLOBAL +DEFAULT +5 export_2
+
+Symbol table '\.symtab' contains [0-9]+ entries:
+#...
+ +[0-9]+: 0+184  +2 FUNC + LOCAL + DEFAULT + 5 dsofn
+#...
diff --git a/ld/testsuite/ld-elf/pr19579a.c b/ld/testsuite/ld-elf/pr19579a.c
index e4a6eb1ea9..69d0f35898 100644
--- a/ld/testsuite/ld-elf/pr19579a.c
+++ b/ld/testsuite/ld-elf/pr19579a.c
@@ -9,7 +9,7 @@ extern int *bar_p (void);
 int
 main ()
 {
-  if (foo[0] == 0 && foo == foo_p () && bar[0] == 0 && bar == bar_p ())
+  if (foo[0] == 0 && foo == foo_p () && bar[0] == -1 && bar == bar_p ())
     printf ("PASS\n");
   return 0;
 }
diff --git a/ld/testsuite/ld-i386/vxworks2.sd b/ld/testsuite/ld-i386/vxworks2.sd
index 5ff87d3bef..4f56f2ac7e 100644
--- a/ld/testsuite/ld-i386/vxworks2.sd
+++ b/ld/testsuite/ld-i386/vxworks2.sd
@@ -6,7 +6,7 @@ Program Headers:
   Type .*
   PHDR .*
 #...
-  LOAD .* 0x00080000 0x00080000 .* R E 0x1000
+  LOAD .* 0x0007f000 0x0007f000 .* R E 0x1000
   LOAD .* 0x00081000 0x00081000 .* RW  0x1000
   DYNAMIC .*
 
diff --git a/opcodes/ChangeLog b/opcodes/ChangeLog
index 7f01e54188..5dfe1661fa 100644
--- a/opcodes/ChangeLog
+++ b/opcodes/ChangeLog
@@ -1,3 +1,71 @@
+2017-05-01  Michael Clark  <michaeljclark@mac.com>
+
+	* riscv-opc.c (riscv_opcodes) <call>: Use RA not T1 as a temporary
+	register.
+
+2017-04-03  Palmer Dabbelt  <palmer@dabbelt.com>
+
+	* riscv-dis.c (riscv_disassemble_insn): Change "_gp" to
+	RISCV_GP_SYMBOL.
+
+2017-03-14  Kito Cheng  <kito.cheng@gmail.com>
+
+	* riscv-opc.c (riscv_opcodes> <c.li>: Use the 'o' immediate encoding.
+	<c.andi>: Likewise.
+	<c.addiw> Likewise.
+
+2017-03-14  Kito Cheng  <kito.cheng@gmail.com>
+
+	* riscv-opc.c (riscv_opcodes) <c.addi>: Use match_opcode.
+
+2017-03-13  Andrew Waterman  <andrew@sifive.com>
+
+	* riscv-opc.c (riscv_opcodes) <srli/C>: Use match_opcode.
+	<srl> Likewise.
+	<srai> Likewise.
+	<sra> Likewise.
+
+2017-03-27  Alan Modra  <amodra@gmail.com>
+
+	PR 21303
+	* ppc-dis.c (struct ppc_mopt): Comment.
+	(ppc_opts <e200z4>): Move PPC_OPCODE_VLE from .sticky to .cpu.
+
+2017-03-21  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2017-03-21  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* s390-mkopc.c (main): Remove vx2 check.
+	* s390-opc.txt: Remove vx2 instruction flags.
+
+2017-03-08  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* ppc-dis.c (ppc_opts) <altivec>: Do not use PPC_OPCODE_ALTIVEC2;
+	<vsx>: Do not use PPC_OPCODE_VSX3;
+
+2017-03-08  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Apply from master.
+	2017-03-08  Peter Bergner  <bergner@vnet.ibm.com>
+	* ppc-opc.c (powerpc_opcodes) <lnia>: New extended mnemonic.
+
+2017-03-07  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-03-06  Alan Modra  <amodra@gmail.com>
+	PR 21124
+	* ppc-opc.c (extract_esync, extract_ls, extract_ral, extract_ram)
+	(extract_raq, extract_ras, extract_rbx): New functions.
+	(powerpc_operands): Use opposite corresponding insert function.
+	(Q_MASK): Define.
+	(powerpc_opcodes): Apply Q_MASK to all quad insns with even
+	register restriction.
+
+2017-03-02  Tristan Gingold  <gingold@adacore.com>
+
+	* configure: Regenerate.
+
 2017-03-02  Tristan Gingold  <gingold@adacore.com>
 
 	* configure: Regenerate.
diff --git a/opcodes/configure b/opcodes/configure
index be87eb22a5..0b352a454d 100755
--- a/opcodes/configure
+++ b/opcodes/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.64 for opcodes 2.28.
+# Generated by GNU Autoconf 2.64 for opcodes 2.28.0.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
@@ -556,8 +556,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='opcodes'
 PACKAGE_TARNAME='opcodes'
-PACKAGE_VERSION='2.28'
-PACKAGE_STRING='opcodes 2.28'
+PACKAGE_VERSION='2.28.0'
+PACKAGE_STRING='opcodes 2.28.0'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
@@ -1322,7 +1322,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures opcodes 2.28 to adapt to many kinds of systems.
+\`configure' configures opcodes 2.28.0 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1393,7 +1393,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of opcodes 2.28:";;
+     short | recursive ) echo "Configuration of opcodes 2.28.0:";;
    esac
   cat <<\_ACEOF
 
@@ -1500,7 +1500,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-opcodes configure 2.28
+opcodes configure 2.28.0
 generated by GNU Autoconf 2.64
 
 Copyright (C) 2009 Free Software Foundation, Inc.
@@ -1910,7 +1910,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by opcodes $as_me 2.28, which was
+It was created by opcodes $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   $ $0 $@
@@ -3719,7 +3719,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='opcodes'
- VERSION='2.28'
+ VERSION='2.28.0'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -13305,7 +13305,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by opcodes $as_me 2.28, which was
+This file was extended by opcodes $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -13369,7 +13369,7 @@ Report bugs to the package provider."
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-opcodes config.status 2.28
+opcodes config.status 2.28.0
 configured by $0, generated by GNU Autoconf 2.64,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
diff --git a/opcodes/ppc-dis.c b/opcodes/ppc-dis.c
index e0eff7a67b..baa73880aa 100644
--- a/opcodes/ppc-dis.c
+++ b/opcodes/ppc-dis.c
@@ -45,8 +45,19 @@ struct dis_private
   (((struct dis_private *) ((INFO)->private_data))->dialect)
 
 struct ppc_mopt {
+  /* Option string, without -m or -M prefix.  */
   const char *opt;
+  /* CPU option flags.  */
   ppc_cpu_t cpu;
+  /* Flags that should stay on, even when combined with another cpu
+     option.  This should only be used for generic options like
+     "-many" or "-maltivec" where it is reasonable to add some
+     capability to another cpu selection.  The added flags are sticky
+     so that, for example, "-many -me500" and "-me500 -many" result in
+     the same assembler or disassembler behaviour.  Do not use
+     "sticky" for specific cpus, as this will prevent that cpu's flags
+     from overriding the defaults set in powerpc_init_dialect or a
+     prior -m option.  */
   ppc_cpu_t sticky;
 };
 
@@ -93,7 +104,7 @@ struct ppc_mopt ppc_opts[] = {
 		| PPC_OPCODE_A2),
     0 },
   { "altivec", PPC_OPCODE_PPC,
-    PPC_OPCODE_ALTIVEC | PPC_OPCODE_ALTIVEC2 },
+    PPC_OPCODE_ALTIVEC },
   { "any",     0,
     PPC_OPCODE_ANY },
   { "booke",   PPC_OPCODE_PPC | PPC_OPCODE_BOOKE,
@@ -108,8 +119,8 @@ struct ppc_mopt ppc_opts[] = {
   { "e200z4",  (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE| PPC_OPCODE_SPE
 		| PPC_OPCODE_ISEL | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
 		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
-		| PPC_OPCODE_E500 | PPC_OPCODE_E200Z4),
-    PPC_OPCODE_VLE },
+		| PPC_OPCODE_E500 | PPC_OPCODE_VLE | PPC_OPCODE_E200Z4),
+    0 },
   { "e300",    PPC_OPCODE_PPC | PPC_OPCODE_E300,
     0 },
   { "e500",    (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_SPE
@@ -221,7 +232,7 @@ struct ppc_mopt ppc_opts[] = {
 		| PPC_OPCODE_E500),
     PPC_OPCODE_VLE },
   { "vsx",     PPC_OPCODE_PPC,
-    PPC_OPCODE_VSX | PPC_OPCODE_VSX3 },
+    PPC_OPCODE_VSX },
   { "htm",     PPC_OPCODE_PPC,
     PPC_OPCODE_HTM },
 };
diff --git a/opcodes/ppc-opc.c b/opcodes/ppc-opc.c
index 9ac779c96a..f7d1dcd7c2 100644
--- a/opcodes/ppc-opc.c
+++ b/opcodes/ppc-opc.c
@@ -54,6 +54,7 @@ static long extract_bo (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_boe (unsigned long, long, ppc_cpu_t, const char **);
 static long extract_boe (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_esync (unsigned long, long, ppc_cpu_t, const char **);
+static long extract_esync (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_dcmxs (unsigned long, long, ppc_cpu_t, const char **);
 static long extract_dcmxs (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_dxd (unsigned long, long, ppc_cpu_t, const char **);
@@ -65,6 +66,7 @@ static long extract_fxm (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_li20 (unsigned long, long, ppc_cpu_t, const char **);
 static long extract_li20 (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_ls (unsigned long, long, ppc_cpu_t, const char **);
+static long extract_ls (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_mbe (unsigned long, long, ppc_cpu_t, const char **);
 static long extract_mbe (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_mb6 (unsigned long, long, ppc_cpu_t, const char **);
@@ -76,12 +78,17 @@ static long extract_nsi (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_oimm (unsigned long, long, ppc_cpu_t, const char **);
 static long extract_oimm (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_ral (unsigned long, long, ppc_cpu_t, const char **);
+static long extract_ral (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_ram (unsigned long, long, ppc_cpu_t, const char **);
+static long extract_ram (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_raq (unsigned long, long, ppc_cpu_t, const char **);
+static long extract_raq (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_ras (unsigned long, long, ppc_cpu_t, const char **);
+static long extract_ras (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_rbs (unsigned long, long, ppc_cpu_t, const char **);
 static long extract_rbs (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_rbx (unsigned long, long, ppc_cpu_t, const char **);
+static long extract_rbx (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_rx (unsigned long, long, ppc_cpu_t, const char **);
 static long extract_rx (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_ry (unsigned long, long, ppc_cpu_t, const char **);
@@ -462,7 +469,7 @@ const struct powerpc_operand powerpc_operands[] =
   /* The LS or WC field in an X (sync or wait) form instruction.  */
 #define LS LIA + 1
 #define WC LS
-  { 0x3, 21, insert_ls, NULL, PPC_OPERAND_OPTIONAL },
+  { 0x3, 21, insert_ls, extract_ls, PPC_OPERAND_OPTIONAL },
 
   /* The ME field in an M form instruction.  */
 #define ME LS + 1
@@ -519,24 +526,24 @@ const struct powerpc_operand powerpc_operands[] =
      value restrictions.  */
 #define RAQ RA0 + 1
 #define RAX RAQ
-  { 0x1f, 16, insert_raq, NULL, PPC_OPERAND_GPR_0 },
+  { 0x1f, 16, insert_raq, extract_raq, PPC_OPERAND_GPR_0 },
 
   /* The RA field in a D or X form instruction which is an updating
      load, which means that the RA field may not be zero and may not
      equal the RT field.  */
 #define RAL RAQ + 1
-  { 0x1f, 16, insert_ral, NULL, PPC_OPERAND_GPR_0 },
+  { 0x1f, 16, insert_ral, extract_ral, PPC_OPERAND_GPR_0 },
 
   /* The RA field in an lmw instruction, which has special value
      restrictions.  */
 #define RAM RAL + 1
-  { 0x1f, 16, insert_ram, NULL, PPC_OPERAND_GPR_0 },
+  { 0x1f, 16, insert_ram, extract_ram, PPC_OPERAND_GPR_0 },
 
   /* The RA field in a D or X form instruction which is an updating
      store or an updating floating point load, which means that the RA
      field may not be zero.  */
 #define RAS RAM + 1
-  { 0x1f, 16, insert_ras, NULL, PPC_OPERAND_GPR_0 },
+  { 0x1f, 16, insert_ras, extract_ras, PPC_OPERAND_GPR_0 },
 
   /* The RA field of the tlbwe, dccci and iccci instructions,
      which are optional.  */
@@ -557,7 +564,7 @@ const struct powerpc_operand powerpc_operands[] =
   /* The RB field in an lswx instruction, which has special value
      restrictions.  */
 #define RBX RBS + 1
-  { 0x1f, 11, insert_rbx, NULL, PPC_OPERAND_GPR },
+  { 0x1f, 11, insert_rbx, extract_rbx, PPC_OPERAND_GPR },
 
   /* The RB field of the dccci and iccci instructions, which are optional.  */
 #define RBOPT RBX + 1
@@ -580,6 +587,7 @@ const struct powerpc_operand powerpc_operands[] =
      which have special value restrictions.  */
 #define RSQ RS + 1
 #define RTQ RSQ
+#define Q_MASK (1 << 21)
   { 0x1e, 21, NULL, NULL, PPC_OPERAND_GPR },
 
   /* The RS field of the tlbwe instruction, which is optional.  */
@@ -694,7 +702,7 @@ const struct powerpc_operand powerpc_operands[] =
 
   /* The ESYNC field in an X (sync) form instruction.  */
 #define ESYNC STRM + 1
-  { 0xf, 16, insert_esync, NULL, PPC_OPERAND_OPTIONAL },
+  { 0xf, 16, insert_esync, extract_esync, PPC_OPERAND_OPTIONAL },
 
   /* The SV field in a POWER SC form instruction.  */
 #define SV ESYNC + 1
@@ -1533,6 +1541,22 @@ insert_ls (unsigned long insn,
   return insn | ((value & 0x3) << 21);
 }
 
+static long
+extract_ls (unsigned long insn,
+	    ppc_cpu_t dialect,
+	    int *invalid)
+{
+  unsigned long lvalue = (insn >> 21) & 3;
+
+  if (((insn >> 1) & 0x3ff) == 598)
+    {
+      unsigned long max_lvalue = (dialect & PPC_OPCODE_POWER4) ? 2 : 1;
+      if (lvalue > max_lvalue)
+	*invalid = 1;
+    }
+  return lvalue;
+}
+
 /* The 4-bit E field in a sync instruction that accepts 2 operands.
    If ESYNC is non-zero, then the L field must be either 0 or 1 and
    the complement of ESYNC-bit2.  */
@@ -1560,6 +1584,27 @@ insert_esync (unsigned long insn,
   return insn | ((value & 0xf) << 16);
 }
 
+static long
+extract_esync (unsigned long insn,
+	       ppc_cpu_t dialect,
+	       int *invalid)
+{
+  unsigned long ls = (insn >> 21) & 0x3;
+  unsigned long lvalue = (insn >> 16) & 0xf;
+
+  if (lvalue == 0)
+    {
+      if (((dialect & PPC_OPCODE_E6500) != 0 && ls > 1)
+	  || ((dialect & PPC_OPCODE_POWER9) != 0 && ls > 2))
+	*invalid = 1;
+    }
+  else if ((ls & ~0x1)
+	   || (((lvalue >> 1) & 0x1) ^ ls) == 0)
+    *invalid = 1;
+
+  return lvalue;
+}
+
 /* The MB and ME fields in an M form instruction expressed as a single
    operand which is itself a bitmask.  The extraction function always
    marks it as invalid, since we never want to recognize an
@@ -1743,6 +1788,19 @@ insert_ral (unsigned long insn,
   return insn | ((value & 0x1f) << 16);
 }
 
+static long
+extract_ral (unsigned long insn,
+	     ppc_cpu_t dialect ATTRIBUTE_UNUSED,
+	     int *invalid)
+{
+  long rtvalue = (insn >> 21) & 0x1f;
+  long ravalue = (insn >> 16) & 0x1f;
+
+  if (rtvalue == ravalue || ravalue == 0)
+    *invalid = 1;
+  return ravalue;
+}
+
 /* The RA field in an lmw instruction, which has special value
    restrictions.  */
 
@@ -1757,6 +1815,19 @@ insert_ram (unsigned long insn,
   return insn | ((value & 0x1f) << 16);
 }
 
+static long
+extract_ram (unsigned long insn,
+	     ppc_cpu_t dialect ATTRIBUTE_UNUSED,
+	     int *invalid)
+{
+  unsigned long rtvalue = (insn >> 21) & 0x1f;
+  unsigned long ravalue = (insn >> 16) & 0x1f;
+
+  if (ravalue >= rtvalue)
+    *invalid = 1;
+  return ravalue;
+}
+
 /* The RA field in the DQ form lq or an lswx instruction, which have special
    value restrictions.  */
 
@@ -1773,6 +1844,19 @@ insert_raq (unsigned long insn,
   return insn | ((value & 0x1f) << 16);
 }
 
+static long
+extract_raq (unsigned long insn,
+	     ppc_cpu_t dialect ATTRIBUTE_UNUSED,
+	     int *invalid)
+{
+  unsigned long rtvalue = (insn >> 21) & 0x1f;
+  unsigned long ravalue = (insn >> 16) & 0x1f;
+
+  if (ravalue == rtvalue)
+    *invalid = 1;
+  return ravalue;
+}
+
 /* The RA field in a D or X form instruction which is an updating
    store or an updating floating point load, which means that the RA
    field may not be zero.  */
@@ -1788,6 +1872,18 @@ insert_ras (unsigned long insn,
   return insn | ((value & 0x1f) << 16);
 }
 
+static long
+extract_ras (unsigned long insn,
+	     ppc_cpu_t dialect ATTRIBUTE_UNUSED,
+	     int *invalid)
+{
+  unsigned long ravalue = (insn >> 16) & 0x1f;
+
+  if (ravalue == 0)
+    *invalid = 1;
+  return ravalue;
+}
+
 /* The RB field in an X form instruction when it must be the same as
    the RS field in the instruction.  This is used for extended
    mnemonics like mr.  This operand is marked FAKE.  The insertion
@@ -1829,6 +1925,19 @@ insert_rbx (unsigned long insn,
   return insn | ((value & 0x1f) << 11);
 }
 
+static long
+extract_rbx (unsigned long insn,
+	     ppc_cpu_t dialect ATTRIBUTE_UNUSED,
+	     int *invalid)
+{
+  unsigned long rtvalue = (insn >> 21) & 0x1f;
+  unsigned long rbvalue = (insn >> 11) & 0x1f;
+
+  if (rbvalue == rtvalue)
+    *invalid = 1;
+  return rbvalue;
+}
+
 /* The SCI8 field is made up of SCL and {U,N}I8 fields.  */
 static unsigned long
 insert_sci8 (unsigned long insn,
@@ -2443,6 +2552,8 @@ extract_vleil (unsigned long insn,
 /* An DX form instruction.  */
 #define DX(op, xop) (OP (op) | ((((unsigned long)(xop)) & 0x1f) << 1))
 #define DX_MASK DX (0x3f, 0x1f)
+/* An DX form instruction with the D bits specified.  */
+#define NODX_MASK (DX_MASK | 0x1fffc1)
 
 /* An EVSEL form instruction.  */
 #define EVSEL(op, xop) (OP (op) | (((unsigned long)(xop)) & 0xff) << 3)
@@ -4155,6 +4266,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"mcrf",     XL(19,0), XLBB_MASK|(3<<21)|(3<<16), COM,	PPCVLE,		{BF, BFA}},
 
+{"lnia",     DX(19,2),		NODX_MASK,   POWER9,	PPCVLE,		{RT}},
 {"addpcis",  DX(19,2),		DX_MASK,     POWER9,	PPCVLE,		{RT, DXD}},
 {"subpcis",  DX(19,2),		DX_MASK,     POWER9,	PPCVLE,		{RT, NDXD}},
 
@@ -4974,7 +5086,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"stdux",	X(31,181),	X_MASK,	     PPC64,	0,		{RS, RAS, RB}},
 
-{"stqcx.",	XRC(31,182,1),	X_MASK,	     POWER8,	0,		{RSQ, RA0, RB}},
+{"stqcx.",	XRC(31,182,1), X_MASK|Q_MASK, POWER8,	0,		{RSQ, RA0, RB}},
 {"wchkall",	X(31,182),	X_MASK,	     PPCA2,	0,		{OBF}},
 
 {"stwux",	X(31,183),	X_MASK,	     PPCCOM,	0,		{RS, RAS, RB}},
@@ -5105,7 +5217,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"mfapidi",	X(31,275),	X_MASK,	     BOOKE,	E500|TITAN,	{RT, RA}},
 
-{"lqarx",	X(31,276),	XEH_MASK,    POWER8,	0,		{RTQ, RAX, RBX, EH}},
+{"lqarx",	X(31,276),  XEH_MASK|Q_MASK, POWER8,	0,		{RTQ, RAX, RBX, EH}},
 
 {"lscbx",	XRC(31,277,0),	X_MASK,	     M601,	0,		{RT, RA, RB}},
 {"lscbx.",	XRC(31,277,1),	X_MASK,	     M601,	0,		{RT, RA, RB}},
@@ -6052,7 +6164,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"lhbrx",	X(31,790),	X_MASK,	     COM,	0,		{RT, RA0, RB}},
 
-{"lfdpx",	X(31,791),	X_MASK,	     POWER6,	POWER7,		{FRTp, RA0, RB}},
+{"lfdpx",	X(31,791),    X_MASK|Q_MASK, POWER6,	POWER7,		{FRTp, RA0, RB}},
 {"lfqx",	X(31,791),	X_MASK,	     POWER2,	0,		{FRT, RA, RB}},
 
 {"sraw",	XRC(31,792,0),	X_MASK,	     PPCCOM,	0,		{RA, RS, RB}},
@@ -6167,7 +6279,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"sthbrx",	X(31,918),	X_MASK,	     COM,	0,		{RS, RA0, RB}},
 
-{"stfdpx",	X(31,919),	X_MASK,	     POWER6,	POWER7,		{FRSp, RA0, RB}},
+{"stfdpx",	X(31,919),    X_MASK|Q_MASK, POWER6,	POWER7,		{FRSp, RA0, RB}},
 {"stfqx",	X(31,919),	X_MASK,	     POWER2,	0,		{FRS, RA0, RB}},
 
 {"sraq",	XRC(31,920,0),	X_MASK,	     M601,	0,		{RA, RS, RB}},
@@ -6345,13 +6457,13 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"stfdu",	OP(55),		OP_MASK,     COM,	PPCEFS|PPCVLE,	{FRS, D, RAS}},
 
-{"lq",		OP(56),		OP_MASK,     POWER4,	PPC476|PPCVLE,	{RTQ, DQ, RAQ}},
+{"lq",		OP(56),	     OP_MASK|Q_MASK, POWER4,	PPC476|PPCVLE,	{RTQ, DQ, RAQ}},
 {"psq_l",	OP(56),		OP_MASK,     PPCPS,	PPCVLE,		{FRT,PSD,RA,PSW,PSQ}},
 {"lfq",		OP(56),		OP_MASK,     POWER2,	PPCVLE,		{FRT, D, RA0}},
 
 {"lxsd",	DSO(57,2),	DS_MASK,     PPCVSX3,	PPCVLE,		{VD, DS, RA0}},
 {"lxssp",	DSO(57,3),	DS_MASK,     PPCVSX3,	PPCVLE,		{VD, DS, RA0}},
-{"lfdp",	OP(57),		OP_MASK,     POWER6,	POWER7|PPCVLE,	{FRTp, DS, RA0}},
+{"lfdp",	OP(57),	     OP_MASK|Q_MASK, POWER6,	POWER7|PPCVLE,	{FRTp, DS, RA0}},
 {"psq_lu",	OP(57),		OP_MASK,     PPCPS,	PPCVLE,		{FRT,PSD,RA,PSW,PSQ}},
 {"lfqu",	OP(57),		OP_MASK,     POWER2,	PPCVLE,		{FRT, D, RA0}},
 
@@ -6676,21 +6788,21 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"stxv",	DQX(61,5),	DQX_MASK,    PPCVSX3,	PPCVLE,		{XSQ6, DQ, RA0}},
 {"stxsd",	DSO(61,2),	DS_MASK,     PPCVSX3,	PPCVLE,		{VS, DS, RA0}},
 {"stxssp",	DSO(61,3),	DS_MASK,     PPCVSX3,	PPCVLE,		{VS, DS, RA0}},
-{"stfdp",	OP(61),		OP_MASK,     POWER6,	POWER7|PPCVLE,	{FRSp, DS, RA0}},
+{"stfdp",	OP(61),	     OP_MASK|Q_MASK, POWER6,	POWER7|PPCVLE,	{FRSp, DS, RA0}},
 {"psq_stu",	OP(61),		OP_MASK,     PPCPS,	PPCVLE,		{FRS,PSD,RA,PSW,PSQ}},
 {"stfqu",	OP(61),		OP_MASK,     POWER2,	PPCVLE,		{FRS, D, RA}},
 
 {"std",		DSO(62,0),	DS_MASK,     PPC64,	PPCVLE,		{RS, DS, RA0}},
 {"stdu",	DSO(62,1),	DS_MASK,     PPC64,	PPCVLE,		{RS, DS, RAS}},
-{"stq",		DSO(62,2),	DS_MASK,     POWER4,	PPC476|PPCVLE,	{RSQ, DS, RA0}},
+{"stq",		DSO(62,2),   DS_MASK|Q_MASK, POWER4,	PPC476|PPCVLE,	{RSQ, DS, RA0}},
 
 {"fcmpu",	X(63,0),	XBF_MASK,    COM,	PPCEFS|PPCVLE,	{BF, FRA, FRB}},
 
-{"daddq",	XRC(63,2,0),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
-{"daddq.",	XRC(63,2,1),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
+{"daddq",	XRC(63,2,0),  X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
+{"daddq.",	XRC(63,2,1),  X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
 
-{"dquaq",	ZRC(63,3,0),	Z2_MASK,     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp, RMC}},
-{"dquaq.",	ZRC(63,3,1),	Z2_MASK,     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp, RMC}},
+{"dquaq",	ZRC(63,3,0), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp, RMC}},
+{"dquaq.",	ZRC(63,3,1), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp, RMC}},
 
 {"xsaddqp",	XRC(63,4,0),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
 {"xsaddqpo",	XRC(63,4,1),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
@@ -6772,11 +6884,11 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"fcmpo",	X(63,32),	XBF_MASK,    COM,	PPCEFS|PPCVLE,	{BF, FRA, FRB}},
 
-{"dmulq",	XRC(63,34,0),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
-{"dmulq.",	XRC(63,34,1),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
+{"dmulq",	XRC(63,34,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
+{"dmulq.",	XRC(63,34,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
 
-{"drrndq",	ZRC(63,35,0),	Z2_MASK,     POWER6,	PPCVLE,		{FRTp, FRA, FRBp, RMC}},
-{"drrndq.",	ZRC(63,35,1),	Z2_MASK,     POWER6,	PPCVLE,		{FRTp, FRA, FRBp, RMC}},
+{"drrndq",	ZRC(63,35,0), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRA, FRBp, RMC}},
+{"drrndq.",	ZRC(63,35,1), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRA, FRBp, RMC}},
 
 {"xsmulqp",	XRC(63,36,0),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
 {"xsmulqpo",	XRC(63,36,1),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
@@ -6791,11 +6903,11 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"mcrfs",      X(63,64), XRB_MASK|(3<<21)|(3<<16), COM,	PPCVLE,		{BF, BFA}},
 
-{"dscliq",	ZRC(63,66,0),	Z_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, SH16}},
-{"dscliq.",	ZRC(63,66,1),	Z_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, SH16}},
+{"dscliq",	ZRC(63,66,0), Z_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, SH16}},
+{"dscliq.",	ZRC(63,66,1), Z_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, SH16}},
 
-{"dquaiq",	ZRC(63,67,0),	Z2_MASK,     POWER6,	PPCVLE,		{TE, FRTp, FRBp, RMC}},
-{"dquaiq.",	ZRC(63,67,1),	Z2_MASK,     POWER6,	PPCVLE,		{TE, FRTp, FRBp, RMC}},
+{"dquaiq",	ZRC(63,67,0), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{TE, FRTp, FRBp, RMC}},
+{"dquaiq.",	ZRC(63,67,1), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{TE, FRTp, FRBp, RMC}},
 
 {"mtfsb0",	XRC(63,70,0),	XRARB_MASK,  COM,	PPCVLE,		{BT}},
 {"mtfsb0.",	XRC(63,70,1),	XRARB_MASK,  COM,	PPCVLE,		{BT}},
@@ -6803,11 +6915,11 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"fmr",		XRC(63,72,0),	XRA_MASK,    COM,	PPCEFS|PPCVLE,	{FRT, FRB}},
 {"fmr.",	XRC(63,72,1),	XRA_MASK,    COM,	PPCEFS|PPCVLE,	{FRT, FRB}},
 
-{"dscriq",	ZRC(63,98,0),	Z_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, SH16}},
-{"dscriq.",	ZRC(63,98,1),	Z_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, SH16}},
+{"dscriq",	ZRC(63,98,0), Z_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, SH16}},
+{"dscriq.",	ZRC(63,98,1), Z_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, SH16}},
 
-{"drintxq",	ZRC(63,99,0),	Z2_MASK,     POWER6,	PPCVLE,		{R, FRTp, FRBp, RMC}},
-{"drintxq.",	ZRC(63,99,1),	Z2_MASK,     POWER6,	PPCVLE,		{R, FRTp, FRBp, RMC}},
+{"drintxq",	ZRC(63,99,0), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{R, FRTp, FRBp, RMC}},
+{"drintxq.",	ZRC(63,99,1), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{R, FRTp, FRBp, RMC}},
 
 {"xscpsgnqp",	X(63,100),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
 
@@ -6839,11 +6951,11 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"dtstdcq",	Z(63,194),	Z_MASK,	     POWER6,	PPCVLE,		{BF, FRAp, DCM}},
 {"dtstdgq",	Z(63,226),	Z_MASK,	     POWER6,	PPCVLE,		{BF, FRAp, DGM}},
 
-{"drintnq",	ZRC(63,227,0),	Z2_MASK,     POWER6,	PPCVLE,		{R, FRTp, FRBp, RMC}},
-{"drintnq.",	ZRC(63,227,1),	Z2_MASK,     POWER6,	PPCVLE,		{R, FRTp, FRBp, RMC}},
+{"drintnq",	ZRC(63,227,0), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{R, FRTp, FRBp, RMC}},
+{"drintnq.",	ZRC(63,227,1), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{R, FRTp, FRBp, RMC}},
 
-{"dctqpq",	XRC(63,258,0),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRB}},
-{"dctqpq.",	XRC(63,258,1),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRB}},
+{"dctqpq",	XRC(63,258,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRB}},
+{"dctqpq.",	XRC(63,258,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRB}},
 
 {"fabs",	XRC(63,264,0),	XRA_MASK,    COM,	PPCEFS|PPCVLE,	{FRT, FRB}},
 {"fabs.",	XRC(63,264,1),	XRA_MASK,    COM,	PPCEFS|PPCVLE,	{FRT, FRB}},
@@ -6851,8 +6963,8 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"dctfixq",	XRC(63,290,0),	X_MASK,	     POWER6,	PPCVLE,		{FRT, FRBp}},
 {"dctfixq.",	XRC(63,290,1),	X_MASK,	     POWER6,	PPCVLE,		{FRT, FRBp}},
 
-{"ddedpdq",	XRC(63,322,0),	X_MASK,	     POWER6,	PPCVLE,		{SP, FRTp, FRBp}},
-{"ddedpdq.",	XRC(63,322,1),	X_MASK,	     POWER6,	PPCVLE,		{SP, FRTp, FRBp}},
+{"ddedpdq",	XRC(63,322,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{SP, FRTp, FRBp}},
+{"ddedpdq.",	XRC(63,322,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{SP, FRTp, FRBp}},
 
 {"dxexq",	XRC(63,354,0),	X_MASK,	     POWER6,	PPCVLE,		{FRT, FRBp}},
 {"dxexq.",	XRC(63,354,1),	X_MASK,	     POWER6,	PPCVLE,		{FRT, FRBp}},
@@ -6881,14 +6993,14 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"frim",	XRC(63,488,0),	XRA_MASK,    POWER5,	PPCVLE,		{FRT, FRB}},
 {"frim.",	XRC(63,488,1),	XRA_MASK,    POWER5,	PPCVLE,		{FRT, FRB}},
 
-{"dsubq",	XRC(63,514,0),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
-{"dsubq.",	XRC(63,514,1),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
+{"dsubq",	XRC(63,514,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
+{"dsubq.",	XRC(63,514,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
 
 {"xssubqp",	XRC(63,516,0),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
 {"xssubqpo",	XRC(63,516,1),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
 
-{"ddivq",	XRC(63,546,0),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
-{"ddivq.",	XRC(63,546,1),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
+{"ddivq",	XRC(63,546,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
+{"ddivq.",	XRC(63,546,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
 
 {"xsdivqp",	XRC(63,548,0),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
 {"xsdivqpo",	XRC(63,548,1),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
@@ -6917,11 +7029,11 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"mtfsf.",	XFL(63,711,1),	XFL_MASK, POWER6|PPCA2|PPC476, PPCVLE,	{FLM, FRB, XFL_L, W}},
 {"mtfsf.",	XFL(63,711,1),	XFL_MASK,    COM, POWER6|PPCA2|PPC476|PPCEFS|PPCVLE, {FLM, FRB}},
 
-{"drdpq",	XRC(63,770,0),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRBp}},
-{"drdpq.",	XRC(63,770,1),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRBp}},
+{"drdpq",	XRC(63,770,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRBp}},
+{"drdpq.",	XRC(63,770,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRBp}},
 
-{"dcffixq",	XRC(63,802,0),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRB}},
-{"dcffixq.",	XRC(63,802,1),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRB}},
+{"dcffixq",	XRC(63,802,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRB}},
+{"dcffixq.",	XRC(63,802,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRB}},
 
 {"xsabsqp",	XVA(63,804,0),	XVA_MASK,    PPCVSX3,	PPCVLE,		{VD, VB}},
 {"xsxexpqp",	XVA(63,804,2),	XVA_MASK,    PPCVSX3,	PPCVLE,		{VD, VB}},
@@ -6941,8 +7053,8 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"fctidz.",	XRC(63,815,1),	XRA_MASK,    PPC64,	PPCVLE,		{FRT, FRB}},
 {"fctidz.",	XRC(63,815,1),	XRA_MASK,    PPC476,	PPCVLE,		{FRT, FRB}},
 
-{"denbcdq",	XRC(63,834,0),	X_MASK,	     POWER6,	PPCVLE,		{S, FRTp, FRBp}},
-{"denbcdq.",	XRC(63,834,1),	X_MASK,	     POWER6,	PPCVLE,		{S, FRTp, FRBp}},
+{"denbcdq",	XRC(63,834,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{S, FRTp, FRBp}},
+{"denbcdq.",	XRC(63,834,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{S, FRTp, FRBp}},
 
 {"xscvqpuwz",	XVA(63,836,1),	XVA_MASK,    PPCVSX3,	PPCVLE,		{VD, VB}},
 {"xscvudqp",	XVA(63,836,2),	XVA_MASK,    PPCVSX3,	PPCVLE,		{VD, VB}},
@@ -6961,8 +7073,8 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"fcfid.",	XRC(63,846,1),	XRA_MASK,    PPC64,	PPCVLE,		{FRT, FRB}},
 {"fcfid.",	XRC(63,846,1),	XRA_MASK,    PPC476,	PPCVLE,		{FRT, FRB}},
 
-{"diexq",	XRC(63,866,0),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRA, FRBp}},
-{"diexq.",	XRC(63,866,1),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRA, FRBp}},
+{"diexq",	XRC(63,866,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRA, FRBp}},
+{"diexq.",	XRC(63,866,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRA, FRBp}},
 
 {"xsiexpqp",	X(63,868),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
 
diff --git a/opcodes/riscv-dis.c b/opcodes/riscv-dis.c
index 070c96ec74..bdc961c317 100644
--- a/opcodes/riscv-dis.c
+++ b/opcodes/riscv-dis.c
@@ -383,7 +383,7 @@ riscv_disassemble_insn (bfd_vma memaddr, insn_t word, disassemble_info *info)
 	pd->hi_addr[i] = -1;
 
       for (i = 0; i < info->symtab_size; i++)
-	if (strcmp (bfd_asymbol_name (info->symtab[i]), "_gp") == 0)
+	if (strcmp (bfd_asymbol_name (info->symtab[i]), RISCV_GP_SYMBOL) == 0)
 	  pd->gp = bfd_asymbol_value (info->symtab[i]);
     }
   else
diff --git a/opcodes/riscv-opc.c b/opcodes/riscv-opc.c
index 867a02682c..8343198366 100644
--- a/opcodes/riscv-opc.c
+++ b/opcodes/riscv-opc.c
@@ -147,7 +147,7 @@ const struct riscv_opcode riscv_opcodes[] =
 {"jal",       "32C", "Ca",  MATCH_C_JAL, MASK_C_JAL, match_opcode, INSN_ALIAS },
 {"jal",       "I",   "a",  MATCH_JAL | (X_RA << OP_SH_RD), MASK_JAL | MASK_RD, match_opcode, INSN_ALIAS },
 {"call",      "I",   "d,c", (X_T1 << OP_SH_RS1), (int) M_CALL,  match_never, INSN_MACRO },
-{"call",      "I",   "c", (X_T1 << OP_SH_RS1) | (X_RA << OP_SH_RD), (int) M_CALL,  match_never, INSN_MACRO },
+{"call",      "I",   "c", (X_RA << OP_SH_RS1) | (X_RA << OP_SH_RD), (int) M_CALL,  match_never, INSN_MACRO },
 {"tail",      "I",   "c", (X_T1 << OP_SH_RS1), (int) M_CALL,  match_never, INSN_MACRO },
 {"jump",      "I",   "c,s", 0, (int) M_CALL,  match_never, INSN_MACRO },
 {"nop",       "C",   "",  MATCH_C_ADDI, 0xffff, match_opcode, INSN_ALIAS },
@@ -210,14 +210,14 @@ const struct riscv_opcode riscv_opcodes[] =
 {"sll",       "C",   "d,CU,C>",  MATCH_C_SLLI, MASK_C_SLLI, match_rd_nonzero, INSN_ALIAS },
 {"sll",       "I",   "d,s,t",   MATCH_SLL, MASK_SLL, match_opcode, 0 },
 {"sll",       "I",   "d,s,>",   MATCH_SLLI, MASK_SLLI, match_opcode, INSN_ALIAS },
-{"srli",      "C",   "Cs,Cw,C>",  MATCH_C_SRLI, MASK_C_SRLI, match_rd_nonzero, INSN_ALIAS },
+{"srli",      "C",   "Cs,Cw,C>",  MATCH_C_SRLI, MASK_C_SRLI, match_opcode, INSN_ALIAS },
 {"srli",      "I",   "d,s,>",   MATCH_SRLI, MASK_SRLI, match_opcode, 0 },
-{"srl",       "C",   "Cs,Cw,C>",  MATCH_C_SRLI, MASK_C_SRLI, match_rd_nonzero, INSN_ALIAS },
+{"srl",       "C",   "Cs,Cw,C>",  MATCH_C_SRLI, MASK_C_SRLI, match_opcode, INSN_ALIAS },
 {"srl",       "I",   "d,s,t",   MATCH_SRL, MASK_SRL, match_opcode, 0 },
 {"srl",       "I",   "d,s,>",   MATCH_SRLI, MASK_SRLI, match_opcode, INSN_ALIAS },
-{"srai",      "C",   "Cs,Cw,C>",  MATCH_C_SRAI, MASK_C_SRAI, match_rd_nonzero, INSN_ALIAS },
+{"srai",      "C",   "Cs,Cw,C>",  MATCH_C_SRAI, MASK_C_SRAI, match_opcode, INSN_ALIAS },
 {"srai",      "I",   "d,s,>",   MATCH_SRAI, MASK_SRAI, match_opcode, 0 },
-{"sra",       "C",   "Cs,Cw,C>",  MATCH_C_SRAI, MASK_C_SRAI, match_rd_nonzero, INSN_ALIAS },
+{"sra",       "C",   "Cs,Cw,C>",  MATCH_C_SRAI, MASK_C_SRAI, match_opcode, INSN_ALIAS },
 {"sra",       "I",   "d,s,t",   MATCH_SRA, MASK_SRA, match_opcode, 0 },
 {"sra",       "I",   "d,s,>",   MATCH_SRAI, MASK_SRAI, match_opcode, INSN_ALIAS },
 {"sub",       "C",   "Cs,Cw,Ct",  MATCH_C_SUB, MASK_C_SUB, match_opcode, INSN_ALIAS },
@@ -562,10 +562,10 @@ const struct riscv_opcode riscv_opcodes[] =
 {"c.nop",     "C",   "",  MATCH_C_ADDI, 0xffff, match_opcode, 0 },
 {"c.mv",      "C",   "d,CV",  MATCH_C_MV, MASK_C_MV, match_c_add, 0 },
 {"c.lui",     "C",   "d,Cu",  MATCH_C_LUI, MASK_C_LUI, match_c_lui, 0 },
-{"c.li",      "C",   "d,Cj",  MATCH_C_LI, MASK_C_LI, match_rd_nonzero, 0 },
+{"c.li",      "C",   "d,Co",  MATCH_C_LI, MASK_C_LI, match_rd_nonzero, 0 },
 {"c.addi4spn","C",   "Ct,Cc,CK", MATCH_C_ADDI4SPN, MASK_C_ADDI4SPN, match_opcode, 0 },
 {"c.addi16sp","C",   "Cc,CL", MATCH_C_ADDI16SP, MASK_C_ADDI16SP, match_opcode, 0 },
-{"c.addi",    "C",   "d,Cj",  MATCH_C_ADDI, MASK_C_ADDI, match_rd_nonzero, 0 },
+{"c.addi",    "C",   "d,Cj",  MATCH_C_ADDI, MASK_C_ADDI, match_opcode, 0 },
 {"c.add",     "C",   "d,CV",  MATCH_C_ADD, MASK_C_ADD, match_c_add, 0 },
 {"c.sub",     "C",   "Cs,Ct",  MATCH_C_SUB, MASK_C_SUB, match_opcode, 0 },
 {"c.and",     "C",   "Cs,Ct",  MATCH_C_AND, MASK_C_AND, match_opcode, 0 },
@@ -574,8 +574,8 @@ const struct riscv_opcode riscv_opcodes[] =
 {"c.slli",    "C",   "d,C>",  MATCH_C_SLLI, MASK_C_SLLI, match_rd_nonzero, 0 },
 {"c.srli",    "C",   "Cs,C>",  MATCH_C_SRLI, MASK_C_SRLI, match_opcode, 0 },
 {"c.srai",    "C",   "Cs,C>",  MATCH_C_SRAI, MASK_C_SRAI, match_opcode, 0 },
-{"c.andi",    "C",   "Cs,Cj",  MATCH_C_ANDI, MASK_C_ANDI, match_opcode, 0 },
-{"c.addiw",   "64C", "d,Cj",  MATCH_C_ADDIW, MASK_C_ADDIW, match_rd_nonzero, 0 },
+{"c.andi",    "C",   "Cs,Co",  MATCH_C_ANDI, MASK_C_ANDI, match_opcode, 0 },
+{"c.addiw",   "64C", "d,Co",  MATCH_C_ADDIW, MASK_C_ADDIW, match_rd_nonzero, 0 },
 {"c.addw",    "64C", "Cs,Ct",  MATCH_C_ADDW, MASK_C_ADDW, match_opcode, 0 },
 {"c.subw",    "64C", "Cs,Ct",  MATCH_C_SUBW, MASK_C_SUBW, match_opcode, 0 },
 {"c.ldsp",    "64C", "d,Cn(Cc)",  MATCH_C_LDSP, MASK_C_LDSP, match_rd_nonzero, 0 },
diff --git a/opcodes/s390-mkopc.c b/opcodes/s390-mkopc.c
index 8e0b332585..68c55a9499 100644
--- a/opcodes/s390-mkopc.c
+++ b/opcodes/s390-mkopc.c
@@ -419,10 +419,6 @@ main (void)
 		&& (str[2] == 0 || str[2] == ',')) {
 	      flag_bits |= S390_INSTR_FLAG_VX;
 	      str += 2;
-	    } else if (strncmp (str, "vx2", 3) == 0
-		&& (str[3] == 0 || str[3] == ',')) {
-	      flag_bits |= S390_INSTR_FLAG_VX2;
-	      str += 3;
 	    } else {
 	      fprintf (stderr, "Couldn't parse flags string %s\n",
 		       flags_string);
diff --git a/opcodes/s390-opc.txt b/opcodes/s390-opc.txt
index b3815873aa..51a17f3b37 100644
--- a/opcodes/s390-opc.txt
+++ b/opcodes/s390-opc.txt
@@ -1685,146 +1685,146 @@ b93c ppno RRE_RR "perform pseudorandom number operation" z13 zarch
 # Vector Enhancements Facility 1
 
 e70000000085 vbperm VRR_VVV "vector bit permute" arch12 zarch
-e70000006004 vllezlf VRX_VRRD "vector load logical word element and zero - left aligned" arch12 zarch vx2
-e700000000b8 vmsl VRR_VVVUU0V "vector multiply sum logical" arch12 zarch vx2
-e700030000b8 vmslg VRR_VVVU0VB "vector multiply sum logical double word" arch12 zarch vx2
-e7000000006c vnx VRR_VVV "vector not exclusive or" arch12 zarch vx2
+e70000006004 vllezlf VRX_VRRD "vector load logical word element and zero - left aligned" arch12 zarch
+e700000000b8 vmsl VRR_VVVUU0V "vector multiply sum logical" arch12 zarch
+e700030000b8 vmslg VRR_VVVU0VB "vector multiply sum logical double word" arch12 zarch
+e7000000006c vnx VRR_VVV "vector not exclusive or" arch12 zarch
 e7000000006e vnn VRR_VVV "vector nand" arch12 zarch
-e7000000006f voc VRR_VVV "vector or with complement" arch12 zarch vx2
-e70000000050 vpopctb VRR_VV "vector population count byte" arch12 zarch vx2
-e70000001050 vpopcth VRR_VV "vector population count halfword" arch12 zarch vx2
-e70000002050 vpopctf VRR_VV "vector population count word" arch12 zarch vx2
-e70000003050 vpopctg VRR_VV "vector population count double word" arch12 zarch vx2
-e700000020e3 vfasb VRR_VVV "vector fp add short" arch12 zarch vx2
-e700000820e3 wfasb VRR_VVV "scalar vector fp add scalar short" arch12 zarch vx2
-e700000840e3 wfaxb VRR_VVV "scalar vector fp add scalar extended" arch12 zarch vx2
-e700000020cb wfcsb VRR_VV "scalar vector fp compare scalar short" arch12 zarch vx2
-e700000040cb wfcxb VRR_VV "scalar vector fp compare scalar extended" arch12 zarch vx2
-e700000020ca wfksb VRR_VV "scalar vector fp compare and signal scalar short" arch12 zarch vx2
-e700000040ca wfkxb VRR_VV "scalar vector fp compare and signal scalar extended" arch12 zarch vx2
+e7000000006f voc VRR_VVV "vector or with complement" arch12 zarch
+e70000000050 vpopctb VRR_VV "vector population count byte" arch12 zarch
+e70000001050 vpopcth VRR_VV "vector population count halfword" arch12 zarch
+e70000002050 vpopctf VRR_VV "vector population count word" arch12 zarch
+e70000003050 vpopctg VRR_VV "vector population count double word" arch12 zarch
+e700000020e3 vfasb VRR_VVV "vector fp add short" arch12 zarch
+e700000820e3 wfasb VRR_VVV "scalar vector fp add scalar short" arch12 zarch
+e700000840e3 wfaxb VRR_VVV "scalar vector fp add scalar extended" arch12 zarch
+e700000020cb wfcsb VRR_VV "scalar vector fp compare scalar short" arch12 zarch
+e700000040cb wfcxb VRR_VV "scalar vector fp compare scalar extended" arch12 zarch
+e700000020ca wfksb VRR_VV "scalar vector fp compare and signal scalar short" arch12 zarch
+e700000040ca wfkxb VRR_VV "scalar vector fp compare and signal scalar extended" arch12 zarch
 
-e700000020e8 vfcesb VRR_VVV "vector fp compare equal short" arch12 zarch vx2
-e700001020e8 vfcesbs VRR_VVV "vector fp compare equal short" arch12 zarch vx2
-e700000820e8 wfcesb VRR_VVV "scalar vector fp compare equal scalar short" arch12 zarch vx2
-e700001820e8 wfcesbs VRR_VVV "scalar fp compare equal scalar short" arch12 zarch vx2
-e700000840e8 wfcexb VRR_VVV "scalar vector fp compare equal scalar extended" arch12 zarch vx2
-e700001840e8 wfcexbs VRR_VVV "scalar vector fp compare equal scalar extended" arch12 zarch vx2
+e700000020e8 vfcesb VRR_VVV "vector fp compare equal short" arch12 zarch
+e700001020e8 vfcesbs VRR_VVV "vector fp compare equal short" arch12 zarch
+e700000820e8 wfcesb VRR_VVV "scalar vector fp compare equal scalar short" arch12 zarch
+e700001820e8 wfcesbs VRR_VVV "scalar fp compare equal scalar short" arch12 zarch
+e700000840e8 wfcexb VRR_VVV "scalar vector fp compare equal scalar extended" arch12 zarch
+e700001840e8 wfcexbs VRR_VVV "scalar vector fp compare equal scalar extended" arch12 zarch
 
-e700000420e8 vfkesb VRR_VVV "vector fp compare and signal equal short" arch12 zarch vx2
-e700001420e8 vfkesbs VRR_VVV "vector fp compare and signal equal short" arch12 zarch vx2
-e700000c20e8 wfkesb VRR_VVV "scalar vector fp compare and signal equal scalar short" arch12 zarch vx2
-e700001c20e8 wfkesbs VRR_VVV "scalar fp compare and signal equal scalar short" arch12 zarch vx2
+e700000420e8 vfkesb VRR_VVV "vector fp compare and signal equal short" arch12 zarch
+e700001420e8 vfkesbs VRR_VVV "vector fp compare and signal equal short" arch12 zarch
+e700000c20e8 wfkesb VRR_VVV "scalar vector fp compare and signal equal scalar short" arch12 zarch
+e700001c20e8 wfkesbs VRR_VVV "scalar fp compare and signal equal scalar short" arch12 zarch
 e700000430e8 vfkedb VRR_VVV "vector fp compare and signal equal long" arch12 zarch vx
 e700001430e8 vfkedbs VRR_VVV "vector fp compare and signal equal long" arch12 zarch vx
 e700000c30e8 wfkedb VRR_VVV "vector fp compare and signal equal long" arch12 zarch vx
 e700001c30e8 wfkedbs VRR_VVV "vector fp compare and signal equal long" arch12 zarch vx
-e700000c40e8 wfkexb VRR_VVV "scalar vector fp compare and signal equal scalar extended" arch12 zarch vx2
-e700001c40e8 wfkexbs VRR_VVV "scalar vector fp compare and signal equal scalar extended" arch12 zarch vx2
+e700000c40e8 wfkexb VRR_VVV "scalar vector fp compare and signal equal scalar extended" arch12 zarch
+e700001c40e8 wfkexbs VRR_VVV "scalar vector fp compare and signal equal scalar extended" arch12 zarch
 
-e700000020eb vfchsb VRR_VVV "vector fp compare high short" arch12 zarch vx2
-e700001020eb vfchsbs VRR_VVV "vector fp compare high short" arch12 zarch vx2
-e700000820eb wfchsb VRR_VVV "scalar vector fp compare high scalar short" arch12 zarch vx2
-e700001820eb wfchsbs VRR_VVV "scalar vector fp compare high scalar short" arch12 zarch vx2
-e700000840eb wfchxb VRR_VVV "scalar vector fp compare high scalar extended" arch12 zarch vx2
-e700001840eb wfchxbs VRR_VVV "scalar vector fp compare high scalar extended" arch12 zarch vx2
+e700000020eb vfchsb VRR_VVV "vector fp compare high short" arch12 zarch
+e700001020eb vfchsbs VRR_VVV "vector fp compare high short" arch12 zarch
+e700000820eb wfchsb VRR_VVV "scalar vector fp compare high scalar short" arch12 zarch
+e700001820eb wfchsbs VRR_VVV "scalar vector fp compare high scalar short" arch12 zarch
+e700000840eb wfchxb VRR_VVV "scalar vector fp compare high scalar extended" arch12 zarch
+e700001840eb wfchxbs VRR_VVV "scalar vector fp compare high scalar extended" arch12 zarch
 
-e700000420eb vfkhsb VRR_VVV "vector fp compare and signal high short" arch12 zarch vx2
-e700001420eb vfkhsbs VRR_VVV "vector fp compare and signal high short" arch12 zarch vx2
-e700000c20eb wfkhsb VRR_VVV "scalar vector fp compare and signal high scalar short" arch12 zarch vx2
-e700001c20eb wfkhsbs VRR_VVV "scalar vector fp compare and signal high scalar short" arch12 zarch vx2
+e700000420eb vfkhsb VRR_VVV "vector fp compare and signal high short" arch12 zarch
+e700001420eb vfkhsbs VRR_VVV "vector fp compare and signal high short" arch12 zarch
+e700000c20eb wfkhsb VRR_VVV "scalar vector fp compare and signal high scalar short" arch12 zarch
+e700001c20eb wfkhsbs VRR_VVV "scalar vector fp compare and signal high scalar short" arch12 zarch
 e700000430eb vfkhdb VRR_VVV "vector fp compare and signal high long" arch12 zarch vx
 e700001430eb vfkhdbs VRR_VVV "vector fp compare and signal high long" arch12 zarch vx
 e700000c30eb wfkhdb VRR_VVV "vector fp compare and signal high long" arch12 zarch vx
 e700001c30eb wfkhdbs VRR_VVV "vector fp compare and signal high long" arch12 zarch vx
-e700000c40eb wfkhxb VRR_VVV "scalar vector fp compare and signal high scalar extended" arch12 zarch vx2
-e700001c40eb wfkhxbs VRR_VVV "scalar vector fp compare and signal high scalar extended" arch12 zarch vx2
+e700000c40eb wfkhxb VRR_VVV "scalar vector fp compare and signal high scalar extended" arch12 zarch
+e700001c40eb wfkhxbs VRR_VVV "scalar vector fp compare and signal high scalar extended" arch12 zarch
 
-e700000020ea vfchesb VRR_VVV "vector fp compare high or equal short" arch12 zarch vx2
-e700001020ea vfchesbs VRR_VVV "vector fp compare high or equal short" arch12 zarch vx2
-e700000820ea wfchesb VRR_VVV "scalar vector fp compare high or equal scalar short" arch12 zarch vx2
-e700001820ea wfchesbs VRR_VVV "scalar vector fp compare high or equal scalar short" arch12 zarch vx2
-e700000840ea wfchexb VRR_VVV "scalar vector fp compare high or equal scalar extended" arch12 zarch vx2
-e700001840ea wfchexbs VRR_VVV "scalar vector fp compare high or equal scalar extended" arch12 zarch vx2
+e700000020ea vfchesb VRR_VVV "vector fp compare high or equal short" arch12 zarch
+e700001020ea vfchesbs VRR_VVV "vector fp compare high or equal short" arch12 zarch
+e700000820ea wfchesb VRR_VVV "scalar vector fp compare high or equal scalar short" arch12 zarch
+e700001820ea wfchesbs VRR_VVV "scalar vector fp compare high or equal scalar short" arch12 zarch
+e700000840ea wfchexb VRR_VVV "scalar vector fp compare high or equal scalar extended" arch12 zarch
+e700001840ea wfchexbs VRR_VVV "scalar vector fp compare high or equal scalar extended" arch12 zarch
 
-e700000420ea vfkhesb VRR_VVV "vector fp compare and signal high or equal short" arch12 zarch vx2
-e700001420ea vfkhesbs VRR_VVV "vector fp compare and signal high or equal short" arch12 zarch vx2
-e700000c20ea wfkhesb VRR_VVV "scalar vector fp compare and signal high or equal scalar short" arch12 zarch vx2
-e700001c20ea wfkhesbs VRR_VVV "scalar vector fp compare and signal high or equal scalar short" arch12 zarch vx2
+e700000420ea vfkhesb VRR_VVV "vector fp compare and signal high or equal short" arch12 zarch
+e700001420ea vfkhesbs VRR_VVV "vector fp compare and signal high or equal short" arch12 zarch
+e700000c20ea wfkhesb VRR_VVV "scalar vector fp compare and signal high or equal scalar short" arch12 zarch
+e700001c20ea wfkhesbs VRR_VVV "scalar vector fp compare and signal high or equal scalar short" arch12 zarch
 e700000430ea vfkhedb VRR_VVV "vector fp compare and signal high or equal long" arch12 zarch vx
 e700001430ea vfkhedbs VRR_VVV "vector fp compare and signal high or equal long" arch12 zarch vx
 e700000c30ea wfkhedb VRR_VVV "vector fp compare and signal high or equal long" arch12 zarch vx
 e700001c30ea wfkhedbs VRR_VVV "vector fp compare and signal high or equal long" arch12 zarch vx
-e700000c40ea wfkhexb VRR_VVV "scalar vector fp compare and signal high or equal scalar extended" arch12 zarch vx2
-e700001c40ea wfkhexbs VRR_VVV "scalar vector fp compare and signal high or equal scalar extended" arch12 zarch vx2
+e700000c40ea wfkhexb VRR_VVV "scalar vector fp compare and signal high or equal scalar extended" arch12 zarch
+e700001c40ea wfkhexbs VRR_VVV "scalar vector fp compare and signal high or equal scalar extended" arch12 zarch
 
-e700000020e5 vfdsb VRR_VVV "vector fp divide short" arch12 zarch vx2
-e700000820e5 wfdsb VRR_VVV "scalar vector fp divide scalar short" arch12 zarch vx2
-e700000840e5 wfdxb VRR_VVV "scalar vector fp divide scalar extended" arch12 zarch vx2
-e700000020c7 vfisb VRR_VV0UU "vector load fp integer short" arch12 zarch vx2
-e700000820c7 wfisb VRR_VV0UU8 "scalar vector load fp integer scalar short" arch12 zarch vx2
-e700000840c7 wfixb VRR_VV0UU8 "scalar vector load fp integer scalar extended" arch12 zarch vx2
-e700000000c4 vfll VRR_VV0UU2 "vector fp load lengthened" arch12 zarch vx2
-e700000020c4 vflls VRR_VV "vector fp load lengthened" arch12 zarch vx2
-e700000820c4 wflls VRR_VV "scalar vector fp load lengthened short" arch12 zarch vx2
-e700000830c4 wflld VRR_VV "scalar vector fp load lengthened long" arch12 zarch vx2
-e700000000c5 vflr VRR_VV0UUU "vector fp load rounded" arch12 zarch vx2
-e700000030c5 vflrd VRR_VV0UU "vector fp load rounded long" arch12 zarch vx2
-e700000830c5 wflrd VRR_VV0UU8 "scalar vector fp load rounded long" arch12 zarch vx2
-e700000840c5 wflrx VRR_VV0UU8 "scalar vector fp load rounded extended" arch12 zarch vx2
-e700000000ef vfmax VRR_VVV0UUU "vector fp maximum" arch12 zarch vx2
-e700000020ef vfmaxsb VRR_VVV0U0 "vector fp maximum short" arch12 zarch vx2
-e700000030ef vfmaxdb VRR_VVV0U0 "vector fp maximum long" arch12 zarch vx2
-e700000820ef wfmaxsb VRR_VVV0U0 "scalar fp maximum scalar short" arch12 zarch vx2
-e700000830ef wfmaxdb VRR_VVV0U0 "scalar fp maximum scalar long" arch12 zarch vx2
-e700000840ef wfmaxxb VRR_VVV0U0 "scalar fp maximum scalar extended" arch12 zarch vx2
-e700000000ee vfmin VRR_VVV0UUU "vector fp minimum" arch12 zarch vx2
-e700000020ee vfminsb VRR_VVV0U0 "vector fp minimum short" arch12 zarch vx2
-e700000030ee vfmindb VRR_VVV0U0 "vector fp minimum long" arch12 zarch vx2
-e700000820ee wfminsb VRR_VVV0U0 "scalar fp minimum scalar short" arch12 zarch vx2
-e700000830ee wfmindb VRR_VVV0U0 "scalar fp minimum scalar long" arch12 zarch vx2
-e700000840ee wfminxb VRR_VVV0U0 "scalar fp minimum scalar extended" arch12 zarch vx2
-e700000020e7 vfmsb VRR_VVV "vector fp multiply short" arch12 zarch vx2
-e700000820e7 wfmsb VRR_VVV "scalar vector fp multiply scalar short" arch12 zarch vx2
-e700000840e7 wfmxb VRR_VVV "scalar vector fp multiply scalar extended" arch12 zarch vx2
-e7000200008f vfmasb VRR_VVVV "vector fp multiply and add short" arch12 zarch vx2
-e7000208008f wfmasb VRR_VVVV "scalar vector fp multiply and add scalar short" arch12 zarch vx2
-e7000408008f wfmaxb VRR_VVVV "scalar vector fp multiply and add scalar extended" arch12 zarch vx2
-e7000200008e vfmssb VRR_VVVV "vector fp multiply and subtract short" arch12 zarch vx2
-e7000208008e wfmssb VRR_VVVV "scalar vector fp multiply and subtract scalar short" arch12 zarch vx2
-e7000408008e wfmsxb VRR_VVVV "scalar vector fp multiply and subtract scalar extended" arch12 zarch vx2
-e7000000009f vfnma VRR_VVVU0UV "vector fp negative multiply and add" arch12 zarch vx2
-e7000200009f vfnmasb VRR_VVVV "vector fp negative multiply and add short" arch12 zarch vx2
-e7000208009f wfnmasb VRR_VVVV "scalar vector fp negative multiply and add scalar short" arch12 zarch vx2
-e7000300009f vfnmadb VRR_VVVV "vector fp negative multiply and add long" arch12 zarch vx2
-e7000308009f wfnmadb VRR_VVVV "scalar vector fp negative multiply and add scalar long" arch12 zarch vx2
-e7000408009f wfnmaxb VRR_VVVV "scalar vector fp negative multiply and add scalar extended" arch12 zarch vx2
-e7000000009e vfnms VRR_VVVU0UV "vector fp negative multiply and subtract" arch12 zarch vx2
-e7000200009e vfnmssb VRR_VVVV "vector fp negative multiply and subtract short" arch12 zarch vx2
-e7000208009e wfnmssb VRR_VVVV "scalar vector fp negative multiply and subtract scalar short" arch12 zarch vx2
-e7000300009e vfnmsdb VRR_VVVV "vector fp negative multiply and subtract long" arch12 zarch vx2
-e7000308009e wfnmsdb VRR_VVVV "scalar vector fp negative multiply and subtract scalar long" arch12 zarch vx2
-e7000408009e wfnmsxb VRR_VVVV "scalar vector fp negative multiply and subtract scalar extended" arch12 zarch vx2
-e700000020cc vfpsosb VRR_VV0U2 "vector fp perform sign operation short" arch12 zarch vx2
-e700000820cc wfpsosb VRR_VV0U2 "scalar vector fp perform sign operation scalar short" arch12 zarch vx2
-e700000020cc vflcsb VRR_VV "vector fp perform sign operation short" arch12 zarch vx2
-e700000820cc wflcsb VRR_VV "scalar vector fp perform sign operation scalar short" arch12 zarch vx2
-e700001020cc vflnsb VRR_VV "vector fp perform sign operation short" arch12 zarch vx2
-e700001820cc wflnsb VRR_VV "scalar vector fp perform sign operation scalar short" arch12 zarch vx2
-e700002020cc vflpsb VRR_VV "vector fp perform sign operation short" arch12 zarch vx2
-e700002820cc wflpsb VRR_VV "scalar vector fp perform sign operation scalar short" arch12 zarch vx2
-e700000840cc wfpsoxb VRR_VV0U2 "scalar vector fp perform sign operation scalar extended" arch12 zarch vx2
-e700000840cc wflcxb VRR_VV "scalar vector fp perform sign operation scalar extended" arch12 zarch vx2
-e700001840cc wflnxb VRR_VV "scalar vector fp perform sign operation scalar extended" arch12 zarch vx2
-e700002840cc wflpxb VRR_VV "scalar vector fp perform sign operation scalar extended" arch12 zarch vx2
-e700000020ce vfsqsb VRR_VV "vector fp square root short" arch12 zarch vx2
-e700000820ce wfsqsb VRR_VV "scalar vector fp square root scalar short" arch12 zarch vx2
-e700000840ce wfsqxb VRR_VV "scalar vector fp square root scalar extended" arch12 zarch vx2
-e700000020e2 vfssb VRR_VVV "vector fp subtract short" arch12 zarch vx2
-e700000820e2 wfssb VRR_VVV "scalar vector fp subtract scalar short" arch12 zarch vx2
-e700000840e2 wfsxb VRR_VVV "scalar vector fp subtract scalar extended" arch12 zarch vx2
-e7000000204a vftcisb VRI_VVU2 "vector fp test data class immediate short" arch12 zarch vx2
-e7000008204a wftcisb VRI_VVU2 "scalar vector fp test data class immediate scalar short" arch12 zarch vx2
-e7000008404a wftcixb VRI_VVU2 "scalar vector fp test data class immediate scalar extended" arch12 zarch vx2
+e700000020e5 vfdsb VRR_VVV "vector fp divide short" arch12 zarch
+e700000820e5 wfdsb VRR_VVV "scalar vector fp divide scalar short" arch12 zarch
+e700000840e5 wfdxb VRR_VVV "scalar vector fp divide scalar extended" arch12 zarch
+e700000020c7 vfisb VRR_VV0UU "vector load fp integer short" arch12 zarch
+e700000820c7 wfisb VRR_VV0UU8 "scalar vector load fp integer scalar short" arch12 zarch
+e700000840c7 wfixb VRR_VV0UU8 "scalar vector load fp integer scalar extended" arch12 zarch
+e700000000c4 vfll VRR_VV0UU2 "vector fp load lengthened" arch12 zarch
+e700000020c4 vflls VRR_VV "vector fp load lengthened" arch12 zarch
+e700000820c4 wflls VRR_VV "scalar vector fp load lengthened short" arch12 zarch
+e700000830c4 wflld VRR_VV "scalar vector fp load lengthened long" arch12 zarch
+e700000000c5 vflr VRR_VV0UUU "vector fp load rounded" arch12 zarch
+e700000030c5 vflrd VRR_VV0UU "vector fp load rounded long" arch12 zarch
+e700000830c5 wflrd VRR_VV0UU8 "scalar vector fp load rounded long" arch12 zarch
+e700000840c5 wflrx VRR_VV0UU8 "scalar vector fp load rounded extended" arch12 zarch
+e700000000ef vfmax VRR_VVV0UUU "vector fp maximum" arch12 zarch
+e700000020ef vfmaxsb VRR_VVV0U0 "vector fp maximum short" arch12 zarch
+e700000030ef vfmaxdb VRR_VVV0U0 "vector fp maximum long" arch12 zarch
+e700000820ef wfmaxsb VRR_VVV0U0 "scalar fp maximum scalar short" arch12 zarch
+e700000830ef wfmaxdb VRR_VVV0U0 "scalar fp maximum scalar long" arch12 zarch
+e700000840ef wfmaxxb VRR_VVV0U0 "scalar fp maximum scalar extended" arch12 zarch
+e700000000ee vfmin VRR_VVV0UUU "vector fp minimum" arch12 zarch
+e700000020ee vfminsb VRR_VVV0U0 "vector fp minimum short" arch12 zarch
+e700000030ee vfmindb VRR_VVV0U0 "vector fp minimum long" arch12 zarch
+e700000820ee wfminsb VRR_VVV0U0 "scalar fp minimum scalar short" arch12 zarch
+e700000830ee wfmindb VRR_VVV0U0 "scalar fp minimum scalar long" arch12 zarch
+e700000840ee wfminxb VRR_VVV0U0 "scalar fp minimum scalar extended" arch12 zarch
+e700000020e7 vfmsb VRR_VVV "vector fp multiply short" arch12 zarch
+e700000820e7 wfmsb VRR_VVV "scalar vector fp multiply scalar short" arch12 zarch
+e700000840e7 wfmxb VRR_VVV "scalar vector fp multiply scalar extended" arch12 zarch
+e7000200008f vfmasb VRR_VVVV "vector fp multiply and add short" arch12 zarch
+e7000208008f wfmasb VRR_VVVV "scalar vector fp multiply and add scalar short" arch12 zarch
+e7000408008f wfmaxb VRR_VVVV "scalar vector fp multiply and add scalar extended" arch12 zarch
+e7000200008e vfmssb VRR_VVVV "vector fp multiply and subtract short" arch12 zarch
+e7000208008e wfmssb VRR_VVVV "scalar vector fp multiply and subtract scalar short" arch12 zarch
+e7000408008e wfmsxb VRR_VVVV "scalar vector fp multiply and subtract scalar extended" arch12 zarch
+e7000000009f vfnma VRR_VVVU0UV "vector fp negative multiply and add" arch12 zarch
+e7000200009f vfnmasb VRR_VVVV "vector fp negative multiply and add short" arch12 zarch
+e7000208009f wfnmasb VRR_VVVV "scalar vector fp negative multiply and add scalar short" arch12 zarch
+e7000300009f vfnmadb VRR_VVVV "vector fp negative multiply and add long" arch12 zarch
+e7000308009f wfnmadb VRR_VVVV "scalar vector fp negative multiply and add scalar long" arch12 zarch
+e7000408009f wfnmaxb VRR_VVVV "scalar vector fp negative multiply and add scalar extended" arch12 zarch
+e7000000009e vfnms VRR_VVVU0UV "vector fp negative multiply and subtract" arch12 zarch
+e7000200009e vfnmssb VRR_VVVV "vector fp negative multiply and subtract short" arch12 zarch
+e7000208009e wfnmssb VRR_VVVV "scalar vector fp negative multiply and subtract scalar short" arch12 zarch
+e7000300009e vfnmsdb VRR_VVVV "vector fp negative multiply and subtract long" arch12 zarch
+e7000308009e wfnmsdb VRR_VVVV "scalar vector fp negative multiply and subtract scalar long" arch12 zarch
+e7000408009e wfnmsxb VRR_VVVV "scalar vector fp negative multiply and subtract scalar extended" arch12 zarch
+e700000020cc vfpsosb VRR_VV0U2 "vector fp perform sign operation short" arch12 zarch
+e700000820cc wfpsosb VRR_VV0U2 "scalar vector fp perform sign operation scalar short" arch12 zarch
+e700000020cc vflcsb VRR_VV "vector fp perform sign operation short" arch12 zarch
+e700000820cc wflcsb VRR_VV "scalar vector fp perform sign operation scalar short" arch12 zarch
+e700001020cc vflnsb VRR_VV "vector fp perform sign operation short" arch12 zarch
+e700001820cc wflnsb VRR_VV "scalar vector fp perform sign operation scalar short" arch12 zarch
+e700002020cc vflpsb VRR_VV "vector fp perform sign operation short" arch12 zarch
+e700002820cc wflpsb VRR_VV "scalar vector fp perform sign operation scalar short" arch12 zarch
+e700000840cc wfpsoxb VRR_VV0U2 "scalar vector fp perform sign operation scalar extended" arch12 zarch
+e700000840cc wflcxb VRR_VV "scalar vector fp perform sign operation scalar extended" arch12 zarch
+e700001840cc wflnxb VRR_VV "scalar vector fp perform sign operation scalar extended" arch12 zarch
+e700002840cc wflpxb VRR_VV "scalar vector fp perform sign operation scalar extended" arch12 zarch
+e700000020ce vfsqsb VRR_VV "vector fp square root short" arch12 zarch
+e700000820ce wfsqsb VRR_VV "scalar vector fp square root scalar short" arch12 zarch
+e700000840ce wfsqxb VRR_VV "scalar vector fp square root scalar extended" arch12 zarch
+e700000020e2 vfssb VRR_VVV "vector fp subtract short" arch12 zarch
+e700000820e2 wfssb VRR_VVV "scalar vector fp subtract scalar short" arch12 zarch
+e700000840e2 wfsxb VRR_VVV "scalar vector fp subtract scalar extended" arch12 zarch
+e7000000204a vftcisb VRI_VVU2 "vector fp test data class immediate short" arch12 zarch
+e7000008204a wftcisb VRI_VVU2 "scalar vector fp test data class immediate scalar short" arch12 zarch
+e7000008404a wftcixb VRI_VVU2 "scalar vector fp test data class immediate scalar extended" arch12 zarch
 
 # Miscellaneous Instruction Extensions Facility 2
 
@@ -1843,28 +1843,28 @@ e30000000039 sgh RXY_RRRD "subtract halfword from 64 bit value" arch12 zarch
 
 # Vector packed decimal facility
 
-e60000000037 vlrlr VRS_RRDV "vector load rightmost with length" arch12 zarch vx2
-e60000000035 vlrl VSI_URDV "vector load rightmost with immediate length" arch12 zarch vx2
-e6000000003f vstrlr VRS_RRDV "vector store rightmost with length" arch12 zarch vx2
-e6000000003d vstrl VSI_URDV "vector store rightmost with immediate length" arch12 zarch vx2
-e60000000071 vap VRI_VVV0UU2 "vector add decimal" arch12 zarch vx2
-e60000000077 vcp VRR_0VV0U "vector compare decimal" arch12 zarch vx2
-e60000000050 vcvb VRR_RV0U "vector convert to binary 32 bit" arch12 zarch vx2
-e60000000052 vcvbg VRR_RV0U "vector convert to binary 64 bit" arch12 zarch vx2
-e60000000058 vcvd VRI_VR0UU "vector convert to decimal 32 bit" arch12 zarch vx2
-e6000000005a vcvdg VRI_VR0UU "vector convert to decimal 64 bit" arch12 zarch vx2
-e6000000007a vdp VRI_VVV0UU2 "vector divide decimal" arch12 zarch vx2
-e60000000049 vlip VRI_V0UU2 "vector load immediate decimal" arch12 zarch vx2
-e60000000078 vmp VRI_VVV0UU2 "vector multiply decimal" arch12 zarch vx2
-e60000000079 vmsp VRI_VVV0UU2 "vector multiply and shift decimal" arch12 zarch vx2
-e60000000034 vpkz VSI_URDV "vector pack zoned" arch12 zarch vx2
-e6000000005b vpsop VRI_VVUUU2 "vector perform sign operation decimal" arch12 zarch vx2
-e6000000007b vrp VRI_VVV0UU2 "vector remainder decimal" arch12 zarch vx2
-e6000000007e vsdp VRI_VVV0UU2 "vector shift and divide decimal" arch12 zarch vx2
-e60000000059 vsrp VRI_VVUUU2 "vector shift and round decimal" arch12 zarch vx2
-e60000000073 vsp VRI_VVV0UU2 "vector subtract decimal" arch12 zarch vx2
-e6000000005f vtp VRR_0V "vector test decimal" arch12 zarch vx2
-e6000000003c vupkz VSI_URDV "vector unpack zoned" arch12 zarch vx2
+e60000000037 vlrlr VRS_RRDV "vector load rightmost with length" arch12 zarch
+e60000000035 vlrl VSI_URDV "vector load rightmost with immediate length" arch12 zarch
+e6000000003f vstrlr VRS_RRDV "vector store rightmost with length" arch12 zarch
+e6000000003d vstrl VSI_URDV "vector store rightmost with immediate length" arch12 zarch
+e60000000071 vap VRI_VVV0UU2 "vector add decimal" arch12 zarch
+e60000000077 vcp VRR_0VV0U "vector compare decimal" arch12 zarch
+e60000000050 vcvb VRR_RV0U "vector convert to binary 32 bit" arch12 zarch
+e60000000052 vcvbg VRR_RV0U "vector convert to binary 64 bit" arch12 zarch
+e60000000058 vcvd VRI_VR0UU "vector convert to decimal 32 bit" arch12 zarch
+e6000000005a vcvdg VRI_VR0UU "vector convert to decimal 64 bit" arch12 zarch
+e6000000007a vdp VRI_VVV0UU2 "vector divide decimal" arch12 zarch
+e60000000049 vlip VRI_V0UU2 "vector load immediate decimal" arch12 zarch
+e60000000078 vmp VRI_VVV0UU2 "vector multiply decimal" arch12 zarch
+e60000000079 vmsp VRI_VVV0UU2 "vector multiply and shift decimal" arch12 zarch
+e60000000034 vpkz VSI_URDV "vector pack zoned" arch12 zarch
+e6000000005b vpsop VRI_VVUUU2 "vector perform sign operation decimal" arch12 zarch
+e6000000007b vrp VRI_VVV0UU2 "vector remainder decimal" arch12 zarch
+e6000000007e vsdp VRI_VVV0UU2 "vector shift and divide decimal" arch12 zarch
+e60000000059 vsrp VRI_VVUUU2 "vector shift and round decimal" arch12 zarch
+e60000000073 vsp VRI_VVV0UU2 "vector subtract decimal" arch12 zarch
+e6000000005f vtp VRR_0V "vector test decimal" arch12 zarch
+e6000000003c vupkz VSI_URDV "vector unpack zoned" arch12 zarch
 
 # Guarded storage facility
 
