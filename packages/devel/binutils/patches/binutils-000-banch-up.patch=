diff --git a/bfd/ChangeLog b/bfd/ChangeLog
index 85c6a817e5..085e9c460a 100644
--- a/bfd/ChangeLog
+++ b/bfd/ChangeLog
@@ -1,3 +1,144 @@
+2017-06-22  Eric Christopher  <echristo@gmail.com>
+
+	Backport from mainline
+	2017-06-22 Eric Christopher <echristo@gmail.com>
+
+        * elf32-arm.c (elf32_arm_final_link_relocate): Use labs rather than
+        abs to fix a truncation warning.
+
+2017-06-20  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2017-05-08  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	* elflink.c (elf_output_implib): Remove executable flag from import
+	library bfd.
+	* elf32-arm.c (elf32_arm_filter_implib_symbols): Assert that the import
+	library is a relocatable object file.
+
+2017-06-13  Nick Clifton  <nickc@redhat.com>
+
+	Import this fix from the mainline sources:
+
+	2017-06-06  James Clarke  <jrtc27@jrtc27.com>
+
+	PR ld/19579
+	* elfnn-aarch64.c (elfNN_aarch64_finish_dynamic_symbol): Check
+	ELF_COMMON_DEF_P for common symbols.
+
+2017-06-07  Nick Clifton  <nickc@redhat.com>
+
+	Import this fix from upstream:
+
+	2017-05-30  Casey Smith  <clegg89@gmail.com>
+
+	PR ld/21523
+	* elf32-arm.c (elf32_arm_final_link_relocate): Install an absolute
+	value when processing the R_ARM_THM_ALU_PREL_11_0 reloc.
+
+2017-06-05  Alan Modra  <amodra@gmail.com>
+
+	PR 21529
+	* linker.c (_bfd_generic_link_output_symbols): Handle BSF_GNU_UNIQUE.
+
+2017-05-01  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>
+
+	PR ld/21404
+	* elf32-avr.c (avr_should_move_sym): New function.
+	(avr_should_reduce_sym_size): Likewise.
+	(avr_should_increase_sym_size): Likewise.
+	(elf32_avr_relax_delete_bytes): Adjust symbol values
+	and sizes by calling new functions.
+
+2017-05-01  Palmer Dabbelt  <palmer@dabbelt.com>
+
+	* config.bfd (riscv32-*): Enable rv64.
+
+2017-04-03  Palmer Dabbelt  <palmer@dabbelt.com>
+
+	* elfnn-riscv.c (GP_NAME): Delete.
+	(riscv_global_pointer_value): Change GP_NAME to RISCV_GP_SYMBOL.
+	(_bfd_riscv_relax_lui): Likewise.
+
+2017-01-17  Kuan-Lin Chen  <kuanlinchentw@gmail.com>
+
+	* elfnn-riscv.c (riscv_elf_object_p): New function.
+
+2017-04-26  Maciej W. Rozycki  <macro@imgtec.com>
+
+	PR ld/21334
+	* elf-bfd.h (elf_backend_data): Add `always_renumber_dynsyms'
+	member.
+	* elfxx-target.h [!elf_backend_always_renumber_dynsyms]
+	(elf_backend_always_renumber_dynsyms): Define.
+	(elfNN_bed): Initialize `always_renumber_dynsyms' member.
+	* elfxx-mips.h (elf_backend_always_renumber_dynsyms): Define.
+	* elflink.c (bfd_elf_size_dynsym_hash_dynstr): Also call
+	`_bfd_elf_link_renumber_dynsyms' if the backend has requested
+	it.
+	(elf_gc_sweep): Likewise.
+
+2017-04-26  Maciej W. Rozycki  <macro@imgtec.com>
+
+	* elflink.c (elf_gc_sweep): Only call
+	`_bfd_elf_link_renumber_dynsyms' if dynamic sections have been
+	created.
+
+2017-04-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/21425
+	* elf32-i386.c (ELF_MAXPAGESIZE): Set to 0x1000 for VxWorks.
+
+2017-03-28  Hans-Peter Nilsson  <hp@axis.com>
+
+	PR ld/16044
+	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Adjust BFD_ASSERT
+	to handle a local symbol with a hash-symbol-entry; without PLT.
+	Add BFD_ASSERT for an incidental case with GOT entry present.
+	(cris_elf_check_relocs): Increment PLT refcount only if the symbol
+	isn't forced-or-set local.
+
+2017-04-13  Alan Modra  <amodra@gmail.com>
+
+	* elf32-arm.c (arm_type_of_stub): Supply missing args to "long
+	branch veneers" error.  Fix double space and format message.
+	* elf32-avr.c (avr_add_stub): Do not pass NULL as %B arg.
+	* elf64-ppc.c (tocsave_find): Supply missing %B arg.
+
+2017-04-10  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/19579
+	PR ld/21306
+	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Check
+	ELF_COMMON_DEF_P for common symbols.
+	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
+	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
+	* elflink.c (_bfd_elf_merge_symbol): Revert commits
+	202ac193bbbecc96a4978d1ac3d17148253f9b01 and
+	07492f668d2173da7a2bda3707ff0985e0f460b6.
+
+2017-03-07  Alan Modra  <amodra@gmail.com>
+
+	PR 21224
+	PR 20519
+	* elf64-ppc.c (ppc64_elf_relocate_section): Add missing
+	dyn_relocs check.
+
+2017-03-07  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-03-02  Alan Modra  <amodra@gmail.com>
+	* elf32-ppc.c (ppc_elf_vle_split16): Correct insn mask typo.
+
+2017-03-02  Tristan Gingold  <gingold@adacore.com>
+
+	* version.m4: Bump version to 2.28.0
+	* configure: Regenerate.
+
+2017-03-02  Tristan Gingold  <gingold@adacore.com>
+
+	* development.sh: Set development to true.
+
 2017-03-02  Tristan Gingold  <gingold@adacore.com>
 
 	* version.m4: Bump version to 2.28
diff --git a/bfd/config.bfd b/bfd/config.bfd
index 1b28016b91..c0312162db 100644
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -1439,10 +1439,9 @@ case "${targ}" in
 #ifdef BFD64
   riscv32-*-*)
     targ_defvec=riscv_elf32_vec
-    targ_selvecs="riscv_elf32_vec"
+    targ_selvecs="riscv_elf32_vec riscv_elf64_vec"
     want64=true
     ;;
-
   riscv64-*-*)
     targ_defvec=riscv_elf64_vec
     targ_selvecs="riscv_elf32_vec riscv_elf64_vec"
diff --git a/bfd/configure b/bfd/configure
index 97693870c4..f30bfabef3 100755
--- a/bfd/configure
+++ b/bfd/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.64 for bfd 2.28.
+# Generated by GNU Autoconf 2.64 for bfd 2.28.0.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
@@ -556,8 +556,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='bfd'
 PACKAGE_TARNAME='bfd'
-PACKAGE_VERSION='2.28'
-PACKAGE_STRING='bfd 2.28'
+PACKAGE_VERSION='2.28.0'
+PACKAGE_STRING='bfd 2.28.0'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
@@ -1354,7 +1354,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures bfd 2.28 to adapt to many kinds of systems.
+\`configure' configures bfd 2.28.0 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1425,7 +1425,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of bfd 2.28:";;
+     short | recursive ) echo "Configuration of bfd 2.28.0:";;
    esac
   cat <<\_ACEOF
 
@@ -1546,7 +1546,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-bfd configure 2.28
+bfd configure 2.28.0
 generated by GNU Autoconf 2.64
 
 Copyright (C) 2009 Free Software Foundation, Inc.
@@ -2188,7 +2188,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by bfd $as_me 2.28, which was
+It was created by bfd $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   $ $0 $@
@@ -3997,7 +3997,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='bfd'
- VERSION='2.28'
+ VERSION='2.28.0'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -16613,7 +16613,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by bfd $as_me 2.28, which was
+This file was extended by bfd $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -16677,7 +16677,7 @@ Report bugs to the package provider."
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-bfd config.status 2.28
+bfd config.status 2.28.0
 configured by $0, generated by GNU Autoconf 2.64,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
diff --git a/bfd/development.sh b/bfd/development.sh
index b001a888ea..cd31410a8e 100644
--- a/bfd/development.sh
+++ b/bfd/development.sh
@@ -16,4 +16,4 @@
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 # Controls whether to enable development-mode features by default.
-development=false
+development=true
diff --git a/bfd/elf-bfd.h b/bfd/elf-bfd.h
index 5de9ab6ca6..dc4bd87f89 100644
--- a/bfd/elf-bfd.h
+++ b/bfd/elf-bfd.h
@@ -1478,6 +1478,10 @@ struct elf_backend_data
   /* Address of protected data defined in the shared library may be
      external, i.e., due to copy relocation.   */
   unsigned extern_protected_data : 1;
+
+  /* True if `_bfd_elf_link_renumber_dynsyms' must be called even for
+     static binaries.  */
+  unsigned always_renumber_dynsyms : 1;
 };
 
 /* Information about reloc sections associated with a bfd_elf_section_data
diff --git a/bfd/elf32-arm.c b/bfd/elf32-arm.c
index 0a785951dc..9f956d3188 100644
--- a/bfd/elf32-arm.c
+++ b/bfd/elf32-arm.c
@@ -4024,10 +4024,12 @@ arm_type_of_stub (struct bfd_link_info *info,
 	      if (!thumb_only)
 		{
 		  if (input_sec->flags & SEC_ELF_PURECODE)
-		    _bfd_error_handler (_("\
-%B(%A): warning: long branch  veneers used in section with SHF_ARM_PURECODE section \
-attribute is only supported for M-profile targets that implement the movw instruction."),
-					input_sec);
+		    _bfd_error_handler
+		      (_("%B(%A): warning: long branch veneers used in"
+			 " section with SHF_ARM_PURECODE section"
+			 " attribute is only supported for M-profile"
+			 " targets that implement the movw instruction."),
+		       input_bfd, input_sec);
 
 		  stub_type = (bfd_link_pic (info) | globals->pic_veneer)
 		    /* PIC stubs.  */
@@ -4056,10 +4058,12 @@ attribute is only supported for M-profile targets that implement the movw instru
 		  else
 		    {
 		      if (input_sec->flags & SEC_ELF_PURECODE)
-			_bfd_error_handler (_("\
-%B(%A): warning: long branch  veneers used in section with SHF_ARM_PURECODE section \
-attribute is only supported for M-profile targets that implement the movw instruction."),
-					    input_sec);
+			_bfd_error_handler
+			  (_("%B(%A): warning: long branch veneers used in"
+			     " section with SHF_ARM_PURECODE section"
+			     " attribute is only supported for M-profile"
+			     " targets that implement the movw instruction."),
+			   input_bfd, input_sec);
 
 		      stub_type = (bfd_link_pic (info) | globals->pic_veneer)
 			/* PIC stub.  */
@@ -4073,13 +4077,12 @@ attribute is only supported for M-profile targets that implement the movw instru
 	  else
 	    {
 	      if (input_sec->flags & SEC_ELF_PURECODE)
-		_bfd_error_handler (_("%B(%s): warning: long branch "
-				      " veneers used in section with "
-				      "SHF_ARM_PURECODE section "
-				      "attribute is only supported"
-				      " for M-profile targets that "
-				      "implement the movw "
-				      "instruction."));
+		_bfd_error_handler
+		  (_("%B(%A): warning: long branch veneers used in"
+		     " section with SHF_ARM_PURECODE section"
+		     " attribute is only supported" " for M-profile"
+		     " targets that implement the movw instruction."),
+		   input_bfd, input_sec);
 
 	      /* Thumb to arm.  */
 	      if (sym_sec != NULL
@@ -4126,13 +4129,12 @@ attribute is only supported for M-profile targets that implement the movw instru
 	   || r_type == R_ARM_TLS_CALL)
     {
       if (input_sec->flags & SEC_ELF_PURECODE)
-	_bfd_error_handler (_("%B(%s): warning: long branch "
-			      " veneers used in section with "
-			      "SHF_ARM_PURECODE section "
-			      "attribute is only supported"
-			      " for M-profile targets that "
-			      "implement the movw "
-			      "instruction."));
+	_bfd_error_handler
+	  (_("%B(%A): warning: long branch veneers used in"
+	     " section with SHF_ARM_PURECODE section"
+	     " attribute is only supported for M-profile"
+	     " targets that implement the movw instruction."),
+	   input_bfd, input_sec);
       if (branch_type == ST_BRANCH_TO_THUMB)
 	{
 	  /* Arm to thumb.  */
@@ -10503,7 +10505,9 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 			  + input_section->output_offset
 			  + rel->r_offset);
 
-	value = relocation;
+	/* PR 21523: Use an absolute value.  The user of this reloc will
+	   have already selected an ADD or SUB insn appropriately.  */
+	value = labs (relocation);
 
 	if (value >= 0x1000)
 	  return bfd_reloc_overflow;
@@ -17496,6 +17500,10 @@ elf32_arm_filter_implib_symbols (bfd *abfd ATTRIBUTE_UNUSED,
 {
   struct elf32_arm_link_hash_table *globals = elf32_arm_hash_table (info);
 
+  /* Requirement 8 of "ARM v8-M Security Extensions: Requirements on
+     Development Tools" (ARM-ECM-0359818) mandates Secure Gateway import
+     library to be a relocatable object file.  */
+  BFD_ASSERT (!(bfd_get_file_flags (info->out_implib_bfd) & EXEC_P));
   if (globals->cmse_implib)
     return elf32_arm_filter_cmse_symbols (abfd, info, syms, symcount);
   else
diff --git a/bfd/elf32-avr.c b/bfd/elf32-avr.c
index 56b143d414..f140aa7ed4 100644
--- a/bfd/elf32-avr.c
+++ b/bfd/elf32-avr.c
@@ -1854,6 +1854,40 @@ elf32_avr_adjust_reloc_if_spans_insn (bfd *abfd,
     }
 }
 
+static bfd_boolean
+avr_should_move_sym (symvalue symval,
+                     bfd_vma start,
+                     bfd_vma end,
+                     bfd_boolean did_pad)
+{
+  bfd_boolean sym_within_boundary =
+          did_pad ? symval < end : symval <= end;
+  return (symval > start && sym_within_boundary);
+}
+
+static bfd_boolean
+avr_should_reduce_sym_size (symvalue symval,
+                            symvalue symend,
+                            bfd_vma start,
+                            bfd_vma end,
+                            bfd_boolean did_pad)
+{
+  bfd_boolean sym_end_within_boundary =
+          did_pad ? symend < end : symend <= end;
+  return (symval <= start && symend > start && sym_end_within_boundary);
+}
+
+static bfd_boolean
+avr_should_increase_sym_size (symvalue symval,
+                              symvalue symend,
+                              bfd_vma start,
+                              bfd_vma end,
+                              bfd_boolean did_pad)
+{
+  return avr_should_move_sym (symval, start, end, did_pad)
+          && symend >= end && did_pad;
+}
+
 /* Delete some bytes from a section while changing the size of an instruction.
    The parameter "addr" denotes the section-relative offset pointing just
    behind the shrinked instruction. "addr+count" point at the first
@@ -1875,13 +1909,14 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
   Elf_Internal_Rela *irel, *irelend;
   Elf_Internal_Sym *isym;
   Elf_Internal_Sym *isymbuf = NULL;
-  bfd_vma toaddr, reloc_toaddr;
+  bfd_vma toaddr;
   struct elf_link_hash_entry **sym_hashes;
   struct elf_link_hash_entry **end_hashes;
   unsigned int symcount;
   struct avr_relax_info *relax_info;
   struct avr_property_record *prop_record = NULL;
   bfd_boolean did_shrink = FALSE;
+  bfd_boolean did_pad = FALSE;
 
   symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
   sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
@@ -1912,17 +1947,6 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
         }
     }
 
-  /* We need to look at all relocs with offsets less than toaddr. prop
-     records handling adjusts toaddr downwards to avoid moving syms at the
-     address of the property record, but all relocs with offsets between addr
-     and the current value of toaddr need to have their offsets adjusted.
-     Assume addr = 0, toaddr = 4 and count = 2. After prop records handling,
-     toaddr becomes 2, but relocs with offsets 2 and 3 still need to be
-     adjusted (to 0 and 1 respectively), as the first 2 bytes are now gone.
-     So record the current value of toaddr here, and use it when adjusting
-     reloc offsets. */
-  reloc_toaddr = toaddr;
-
   irel = elf_section_data (sec)->relocs;
   irelend = irel + sec->reloc_count;
 
@@ -1962,10 +1986,7 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
          to remember we didn't delete anything i.e. don't set did_shrink,
          so that we don't corrupt reloc offsets or symbol values.*/
       memset (contents + toaddr - count, fill, count);
-
-      /* Adjust the TOADDR to avoid moving symbols located at the address
-         of the property record, which has not moved.  */
-      toaddr -= count;
+      did_pad = TRUE;
     }
 
   if (!did_shrink)
@@ -1981,7 +2002,7 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
 
       /* Get the new reloc address.  */
       if ((irel->r_offset > addr
-           && irel->r_offset < reloc_toaddr))
+           && irel->r_offset < toaddr))
         {
           if (debug_relax)
             printf ("Relocation at address 0x%x needs to be moved.\n"
@@ -2059,7 +2080,7 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
                  {
                    /* If there is an alignment boundary, we only need to
                       adjust addends that end up below the boundary. */
-                   bfd_vma shrink_boundary = (reloc_toaddr
+                   bfd_vma shrink_boundary = (toaddr
                                               + sec->output_section->vma
                                               + sec->output_offset);
 
@@ -2102,12 +2123,10 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
 	{
 	  if (isym->st_shndx == sec_shndx)
             {
-	      if (isym->st_value > addr
-                  && isym->st_value <= toaddr)
-                isym->st_value -= count;
-
-              if (isym->st_value <= addr
-                  && isym->st_value + isym->st_size > addr)
+              symvalue symval = isym->st_value;
+              symvalue symend = symval + isym->st_size;
+              if (avr_should_reduce_sym_size (symval, symend,
+                                      addr, toaddr, did_pad))
                 {
                   /* If this assert fires then we have a symbol that ends
                      part way through an instruction.  Does that make
@@ -2115,6 +2134,12 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
                   BFD_ASSERT (isym->st_value + isym->st_size >= addr + count);
                   isym->st_size -= count;
                 }
+              else if (avr_should_increase_sym_size (symval, symend,
+                                      addr, toaddr, did_pad))
+                isym->st_size += count;
+
+              if (avr_should_move_sym (symval, addr, toaddr, did_pad))
+                isym->st_value -= count;
             }
 	}
     }
@@ -2131,20 +2156,24 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
            || sym_hash->root.type == bfd_link_hash_defweak)
           && sym_hash->root.u.def.section == sec)
         {
-          if (sym_hash->root.u.def.value > addr
-              && sym_hash->root.u.def.value <= toaddr)
-            sym_hash->root.u.def.value -= count;
+          symvalue symval = sym_hash->root.u.def.value;
+          symvalue symend = symval + sym_hash->size;
 
-          if (sym_hash->root.u.def.value <= addr
-              && (sym_hash->root.u.def.value + sym_hash->size > addr))
+          if (avr_should_reduce_sym_size (symval, symend,
+                                  addr, toaddr, did_pad))
             {
               /* If this assert fires then we have a symbol that ends
                  part way through an instruction.  Does that make
                  sense?  */
-              BFD_ASSERT (sym_hash->root.u.def.value + sym_hash->size
-                          >= addr + count);
+              BFD_ASSERT (symend >= addr + count);
               sym_hash->size -= count;
             }
+          else if (avr_should_increase_sym_size (symval, symend,
+                                  addr, toaddr, did_pad))
+              sym_hash->size += count;
+
+          if (avr_should_move_sym (symval, addr, toaddr, did_pad))
+            sym_hash->root.u.def.value -= count;
         }
     }
 
@@ -3284,8 +3313,7 @@ avr_add_stub (const char *stub_name,
   if (hsh == NULL)
     {
       /* xgettext:c-format */
-      _bfd_error_handler (_("%B: cannot create stub entry %s"),
-			  NULL, stub_name);
+      _bfd_error_handler (_("cannot create stub entry %s"), stub_name);
       return NULL;
     }
 
diff --git a/bfd/elf32-cris.c b/bfd/elf32-cris.c
index 97b8cc3eb8..d4bbcebecc 100644
--- a/bfd/elf32-cris.c
+++ b/bfd/elf32-cris.c
@@ -2714,8 +2714,9 @@ elf_cris_adjust_gotplt_to_got (struct elf_cris_link_hash_entry *h, void * p)
   struct bfd_link_info *info = (struct bfd_link_info *) p;
 
   /* A GOTPLT reloc, when activated, is supposed to be included into
-     the PLT refcount.  */
+     the PLT refcount, when the symbol isn't set-or-forced local.  */
   BFD_ASSERT (h->gotplt_refcount == 0
+	      || h->root.plt.refcount == -1
 	      || h->gotplt_refcount <= h->root.plt.refcount);
 
   /* If nobody wanted a GOTPLT with this symbol, we're done.  */
@@ -2741,6 +2742,7 @@ elf_cris_adjust_gotplt_to_got (struct elf_cris_link_hash_entry *h, void * p)
       srelgot = elf_hash_table (info)->srelgot;
 
       /* Put accurate refcounts there.  */
+      BFD_ASSERT (h->root.got.refcount >= 0);
       h->root.got.refcount += h->gotplt_refcount;
       h->reg_got_refcount = h->gotplt_refcount;
 
@@ -3476,7 +3478,10 @@ cris_elf_check_relocs (bfd *abfd,
 	    continue;
 
 	  h->needs_plt = 1;
-	  h->plt.refcount++;
+
+	  /* If the symbol is forced local, the refcount is unavailable.  */
+	  if (h->plt.refcount != -1)
+	    h->plt.refcount++;
 	  break;
 
 	case R_CRIS_8:
diff --git a/bfd/elf32-i386.c b/bfd/elf32-i386.c
index 24beba3e1d..f570253ee3 100644
--- a/bfd/elf32-i386.c
+++ b/bfd/elf32-i386.c
@@ -6576,6 +6576,8 @@ elf32_i386_nacl_elf_object_p (bfd *abfd)
 #undef	TARGET_LITTLE_NAME
 #define TARGET_LITTLE_NAME		"elf32-i386-vxworks"
 #undef	ELF_OSABI
+#undef	ELF_MAXPAGESIZE
+#define ELF_MAXPAGESIZE			0x1000
 #undef	elf_backend_plt_alignment
 #define elf_backend_plt_alignment	4
 
diff --git a/bfd/elf32-ppc.c b/bfd/elf32-ppc.c
index 0f3eb68d35..10caa8a95b 100644
--- a/bfd/elf32-ppc.c
+++ b/bfd/elf32-ppc.c
@@ -4921,7 +4921,7 @@ ppc_elf_vle_split16 (bfd *input_bfd,
   unsigned int insn, opcode, top5;
 
   insn = bfd_get_32 (input_bfd, loc);
-  opcode = insn & 0xf300f800;
+  opcode = insn & 0xfc00f800;
   if (opcode == E_OR2I_INSN
       || opcode == E_AND2I_DOT_INSN
       || opcode == E_OR2IS_INSN
diff --git a/bfd/elf32-s390.c b/bfd/elf32-s390.c
index fd1bc13d5c..ddb6f5b255 100644
--- a/bfd/elf32-s390.c
+++ b/bfd/elf32-s390.c
@@ -3785,7 +3785,7 @@ elf_s390_finish_dynamic_symbol (bfd *output_bfd,
 	     RELATIVE reloc.  The entry in the global offset table
 	     will already have been initialized in the
 	     relocate_section function.  */
-	  if (!h->def_regular)
+	  if (!(h->def_regular || ELF_COMMON_DEF_P (h)))
 	    return FALSE;
 	  BFD_ASSERT((h->got.offset & 1) != 0);
 	  rela.r_info = ELF32_R_INFO (0, R_390_RELATIVE);
diff --git a/bfd/elf64-ppc.c b/bfd/elf64-ppc.c
index e7d4792245..765bc6b2d8 100644
--- a/bfd/elf64-ppc.c
+++ b/bfd/elf64-ppc.c
@@ -7627,7 +7627,7 @@ tocsave_find (struct ppc_link_hash_table *htab,
   if (ent.sec == NULL || ent.sec->output_section == NULL)
     {
       _bfd_error_handler
-	(_("%B: undefined symbol on R_PPC64_TOCSAVE relocation"));
+	(_("%B: undefined symbol on R_PPC64_TOCSAVE relocation"), ibfd);
       return NULL;
     }
 
@@ -14798,8 +14798,10 @@ ppc64_elf_relocate_section (bfd *output_bfd,
 	    break;
 
 	  if (bfd_link_pic (info)
-	      ? ((h != NULL && pc_dynrelocs (h))
-		 || must_be_dyn_reloc (info, r_type))
+	      ? ((h == NULL
+		  || h->dyn_relocs != NULL)
+		 && ((h != NULL && pc_dynrelocs (h))
+		     || must_be_dyn_reloc (info, r_type)))
 	      : (h != NULL
 		 ? h->dyn_relocs != NULL
 		 : ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC))
diff --git a/bfd/elf64-s390.c b/bfd/elf64-s390.c
index b5fd05f263..fbbf8d6e1d 100644
--- a/bfd/elf64-s390.c
+++ b/bfd/elf64-s390.c
@@ -3582,7 +3582,7 @@ elf_s390_finish_dynamic_symbol (bfd *output_bfd,
 	     RELATIVE reloc.  The entry in the global offset table
 	     will already have been initialized in the
 	     relocate_section function.  */
-	  if (!h->def_regular)
+	  if (!(h->def_regular || ELF_COMMON_DEF_P (h)))
 	    return FALSE;
 	  BFD_ASSERT((h->got.offset & 1) != 0);
 	  rela.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
diff --git a/bfd/elf64-x86-64.c b/bfd/elf64-x86-64.c
index e0e6c16fcd..e363eafc02 100644
--- a/bfd/elf64-x86-64.c
+++ b/bfd/elf64-x86-64.c
@@ -4926,7 +4926,8 @@ do_ifunc_pointer:
 		{
 		  /* Symbol is referenced locally.  Make sure it is
 		     defined locally or for a branch.  */
-		  fail = !h->def_regular && !branch;
+		  fail = (!(h->def_regular || ELF_COMMON_DEF_P (h))
+			  && !branch);
 		}
 	      else if (!(bfd_link_pie (info)
 			 && (h->needs_copy || eh->needs_copy)))
diff --git a/bfd/elflink.c b/bfd/elflink.c
index 69b66f2831..f82bd8202b 100644
--- a/bfd/elflink.c
+++ b/bfd/elflink.c
@@ -1543,16 +1543,13 @@ _bfd_elf_merge_symbol (bfd *abfd,
      represent variables; this can cause confusion in principle, but
      any such confusion would seem to indicate an erroneous program or
      shared library.  We also permit a common symbol in a regular
-     object to override a weak symbol in a shared object.  A common
-     symbol in executable also overrides a symbol in a shared object.  */
+     object to override a weak symbol in a shared object.  */
 
   if (newdyn
       && newdef
       && (olddef
 	  || (h->root.type == bfd_link_hash_common
-	      && (newweak
-		  || newfunc
-		  || (!olddyn && bfd_link_executable (info))))))
+	      && (newweak || newfunc))))
     {
       *override = TRUE;
       newdef = FALSE;
@@ -6710,6 +6707,8 @@ bfd_boolean
 bfd_elf_size_dynsym_hash_dynstr (bfd *output_bfd, struct bfd_link_info *info)
 {
   const struct elf_backend_data *bed;
+  unsigned long section_sym_count;
+  bfd_size_type dynsymcount;
 
   if (!is_elf_hash_table (info->hash))
     return TRUE;
@@ -6717,24 +6716,30 @@ bfd_elf_size_dynsym_hash_dynstr (bfd *output_bfd, struct bfd_link_info *info)
   bed = get_elf_backend_data (output_bfd);
   (*bed->elf_backend_init_index_section) (output_bfd, info);
 
+  /* Assign dynsym indices.  In a shared library we generate a section
+     symbol for each output section, which come first.  Next come all
+     of the back-end allocated local dynamic syms, followed by the rest
+     of the global symbols.
+
+     This is usually not needed for static binaries, however backends
+     can request to always do it, e.g. the MIPS backend uses dynamic
+     symbol counts to lay out GOT, which will be produced in the
+     presence of GOT relocations even in static binaries (holding fixed
+     data in that case, to satisfy those relocations).  */
+
+  if (elf_hash_table (info)->dynamic_sections_created
+      || bed->always_renumber_dynsyms)
+    dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info,
+						  &section_sym_count);
+
   if (elf_hash_table (info)->dynamic_sections_created)
     {
       bfd *dynobj;
       asection *s;
-      bfd_size_type dynsymcount;
-      unsigned long section_sym_count;
       unsigned int dtagcount;
 
       dynobj = elf_hash_table (info)->dynobj;
 
-      /* Assign dynsym indicies.  In a shared library we generate a
-	 section symbol for each output section, which come first.
-	 Next come all of the back-end allocated local dynamic syms,
-	 followed by the rest of the global symbols.  */
-
-      dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info,
-						    &section_sym_count);
-
       /* Work out the size of the symbol version section.  */
       s = bfd_get_linker_section (dynobj, ".gnu.version");
       BFD_ASSERT (s != NULL);
@@ -11141,10 +11146,11 @@ elf_output_implib (bfd *abfd, struct bfd_link_info *info)
   if (!bfd_set_format (implib_bfd, bfd_object))
     return FALSE;
 
+  /* Use flag from executable but make it a relocatable object.  */
   flags = bfd_get_file_flags (abfd);
   flags &= ~HAS_RELOC;
   if (!bfd_set_start_address (implib_bfd, 0)
-      || !bfd_set_file_flags (implib_bfd, flags))
+      || !bfd_set_file_flags (implib_bfd, flags & ~EXEC_P))
     return FALSE;
 
   /* Copy architecture of output file to import library file.  */
@@ -12986,7 +12992,12 @@ elf_gc_sweep (bfd *abfd, struct bfd_link_info *info)
   elf_link_hash_traverse (elf_hash_table (info), elf_gc_sweep_symbol,
 			  &sweep_info);
 
-  _bfd_elf_link_renumber_dynsyms (abfd, info, &section_sym_count);
+  /* We need to reassign dynsym indices now that symbols may have
+     been removed.  See the call in `bfd_elf_size_dynsym_hash_dynstr'
+     for the details of the conditions used here.  */
+  if (elf_hash_table (info)->dynamic_sections_created
+      || bed->always_renumber_dynsyms)
+    _bfd_elf_link_renumber_dynsyms (abfd, info, &section_sym_count);
   return TRUE;
 }
 
diff --git a/bfd/elfnn-aarch64.c b/bfd/elfnn-aarch64.c
index d632b3c3f5..a92c0f3c2d 100644
--- a/bfd/elfnn-aarch64.c
+++ b/bfd/elfnn-aarch64.c
@@ -8903,7 +8903,7 @@ elfNN_aarch64_finish_dynamic_symbol (bfd *output_bfd,
 	}
       else if (bfd_link_pic (info) && SYMBOL_REFERENCES_LOCAL (info, h))
 	{
-	  if (!h->def_regular)
+	  if (!(h->def_regular || ELF_COMMON_DEF_P (h)))
 	    return FALSE;
 
 	  BFD_ASSERT ((h->got.offset & 1) != 0);
diff --git a/bfd/elfnn-riscv.c b/bfd/elfnn-riscv.c
index ff25ebd32e..3c04507623 100644
--- a/bfd/elfnn-riscv.c
+++ b/bfd/elfnn-riscv.c
@@ -52,10 +52,6 @@
 #define ELF_MAXPAGESIZE			0x1000
 #define ELF_COMMONPAGESIZE		0x1000
 
-/* The global pointer's symbol name.  */
-
-#define GP_NAME "__global_pointer$"
-
 /* The RISC-V linker needs to keep track of the number of relocs that it
    decides to copy as dynamic relocs in check_relocs for each symbol.
    This is so that it can later discard them if they are found to be
@@ -1467,7 +1463,7 @@ riscv_global_pointer_value (struct bfd_link_info *info)
 {
   struct bfd_link_hash_entry *h;
 
-  h = bfd_link_hash_lookup (info->hash, GP_NAME, FALSE, FALSE, TRUE);
+  h = bfd_link_hash_lookup (info->hash, RISCV_GP_SYMBOL, FALSE, FALSE, TRUE);
   if (h == NULL || h->type != bfd_link_hash_defined)
     return 0;
 
@@ -2818,7 +2814,8 @@ _bfd_riscv_relax_lui (bfd *abfd,
       /* If gp and the symbol are in the same output section, then
 	 consider only that section's alignment.  */
       struct bfd_link_hash_entry *h =
-	bfd_link_hash_lookup (link_info->hash, GP_NAME, FALSE, FALSE, TRUE);
+	bfd_link_hash_lookup (link_info->hash, RISCV_GP_SYMBOL, FALSE, FALSE,
+			      TRUE);
       if (h->u.def.section->output_section == sym_sec->output_section)
 	max_alignment = (bfd_vma) 1 << sym_sec->output_section->alignment_power;
     }
@@ -3205,6 +3202,19 @@ riscv_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
   return TRUE;
 }
 
+/* Set the right mach type.  */
+static bfd_boolean
+riscv_elf_object_p (bfd *abfd)
+{
+  /* There are only two mach types in RISCV currently.  */
+  if (strcmp (abfd->xvec->name, "elf32-littleriscv") == 0)
+    bfd_default_set_arch_mach (abfd, bfd_arch_riscv, bfd_mach_riscv32);
+  else
+    bfd_default_set_arch_mach (abfd, bfd_arch_riscv, bfd_mach_riscv64);
+
+  return TRUE;
+}
+
 
 #define TARGET_LITTLE_SYM		riscv_elfNN_vec
 #define TARGET_LITTLE_NAME		"elfNN-littleriscv"
@@ -3230,6 +3240,7 @@ riscv_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
 #define elf_backend_plt_sym_val		     riscv_elf_plt_sym_val
 #define elf_backend_grok_prstatus            riscv_elf_grok_prstatus
 #define elf_backend_grok_psinfo              riscv_elf_grok_psinfo
+#define elf_backend_object_p                 riscv_elf_object_p
 #define elf_info_to_howto_rel		     NULL
 #define elf_info_to_howto		     riscv_info_to_howto_rela
 #define bfd_elfNN_bfd_relax_section	     _bfd_riscv_relax_section
diff --git a/bfd/elfxx-mips.h b/bfd/elfxx-mips.h
index fa5b5d2de9..274129b2e5 100644
--- a/bfd/elfxx-mips.h
+++ b/bfd/elfxx-mips.h
@@ -196,3 +196,4 @@ literal_reloc_p (int r_type)
 #define elf_backend_post_process_headers _bfd_mips_post_process_headers
 #define elf_backend_compact_eh_encoding _bfd_mips_elf_compact_eh_encoding
 #define elf_backend_cant_unwind_opcode _bfd_mips_elf_cant_unwind_opcode
+#define elf_backend_always_renumber_dynsyms TRUE
diff --git a/bfd/elfxx-target.h b/bfd/elfxx-target.h
index d063fb7f1b..d07600c15d 100644
--- a/bfd/elfxx-target.h
+++ b/bfd/elfxx-target.h
@@ -126,6 +126,9 @@
 #ifndef elf_backend_extern_protected_data
 #define elf_backend_extern_protected_data 0
 #endif
+#ifndef elf_backend_always_renumber_dynsyms
+#define elf_backend_always_renumber_dynsyms FALSE
+#endif
 #ifndef elf_backend_stack_align
 #define elf_backend_stack_align 16
 #endif
@@ -866,7 +869,8 @@ static struct elf_backend_data elfNN_bed =
   elf_backend_no_page_alias,
   elf_backend_default_execstack,
   elf_backend_caches_rawsize,
-  elf_backend_extern_protected_data
+  elf_backend_extern_protected_data,
+  elf_backend_always_renumber_dynsyms
 };
 
 /* Forward declaration for use when initialising alternative_target field.  */
diff --git a/bfd/linker.c b/bfd/linker.c
index 12c9fb0d87..c3ec4fefb6 100644
--- a/bfd/linker.c
+++ b/bfd/linker.c
@@ -2091,7 +2091,7 @@ _bfd_generic_link_output_symbols (bfd *output_bfd,
 	      && bfd_hash_lookup (info->keep_hash, bfd_asymbol_name (sym),
 				  FALSE, FALSE) == NULL))
 	output = FALSE;
-      else if ((sym->flags & (BSF_GLOBAL | BSF_WEAK)) != 0)
+      else if ((sym->flags & (BSF_GLOBAL | BSF_WEAK | BSF_GNU_UNIQUE)) != 0)
 	{
 	  /* If this symbol is marked as occurring now, rather
 	     than at the end, output it now.  This is used for
diff --git a/bfd/version.h b/bfd/version.h
index eda06e4ac6..8e8f0bf679 100644
--- a/bfd/version.h
+++ b/bfd/version.h
@@ -1,4 +1,4 @@
-#define BFD_VERSION_DATE 20170302
+#define BFD_VERSION_DATE 20170706
 #define BFD_VERSION @bfd_version@
 #define BFD_VERSION_STRING  @bfd_version_package@ @bfd_version_string@
 #define REPORT_BUGS_TO @report_bugs_to@
diff --git a/bfd/version.m4 b/bfd/version.m4
index 0cfca2dda8..8bde21ee1c 100644
--- a/bfd/version.m4
+++ b/bfd/version.m4
@@ -1 +1 @@
-m4_define([BFD_VERSION], [2.28])
+m4_define([BFD_VERSION], [2.28.0])
diff --git a/binutils/ChangeLog b/binutils/ChangeLog
index aa17468ffb..431822add9 100644
--- a/binutils/ChangeLog
+++ b/binutils/ChangeLog
@@ -1,3 +1,15 @@
+2017-05-18  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-01-10  Nick Clifton  <nickc@redhat.com>
+	PR 21034
+	* stabs.c (parse_stab_members): Fix thinko checking for g++
+	version 1 stabs information.
+
+2017-03-02  Tristan Gingold  <gingold@adacore.com>
+
+	* configure: Regenerate.
+
 2017-03-02  Tristan Gingold  <gingold@adacore.com>
 
 	* configure: Regenerate.
diff --git a/binutils/configure b/binutils/configure
index baddf348d0..82119efe72 100755
--- a/binutils/configure
+++ b/binutils/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.64 for binutils 2.28.
+# Generated by GNU Autoconf 2.64 for binutils 2.28.0.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
@@ -556,8 +556,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='binutils'
 PACKAGE_TARNAME='binutils'
-PACKAGE_VERSION='2.28'
-PACKAGE_STRING='binutils 2.28'
+PACKAGE_VERSION='2.28.0'
+PACKAGE_STRING='binutils 2.28.0'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
@@ -1338,7 +1338,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures binutils 2.28 to adapt to many kinds of systems.
+\`configure' configures binutils 2.28.0 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1409,7 +1409,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of binutils 2.28:";;
+     short | recursive ) echo "Configuration of binutils 2.28.0:";;
    esac
   cat <<\_ACEOF
 
@@ -1530,7 +1530,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-binutils configure 2.28
+binutils configure 2.28.0
 generated by GNU Autoconf 2.64
 
 Copyright (C) 2009 Free Software Foundation, Inc.
@@ -2172,7 +2172,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by binutils $as_me 2.28, which was
+It was created by binutils $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   $ $0 $@
@@ -3981,7 +3981,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='binutils'
- VERSION='2.28'
+ VERSION='2.28.0'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -15223,7 +15223,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by binutils $as_me 2.28, which was
+This file was extended by binutils $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -15287,7 +15287,7 @@ Report bugs to the package provider."
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-binutils config.status 2.28
+binutils config.status 2.28.0
 configured by $0, generated by GNU Autoconf 2.64,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
diff --git a/binutils/stabs.c b/binutils/stabs.c
index f5c5d2d8e0..d3fc4afe24 100644
--- a/binutils/stabs.c
+++ b/binutils/stabs.c
@@ -2702,7 +2702,7 @@ parse_stab_members (void *dhandle, struct stab_handle *info,
 	      ++*pp;
 	      voffset &= 0x7fffffff;
 
-	      if (**pp == ';' || *pp == '\0')
+	      if (**pp == ';' || **pp == '\0')
 		{
 		  /* Must be g++ version 1.  */
 		  context = DEBUG_TYPE_NULL;
diff --git a/gas/ChangeLog b/gas/ChangeLog
index 8a586ad7a0..a89a5f5d65 100644
--- a/gas/ChangeLog
+++ b/gas/ChangeLog
@@ -1,3 +1,104 @@
+2017-04-05  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline
+	2017-04-04  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+	* config/tc-arm.c (arm_regs): Add MVFR2.
+        (do_vmrs): Constraint for MVFR2 and armv8.
+        (do_vmsr): Likewise.
+        * testsuite/gas/arm/armv8-a+fp.d: Update.
+        * testsuite/gas/arm/armv8-a+fp.s: Likewise.
+        * testsuite/gas/arm/vfp-bad.s: Likewise.
+        * testsuite/gas/arm/vfp-bad.l: Likewise.
+
+2017-06-20  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2017-04-24  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	* config/tc-arm.c (move_or_literal_pool): Remove code generating MOVS.
+	Forbid MOV.W and MOVW if destination is SP or PC.
+	* testsuite/gas/arm/thumb2_ldr_immediate_highregs_armv6t2.s: Explain
+	expectation of LDR not generating a MOVS for low registers and small
+	constants.  Add tests of MOVW generation.
+	* testsuite/gas/arm/thumb2_ldr_immediate_highregs_armv6t2.d: Update
+	expected disassembly.
+
+2017-06-05  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-03-15  Nick Clifton  <nickc@redhat.com>
+	* config/tc-riscv.c (riscv_pre_output_hook): Fix compile time
+	warning about discarding a const qualifier.
+
+2017-04-03  Palmer Dabbelt  <palmer@dabbelt.com>
+
+	* config/tc-riscv.c (riscv_clear_subsets): Cast argument to free to
+	avoid const warnings.
+
+2017-03-30  Palmer Dabbelt  <palmer@dabbelt.com>
+
+	* config/tc-riscv.c (riscv_clear_subsets): New function.
+	(riscv_add_subset): Call riscv_clear_subsets and riscv_set_rvc to
+	clear RVC when it's been previously set.
+
+2017-03-21  Palmer Dabbbelt  <palmer@dabbelt.com>
+
+	* config/tc-riscv.c (md_show_usage): Remove defuct -m32, -m64,
+	-msoft-float, -mhard-float, -mno-rvc, and -mrvc options; and don't
+	print an invalid default ISA string.
+	* doc/c-riscv.texi (OPTIONS): Add -fpic and -fno-pic options.
+
+2017-03-14  Kito Cheng  <kito.cheng@gmail.com>
+
+	* config/tc-riscv.c (validate_riscv_insn): Add 'o' RVC immediate
+	encoding format, which can accept 0-valued immediates.
+	(riscv_ip): Likewise.
+
+2017-03-02  Kuan-Lin Chen  <rufus@andestech.com>
+
+	* config/tc-riscv.h (HWARD2_USE_FIXED_ADVANCE_PC): New define.
+
+2017-03-02  Kuan-Lin Chen  <rufus@andestech.com>
+
+	* config/tc-riscv.c (md_apply_fix): Set fx_frag and
+	fx_next->fx_frag for CFA_advance_loc relocations.
+
+2017-03-02  Kuan-Lin Chen  <rufus@andestech.com>
+
+	* config/tc-riscv.c (md_apply_fix): Compute the correct offsets
+	for CFA relocations.
+
+2017-03-27  Alan Modra  <amodra@gmail.com>
+
+	PR 21303
+	* testsuite/gas/ppc/pr21303.d,
+	* testsuite/gas/ppc/pr21303.s: New test
+	* testsuite/gas/ppc/ppc.exp: Run it.
+
+2017-03-21  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2017-03-21  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/tc-s390.c (s390_parse_cpu): Remove S390_INSTR_FLAG_VX2
+	from cpu_table.  Remove vx2, and novx2 from cpu_flags.
+
+2017-03-08  Peter Bergner <bergner@vnet.ibm.com>
+
+	* testsuite/gas/ppc/altivec2.d (as): Use the -mpower8 option.
+	(objdump): Use the -Mpower8 option.
+
+2017-03-08  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Apply from master.
+	2017-03-08  Peter Bergner  <bergner@vnet.ibm.com>
+	* testsuite/gas/ppc/power9.d <lnia> New test.
+	* testsuite/gas/ppc/power9.s: Likewise.
+
+2017-03-02  Tristan Gingold  <gingold@adacore.com>
+
+	* configure: Regenerate.
+
 2017-03-02  Tristan Gingold  <gingold@adacore.com>
 
 	* configure: Regenerate.
diff --git a/gas/config/tc-arm.c b/gas/config/tc-arm.c
index 60bda51070..be85927319 100644
--- a/gas/config/tc-arm.c
+++ b/gas/config/tc-arm.c
@@ -7955,17 +7955,13 @@ move_or_literal_pool (int i, enum lit_type t, bfd_boolean mode_3)
 	{
 	  if (thumb_p)
 	    {
-	      /* This can be encoded only for a low register.  */
-	      if ((v & ~0xFF) == 0 && (inst.operands[i].reg < 8))
-		{
-		  /* This can be done with a mov(1) instruction.  */
-		  inst.instruction = T_OPCODE_MOV_I8 | (inst.operands[i].reg << 8);
-		  inst.instruction |= v;
-		  return TRUE;
-		}
+	      /* LDR should not use lead in a flag-setting instruction being
+		 chosen so we do not check whether movs can be used.  */
 
-	      if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6t2)
+	      if ((ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6t2)
 		  || ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6t2_v8m))
+		  && inst.operands[i].reg != 13
+		  && inst.operands[i].reg != 15)
 		{
 		  /* Check if on thumb2 it can be done with a mov.w, mvn or
 		     movw instruction.  */
@@ -9112,6 +9108,11 @@ do_vmrs (void)
       return;
     }
 
+  /* MVFR2 is only valid at ARMv8-A.  */
+  if (inst.operands[1].reg == 5)
+    constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_armv8),
+		_(BAD_FPU));
+
   /* APSR_ sets isvec. All other refs to PC are illegal.  */
   if (!inst.operands[0].isvec && Rt == REG_PC)
     {
@@ -9138,6 +9139,11 @@ do_vmsr (void)
       return;
     }
 
+  /* MVFR2 is only valid for ARMv8-A.  */
+  if (inst.operands[0].reg == 5)
+    constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_armv8),
+		_(BAD_FPU));
+
   /* If we get through parsing the register name, we just insert the number
      generated into the instruction without further validation.  */
   inst.instruction |= (inst.operands[0].reg << 16);
@@ -18799,6 +18805,7 @@ static const struct reg_entry reg_names[] =
   REGDEF(FPINST,9,VFC), REGDEF(FPINST2,10,VFC),
   REGDEF(mvfr0,7,VFC), REGDEF(mvfr1,6,VFC),
   REGDEF(MVFR0,7,VFC), REGDEF(MVFR1,6,VFC),
+  REGDEF(mvfr2,5,VFC), REGDEF(MVFR2,5,VFC),
 
   /* Maverick DSP coprocessor registers.  */
   REGSET(mvf,MVF),  REGSET(mvd,MVD),  REGSET(mvfx,MVFX),  REGSET(mvdx,MVDX),
diff --git a/gas/config/tc-riscv.c b/gas/config/tc-riscv.c
index ec5b0bb036..fb9a3ed53f 100644
--- a/gas/config/tc-riscv.c
+++ b/gas/config/tc-riscv.c
@@ -121,6 +121,18 @@ riscv_subset_supports (const char *feature)
 }
 
 static void
+riscv_clear_subsets (void)
+{
+  while (riscv_subsets != NULL)
+    {
+      struct riscv_subset *next = riscv_subsets->next;
+      free ((void *) riscv_subsets->name);
+      free (riscv_subsets);
+      riscv_subsets = next;
+    }
+}
+
+static void
 riscv_add_subset (const char *subset)
 {
   struct riscv_subset *s = xmalloc (sizeof *s);
@@ -139,6 +151,8 @@ riscv_set_arch (const char *s)
   const char *extension = NULL;
   const char *p = s;
 
+  riscv_clear_subsets();
+
   if (strncmp (p, "rv32", 4) == 0)
     {
       xlen = 32;
@@ -500,6 +514,7 @@ validate_riscv_insn (const struct riscv_opcode *opc)
 	  case 'c': break; /* RS1, constrained to equal sp */
 	  case 'i': used_bits |= ENCODE_RVC_SIMM3(-1U); break;
 	  case 'j': used_bits |= ENCODE_RVC_IMM (-1U); break;
+	  case 'o': used_bits |= ENCODE_RVC_IMM (-1U); break;
 	  case 'k': used_bits |= ENCODE_RVC_LW_IMM (-1U); break;
 	  case 'l': used_bits |= ENCODE_RVC_LD_IMM (-1U); break;
 	  case 'm': used_bits |= ENCODE_RVC_LWSP_IMM (-1U); break;
@@ -1321,6 +1336,13 @@ rvc_imm_done:
 		  ip->insn_opcode |=
 		    ENCODE_RVC_LDSP_IMM (imm_expr->X_add_number);
 		  goto rvc_imm_done;
+		case 'o':
+		  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)
+		      || imm_expr->X_op != O_constant
+		      || !VALID_RVC_IMM (imm_expr->X_add_number))
+		    break;
+		  ip->insn_opcode |= ENCODE_RVC_IMM (imm_expr->X_add_number);
+		  goto rvc_imm_done;
 		case 'K':
 		  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)
 		      || imm_expr->X_op != O_constant
@@ -1794,6 +1816,7 @@ riscv_after_parse_args (void)
     riscv_set_arch (xlen == 64 ? "rv64g" : "rv32g");
 
   /* Add the RVC extension, regardless of -march, to support .option rvc.  */
+  riscv_set_rvc (FALSE);
   if (riscv_subset_supports ("c"))
     riscv_set_rvc (TRUE);
   else
@@ -1837,6 +1860,7 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
   unsigned int subtype;
   bfd_byte *buf = (bfd_byte *) (fixP->fx_frag->fr_literal + fixP->fx_where);
   bfd_boolean relaxable = FALSE;
+  offsetT loc;
 
   /* Remember value for tc_gen_reloc.  */
   fixP->fx_addnumber = *valP;
@@ -1922,30 +1946,31 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
 
 	    case BFD_RELOC_RISCV_CFA:
 	      /* Load the byte to get the subtype.  */
-	      subtype = bfd_get_8 (NULL, &fixP->fx_frag->fr_literal[fixP->fx_where]);
+	      subtype = bfd_get_8 (NULL, &((fragS *) (fixP->fx_frag->fr_opcode))->fr_literal[fixP->fx_where]);
+	      loc = fixP->fx_frag->fr_fix - (subtype & 7);
 	      switch (subtype)
 		{
 		case DW_CFA_advance_loc1:
-		  fixP->fx_where++;
-		  fixP->fx_next->fx_where++;
+		  fixP->fx_where = loc + 1;
+		  fixP->fx_next->fx_where = loc + 1;
 		  fixP->fx_r_type = BFD_RELOC_RISCV_SET8;
 		  fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_SUB8;
 		  break;
 
 		case DW_CFA_advance_loc2:
 		  fixP->fx_size = 2;
-		  fixP->fx_where++;
 		  fixP->fx_next->fx_size = 2;
-		  fixP->fx_next->fx_where++;
+		  fixP->fx_where = loc + 1;
+		  fixP->fx_next->fx_where = loc + 1;
 		  fixP->fx_r_type = BFD_RELOC_RISCV_SET16;
 		  fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_SUB16;
 		  break;
 
 		case DW_CFA_advance_loc4:
 		  fixP->fx_size = 4;
-		  fixP->fx_where++;
 		  fixP->fx_next->fx_size = 4;
-		  fixP->fx_next->fx_where++;
+		  fixP->fx_where = loc;
+		  fixP->fx_next->fx_where = loc;
 		  fixP->fx_r_type = BFD_RELOC_RISCV_SET32;
 		  fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_SUB32;
 		  break;
@@ -1954,6 +1979,8 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
 		  if (subtype < 0x80 && (subtype & 0x40))
 		    {
 		      /* DW_CFA_advance_loc */
+		      fixP->fx_frag = (fragS *) fixP->fx_frag->fr_opcode;
+		      fixP->fx_next->fx_frag = fixP->fx_frag;
 		      fixP->fx_r_type = BFD_RELOC_RISCV_SET6;
 		      fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_SUB6;
 		    }
@@ -2063,13 +2090,12 @@ riscv_pre_output_hook (void)
   for (s = stdoutput->sections; s; s = s->next)
     for (frch = seg_info (s)->frchainP; frch; frch = frch->frch_next)
       {
-	const fragS *frag;
+	fragS *frag;
 
 	for (frag = frch->frch_root; frag; frag = frag->fr_next)
 	  {
 	    if (frag->fr_type == rs_cfa)
 	      {
-		fragS *loc4_frag;
 		expressionS exp;
 
 		symbolS *add_symbol = frag->fr_symbol->sy_value.X_add_symbol;
@@ -2080,8 +2106,7 @@ riscv_pre_output_hook (void)
 		exp.X_add_number = 0;
 		exp.X_op_symbol = op_symbol;
 
-		loc4_frag = (fragS *) frag->fr_opcode;
-		fix_new_exp (loc4_frag, (int) frag->fr_offset, 1, &exp, 0,
+		fix_new_exp (frag, (int) frag->fr_offset, 1, &exp, 0,
 			     BFD_RELOC_RISCV_CFA);
 	      }
 	  }
@@ -2455,15 +2480,10 @@ md_show_usage (FILE *stream)
 {
   fprintf (stream, _("\
 RISC-V options:\n\
-  -m32           assemble RV32 code\n\
-  -m64           assemble RV64 code (default)\n\
   -fpic          generate position-independent code\n\
   -fno-pic       don't generate position-independent code (default)\n\
-  -msoft-float   don't use F registers for floating-point values\n\
-  -mhard-float   use F registers for floating-point values (default)\n\
-  -mno-rvc       disable the C extension for compressed instructions (default)\n\
-  -mrvc          enable the C extension for compressed instructions\n\
-  -march=ISA     set the RISC-V architecture, RV64IMAFD by default\n\
+  -march=ISA     set the RISC-V architecture\n\
+  -mabi=ABI      set the RISC-V ABI\n\
 "));
 }
 
diff --git a/gas/config/tc-riscv.h b/gas/config/tc-riscv.h
index ae8d60eb21..e92b3879a9 100644
--- a/gas/config/tc-riscv.h
+++ b/gas/config/tc-riscv.h
@@ -112,4 +112,7 @@ extern int tc_riscv_regname_to_dw2regnum (char *);
 #define elf_tc_final_processing riscv_elf_final_processing
 extern void riscv_elf_final_processing (void);
 
+/* Adjust debug_line after relaxation.  */
+#define DWARF2_USE_FIXED_ADVANCE_PC 1
+
 #endif /* TC_RISCV */
diff --git a/gas/config/tc-s390.c b/gas/config/tc-s390.c
index 7c8087e009..dccbe2c945 100644
--- a/gas/config/tc-s390.c
+++ b/gas/config/tc-s390.c
@@ -291,7 +291,7 @@ s390_parse_cpu (const char *         arg,
     { STRING_COMMA_LEN ("z13"), STRING_COMMA_LEN ("arch11"),
       S390_INSTR_FLAG_HTM | S390_INSTR_FLAG_VX },
     { STRING_COMMA_LEN ("arch12"), STRING_COMMA_LEN (""),
-      S390_INSTR_FLAG_HTM | S390_INSTR_FLAG_VX | S390_INSTR_FLAG_VX2 }
+      S390_INSTR_FLAG_HTM | S390_INSTR_FLAG_VX }
   };
   static struct
   {
@@ -303,9 +303,7 @@ s390_parse_cpu (const char *         arg,
     { "htm",   S390_INSTR_FLAG_HTM, TRUE },
     { "nohtm", S390_INSTR_FLAG_HTM, FALSE },
     { "vx",    S390_INSTR_FLAG_VX, TRUE },
-    { "novx",  S390_INSTR_FLAG_VX, FALSE },
-    { "vx2",    S390_INSTR_FLAG_VX2, TRUE },
-    { "novx2",  S390_INSTR_FLAG_VX2, FALSE }
+    { "novx",  S390_INSTR_FLAG_VX, FALSE }
   };
   unsigned int icpu;
   char *ilp_bak;
diff --git a/gas/configure b/gas/configure
index ce7091e33b..e574cb8514 100755
--- a/gas/configure
+++ b/gas/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.64 for gas 2.28.
+# Generated by GNU Autoconf 2.64 for gas 2.28.0.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
@@ -556,8 +556,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='gas'
 PACKAGE_TARNAME='gas'
-PACKAGE_VERSION='2.28'
-PACKAGE_STRING='gas 2.28'
+PACKAGE_VERSION='2.28.0'
+PACKAGE_STRING='gas 2.28.0'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
@@ -1330,7 +1330,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures gas 2.28 to adapt to many kinds of systems.
+\`configure' configures gas 2.28.0 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1401,7 +1401,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of gas 2.28:";;
+     short | recursive ) echo "Configuration of gas 2.28.0:";;
    esac
   cat <<\_ACEOF
 
@@ -1523,7 +1523,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-gas configure 2.28
+gas configure 2.28.0
 generated by GNU Autoconf 2.64
 
 Copyright (C) 2009 Free Software Foundation, Inc.
@@ -1933,7 +1933,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by gas $as_me 2.28, which was
+It was created by gas $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   $ $0 $@
@@ -3742,7 +3742,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='gas'
- VERSION='2.28'
+ VERSION='2.28.0'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -15212,7 +15212,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by gas $as_me 2.28, which was
+This file was extended by gas $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -15276,7 +15276,7 @@ Report bugs to the package provider."
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-gas config.status 2.28
+gas config.status 2.28.0
 configured by $0, generated by GNU Autoconf 2.64,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
diff --git a/gas/doc/c-riscv.texi b/gas/doc/c-riscv.texi
index 0fa1b58356..2efba4b5cb 100644
--- a/gas/doc/c-riscv.texi
+++ b/gas/doc/c-riscv.texi
@@ -26,6 +26,14 @@ The following table lists all availiable RISC-V specific options
 @c man begin OPTIONS
 @table @gcctabopt
 
+@cindex @samp{-fpic} option, RISC-V
+@item -fpic
+Generate position-independent code
+
+@cindex @samp{-fno-pic} option, RISC-V
+@item -fno-pic
+Don't generate position-independent code (default)
+
 @cindex @samp{-march=ISA} option, RISC-V
 @item -march=ISA
 Select the base isa, as specified by ISA.  For example -march=rv32ima.
diff --git a/gas/testsuite/gas/arm/armv8-a+fp.d b/gas/testsuite/gas/arm/armv8-a+fp.d
index f77e742adc..5a2c95ab3f 100644
--- a/gas/testsuite/gas/arm/armv8-a+fp.d
+++ b/gas/testsuite/gas/arm/armv8-a+fp.d
@@ -113,3 +113,7 @@ Disassembly of section .text:
 0[0-9a-f]+ <[^>]+> eef2 0b60 	vcvtb.f64.f16	d16, s1
 0[0-9a-f]+ <[^>]+> eeb2 fbcf 	vcvtt.f64.f16	d15, s30
 0[0-9a-f]+ <[^>]+> eef2 fb6f 	vcvtb.f64.f16	d31, s31
+0[0-9a-f]+ <[^>]+> eef5 9a10 	vmrs	r9, mvfr2
+0[0-9a-f]+ <[^>]+> eee5 7a10 	vmsr	mvfr2, r7
+0[0-9a-f]+ <[^>]+> eef5 4a10 	vmrs	r4, mvfr2
+0[0-9a-f]+ <[^>]+> eee5 5a10 	vmsr	mvfr2, r5
\ No newline at end of file
diff --git a/gas/testsuite/gas/arm/armv8-a+fp.s b/gas/testsuite/gas/arm/armv8-a+fp.s
index f7a54736a1..b98aab7b9a 100644
--- a/gas/testsuite/gas/arm/armv8-a+fp.s
+++ b/gas/testsuite/gas/arm/armv8-a+fp.s
@@ -114,3 +114,8 @@
 	vcvtb.f64.f16	d16, s1
 	vcvtt.f64.f16	d15, s30
 	vcvtb.f64.f16	d31, s31
+	vmrs		r9, MVFR2
+	vmsr		MVFR2, r7
+	vmrs		r4, mvfr2
+	vmsr		mvfr2, r5
+
diff --git a/gas/testsuite/gas/arm/thumb2_ldr_immediate_highregs_armv6t2.d b/gas/testsuite/gas/arm/thumb2_ldr_immediate_highregs_armv6t2.d
index 55b5f17887..7afc1350e5 100644
--- a/gas/testsuite/gas/arm/thumb2_ldr_immediate_highregs_armv6t2.d
+++ b/gas/testsuite/gas/arm/thumb2_ldr_immediate_highregs_armv6t2.d
@@ -6,19 +6,23 @@
 .*: +file format .*arm.*
 
 Disassembly of section \.text:
-0[0-9a-f]+ <[^>]+> 2000[[:space:]]+movs[[:space:]]+r0, #0.*
-0[0-9a-f]+ <[^>]+> 2108[[:space:]]+movs[[:space:]]+r1, #8.*
-0[0-9a-f]+ <[^>]+> 2251[[:space:]]+movs[[:space:]]+r2, #81.*
-0[0-9a-f]+ <[^>]+> 231f[[:space:]]+movs[[:space:]]+r3, #31.*
-0[0-9a-f]+ <[^>]+> 242f[[:space:]]+movs[[:space:]]+r4, #47.*
-0[0-9a-f]+ <[^>]+> 253f[[:space:]]+movs[[:space:]]+r5, #63.*
-0[0-9a-f]+ <[^>]+> 2680[[:space:]]+movs[[:space:]]+r6, #128.*
-0[0-9a-f]+ <[^>]+> 27ff[[:space:]]+movs[[:space:]]+r7, #255.*
+0[0-9a-f]+ <[^>]+> f04f 0000[[:space:]]+mov\.w[[:space:]]+r0, #0.*
+0[0-9a-f]+ <[^>]+> f04f 0108[[:space:]]+mov\.w[[:space:]]+r1, #8.*
+0[0-9a-f]+ <[^>]+> f04f 0251[[:space:]]+mov\.w[[:space:]]+r2, #81.*
+0[0-9a-f]+ <[^>]+> f04f 031f[[:space:]]+mov\.w[[:space:]]+r3, #31.*
+0[0-9a-f]+ <[^>]+> f04f 042f[[:space:]]+mov\.w[[:space:]]+r4, #47.*
+0[0-9a-f]+ <[^>]+> f04f 053f[[:space:]]+mov\.w[[:space:]]+r5, #63.*
+0[0-9a-f]+ <[^>]+> f04f 0680[[:space:]]+mov\.w[[:space:]]+r6, #128.*
+0[0-9a-f]+ <[^>]+> f04f 07ff[[:space:]]+mov\.w[[:space:]]+r7, #255.*
 0[0-9a-f]+ <[^>]+> f04f 0800[[:space:]]+mov\.w[[:space:]]+r8, #0.*
 0[0-9a-f]+ <[^>]+> f04f 0908[[:space:]]+mov\.w[[:space:]]+r9, #8.*
 0[0-9a-f]+ <[^>]+> f04f 0a51[[:space:]]+mov\.w[[:space:]]+sl, #81.*
 0[0-9a-f]+ <[^>]+> f04f 0b1f[[:space:]]+mov\.w[[:space:]]+fp, #31.*
 0[0-9a-f]+ <[^>]+> f04f 0c2f[[:space:]]+mov\.w[[:space:]]+ip, #47.*
-0[0-9a-f]+ <[^>]+> f04f 0d3f[[:space:]]+mov\.w[[:space:]]+sp, #63.*
 0[0-9a-f]+ <[^>]+> f04f 0e80[[:space:]]+mov\.w[[:space:]]+lr, #128.*
-0[0-9a-f]+ <[^>]+> f04f 0fff[[:space:]]+mov\.w[[:space:]]+pc, #255.*
+0[0-9a-f]+ <[^>]+> f64f 78ff[[:space:]]+movw[[:space:]]+r8, #65535.*
+0[0-9a-f]+ <[^>]+> f24f 09f0[[:space:]]+movw[[:space:]]+r9, #61680.*
+0[0-9a-f]+ <[^>]+> f8df d004[[:space:]]+ldr\.w[[:space:]]+sp, \[pc, #4\].*
+0[0-9a-f]+ <[^>]+> f8df f004[[:space:]]+ldr\.w[[:space:]]+pc, \[pc, #4\].*
+0[0-9a-f]+ <[^>]+> 0000003f[[:space:]]+.word[[:space:]]+0x0000003f.*
+0[0-9a-f]+ <[^>]+> 000000ff[[:space:]]+.word[[:space:]]+0x000000ff.*
diff --git a/gas/testsuite/gas/arm/thumb2_ldr_immediate_highregs_armv6t2.s b/gas/testsuite/gas/arm/thumb2_ldr_immediate_highregs_armv6t2.s
index d225410186..b473857223 100644
--- a/gas/testsuite/gas/arm/thumb2_ldr_immediate_highregs_armv6t2.s
+++ b/gas/testsuite/gas/arm/thumb2_ldr_immediate_highregs_armv6t2.s
@@ -2,8 +2,8 @@
 	.syntax unified
 	.thumb_func
 thumb2_ldr:
-	# These can be encoded into movs since constant is small
-	# And register can be encoded in 3 bits
+	# These must be encoded into mov.w despite constant and register being
+	# small enough as ldr should not generate a flag-setting instruction.
 	ldr r0,=0x00
 	ldr r1,=0x08
 	ldr r2,=0x51
@@ -12,13 +12,19 @@ thumb2_ldr:
 	ldr r5,=0x3F
 	ldr r6,=0x80
 	ldr r7,=0xFF
-	# These shall be encoded into mov.w
-	# Since register cannot be encoded in 3 bits
+	# These shall be encoded into mov.w since register cannot be encoded in
+	# 3 bits
 	ldr r8,=0x00
 	ldr r9,=0x08
 	ldr r10,=0x51
 	ldr r11,=0x1F
 	ldr r12,=0x2F
-	ldr r13,=0x3F
 	ldr r14,=0x80
+	# These shall be encoded into movw since immediate cannot be encoded
+	# with mov.w
+	ldr r8,=0xFFFF
+	ldr r9,=0xF0F0
+	# These should be encoded as ldr since mov immediate is unpredictable
+	# for sp and pc
+	ldr r13,=0x3F
 	ldr r15,=0xFF
diff --git a/gas/testsuite/gas/arm/vfp-bad.l b/gas/testsuite/gas/arm/vfp-bad.l
index 7726e63180..a1479f484f 100644
--- a/gas/testsuite/gas/arm/vfp-bad.l
+++ b/gas/testsuite/gas/arm/vfp-bad.l
@@ -7,3 +7,5 @@
 [^:]*:9: Error: instruction does not support writeback -- `fldd d0,\[r0,#-8\]!'
 [^:]*:10: Error: instruction does not support writeback -- `flds s0,\[r0\],#8'
 [^:]*:11: Error: instruction does not support writeback -- `flds s0,\[r0,#-8\]!'
+[^:]*:12: Error: selected FPU does not support instruction -- `vmrs r0,MVFR2'
+[^:]*:13: Error: selected FPU does not support instruction -- `vmsr MVFR2,r2'
diff --git a/gas/testsuite/gas/arm/vfp-bad.s b/gas/testsuite/gas/arm/vfp-bad.s
index ac44371773..1a446fee93 100644
--- a/gas/testsuite/gas/arm/vfp-bad.s
+++ b/gas/testsuite/gas/arm/vfp-bad.s
@@ -9,3 +9,5 @@ entry:
 	fldd	d0, [r0, #-8]!
 	flds	s0, [r0], #8
 	flds	s0, [r0, #-8]!
+	vmrs	r0, MVFR2
+	vmsr	MVFR2, r2
diff --git a/gas/testsuite/gas/ppc/altivec2.d b/gas/testsuite/gas/ppc/altivec2.d
index fc10fb5a2e..26f9afa9a8 100644
--- a/gas/testsuite/gas/ppc/altivec2.d
+++ b/gas/testsuite/gas/ppc/altivec2.d
@@ -1,5 +1,5 @@
-#as: -maltivec
-#objdump: -dr -Maltivec
+#as: -mpower8
+#objdump: -dr -Mpower8
 #name: Altivec ISA 2.07 instructions
 
 .*
diff --git a/gas/testsuite/gas/ppc/power9.d b/gas/testsuite/gas/ppc/power9.d
index 9ba53d0679..a67898ff3a 100644
--- a/gas/testsuite/gas/ppc/power9.d
+++ b/gas/testsuite/gas/ppc/power9.d
@@ -312,8 +312,9 @@ Disassembly of section \.text:
 .*:	(f1 31 9d 6f|6f 9d 31 f1) 	xscvdphp vs41,vs51
 .*:	(f1 58 a7 6f|6f a7 58 f1) 	xvcvhpsp vs42,vs52
 .*:	(f1 79 af 6f|6f af 79 f1) 	xvcvsphp vs43,vs53
-.*:	(4c 60 00 04|04 00 60 4c) 	addpcis r3,0
-.*:	(4c 60 00 04|04 00 60 4c) 	addpcis r3,0
+.*:	(4c 60 00 04|04 00 60 4c) 	lnia    r3
+.*:	(4c 60 00 04|04 00 60 4c) 	lnia    r3
+.*:	(4c 60 00 04|04 00 60 4c) 	lnia    r3
 .*:	(4c 80 00 05|05 00 80 4c) 	addpcis r4,1
 .*:	(4c 80 00 05|05 00 80 4c) 	addpcis r4,1
 .*:	(4c bf ff c4|c4 ff bf 4c) 	addpcis r5,-2
diff --git a/gas/testsuite/gas/ppc/power9.s b/gas/testsuite/gas/ppc/power9.s
index 27f1122018..4e3530fba9 100644
--- a/gas/testsuite/gas/ppc/power9.s
+++ b/gas/testsuite/gas/ppc/power9.s
@@ -303,6 +303,7 @@ power9:
 	xscvdphp    41,51
 	xvcvhpsp    42,52
 	xvcvsphp    43,53
+	lnia        3
 	addpcis     3,0
 	subpcis     3,0
 	addpcis     4,1
diff --git a/gas/testsuite/gas/ppc/ppc.exp b/gas/testsuite/gas/ppc/ppc.exp
index 86db4553df..55367adc08 100644
--- a/gas/testsuite/gas/ppc/ppc.exp
+++ b/gas/testsuite/gas/ppc/ppc.exp
@@ -50,6 +50,7 @@ if { [istarget powerpc*-*-*] } then {
 	run_dump_test "common"
 	run_dump_test "476"
 	run_dump_test "a2"
+	run_dump_test "pr21303"
 	if { ![istarget powerpc*le-*-*] } then {
 	    run_dump_test "vle"
 	    run_dump_test "vle-reloc"
diff --git a/gas/testsuite/gas/ppc/pr21303.d b/gas/testsuite/gas/ppc/pr21303.d
new file mode 100644
index 0000000000..64761a4d5d
--- /dev/null
+++ b/gas/testsuite/gas/ppc/pr21303.d
@@ -0,0 +1,12 @@
+#objdump: -d -Me200z4
+#as: -a32 -mbig -me200z4
+
+.*
+
+Disassembly of section \.text:
+
+0+ <\.text>:
+   0:	70 00 00 00 	e_li    r0,0
+   4:	7c 01 14 04 	lbdcbx  r0,r1,r2
+   8:	7c 01 14 44 	lhdcbx  r0,r1,r2
+   c:	7c 01 14 84 	lwdcbx  r0,r1,r2
diff --git a/gas/testsuite/gas/ppc/pr21303.s b/gas/testsuite/gas/ppc/pr21303.s
new file mode 100644
index 0000000000..890ba94b08
--- /dev/null
+++ b/gas/testsuite/gas/ppc/pr21303.s
@@ -0,0 +1,5 @@
+ .text
+ e_li 0, 0
+ lbdcbx 0, 1, 2
+ lhdcbx 0, 1, 2
+ lwdcbx 0, 1, 2
diff --git a/gold/ChangeLog b/gold/ChangeLog
index d598386fd7..d27713d404 100644
--- a/gold/ChangeLog
+++ b/gold/ChangeLog
@@ -1,3 +1,90 @@
+2017-07-06  Han Shen  <shenhan@google.com>
+
+	PR gold/21491
+	* aarch64.cc (Erratum_stub::invalidate_erratum_stub): New method.
+	(Erratum_stub::is_invalidated_erratum_stub): New method.
+	(Stub_table::relocate_reloc_stub): Renamed from "relocate_stub".
+	(Stub_table::relocate_reloc_stubs): Renamed from "relocate_stubs".
+	(Stub_table::relocate_erratum_stub): New method.
+	(AArch64_relobj::fix_errata_and_relocate_erratum_stubs): Renamed from
+	"fix_errata".
+	(Target_aarch64::relocate_reloc_stub): Renamed from "relocate_stub".
+
+2017-06-21  Eric Christopher  <echristo@gmail.com>
+
+	Apply from master
+        2017-06-20  Eric Christopher  <echristo@gmail.com>
+
+	* aarch64.cc (scan_reloc_for_stub): Use plt_address_for_global to
+	calculate the symbol value.
+	(scan_reloc_section_for_stubs): Allow stubs to be created for
+	section symbols.
+	(maybe_apply_stub): Handle creating stubs for weak symbols to
+	match the code in scan_reloc_for_stub.
+
+2017-06-21  Eric Christopher  <echristo@gmail.com>
+
+	Apply from master
+        2017-06-15  Eric Christopher  <echristo@gmail.com>
+
+	* aarch64.cc: Fix a few typos and grammar-os.
+
+2017-06-21  Eric Christopher  <echristo@gmail.com>
+
+	Apply from master
+        2017-06-07  Eric Christopher  <echristo@gmail.com>
+
+	* aarch64.cc (maybe_apply_stub): Add debug logging for looking
+	up stubs to undefined symbols and early return rather than
+	fail to look them up.
+	(scan_reloc_for_stub): Add debug logging for no stub creation
+	for undefined symbols.
+
+2017-06-21  Eric Christopher  <echristo@gmail.com>
+
+	Apply from master
+	2017-05-15  Eric Christopher <echristo@gmail.com>
+
+        * layout.cc (Layout::segment_precedes): Add a case for testing
+        pointer equality when determining which segment precedes
+        another.
+
+2017-06-20  James Clarke  <jrtc27@jrtc27.com>
+
+	* powerpc.cc (Stub_table::define_stub_syms): Always include object's
+	uniq_ value.
+
+2017-06-03  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-05-23  Alan Modra  <amodra@gmail.com>
+	PR 21503
+	* options.h: Add --emit-stub-syms option.
+	* powerpc.cc (object_id): New.
+	(Powerpc_relobj): Add uniq_ and accessor.  Sort variables for
+	better packing.
+	(Powerpc_dynobj): Sort variables for better packing.
+	(Target_powerpc::define_local): New function.
+	(Target_powerpc::group_sections): Pass stub table size to
+	Stub_table constructor.
+	(Target_powerpc::do_relax): Define stub and glink symbols.
+	(Stub_table): Add uniq_ variable, and id param to constructor.
+	(Stub_table::Plt_stub_ent): Add indx_ variable.
+	(Stub_table::Branch_stub_entries): Move typedef earlier.
+	(Stub_table::branch_stub_size): Replace "to" parameter with a
+	Branch_stub_entries iterator.
+	(Stub_table::add_long_branch_entry): Adjust to suit.
+	(Stub_table::add_plt_call_entry): Set indx_.
+	(Stub_table::define_stub_syms): New function.
+
+2017-05-13  James Clarke  <jrtc27@jrtc27.com>
+
+	PR gold/21444
+	* gold.cc (Target_sparc::Relocate::relocate_tls): Local
+	variables are final for position-independent executables. This
+	has to be consistent with Target_sparc::Scan::local otherwise
+	they will disagree as to whether local-exec is used.
+
 2017-02-22  Alan Modra  <amodra@gmail.com>
 
 	* powerpc.cc (Target_powerpc::make_iplt_section): Check that
diff --git a/gold/aarch64.cc b/gold/aarch64.cc
index b207dcdc3d..a37076b58e 100644
--- a/gold/aarch64.cc
+++ b/gold/aarch64.cc
@@ -920,7 +920,7 @@ private:
 
 // Erratum stub class. An erratum stub differs from a reloc stub in that for
 // each erratum occurrence, we generate an erratum stub. We never share erratum
-// stubs, whereas for reloc stubs, different branches insns share a single reloc
+// stubs, whereas for reloc stubs, different branch insns share a single reloc
 // stub as long as the branch targets are the same. (More to the point, reloc
 // stubs can be shared because they're used to reach a specific target, whereas
 // erratum stubs branch back to the original control flow.)
@@ -1039,6 +1039,17 @@ public:
     return this->sh_offset_ < k.sh_offset_;
   }
 
+  void
+  invalidate_erratum_stub()
+  {
+     gold_assert(this->relobj_ != NULL);
+     this->relobj_ = NULL;
+  }
+
+  bool
+  is_invalidated_erratum_stub()
+  { return this->relobj_ == NULL; }
+
 protected:
   virtual void
   do_write(unsigned char*, section_size_type);
@@ -1336,7 +1347,8 @@ Reloc_stub<size, big_endian>::stub_type_for_reloc(
   return ST_LONG_BRANCH_ABS;
 }
 
-// A class to hold stubs for the ARM target.
+// A class to hold stubs for the ARM target. This contains 2 different types of
+// stubs - reloc stubs and erratum stubs.
 
 template<int size, bool big_endian>
 class Stub_table : public Output_data
@@ -1428,14 +1440,18 @@ class Stub_table : public Output_data
     return (p != this->reloc_stubs_.end()) ? p->second : NULL;
   }
 
-  // Relocate stubs in this stub table.
+  // Relocate reloc stubs in this stub table. This does not relocate erratum stubs.
   void
-  relocate_stubs(const The_relocate_info*,
-		 The_target_aarch64*,
-		 Output_section*,
-		 unsigned char*,
-		 AArch64_address,
-		 section_size_type);
+  relocate_reloc_stubs(const The_relocate_info*,
+                       The_target_aarch64*,
+                       Output_section*,
+                       unsigned char*,
+                       AArch64_address,
+                       section_size_type);
+
+  // Relocate an erratum stub.
+  void
+  relocate_erratum_stub(The_erratum_stub*, unsigned char*);
 
   // Update data size at the end of a relaxation pass.  Return true if data size
   // is different from that of the previous relaxation pass.
@@ -1475,15 +1491,15 @@ class Stub_table : public Output_data
   { this->set_data_size(this->current_data_size()); }
 
  private:
-  // Relocate one stub.
+  // Relocate one reloc stub.
   void
-  relocate_stub(The_reloc_stub*,
-		const The_relocate_info*,
-		The_target_aarch64*,
-		Output_section*,
-		unsigned char*,
-		AArch64_address,
-		section_size_type);
+  relocate_reloc_stub(The_reloc_stub*,
+                      const The_relocate_info*,
+                      The_target_aarch64*,
+                      Output_section*,
+                      unsigned char*,
+                      AArch64_address,
+                      section_size_type);
 
  private:
   // Owner of this stub table.
@@ -1583,76 +1599,85 @@ Stub_table<size, big_endian>::add_reloc_stub(
 }
 
 
-// Relocate all stubs in this stub table.
+// Relocate an erratum stub.
 
 template<int size, bool big_endian>
 void
 Stub_table<size, big_endian>::
-relocate_stubs(const The_relocate_info* relinfo,
-	       The_target_aarch64* target_aarch64,
-	       Output_section* output_section,
-	       unsigned char* view,
-	       AArch64_address address,
-	       section_size_type view_size)
+relocate_erratum_stub(The_erratum_stub* estub,
+                      unsigned char* view)
 {
-  // "view_size" is the total size of the stub_table.
-  gold_assert(address == this->address() &&
-	      view_size == static_cast<section_size_type>(this->data_size()));
-  for(Reloc_stub_map_const_iter p = this->reloc_stubs_.begin();
-      p != this->reloc_stubs_.end(); ++p)
-    relocate_stub(p->second, relinfo, target_aarch64, output_section,
-		  view, address, view_size);
-
   // Just for convenience.
   const int BPI = AArch64_insn_utilities<big_endian>::BYTES_PER_INSN;
 
-  // Now 'relocate' erratum stubs.
-  for(Erratum_stub_set_iter i = this->erratum_stubs_.begin();
-      i != this->erratum_stubs_.end(); ++i)
+  gold_assert(!estub->is_invalidated_erratum_stub());
+  AArch64_address stub_address = this->erratum_stub_address(estub);
+  // The address of "b" in the stub that is to be "relocated".
+  AArch64_address stub_b_insn_address;
+  // Branch offset that is to be filled in "b" insn.
+  int b_offset = 0;
+  switch (estub->type())
     {
-      AArch64_address stub_address = this->erratum_stub_address(*i);
-      // The address of "b" in the stub that is to be "relocated".
-      AArch64_address stub_b_insn_address;
-      // Branch offset that is to be filled in "b" insn.
-      int b_offset = 0;
-      switch ((*i)->type())
-	{
-	case ST_E_843419:
-	case ST_E_835769:
-	  // The 1st insn of the erratum could be a relocation spot,
-	  // in this case we need to fix it with
-	  // "(*i)->erratum_insn()".
-	  elfcpp::Swap<32, big_endian>::writeval(
-	      view + (stub_address - this->address()),
-	      (*i)->erratum_insn());
-	  // For the erratum, the 2nd insn is a b-insn to be patched
-	  // (relocated).
-	  stub_b_insn_address = stub_address + 1 * BPI;
-	  b_offset = (*i)->destination_address() - stub_b_insn_address;
-	  AArch64_relocate_functions<size, big_endian>::construct_b(
-	      view + (stub_b_insn_address - this->address()),
-	      ((unsigned int)(b_offset)) & 0xfffffff);
-	  break;
-	default:
-	  gold_unreachable();
-	  break;
-	}
+    case ST_E_843419:
+    case ST_E_835769:
+      // The 1st insn of the erratum could be a relocation spot,
+      // in this case we need to fix it with
+      // "(*i)->erratum_insn()".
+      elfcpp::Swap<32, big_endian>::writeval(
+          view + (stub_address - this->address()),
+          estub->erratum_insn());
+      // For the erratum, the 2nd insn is a b-insn to be patched
+      // (relocated).
+      stub_b_insn_address = stub_address + 1 * BPI;
+      b_offset = estub->destination_address() - stub_b_insn_address;
+      AArch64_relocate_functions<size, big_endian>::construct_b(
+          view + (stub_b_insn_address - this->address()),
+          ((unsigned int)(b_offset)) & 0xfffffff);
+      break;
+    default:
+      gold_unreachable();
+      break;
     }
+  estub->invalidate_erratum_stub();
 }
 
 
-// Relocate one stub.  This is a helper for Stub_table::relocate_stubs().
+// Relocate only reloc stubs in this stub table. This does not relocate erratum
+// stubs.
 
 template<int size, bool big_endian>
 void
 Stub_table<size, big_endian>::
-relocate_stub(The_reloc_stub* stub,
-	      const The_relocate_info* relinfo,
-	      The_target_aarch64* target_aarch64,
-	      Output_section* output_section,
-	      unsigned char* view,
-	      AArch64_address address,
-	      section_size_type view_size)
+relocate_reloc_stubs(const The_relocate_info* relinfo,
+                     The_target_aarch64* target_aarch64,
+                     Output_section* output_section,
+                     unsigned char* view,
+                     AArch64_address address,
+                     section_size_type view_size)
+{
+  // "view_size" is the total size of the stub_table.
+  gold_assert(address == this->address() &&
+	      view_size == static_cast<section_size_type>(this->data_size()));
+  for(Reloc_stub_map_const_iter p = this->reloc_stubs_.begin();
+      p != this->reloc_stubs_.end(); ++p)
+    relocate_reloc_stub(p->second, relinfo, target_aarch64, output_section,
+                        view, address, view_size);
+}
+
+
+// Relocate one reloc stub. This is a helper for
+// Stub_table::relocate_reloc_stubs().
+
+template<int size, bool big_endian>
+void
+Stub_table<size, big_endian>::
+relocate_reloc_stub(The_reloc_stub* stub,
+                    const The_relocate_info* relinfo,
+                    The_target_aarch64* target_aarch64,
+                    Output_section* output_section,
+                    unsigned char* view,
+                    AArch64_address address,
+                    section_size_type view_size)
 {
   // "offset" is the offset from the beginning of the stub_table.
   section_size_type offset = stub->offset();
@@ -1660,8 +1685,8 @@ relocate_stub(The_reloc_stub* stub,
   // "view_size" is the total size of the stub_table.
   gold_assert(offset + stub_size <= view_size);
 
-  target_aarch64->relocate_stub(stub, relinfo, output_section,
-				view + offset, address + offset, view_size);
+  target_aarch64->relocate_reloc_stub(stub, relinfo, output_section,
+                                      view + offset, address + offset, view_size);
 }
 
 
@@ -1818,9 +1843,11 @@ class AArch64_relobj : public Sized_relobj_file<size, big_endian>
 			 Stringpool_template<char>*);
 
  private:
-  // Fix all errata in the object.
+  // Fix all errata in the object, and for each erratum, relocate corresponding
+  // erratum stub.
   void
-  fix_errata(typename Sized_relobj_file<size, big_endian>::Views* pviews);
+  fix_errata_and_relocate_erratum_stubs(
+      typename Sized_relobj_file<size, big_endian>::Views* pviews);
 
   // Try to fix erratum 843419 in an optimized way. Return true if patch is
   // applied.
@@ -1932,11 +1959,12 @@ AArch64_relobj<size, big_endian>::do_count_local_symbols(
 }
 
 
-// Fix all errata in the object.
+// Fix all errata in the object and for each erratum, we relocate the
+// corresponding erratum stub (by calling Stub_table::relocate_erratum_stub).
 
 template<int size, bool big_endian>
 void
-AArch64_relobj<size, big_endian>::fix_errata(
+AArch64_relobj<size, big_endian>::fix_errata_and_relocate_erratum_stubs(
     typename Sized_relobj_file<size, big_endian>::Views* pviews)
 {
   typedef typename elfcpp::Swap<32,big_endian>::Valtype Insntype;
@@ -1977,6 +2005,17 @@ AArch64_relobj<size, big_endian>::fix_errata(
 	      AArch64_relocate_functions<size, big_endian>::construct_b(
 		pview.view + stub->sh_offset(), b_offset & 0xfffffff);
 	    }
+
+          // Erratum fix is done (or skipped), continue to relocate erratum
+          // stub. Note, when erratum fix is skipped (either because we
+          // proactively change the code sequence or the code sequence is
+          // changed by relaxation, etc), we can still safely relocate the
+          // erratum stub, ignoring the fact the erratum could never be
+          // executed.
+          stub_table->relocate_erratum_stub(
+              stub, pview.view + (stub_table->address() - pview.address));
+
+          // Next erratum stub.
 	  ++p;
 	}
     }
@@ -2052,16 +2091,19 @@ AArch64_relobj<size, big_endian>::do_relocate_sections(
   if (parameters->options().relocatable())
     return;
 
+  // This part only relocates erratum stubs that belong to input sections of this
+  // object file.
   if (parameters->options().fix_cortex_a53_843419()
       || parameters->options().fix_cortex_a53_835769())
-    this->fix_errata(pviews);
+    this->fix_errata_and_relocate_erratum_stubs(pviews);
 
   Relocate_info<size, big_endian> relinfo;
   relinfo.symtab = symtab;
   relinfo.layout = layout;
   relinfo.object = this;
 
-  // Relocate stub tables.
+  // This part relocates all reloc stubs that are contained in stub_tables of
+  // this object file.
   unsigned int shnum = this->shnum();
   The_target_aarch64* target = The_target_aarch64::current_target();
 
@@ -2090,8 +2132,8 @@ AArch64_relobj<size, big_endian>::do_relocate_sections(
 	  unsigned char* view = view_struct.view + offset;
 	  AArch64_address address = stub_table->address();
 	  section_size_type view_size = stub_table->data_size();
-	  stub_table->relocate_stubs(&relinfo, target, os, view, address,
-				     view_size);
+	  stub_table->relocate_reloc_stubs(&relinfo, target, os, view, address,
+					   view_size);
 	}
     }
 }
@@ -2982,11 +3024,11 @@ class Target_aarch64 : public Sized_target<size, big_endian>
       Address view_address,
       section_size_type);
 
-  // Relocate a single stub.
+  // Relocate a single reloc stub.
   void
-  relocate_stub(The_reloc_stub*, const Relocate_info<size, big_endian>*,
-		Output_section*, unsigned char*, Address,
-		section_size_type);
+  relocate_reloc_stub(The_reloc_stub*, const Relocate_info<size, big_endian>*,
+                      Output_section*, unsigned char*, Address,
+                      section_size_type);
 
   // Get the default AArch64 target.
   static This*
@@ -3734,13 +3776,18 @@ Target_aarch64<size, big_endian>::scan_reloc_for_stub(
       if (gsym->use_plt_offset(arp->reference_flags()))
 	{
 	  // This uses a PLT, change the symbol value.
-	  symval.set_output_value(this->plt_section()->address()
-				  + gsym->plt_offset());
+	  symval.set_output_value(this->plt_address_for_global(gsym));
 	  psymval = &symval;
 	}
       else if (gsym->is_undefined())
-	// There is no need to generate a stub symbol is undefined.
-	return;
+	{
+          // There is no need to generate a stub symbol if the original symbol
+          // is undefined.
+          gold_debug(DEBUG_TARGET,
+                     "stub: not creating a stub for undefined symbol %s in file %s",
+                     gsym->name(), aarch64_relobj->name().c_str());
+          return;
+	}
     }
 
   // Get the symbol value.
@@ -3962,11 +4009,6 @@ Target_aarch64<size, big_endian>::scan_reloc_section_for_stubs(
 	  psymval = &symval2;
 	}
 
-      // If symbol is a section symbol, we don't know the actual type of
-      // destination.  Give up.
-      if (psymval->is_section_symbol())
-	continue;
-
       this->scan_reloc_for_stub(relinfo, r_type, sym, r_sym, psymval,
 				addend, view_address + offset);
     }  // End of iterating relocs in a section
@@ -4001,16 +4043,16 @@ Target_aarch64<size, big_endian>::scan_section_for_stubs(
 }
 
 
-// Relocate a single stub.
+// Relocate a single reloc stub.
 
 template<int size, bool big_endian>
 void Target_aarch64<size, big_endian>::
-relocate_stub(The_reloc_stub* stub,
-	      const The_relocate_info*,
-	      Output_section*,
-	      unsigned char* view,
-	      Address address,
-	      section_size_type)
+relocate_reloc_stub(The_reloc_stub* stub,
+                    const The_relocate_info*,
+                    Output_section*,
+                    unsigned char* view,
+                    Address address,
+                    section_size_type)
 {
   typedef AArch64_relocate_functions<size, big_endian> The_reloc_functions;
   typedef typename The_reloc_functions::Status The_reloc_functions_status;
@@ -5398,6 +5440,21 @@ maybe_apply_stub(unsigned int r_type,
 
   const The_aarch64_relobj* aarch64_relobj =
       static_cast<const The_aarch64_relobj*>(object);
+  const AArch64_reloc_property* arp =
+    aarch64_reloc_property_table->get_reloc_property(r_type);
+  gold_assert(arp != NULL);
+
+  // We don't create stubs for undefined symbols, but do for weak.
+  if (gsym
+      && !gsym->use_plt_offset(arp->reference_flags())
+      && gsym->is_undefined())
+    {
+      gold_debug(DEBUG_TARGET,
+		 "stub: looking for a stub for undefined symbol %s in file %s",
+		 gsym->name(), aarch64_relobj->name().c_str());
+      return false;
+    }
+
   The_stub_table* stub_table = aarch64_relobj->stub_table(relinfo->data_shndx);
   gold_assert(stub_table != NULL);
 
@@ -5409,9 +5466,6 @@ maybe_apply_stub(unsigned int r_type,
   Address new_branch_target = stub_table->address() + stub->offset();
   typename elfcpp::Swap<size, big_endian>::Valtype branch_offset =
       new_branch_target - address;
-  const AArch64_reloc_property* arp =
-      aarch64_reloc_property_table->get_reloc_property(r_type);
-  gold_assert(arp != NULL);
   typename This::Status status = This::template
       rela_general<32>(view, branch_offset, 0, arp);
   if (status != This::STATUS_OKAY)
@@ -7688,8 +7742,8 @@ Target_aarch64<size, big_endian>::Relocate::tls_ld_to_le(
     {
       // Ideally we should give up gd_to_le relaxation and do gd access.
       // However the gd_to_le relaxation decision has been made early
-      // in the scan stage, where we did not allocate any GOT entry for
-      // this symbol. Therefore we have to exit and report error now.
+      // in the scan stage, where we did not allocate a GOT entry for
+      // this symbol. Therefore we have to exit and report an error now.
       gold_error(_("unexpected reloc insn sequence while relaxing "
 		   "tls gd to le for reloc %u."), r_type);
       return aarch64_reloc_funcs::STATUS_BAD_RELOC;
diff --git a/gold/layout.cc b/gold/layout.cc
index 07a359074e..bb13d7136e 100644
--- a/gold/layout.cc
+++ b/gold/layout.cc
@@ -3300,6 +3300,11 @@ bool
 Layout::segment_precedes(const Output_segment* seg1,
 			 const Output_segment* seg2)
 {
+  // In order to produce a stable ordering if we're called with the same pointer
+  // return false.
+  if (seg1 == seg2)
+    return false;
+
   elfcpp::Elf_Word type1 = seg1->type();
   elfcpp::Elf_Word type2 = seg2->type();
 
diff --git a/gold/options.h b/gold/options.h
index a8b1d46aa1..202d4b0e8d 100644
--- a/gold/options.h
+++ b/gold/options.h
@@ -814,6 +814,10 @@ class General_options
 
   // e
 
+  DEFINE_bool(emit_stub_syms, options::TWO_DASHES, '\0', true,
+	      N_("(PowerPC only) Label linker stubs with a symbol"),
+	      N_("(PowerPC only) Do not label linker stubs with a symbol"));
+
   DEFINE_string(entry, options::TWO_DASHES, 'e', NULL,
 		N_("Set program start address"), N_("ADDRESS"));
 
diff --git a/gold/powerpc.cc b/gold/powerpc.cc
index 1477a10d67..a448efbc94 100644
--- a/gold/powerpc.cc
+++ b/gold/powerpc.cc
@@ -81,6 +81,9 @@ struct Stub_table_owner
 inline bool
 is_branch_reloc(unsigned int r_type);
 
+// Counter incremented on every Powerpc_relobj constructed.
+static uint32_t object_id = 0;
+
 template<int size, bool big_endian>
 class Powerpc_relobj : public Sized_relobj_file<size, big_endian>
 {
@@ -92,10 +95,10 @@ public:
   Powerpc_relobj(const std::string& name, Input_file* input_file, off_t offset,
 		 const typename elfcpp::Ehdr<size, big_endian>& ehdr)
     : Sized_relobj_file<size, big_endian>(name, input_file, offset, ehdr),
-      special_(0), relatoc_(0), toc_(0), no_toc_opt_(),
-      has_small_toc_reloc_(false), opd_valid_(false), opd_ent_(),
-      access_from_map_(), has14_(), stub_table_index_(),
-      e_flags_(ehdr.get_e_flags()), st_other_()
+      uniq_(object_id++), special_(0), relatoc_(0), toc_(0),
+      has_small_toc_reloc_(false), opd_valid_(false),
+      e_flags_(ehdr.get_e_flags()), no_toc_opt_(), opd_ent_(),
+      access_from_map_(), has14_(), stub_table_index_(), st_other_()
   {
     this->set_abiversion(0);
   }
@@ -357,6 +360,10 @@ public:
     this->stub_table_index_.clear();
   }
 
+  uint32_t
+  uniq() const
+  { return this->uniq_; }
+
   int
   abiversion() const
   { return this->e_flags_ & elfcpp::EF_PPC64_ABI; }
@@ -396,6 +403,9 @@ private:
   opd_ent_ndx(size_t off) const
   { return off >> 4;}
 
+  // Per object unique identifier
+  uint32_t uniq_;
+
   // For 32-bit the .got2 section shdnx, for 64-bit the .opd section shndx.
   unsigned int special_;
 
@@ -403,10 +413,6 @@ private:
   unsigned int relatoc_;
   unsigned int toc_;
 
-  // For 64-bit, an array with one entry per 64-bit word in the .toc
-  // section, set if accesses using that word cannot be optimised.
-  std::vector<bool> no_toc_opt_;
-
   // For 64-bit, whether this object uses small model relocs to access
   // the toc.
   bool has_small_toc_reloc_;
@@ -418,6 +424,13 @@ private:
   // access_from_map_.
   bool opd_valid_;
 
+  // Header e_flags
+  elfcpp::Elf_Word e_flags_;
+
+  // For 64-bit, an array with one entry per 64-bit word in the .toc
+  // section, set if accesses using that word cannot be optimised.
+  std::vector<bool> no_toc_opt_;
+
   // The first 8-byte word of an OPD entry gives the address of the
   // entry point of the function.  Relocatable object files have a
   // relocation on this word.  The following vector records the
@@ -435,9 +448,6 @@ private:
   // The stub table to use for a given input section.
   std::vector<unsigned int> stub_table_index_;
 
-  // Header e_flags
-  elfcpp::Elf_Word e_flags_;
-
   // ELF st_other field for local symbols.
   std::vector<unsigned char> st_other_;
 };
@@ -451,7 +461,7 @@ public:
   Powerpc_dynobj(const std::string& name, Input_file* input_file, off_t offset,
 		 const typename elfcpp::Ehdr<size, big_endian>& ehdr)
     : Sized_dynobj<size, big_endian>(name, input_file, offset, ehdr),
-      opd_shndx_(0), opd_ent_(), e_flags_(ehdr.get_e_flags())
+      opd_shndx_(0), e_flags_(ehdr.get_e_flags()), opd_ent_()
   {
     this->set_abiversion(0);
   }
@@ -548,14 +558,14 @@ private:
   unsigned int opd_shndx_;
   Address opd_address_;
 
+  // Header e_flags
+  elfcpp::Elf_Word e_flags_;
+
   // The first 8-byte word of an OPD entry gives the address of the
   // entry point of the function.  Records the section and offset
   // corresponding to the address.  Note that in dynamic objects,
   // offset is *not* relative to the section.
   std::vector<Opd_ent> opd_ent_;
-
-  // Header e_flags
-  elfcpp::Elf_Word e_flags_;
 };
 
 // Powerpc_copy_relocs class.  Needed to peek at dynamic relocs the
@@ -935,6 +945,23 @@ class Target_powerpc : public Sized_target<size, big_endian>
       }
   }
 
+  // Wrapper used after relax to define a local symbol in output data,
+  // from the end if value < 0.
+  void
+  define_local(Symbol_table* symtab, const char* name,
+	       Output_data* od, Address value, unsigned int symsize)
+  {
+    Symbol* sym
+      = symtab->define_in_output_data(name, NULL, Symbol_table::PREDEFINED,
+				      od, value, symsize, elfcpp::STT_NOTYPE,
+				      elfcpp::STB_LOCAL, elfcpp::STV_HIDDEN, 0,
+				      static_cast<Signed_address>(value) < 0,
+				      false);
+    // We are creating this symbol late, so need to fix up things
+    // done early in Layout::finalize.
+    sym->set_dynsym_index(-1U);
+  }
+
   bool
   plt_thread_safe() const
   { return this->plt_thread_safe_; }
@@ -2836,7 +2863,8 @@ Target_powerpc<size, big_endian>::group_sections(Layout* layout,
       if ((*t)->owner->is_input_section())
 	stub_table = new Stub_table<size, big_endian>(this,
 						      (*t)->output_section,
-						      (*t)->owner);
+						      (*t)->owner,
+						      this->stub_tables_.size());
       else if ((*t)->owner->is_relaxed_input_section())
 	stub_table = static_cast<Stub_table<size, big_endian>*>(
 			(*t)->owner->relaxed_input_section());
@@ -3232,6 +3260,36 @@ Target_powerpc<size, big_endian>::do_relax(int pass,
 	}
       this->brlt_section_->finalize_brlt_sizes();
     }
+
+  if (!again
+      && (parameters->options().user_set_emit_stub_syms()
+	  ? parameters->options().emit_stub_syms()
+	  : (size == 64
+	     || parameters->options().output_is_position_independent()
+	     || parameters->options().emit_relocs())))
+    {
+      for (typename Stub_tables::iterator p = this->stub_tables_.begin();
+	   p != this->stub_tables_.end();
+	   ++p)
+	(*p)->define_stub_syms(symtab);
+
+      if (this->glink_ != NULL)
+	{
+	  int stub_size = this->glink_->pltresolve_size;
+	  Address value = -stub_size;
+	  if (size == 64)
+	    {
+	      value = 8;
+	      stub_size -= 8;
+	    }
+	  this->define_local(symtab, "__glink_PLTresolve",
+			     this->glink_, value, stub_size);
+
+	  if (size != 64)
+	    this->define_local(symtab, "__glink", this->glink_, 0, 0);
+	}
+    }
+
   return again;
 }
 
@@ -3857,7 +3915,8 @@ class Stub_table : public Output_relaxed_input_section
 
   Stub_table(Target_powerpc<size, big_endian>* targ,
 	     Output_section* output_section,
-	     const Output_section::Input_section* owner)
+	     const Output_section::Input_section* owner,
+	     uint32_t id)
     : Output_relaxed_input_section(owner->relobj(), owner->shndx(),
 				   owner->relobj()
 				   ->section_addralign(owner->shndx())),
@@ -3865,7 +3924,7 @@ class Stub_table : public Output_relaxed_input_section
       orig_data_size_(owner->current_data_size()),
       plt_size_(0), last_plt_size_(0),
       branch_size_(0), last_branch_size_(0), min_size_threshold_(0),
-      eh_frame_added_(false), need_save_res_(false)
+      eh_frame_added_(false), need_save_res_(false), uniq_(id)
   {
     this->set_output_section(output_section);
 
@@ -3986,9 +4045,13 @@ class Stub_table : public Output_relaxed_input_section
   plt_size() const
   { return this->plt_size_; }
 
-  void set_min_size_threshold(Address min_size)
+  void
+  set_min_size_threshold(Address min_size)
   { this->min_size_threshold_ = min_size; }
 
+  void
+  define_stub_syms(Symbol_table*);
+
   bool
   size_update()
   {
@@ -4058,6 +4121,10 @@ class Stub_table : public Output_relaxed_input_section
   class Plt_stub_ent_hash;
   typedef Unordered_map<Plt_stub_ent, unsigned int,
 			Plt_stub_ent_hash> Plt_stub_entries;
+  class Branch_stub_ent;
+  class Branch_stub_ent_hash;
+  typedef Unordered_map<Branch_stub_ent, unsigned int,
+			Branch_stub_ent_hash> Branch_stub_entries;
 
   // Alignment of stub section.
   unsigned int
@@ -4126,11 +4193,10 @@ class Stub_table : public Output_relaxed_input_section
 
   // Return long branch stub size.
   unsigned int
-  branch_stub_size(Address to)
+  branch_stub_size(typename Branch_stub_entries::const_iterator p)
   {
-    Address loc
-      = this->stub_address() + this->last_plt_size_ + this->branch_size_;
-    if (to - loc + (1 << 25) < 2 << 25)
+    Address loc = this->stub_address() + this->last_plt_size_ + p->second;
+    if (p->first.dest_ - loc + (1 << 25) < 2 << 25)
       return 4;
     if (size == 64 || !parameters->options().output_is_position_independent())
       return 16;
@@ -4196,6 +4262,7 @@ class Stub_table : public Output_relaxed_input_section
     const Sized_relobj_file<size, big_endian>* object_;
     typename elfcpp::Elf_types<size>::Elf_Addr addend_;
     unsigned int locsym_;
+    unsigned int indx_;
   };
 
   class Plt_stub_ent_hash
@@ -4246,8 +4313,6 @@ class Stub_table : public Output_relaxed_input_section
   // Map sym/object/addend to stub offset.
   Plt_stub_entries plt_call_stubs_;
   // Map destination address to stub offset.
-  typedef Unordered_map<Branch_stub_ent, unsigned int,
-			Branch_stub_ent_hash> Branch_stub_entries;
   Branch_stub_entries long_branch_stubs_;
   // size of input section
   section_size_type orig_data_size_;
@@ -4265,6 +4330,8 @@ class Stub_table : public Output_relaxed_input_section
   // Set if this stub group needs a copy of out-of-line register
   // save/restore functions.
   bool need_save_res_;
+  // Per stub table unique identifier.
+  uint32_t uniq_;
 };
 
 // Add a plt call stub, if we do not already have one for this
@@ -4281,6 +4348,7 @@ Stub_table<size, big_endian>::add_plt_call_entry(
 {
   Plt_stub_ent ent(object, gsym, r_type, addend);
   unsigned int off = this->plt_size_;
+  ent.indx_ = this->plt_call_stubs_.size();
   std::pair<typename Plt_stub_entries::iterator, bool> p
     = this->plt_call_stubs_.insert(std::make_pair(ent, off));
   if (p.second)
@@ -4299,6 +4367,7 @@ Stub_table<size, big_endian>::add_plt_call_entry(
 {
   Plt_stub_ent ent(object, locsym_index, r_type, addend);
   unsigned int off = this->plt_size_;
+  ent.indx_ = this->plt_call_stubs_.size();
   std::pair<typename Plt_stub_entries::iterator, bool> p
     = this->plt_call_stubs_.insert(std::make_pair(ent, off));
   if (p.second)
@@ -4368,13 +4437,15 @@ Stub_table<size, big_endian>::add_long_branch_entry(
 {
   Branch_stub_ent ent(object, to, save_res);
   Address off = this->branch_size_;
-  if (this->long_branch_stubs_.insert(std::make_pair(ent, off)).second)
+  std::pair<typename Branch_stub_entries::iterator, bool> p
+    = this->long_branch_stubs_.insert(std::make_pair(ent, off));
+  if (p.second)
     {
       if (save_res)
 	this->need_save_res_ = true;
       else
 	{
-	  unsigned int stub_size = this->branch_stub_size(to);
+	  unsigned int stub_size = this->branch_stub_size(p.first);
 	  this->branch_size_ = off + stub_size;
 	  if (size == 64 && stub_size != 4)
 	    this->targ_->add_branch_lookup_table(to);
@@ -4555,6 +4626,79 @@ Output_data_glink<size, big_endian>::set_final_data_size()
   this->set_data_size(total);
 }
 
+// Define symbols on stubs, identifying the stub.
+
+template<int size, bool big_endian>
+void
+Stub_table<size, big_endian>::define_stub_syms(Symbol_table* symtab)
+{
+  if (!this->plt_call_stubs_.empty())
+    {
+      // The key for the plt call stub hash table includes addresses,
+      // therefore traversal order depends on those addresses, which
+      // can change between runs if gold is a PIE.  Unfortunately the
+      // output .symtab ordering depends on the order in which symbols
+      // are added to the linker symtab.  We want reproducible output
+      // so must sort the call stub symbols.
+      typedef typename Plt_stub_entries::const_iterator plt_iter;
+      std::vector<plt_iter> sorted;
+      sorted.resize(this->plt_call_stubs_.size());
+
+      for (plt_iter cs = this->plt_call_stubs_.begin();
+	   cs != this->plt_call_stubs_.end();
+	   ++cs)
+	sorted[cs->first.indx_] = cs;
+
+      for (unsigned int i = 0; i < this->plt_call_stubs_.size(); ++i)
+	{
+	  plt_iter cs = sorted[i];
+	  char add[10];
+	  add[0] = 0;
+	  if (cs->first.addend_ != 0)
+	    sprintf(add, "+%x", static_cast<uint32_t>(cs->first.addend_));
+	  char obj[10];
+	  obj[0] = 0;
+	  if (cs->first.object_)
+	    {
+	      const Powerpc_relobj<size, big_endian>* ppcobj = static_cast
+		<const Powerpc_relobj<size, big_endian>*>(cs->first.object_);
+	      sprintf(obj, "%x:", ppcobj->uniq());
+	    }
+	  char localname[9];
+	  const char *symname;
+	  if (cs->first.sym_ == NULL)
+	    {
+	      sprintf(localname, "%x", cs->first.locsym_);
+	      symname = localname;
+	    }
+	  else
+	    symname = cs->first.sym_->name();
+	  char* name = new char[8 + 10 + strlen(obj) + strlen(symname) + strlen(add) + 1];
+	  sprintf(name, "%08x.plt_call.%s%s%s", this->uniq_, obj, symname, add);
+	  Address value = this->stub_address() - this->address() + cs->second;
+	  unsigned int stub_size = this->plt_call_size(cs);
+	  this->targ_->define_local(symtab, name, this, value, stub_size);
+	}
+    }
+
+  typedef typename Branch_stub_entries::const_iterator branch_iter;
+  for (branch_iter bs = this->long_branch_stubs_.begin();
+       bs != this->long_branch_stubs_.end();
+       ++bs)
+    {
+      if (bs->first.save_res_)
+	continue;
+
+      char* name = new char[8 + 13 + 16 + 1];
+      sprintf(name, "%08x.long_branch.%llx", this->uniq_,
+	      static_cast<unsigned long long>(bs->first.dest_));
+      Address value = (this->stub_address() - this->address()
+		       + this->plt_size_ + bs->second);
+      unsigned int stub_size = this->branch_stub_size(bs);
+      this->targ_->define_local(symtab, name, this, value, stub_size);
+    }
+}
+
 // Write out plt and long branch stub code.
 
 template<int size, bool big_endian>
diff --git a/gold/sparc.cc b/gold/sparc.cc
index a9cb93adda..54c7c33498 100644
--- a/gold/sparc.cc
+++ b/gold/sparc.cc
@@ -3730,7 +3730,7 @@ Target_sparc<size, big_endian>::Relocate::relocate_tls(
 
   const bool is_final =
     (gsym == NULL
-     ? !parameters->options().output_is_position_independent()
+     ? !parameters->options().shared()
      : gsym->final_value_is_known());
   const tls::Tls_optimization optimized_type
       = optimize_tls_reloc(is_final, r_type);
diff --git a/gprof/ChangeLog b/gprof/ChangeLog
index cc57e0d872..0c25d519d6 100644
--- a/gprof/ChangeLog
+++ b/gprof/ChangeLog
@@ -2,6 +2,10 @@
 
 	* configure: Regenerate.
 
+2017-03-02  Tristan Gingold  <gingold@adacore.com>
+
+	* configure: Regenerate.
+
 2017-01-02  Alan Modra  <amodra@gmail.com>
 
 	Update year range in copyright notice of all files.
diff --git a/gprof/configure b/gprof/configure
index 43e0dac041..9e6b8f3525 100755
--- a/gprof/configure
+++ b/gprof/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.64 for gprof 2.28.
+# Generated by GNU Autoconf 2.64 for gprof 2.28.0.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
@@ -556,8 +556,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='gprof'
 PACKAGE_TARNAME='gprof'
-PACKAGE_VERSION='2.28'
-PACKAGE_STRING='gprof 2.28'
+PACKAGE_VERSION='2.28.0'
+PACKAGE_STRING='gprof 2.28.0'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
@@ -1302,7 +1302,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures gprof 2.28 to adapt to many kinds of systems.
+\`configure' configures gprof 2.28.0 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1373,7 +1373,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of gprof 2.28:";;
+     short | recursive ) echo "Configuration of gprof 2.28.0:";;
    esac
   cat <<\_ACEOF
 
@@ -1479,7 +1479,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-gprof configure 2.28
+gprof configure 2.28.0
 generated by GNU Autoconf 2.64
 
 Copyright (C) 2009 Free Software Foundation, Inc.
@@ -1844,7 +1844,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by gprof $as_me 2.28, which was
+It was created by gprof $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   $ $0 $@
@@ -3653,7 +3653,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='gprof'
- VERSION='2.28'
+ VERSION='2.28.0'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -12787,7 +12787,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by gprof $as_me 2.28, which was
+This file was extended by gprof $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -12851,7 +12851,7 @@ Report bugs to the package provider."
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-gprof config.status 2.28
+gprof config.status 2.28.0
 configured by $0, generated by GNU Autoconf 2.64,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
diff --git a/include/ChangeLog b/include/ChangeLog
index af39f333d4..dddecfb49b 100644
--- a/include/ChangeLog
+++ b/include/ChangeLog
@@ -1,3 +1,58 @@
+2017-04-03  Palmer Dabbelt  <palmer@dabbelt.com>
+
+	* elf/riscv.h (RISCV_GP_SYMBOL): New define.
+
+2017-03-27  Andrew Waterman  <andrew@sifive.com>
+
+	* opcode/riscv-opc.h (CSR_PMPCFG0): New define.
+	(CSR_PMPCFG1): Likewise.
+	(CSR_PMPCFG2): Likewise.
+	(CSR_PMPCFG3): Likewise.
+	(CSR_PMPADDR0): Likewise.
+	(CSR_PMPADDR1): Likewise.
+	(CSR_PMPADDR2): Likewise.
+	(CSR_PMPADDR3): Likewise.
+	(CSR_PMPADDR4): Likewise.
+	(CSR_PMPADDR5): Likewise.
+	(CSR_PMPADDR6): Likewise.
+	(CSR_PMPADDR7): Likewise.
+	(CSR_PMPADDR8): Likewise.
+	(CSR_PMPADDR9): Likewise.
+	(CSR_PMPADDR10): Likewise.
+	(CSR_PMPADDR11): Likewise.
+	(CSR_PMPADDR12): Likewise.
+	(CSR_PMPADDR13): Likewise.
+	(CSR_PMPADDR14): Likewise.
+	(CSR_PMPADDR15): Likewise.
+	(pmpcfg0): Declare register.
+	(pmpcfg1): Likewise.
+	(pmpcfg2): Likewise.
+	(pmpcfg3): Likewise.
+	(pmpaddr0): Likewise.
+	(pmpaddr1): Likewise.
+	(pmpaddr2): Likewise.
+	(pmpaddr3): Likewise.
+	(pmpaddr4): Likewise.
+	(pmpaddr5): Likewise.
+	(pmpaddr6): Likewise.
+	(pmpaddr7): Likewise.
+	(pmpaddr8): Likewise.
+	(pmpaddr9): Likewise.
+	(pmpaddr10): Likewise.
+	(pmpaddr11): Likewise.
+	(pmpaddr12): Likewise.
+	(pmpaddr13): Likewise.
+	(pmpaddr14): Likewise.
+	(pmpaddr15): Likewise.
+
+2017-03-21  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2017-03-21  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* opcode/s390.h (S390_INSTR_FLAG_VX2): Remove.
+	(S390_INSTR_FLAG_FACILITY_MASK): Adjust value.
+
 2017-02-28  Alan Modra  <amodra@gmail.com>
 
 	* elf/ppc64.h (R_PPC64_16DX_HA): New.  Expand fake reloc comment.
diff --git a/include/elf/riscv.h b/include/elf/riscv.h
index 526bc11f15..daa4463926 100644
--- a/include/elf/riscv.h
+++ b/include/elf/riscv.h
@@ -109,4 +109,7 @@ END_RELOC_NUMBERS (R_RISCV_max)
 /* File uses the quad-float ABI.  */
 #define EF_RISCV_FLOAT_ABI_QUAD 0x0006
 
+/* The name of the global pointer symbol.  */
+#define RISCV_GP_SYMBOL "__global_pointer$"
+
 #endif /* _ELF_RISCV_H */
diff --git a/include/opcode/riscv-opc.h b/include/opcode/riscv-opc.h
index 9269c6be93..f80037b8f0 100644
--- a/include/opcode/riscv-opc.h
+++ b/include/opcode/riscv-opc.h
@@ -556,6 +556,26 @@
 #define CSR_MCAUSE 0x342
 #define CSR_MBADADDR 0x343
 #define CSR_MIP 0x344
+#define CSR_PMPCFG0 0x3a0
+#define CSR_PMPCFG1 0x3a1
+#define CSR_PMPCFG2 0x3a2
+#define CSR_PMPCFG3 0x3a3
+#define CSR_PMPADDR0 0x3b0
+#define CSR_PMPADDR1 0x3b1
+#define CSR_PMPADDR2 0x3b2
+#define CSR_PMPADDR3 0x3b3
+#define CSR_PMPADDR4 0x3b4
+#define CSR_PMPADDR5 0x3b5
+#define CSR_PMPADDR6 0x3b6
+#define CSR_PMPADDR7 0x3b7
+#define CSR_PMPADDR8 0x3b8
+#define CSR_PMPADDR9 0x3b9
+#define CSR_PMPADDR10 0x3ba
+#define CSR_PMPADDR11 0x3bb
+#define CSR_PMPADDR12 0x3bc
+#define CSR_PMPADDR13 0x3bd
+#define CSR_PMPADDR14 0x3be
+#define CSR_PMPADDR15 0x3bf
 #define CSR_TSELECT 0x7a0
 #define CSR_TDATA1 0x7a1
 #define CSR_TDATA2 0x7a2
@@ -1014,6 +1034,26 @@ DECLARE_CSR(mepc, CSR_MEPC)
 DECLARE_CSR(mcause, CSR_MCAUSE)
 DECLARE_CSR(mbadaddr, CSR_MBADADDR)
 DECLARE_CSR(mip, CSR_MIP)
+DECLARE_CSR(pmpcfg0, CSR_PMPCFG0)
+DECLARE_CSR(pmpcfg1, CSR_PMPCFG1)
+DECLARE_CSR(pmpcfg2, CSR_PMPCFG2)
+DECLARE_CSR(pmpcfg3, CSR_PMPCFG3)
+DECLARE_CSR(pmpaddr0, CSR_PMPADDR0)
+DECLARE_CSR(pmpaddr1, CSR_PMPADDR1)
+DECLARE_CSR(pmpaddr2, CSR_PMPADDR2)
+DECLARE_CSR(pmpaddr3, CSR_PMPADDR3)
+DECLARE_CSR(pmpaddr4, CSR_PMPADDR4)
+DECLARE_CSR(pmpaddr5, CSR_PMPADDR5)
+DECLARE_CSR(pmpaddr6, CSR_PMPADDR6)
+DECLARE_CSR(pmpaddr7, CSR_PMPADDR7)
+DECLARE_CSR(pmpaddr8, CSR_PMPADDR8)
+DECLARE_CSR(pmpaddr9, CSR_PMPADDR9)
+DECLARE_CSR(pmpaddr10, CSR_PMPADDR10)
+DECLARE_CSR(pmpaddr11, CSR_PMPADDR11)
+DECLARE_CSR(pmpaddr12, CSR_PMPADDR12)
+DECLARE_CSR(pmpaddr13, CSR_PMPADDR13)
+DECLARE_CSR(pmpaddr14, CSR_PMPADDR14)
+DECLARE_CSR(pmpaddr15, CSR_PMPADDR15)
 DECLARE_CSR(tselect, CSR_TSELECT)
 DECLARE_CSR(tdata1, CSR_TDATA1)
 DECLARE_CSR(tdata2, CSR_TDATA2)
diff --git a/include/opcode/s390.h b/include/opcode/s390.h
index 7ce5616841..2e07664425 100644
--- a/include/opcode/s390.h
+++ b/include/opcode/s390.h
@@ -51,8 +51,7 @@ enum s390_opcode_cpu_val
 
 #define S390_INSTR_FLAG_HTM 0x2
 #define S390_INSTR_FLAG_VX 0x4
-#define S390_INSTR_FLAG_VX2 0x8
-#define S390_INSTR_FLAG_FACILITY_MASK 0xe
+#define S390_INSTR_FLAG_FACILITY_MASK 0x6
 
 /* The opcode table is an array of struct s390_opcode.  */
 
diff --git a/ld/ChangeLog b/ld/ChangeLog
index ba7d1d4ce1..8458f135b6 100644
--- a/ld/ChangeLog
+++ b/ld/ChangeLog
@@ -1,3 +1,82 @@
+2017-06-20  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2017-05-08  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	* testsuite/ld-arm/arm-elf.exp
+	(Secure gateway import library generation): Check e_type field
+	of import library and executable produced.
+	* testsuite/ld-arm/cmse-implib.type: Expectations for e_type field.
+
+2017-06-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* emulparams/call_nop.sh: Remove -z prefix-nop.
+	* ld.texinfo: Likewise.
+	* testsuite/ld-i386/call3c.d: Check for linker error.
+	* testsuite/ld-x86-64/call1c.d: Likewise.
+
+2017-05-31  Alan Modra  <amodra@gmail.com>
+
+	* emultempl/ppc64elf.em (plt-static-chain help): Fix quoting.
+
+2017-05-18  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-03-13  Alexey Neyman  <stilor@att.net>
+	* emulparams/elf32ppccommon.sh (LIBPATH_SUFFIX): Set from target
+	cpu, not host.
+
+2017-04-28  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>
+
+	PR ld/21404
+	* testsuite/ld-avr/pr21404-1.d: New test.
+	* testsuite/ld-avr/pr21404-1.s: New test.
+	* testsuite/ld-avr/pr21404-2.d: New test.
+	* testsuite/ld-avr/pr21404-2.s: New test.
+	* testsuite/ld-avr/pr21404-3.d: New test.
+	* testsuite/ld-avr/pr21404-3.s: New test.
+	* testsuite/ld-avr/pr21404-4.d: New test.
+	* testsuite/ld-avr/pr21404-4.s: New test.
+	* testsuite/ld-avr/pr21404-5.d: New test.
+	* testsuite/ld-avr/pr21404-5.s: New test.
+	* testsuite/ld-avr/pr21404-6.d: New test.
+	* testsuite/ld-avr/pr21404-6.s: New test.
+	* testsuite/ld-avr/pr21404-7.d: New test.
+	* testsuite/ld-avr/pr21404-7.s: New test.
+	* testsuite/ld-avr/pr21404-8.d: New test.
+	* testsuite/ld-avr/pr21404-8.s: New test.
+
+2017-04-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/20815
+	* testsuite/ld-i386/vxworks2.sd: Add space for program headers.
+
+2017-03-28  Hans-Peter Nilsson  <hp@axis.com>
+
+	PR ld/16044
+	* testsuite/ld-cris/pr16044.d, testsuite/ld-cris/dso-1c.s,
+	testsuite/ld-cris/dso-2b.s, testsuite/ld-cris/dso-4.s: New test.
+
+2017-04-10  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/19579
+	PR ld/21306
+	* testsuite/ld-elf/pr19579a.c (main): Updated.
+
+2017-04-05  Maciej W. Rozycki  <macro@imgtec.com>
+
+	PR ld/21233
+	* ldlang.c (insert_undefined): Set `mark' for ELF symbols.
+
+2017-03-07  Alan Modra  <amodra@gmail.com>
+
+	* ldlang.c (open_input_bfds): Check that lang_assignment_statement
+	is not an assert before referencing defsym.
+
+2017-03-02  Tristan Gingold  <gingold@adacore.com>
+
+	* configure: Regenerate.
+
 2017-03-02  Tristan Gingold  <gingold@adacore.com>
 
 	* configure: Regenerate.
diff --git a/ld/configure b/ld/configure
index 36af9695b1..a16c6db059 100755
--- a/ld/configure
+++ b/ld/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.64 for ld 2.28.
+# Generated by GNU Autoconf 2.64 for ld 2.28.0.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
@@ -556,8 +556,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='ld'
 PACKAGE_TARNAME='ld'
-PACKAGE_VERSION='2.28'
-PACKAGE_STRING='ld 2.28'
+PACKAGE_VERSION='2.28.0'
+PACKAGE_STRING='ld 2.28.0'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
@@ -1354,7 +1354,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures ld 2.28 to adapt to many kinds of systems.
+\`configure' configures ld 2.28.0 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1425,7 +1425,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of ld 2.28:";;
+     short | recursive ) echo "Configuration of ld 2.28.0:";;
    esac
   cat <<\_ACEOF
 
@@ -1550,7 +1550,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-ld configure 2.28
+ld configure 2.28.0
 generated by GNU Autoconf 2.64
 
 Copyright (C) 2009 Free Software Foundation, Inc.
@@ -2259,7 +2259,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by ld $as_me 2.28, which was
+It was created by ld $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   $ $0 $@
@@ -4069,7 +4069,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='ld'
- VERSION='2.28'
+ VERSION='2.28.0'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -17813,7 +17813,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by ld $as_me 2.28, which was
+This file was extended by ld $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -17877,7 +17877,7 @@ Report bugs to the package provider."
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-ld config.status 2.28
+ld config.status 2.28.0
 configured by $0, generated by GNU Autoconf 2.64,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
diff --git a/ld/emulparams/call_nop.sh b/ld/emulparams/call_nop.sh
index fee4a8154e..d45806ca94 100644
--- a/ld/emulparams/call_nop.sh
+++ b/ld/emulparams/call_nop.sh
@@ -10,11 +10,6 @@ PARSE_AND_LIST_ARGS_CASE_Z_CALL_NOP='
 	      link_info.call_nop_as_suffix = FALSE;
 	      link_info.call_nop_byte = 0x67;
 	    }
-	  else if (strcmp (optarg + 9, "prefix-nop") == 0)
-	    {
-	      link_info.call_nop_as_suffix = FALSE;
-	      link_info.call_nop_byte = 0x90;
-	    }
 	  else if (strcmp (optarg + 9, "suffix-nop") == 0)
 	    {
 	      link_info.call_nop_as_suffix = TRUE;
diff --git a/ld/emulparams/elf32ppccommon.sh b/ld/emulparams/elf32ppccommon.sh
index 1f54ef8056..d00cf68d89 100644
--- a/ld/emulparams/elf32ppccommon.sh
+++ b/ld/emulparams/elf32ppccommon.sh
@@ -44,11 +44,11 @@ fi
 
 # Look for 64 bit target libraries in /lib64, /usr/lib64 etc., first.
 # Similarly, look for 32 bit libraries in /lib32, /usr/lib32 etc.
-case "$host":"$EMULATION_NAME" in
-  *le-*:*64lppc*) LIBPATH_SUFFIX=64 ;;
-  *le-*:*32lppc*) LIBPATH_SUFFIX=32 ;;
-  *le-*:*64*) LIBPATH_SUFFIX=64be ;;
-  *le-*:*32*) LIBPATH_SUFFIX=32be ;;
+case `echo "$target" | sed -e 's/-.*//'`:"$EMULATION_NAME" in
+  *le:*64lppc*) LIBPATH_SUFFIX=64 ;;
+  *le:*32lppc*) LIBPATH_SUFFIX=32 ;;
+  *le:*64*) LIBPATH_SUFFIX=64be ;;
+  *le:*32*) LIBPATH_SUFFIX=32be ;;
   *:*64lppc*) LIBPATH_SUFFIX=64le ;;
   *:*32lppc*) LIBPATH_SUFFIX=32le ;;
   *:*64*) LIBPATH_SUFFIX=64 ;;
diff --git a/ld/emultempl/ppc64elf.em b/ld/emultempl/ppc64elf.em
index 9e5f24041a..f1d5274620 100644
--- a/ld/emultempl/ppc64elf.em
+++ b/ld/emultempl/ppc64elf.em
@@ -742,10 +742,10 @@ PARSE_AND_LIST_OPTIONS=${PARSE_AND_LIST_OPTIONS}'
                                 choose suitable defaults.\n"
 		   ));
   fprintf (file, _("\
-  --plt-static-chain          PLT call stubs should load r11.${DEFAULT_PLT_STATIC_CHAIN- (default)}\n"
+  --plt-static-chain          PLT call stubs should load r11.'${DEFAULT_PLT_STATIC_CHAIN- (default)}'\n"
 		   ));
   fprintf (file, _("\
-  --no-plt-static-chain       PLT call stubs should not load r11.${DEFAULT_PLT_STATIC_CHAIN+ (default)}\n"
+  --no-plt-static-chain       PLT call stubs should not load r11.'${DEFAULT_PLT_STATIC_CHAIN+ (default)}'\n"
 		   ));
   fprintf (file, _("\
   --plt-thread-safe           PLT call stubs with load-load barrier.\n"
diff --git a/ld/ld.texinfo b/ld/ld.texinfo
index d393acdd94..4b5046a6bb 100644
--- a/ld/ld.texinfo
+++ b/ld/ld.texinfo
@@ -1219,14 +1219,12 @@ relocation overflow check if there will be no dynamic relocation
 overflow at run-time.  Supported for x86_64.
 
 @item call-nop=prefix-addr
-@itemx call-nop=prefix-nop
 @itemx call-nop=suffix-nop
 @itemx call-nop=prefix-@var{byte}
 @itemx call-nop=suffix-@var{byte}
 Specify the 1-byte @code{NOP} padding when transforming indirect call
 to a locally defined function, foo, via its GOT slot.
 @option{call-nop=prefix-addr} generates @code{0x67 call foo}.
-@option{call-nop=prefix-nop} generates @code{0x90 call foo}.
 @option{call-nop=suffix-nop} generates @code{call foo 0x90}.
 @option{call-nop=prefix-@var{byte}} generates @code{@var{byte} call foo}.
 @option{call-nop=suffix-@var{byte}} generates @code{call foo @var{byte}}.
diff --git a/ld/ldlang.c b/ld/ldlang.c
index dafc3489fd..a8ff0a413e 100644
--- a/ld/ldlang.c
+++ b/ld/ldlang.c
@@ -3377,7 +3377,8 @@ open_input_bfds (lang_statement_union_type *s, enum open_bfd_mode mode)
 #endif
 	  break;
 	case lang_assignment_statement_enum:
-	  if (s->assignment_statement.exp->assign.defsym)
+	  if (s->assignment_statement.exp->type.node_class != etree_assert
+	      && s->assignment_statement.exp->assign.defsym)
 	    /* This is from a --defsym on the command line.  */
 	    exp_fold_tree_no_dot (s->assignment_statement.exp);
 	  break;
@@ -3431,6 +3432,8 @@ insert_undefined (const char *name)
     {
       h->type = bfd_link_hash_undefined;
       h->u.undef.abfd = NULL;
+      if (is_elf_hash_table (link_info.hash))
+	((struct elf_link_hash_entry *) h)->mark = 1;
       bfd_link_add_undef (link_info.hash, h);
     }
 }
diff --git a/ld/testsuite/ld-arm/arm-elf.exp b/ld/testsuite/ld-arm/arm-elf.exp
index 1a4d262e60..2e19332490 100644
--- a/ld/testsuite/ld-arm/arm-elf.exp
+++ b/ld/testsuite/ld-arm/arm-elf.exp
@@ -685,7 +685,8 @@ set armeabitests_nonacl {
      "--section-start .gnu.sgstubs=0x20000 --out-implib=tmpdir/cmse-implib.lib --cmse-implib" ""
      "-march=armv8-m.base -mthumb --defsym VER=1"
      {cmse-implib.s}
-     {{readelf {-s tmpdir/cmse-implib.lib} cmse-implib.rd}}
+     {{readelf {-s tmpdir/cmse-implib.lib} cmse-implib.rd}
+      {readelf {-h tmpdir/cmse-implib.lib} cmse-implib.type}}
      "cmse-implib"}
     {"Input secure gateway import library"
      "--section-start .gnu.sgstubs=0x20000 --out-implib=tmpdir/cmse-new-implib.lib --in-implib=tmpdir/cmse-implib.lib --cmse-implib" ""
diff --git a/ld/testsuite/ld-arm/cmse-implib.type b/ld/testsuite/ld-arm/cmse-implib.type
new file mode 100644
index 0000000000..7bb3bccc8e
--- /dev/null
+++ b/ld/testsuite/ld-arm/cmse-implib.type
@@ -0,0 +1,9 @@
+#...
+File: tmpdir/cmse-implib.lib
+#...
+[[:space:]]+Type:[[:space:]]+REL \(Relocatable file\)
+#...
+File: tmpdir/cmse-implib
+#...
+[[:space:]]+Type:[[:space:]]+EXEC \(Executable file\)
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-1.d b/ld/testsuite/ld-avr/pr21404-1.d
new file mode 100644
index 0000000000..fc7103fc9f
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-1.d
@@ -0,0 +1,12 @@
+#name: AVR symbol size adjustment with non zero symbol value
+#as: -mmcu=avrxmega2 -mlink-relax
+#ld:  -mavrxmega2 --relax
+#source: pr21404-1.s
+#nm: -n -S
+#target: avr-*-*
+
+#...
+00000000 00000004 T main
+#...
+00000002 00000002 T nonzero_sym
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-1.s b/ld/testsuite/ld-avr/pr21404-1.s
new file mode 100644
index 0000000000..66ddb7d4a3
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-1.s
@@ -0,0 +1,11 @@
+    .file "pr21404-1.s"
+.section	.text,"ax",@progbits
+.global nonzero_sym
+.global main
+main:
+L1:
+    jmp  L1
+nonzero_sym:
+    nop
+.size main, .-main
+.size nonzero_sym, .-nonzero_sym
diff --git a/ld/testsuite/ld-avr/pr21404-2.d b/ld/testsuite/ld-avr/pr21404-2.d
new file mode 100644
index 0000000000..e85735cd7d
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-2.d
@@ -0,0 +1,16 @@
+#name: AVR symbol size adjustment across alignment boundary
+#as: -mmcu=avrxmega2 -mlink-relax
+#ld:  -mavrxmega2 --relax
+#source: pr21404-2.s
+#nm: -n -S
+#target: avr-*-*
+
+#...
+00000000 00000006 T main
+00000000 00000004 T size_after_align
+00000000 00000004 T size_before_align
+#...
+00000002 00000002 T nonzero_sym_after_align
+00000002 00000004 T nonzero_sym_after_end
+00000002 00000002 T nonzero_sym_before_align
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-2.s b/ld/testsuite/ld-avr/pr21404-2.s
new file mode 100644
index 0000000000..e1da1ae4b3
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-2.s
@@ -0,0 +1,25 @@
+    .file "pr21404.s"
+.section	.text,"ax",@progbits
+.global size_before_align
+.global size_after_align
+.global main
+.global nonzero_sym_before_align
+.global nonzero_sym_after_align
+.global nonzero_sym_after_end
+main:
+size_before_align:
+size_after_align:
+L1:
+    jmp  L1
+nonzero_sym_before_align:
+nonzero_sym_after_align:
+nonzero_sym_after_end:
+    jmp  L1
+.size size_before_align, .-size_before_align
+.size nonzero_sym_before_align, .-nonzero_sym_before_align
+    .p2align 1
+.size size_after_align, .-size_after_align
+.size nonzero_sym_after_align, .-nonzero_sym_after_align
+.word L1
+.size main, .-main
+.size nonzero_sym_after_end, .-nonzero_sym_after_end
diff --git a/ld/testsuite/ld-avr/pr21404-3.d b/ld/testsuite/ld-avr/pr21404-3.d
new file mode 100644
index 0000000000..145b48fff2
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-3.d
@@ -0,0 +1,10 @@
+#name: AVR symbol value adjustment with non zero symbol value
+#as: -mmcu=avrxmega2 -mlink-relax
+#ld:  -mavrxmega2 --relax
+#source: pr21404-3.s
+#nm: -n -S
+#target: avr-*-*
+
+#...
+00000006 T nonzero_sym
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-3.s b/ld/testsuite/ld-avr/pr21404-3.s
new file mode 100644
index 0000000000..d62ecd99ed
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-3.s
@@ -0,0 +1,10 @@
+    .file "pr21404-3.s"
+.section	.text,"ax",@progbits
+.global nonzero_sym
+L1:
+    jmp  L1
+    jmp  L1
+    jmp L1
+    .p2align 1
+nonzero_sym:
+    jmp L1
diff --git a/ld/testsuite/ld-avr/pr21404-4.d b/ld/testsuite/ld-avr/pr21404-4.d
new file mode 100644
index 0000000000..b80dfcffbe
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-4.d
@@ -0,0 +1,10 @@
+#name: AVR symbol size increase for alignment
+#as: -mmcu=avrxmega2 -mlink-relax
+#ld:  -mavrxmega2 --relax
+#source: pr21404-4.s
+#nm: -n -S
+#target: avr-*-*
+
+#...
+00000002 00000006 T nonzero_sym
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-4.s b/ld/testsuite/ld-avr/pr21404-4.s
new file mode 100644
index 0000000000..3e957bb43b
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-4.s
@@ -0,0 +1,10 @@
+    .file "pr21404-4.s"
+.section	.text,"ax",@progbits
+.global nonzero_sym
+L1:
+    jmp  L1
+nonzero_sym:
+    nop
+    nop
+    .p2align 2
+.size nonzero_sym, .-nonzero_sym
diff --git a/ld/testsuite/ld-avr/pr21404-5.d b/ld/testsuite/ld-avr/pr21404-5.d
new file mode 100644
index 0000000000..519c50fdd6
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-5.d
@@ -0,0 +1,11 @@
+#name: AVR local symbol size adjustment with non zero symbol value
+#as: -mmcu=avrxmega2 -mlink-relax
+#ld:  -mavrxmega2 --relax
+#source: pr21404-5.s
+#nm: -n -S
+#target: avr-*-*
+
+#...
+00000000 00000004 t _main
+00000002 00000002 t _nonzero_sym
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-5.s b/ld/testsuite/ld-avr/pr21404-5.s
new file mode 100644
index 0000000000..ccf2394e0e
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-5.s
@@ -0,0 +1,9 @@
+    .file "pr21404-1.s"
+.section	.text,"ax",@progbits
+_main:
+L1:
+    jmp  L1
+_nonzero_sym:
+    nop
+.size _main, .-_main
+.size _nonzero_sym, .-_nonzero_sym
diff --git a/ld/testsuite/ld-avr/pr21404-6.d b/ld/testsuite/ld-avr/pr21404-6.d
new file mode 100644
index 0000000000..784fc7c326
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-6.d
@@ -0,0 +1,16 @@
+#name: AVR local symbol size adjustment across alignment boundary
+#as: -mmcu=avrxmega2 -mlink-relax
+#ld:  -mavrxmega2 --relax
+#source: pr21404-6.s
+#nm: -n -S
+#target: avr-*-*
+
+#...
+00000000 00000006 t main
+00000000 00000004 t size_after_align
+00000000 00000004 t size_before_align
+#...
+00000002 00000002 t nonzero_sym_after_align
+00000002 00000004 t nonzero_sym_after_end
+00000002 00000002 t nonzero_sym_before_align
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-6.s b/ld/testsuite/ld-avr/pr21404-6.s
new file mode 100644
index 0000000000..36f2301ba8
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-6.s
@@ -0,0 +1,19 @@
+    .file "pr21404-6.s"
+.section	.text,"ax",@progbits
+main:
+size_before_align:
+size_after_align:
+L1:
+    jmp  L1
+nonzero_sym_before_align:
+nonzero_sym_after_align:
+nonzero_sym_after_end:
+    jmp  L1
+.size size_before_align, .-size_before_align
+.size nonzero_sym_before_align, .-nonzero_sym_before_align
+    .p2align 1
+.size size_after_align, .-size_after_align
+.size nonzero_sym_after_align, .-nonzero_sym_after_align
+.word L1
+.size main, .-main
+.size nonzero_sym_after_end, .-nonzero_sym_after_end
diff --git a/ld/testsuite/ld-avr/pr21404-7.d b/ld/testsuite/ld-avr/pr21404-7.d
new file mode 100644
index 0000000000..1360acb3e5
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-7.d
@@ -0,0 +1,10 @@
+#name: AVR local symbol value adjustment with non zero symbol value
+#as: -mmcu=avrxmega2 -mlink-relax
+#ld:  -mavrxmega2 --relax
+#source: pr21404-7.s
+#nm: -n -S
+#target: avr-*-*
+
+#...
+00000006 t nonzero_sym
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-7.s b/ld/testsuite/ld-avr/pr21404-7.s
new file mode 100644
index 0000000000..b7e4e354dd
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-7.s
@@ -0,0 +1,9 @@
+    .file "pr21404-7.s"
+.section	.text,"ax",@progbits
+L1:
+    jmp  L1
+    jmp  L1
+    jmp L1
+    .p2align 1
+nonzero_sym:
+    jmp L1
diff --git a/ld/testsuite/ld-avr/pr21404-8.d b/ld/testsuite/ld-avr/pr21404-8.d
new file mode 100644
index 0000000000..d70ba8fc3a
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-8.d
@@ -0,0 +1,10 @@
+#name: AVR local symbol size increase for alignment
+#as: -mmcu=avrxmega2 -mlink-relax
+#ld:  -mavrxmega2 --relax
+#source: pr21404-8.s
+#nm: -n -S
+#target: avr-*-*
+
+#...
+00000002 00000006 t nonzero_sym
+#...
diff --git a/ld/testsuite/ld-avr/pr21404-8.s b/ld/testsuite/ld-avr/pr21404-8.s
new file mode 100644
index 0000000000..6b00df541a
--- /dev/null
+++ b/ld/testsuite/ld-avr/pr21404-8.s
@@ -0,0 +1,9 @@
+    .file "pr21404-8.s"
+.section	.text,"ax",@progbits
+L1:
+    jmp  L1
+nonzero_sym:
+    nop
+    nop
+    .p2align 2
+.size nonzero_sym, .-nonzero_sym
diff --git a/ld/testsuite/ld-cris/dso-1c.s b/ld/testsuite/ld-cris/dso-1c.s
new file mode 100644
index 0000000000..92ad4ee082
--- /dev/null
+++ b/ld/testsuite/ld-cris/dso-1c.s
@@ -0,0 +1,2 @@
+	.include "dso-1.s"
+	.hidden dsofn
diff --git a/ld/testsuite/ld-cris/dso-2b.s b/ld/testsuite/ld-cris/dso-2b.s
new file mode 100644
index 0000000000..f1fbf14780
--- /dev/null
+++ b/ld/testsuite/ld-cris/dso-2b.s
@@ -0,0 +1,2 @@
+	.include "dso-2.s"
+	.hidden dsofn
diff --git a/ld/testsuite/ld-cris/dso-4.s b/ld/testsuite/ld-cris/dso-4.s
new file mode 100644
index 0000000000..767a0d8226
--- /dev/null
+++ b/ld/testsuite/ld-cris/dso-4.s
@@ -0,0 +1,6 @@
+	.text
+	.global	export_2
+	.type	export_2,@function
+export_2:
+	.hidden dsofn
+	move.d dsofn:GOTOFF,$r4
diff --git a/ld/testsuite/ld-cris/pr16044.d b/ld/testsuite/ld-cris/pr16044.d
new file mode 100644
index 0000000000..e5d373df8f
--- /dev/null
+++ b/ld/testsuite/ld-cris/pr16044.d
@@ -0,0 +1,43 @@
+#source: dso-4.s
+#source: dso-2b.s
+#source: dso-1c.s
+#as: --pic --no-underscore --em=criself -I$srcdir/$subdir
+#ld: --shared -m crislinux
+#readelf: -s -r
+
+# PR 16044 is about a (compile-time-non-local) hidden function symbol,
+# entered as an undef reference with a R_CRIS_32_PLT_GOTREL relocation
+# referring to a hidden symbol, later defined.  Here, we invalidly
+# incremented the h->plt.refcount (from -1) as part of that relocation
+# processing.  There are some PLTGOT relocations.  As there are no
+# circumstances requiring a PLT entry for this symbol, its PLT entry
+# can be eliminated and the PLTGOT relocations can be made to a static
+# element in the GOT, relocated with the absolute-to-relative
+# R_CRIS_RELATIVE relocation without symbol lookup.  As part of
+# eliminating unneeded PLT entries (and PLTGOT to "static" GOT
+# elimination), a later pass noticed the inconsistency through an
+# assert.
+#
+# The key points in this dump that may need future adjustments are the
+# single dynamic relocation, that the dsofn symbol it points to, is
+# local, its absence from the dynamic symbol table and that the
+# relocation and symbol values match.
+
+Relocation section '\.rela\.dyn' at offset 0x[0-9a-f]+ contains 1 entries:
+ Offset[ 	]+Info[ 	]+Type[ 	]+Sym\.Value  Sym\. Name \+ Addend
+[0-9a-f]+  0+[0-9a-f]+ R_CRIS_RELATIVE[ 	]+184
+
+Symbol table '\.dynsym' contains 7 entries:
+ +Num: +Value +Size +Type +Bind +Vis +Ndx +Name
+ +0: 0+ +0 +NOTYPE +LOCAL +DEFAULT +UND 
+ +1: [0-9a-f]+ +0 +SECTION +LOCAL +DEFAULT +5 
+ +2: [0-9a-f]+ +0 +FUNC +GLOBAL +DEFAULT +5 export_1
+ +3: [0-9a-f]+ +0 +NOTYPE +GLOBAL +DEFAULT +7 __bss_start
+ +4: [0-9a-f]+ +0 +NOTYPE +GLOBAL +DEFAULT +7 _edata
+ +5: [0-9a-f]+ +0 +NOTYPE +GLOBAL +DEFAULT +7 _end
+ +6: [0-9a-f]+ +0 +FUNC +GLOBAL +DEFAULT +5 export_2
+
+Symbol table '\.symtab' contains [0-9]+ entries:
+#...
+ +[0-9]+: 0+184  +2 FUNC + LOCAL + DEFAULT + 5 dsofn
+#...
diff --git a/ld/testsuite/ld-elf/pr19579a.c b/ld/testsuite/ld-elf/pr19579a.c
index e4a6eb1ea9..69d0f35898 100644
--- a/ld/testsuite/ld-elf/pr19579a.c
+++ b/ld/testsuite/ld-elf/pr19579a.c
@@ -9,7 +9,7 @@ extern int *bar_p (void);
 int
 main ()
 {
-  if (foo[0] == 0 && foo == foo_p () && bar[0] == 0 && bar == bar_p ())
+  if (foo[0] == 0 && foo == foo_p () && bar[0] == -1 && bar == bar_p ())
     printf ("PASS\n");
   return 0;
 }
diff --git a/ld/testsuite/ld-i386/call3c.d b/ld/testsuite/ld-i386/call3c.d
index 0fdbee454a..f869dcc886 100644
--- a/ld/testsuite/ld-i386/call3c.d
+++ b/ld/testsuite/ld-i386/call3c.d
@@ -1,14 +1,4 @@
 #source: call3.s
 #as: --32 -mrelax-relocations=yes
 #ld: -melf_i386 -z call-nop=prefix-nop
-#objdump: -dw
-
-.*: +file format .*
-
-
-Disassembly of section .text:
-
-#...
-[ 	]*[a-f0-9]+:	90                   	nop
-[ 	]*[a-f0-9]+:	e8 ([0-9a-f]{2} ){4} *	call +[a-f0-9]+ <foo>
-#pass
+#error: invalid number for -z call-nop=prefix-: nop
diff --git a/ld/testsuite/ld-i386/vxworks2.sd b/ld/testsuite/ld-i386/vxworks2.sd
index 5ff87d3bef..4f56f2ac7e 100644
--- a/ld/testsuite/ld-i386/vxworks2.sd
+++ b/ld/testsuite/ld-i386/vxworks2.sd
@@ -6,7 +6,7 @@ Program Headers:
   Type .*
   PHDR .*
 #...
-  LOAD .* 0x00080000 0x00080000 .* R E 0x1000
+  LOAD .* 0x0007f000 0x0007f000 .* R E 0x1000
   LOAD .* 0x00081000 0x00081000 .* RW  0x1000
   DYNAMIC .*
 
diff --git a/ld/testsuite/ld-x86-64/call1c.d b/ld/testsuite/ld-x86-64/call1c.d
index 7fe8056e49..70933daa10 100644
--- a/ld/testsuite/ld-x86-64/call1c.d
+++ b/ld/testsuite/ld-x86-64/call1c.d
@@ -1,14 +1,4 @@
 #source: call1.s
 #as: --64 -mrelax-relocations=yes
 #ld: -melf_x86_64 -z call-nop=prefix-nop
-#objdump: -dw
-
-.*: +file format .*
-
-
-Disassembly of section .text:
-
-#...
-[ 	]*[a-f0-9]+:	90                   	nop
-[ 	]*[a-f0-9]+:	e8 ([0-9a-f]{2} ){4} *	callq +[a-f0-9]+ <foo>
-#pass
+#error: invalid number for -z call-nop=prefix-: nop
diff --git a/opcodes/ChangeLog b/opcodes/ChangeLog
index 7f01e54188..dc6c635360 100644
--- a/opcodes/ChangeLog
+++ b/opcodes/ChangeLog
@@ -1,3 +1,77 @@
+2017-07-05  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline
+	2017-07-04  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+	* arm-dis.c: Support MVFR2 in disassembly with vmrs and vmsr.
+
+2017-05-01  Michael Clark  <michaeljclark@mac.com>
+
+	* riscv-opc.c (riscv_opcodes) <call>: Use RA not T1 as a temporary
+	register.
+
+2017-04-03  Palmer Dabbelt  <palmer@dabbelt.com>
+
+	* riscv-dis.c (riscv_disassemble_insn): Change "_gp" to
+	RISCV_GP_SYMBOL.
+
+2017-03-14  Kito Cheng  <kito.cheng@gmail.com>
+
+	* riscv-opc.c (riscv_opcodes> <c.li>: Use the 'o' immediate encoding.
+	<c.andi>: Likewise.
+	<c.addiw> Likewise.
+
+2017-03-14  Kito Cheng  <kito.cheng@gmail.com>
+
+	* riscv-opc.c (riscv_opcodes) <c.addi>: Use match_opcode.
+
+2017-03-13  Andrew Waterman  <andrew@sifive.com>
+
+	* riscv-opc.c (riscv_opcodes) <srli/C>: Use match_opcode.
+	<srl> Likewise.
+	<srai> Likewise.
+	<sra> Likewise.
+
+2017-03-27  Alan Modra  <amodra@gmail.com>
+
+	PR 21303
+	* ppc-dis.c (struct ppc_mopt): Comment.
+	(ppc_opts <e200z4>): Move PPC_OPCODE_VLE from .sticky to .cpu.
+
+2017-03-21  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2017-03-21  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* s390-mkopc.c (main): Remove vx2 check.
+	* s390-opc.txt: Remove vx2 instruction flags.
+
+2017-03-08  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* ppc-dis.c (ppc_opts) <altivec>: Do not use PPC_OPCODE_ALTIVEC2;
+	<vsx>: Do not use PPC_OPCODE_VSX3;
+
+2017-03-08  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Apply from master.
+	2017-03-08  Peter Bergner  <bergner@vnet.ibm.com>
+	* ppc-opc.c (powerpc_opcodes) <lnia>: New extended mnemonic.
+
+2017-03-07  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-03-06  Alan Modra  <amodra@gmail.com>
+	PR 21124
+	* ppc-opc.c (extract_esync, extract_ls, extract_ral, extract_ram)
+	(extract_raq, extract_ras, extract_rbx): New functions.
+	(powerpc_operands): Use opposite corresponding insert function.
+	(Q_MASK): Define.
+	(powerpc_opcodes): Apply Q_MASK to all quad insns with even
+	register restriction.
+
+2017-03-02  Tristan Gingold  <gingold@adacore.com>
+
+	* configure: Regenerate.
+
 2017-03-02  Tristan Gingold  <gingold@adacore.com>
 
 	* configure: Regenerate.
diff --git a/opcodes/arm-dis.c b/opcodes/arm-dis.c
index 167c6685c5..eeeea58cbd 100644
--- a/opcodes/arm-dis.c
+++ b/opcodes/arm-dis.c
@@ -506,6 +506,8 @@ static const struct opcode32 coprocessor_opcodes[] =
     0x0ee60a10, 0x0fff0fff, "vmsr%c\tmvfr1, %12-15r"},
   {ARM_FEATURE_COPROC (FPU_VFP_EXT_V1xD),
     0x0ee70a10, 0x0fff0fff, "vmsr%c\tmvfr0, %12-15r"},
+  {ARM_FEATURE_COPROC (FPU_VFP_EXT_ARMV8),
+    0x0ee50a10, 0x0fff0fff, "vmsr%c\tmvfr2, %12-15r"},
   {ARM_FEATURE_COPROC (FPU_VFP_EXT_V1xD),
     0x0ee80a10, 0x0fff0fff, "vmsr%c\tfpexc, %12-15r"},
   {ARM_FEATURE_COPROC (FPU_VFP_EXT_V1xD),
@@ -518,6 +520,8 @@ static const struct opcode32 coprocessor_opcodes[] =
     0x0ef1fa10, 0x0fffffff, "vmrs%c\tAPSR_nzcv, fpscr"},
   {ARM_FEATURE_COPROC (FPU_VFP_EXT_V1xD),
     0x0ef10a10, 0x0fff0fff, "vmrs%c\t%12-15r, fpscr"},
+  {ARM_FEATURE_COPROC (FPU_VFP_EXT_ARMV8),
+    0x0ef50a10, 0x0fff0fff, "vmrs%c\t%12-15r, mvfr2"},
   {ARM_FEATURE_COPROC (FPU_VFP_EXT_V1xD),
     0x0ef60a10, 0x0fff0fff, "vmrs%c\t%12-15r, mvfr1"},
   {ARM_FEATURE_COPROC (FPU_VFP_EXT_V1xD),
diff --git a/opcodes/configure b/opcodes/configure
index be87eb22a5..0b352a454d 100755
--- a/opcodes/configure
+++ b/opcodes/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.64 for opcodes 2.28.
+# Generated by GNU Autoconf 2.64 for opcodes 2.28.0.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
@@ -556,8 +556,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='opcodes'
 PACKAGE_TARNAME='opcodes'
-PACKAGE_VERSION='2.28'
-PACKAGE_STRING='opcodes 2.28'
+PACKAGE_VERSION='2.28.0'
+PACKAGE_STRING='opcodes 2.28.0'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
@@ -1322,7 +1322,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures opcodes 2.28 to adapt to many kinds of systems.
+\`configure' configures opcodes 2.28.0 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1393,7 +1393,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of opcodes 2.28:";;
+     short | recursive ) echo "Configuration of opcodes 2.28.0:";;
    esac
   cat <<\_ACEOF
 
@@ -1500,7 +1500,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-opcodes configure 2.28
+opcodes configure 2.28.0
 generated by GNU Autoconf 2.64
 
 Copyright (C) 2009 Free Software Foundation, Inc.
@@ -1910,7 +1910,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by opcodes $as_me 2.28, which was
+It was created by opcodes $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   $ $0 $@
@@ -3719,7 +3719,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='opcodes'
- VERSION='2.28'
+ VERSION='2.28.0'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -13305,7 +13305,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by opcodes $as_me 2.28, which was
+This file was extended by opcodes $as_me 2.28.0, which was
 generated by GNU Autoconf 2.64.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -13369,7 +13369,7 @@ Report bugs to the package provider."
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-opcodes config.status 2.28
+opcodes config.status 2.28.0
 configured by $0, generated by GNU Autoconf 2.64,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
diff --git a/opcodes/ppc-dis.c b/opcodes/ppc-dis.c
index e0eff7a67b..baa73880aa 100644
--- a/opcodes/ppc-dis.c
+++ b/opcodes/ppc-dis.c
@@ -45,8 +45,19 @@ struct dis_private
   (((struct dis_private *) ((INFO)->private_data))->dialect)
 
 struct ppc_mopt {
+  /* Option string, without -m or -M prefix.  */
   const char *opt;
+  /* CPU option flags.  */
   ppc_cpu_t cpu;
+  /* Flags that should stay on, even when combined with another cpu
+     option.  This should only be used for generic options like
+     "-many" or "-maltivec" where it is reasonable to add some
+     capability to another cpu selection.  The added flags are sticky
+     so that, for example, "-many -me500" and "-me500 -many" result in
+     the same assembler or disassembler behaviour.  Do not use
+     "sticky" for specific cpus, as this will prevent that cpu's flags
+     from overriding the defaults set in powerpc_init_dialect or a
+     prior -m option.  */
   ppc_cpu_t sticky;
 };
 
@@ -93,7 +104,7 @@ struct ppc_mopt ppc_opts[] = {
 		| PPC_OPCODE_A2),
     0 },
   { "altivec", PPC_OPCODE_PPC,
-    PPC_OPCODE_ALTIVEC | PPC_OPCODE_ALTIVEC2 },
+    PPC_OPCODE_ALTIVEC },
   { "any",     0,
     PPC_OPCODE_ANY },
   { "booke",   PPC_OPCODE_PPC | PPC_OPCODE_BOOKE,
@@ -108,8 +119,8 @@ struct ppc_mopt ppc_opts[] = {
   { "e200z4",  (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE| PPC_OPCODE_SPE
 		| PPC_OPCODE_ISEL | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
 		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
-		| PPC_OPCODE_E500 | PPC_OPCODE_E200Z4),
-    PPC_OPCODE_VLE },
+		| PPC_OPCODE_E500 | PPC_OPCODE_VLE | PPC_OPCODE_E200Z4),
+    0 },
   { "e300",    PPC_OPCODE_PPC | PPC_OPCODE_E300,
     0 },
   { "e500",    (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_SPE
@@ -221,7 +232,7 @@ struct ppc_mopt ppc_opts[] = {
 		| PPC_OPCODE_E500),
     PPC_OPCODE_VLE },
   { "vsx",     PPC_OPCODE_PPC,
-    PPC_OPCODE_VSX | PPC_OPCODE_VSX3 },
+    PPC_OPCODE_VSX },
   { "htm",     PPC_OPCODE_PPC,
     PPC_OPCODE_HTM },
 };
diff --git a/opcodes/ppc-opc.c b/opcodes/ppc-opc.c
index 9ac779c96a..f7d1dcd7c2 100644
--- a/opcodes/ppc-opc.c
+++ b/opcodes/ppc-opc.c
@@ -54,6 +54,7 @@ static long extract_bo (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_boe (unsigned long, long, ppc_cpu_t, const char **);
 static long extract_boe (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_esync (unsigned long, long, ppc_cpu_t, const char **);
+static long extract_esync (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_dcmxs (unsigned long, long, ppc_cpu_t, const char **);
 static long extract_dcmxs (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_dxd (unsigned long, long, ppc_cpu_t, const char **);
@@ -65,6 +66,7 @@ static long extract_fxm (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_li20 (unsigned long, long, ppc_cpu_t, const char **);
 static long extract_li20 (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_ls (unsigned long, long, ppc_cpu_t, const char **);
+static long extract_ls (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_mbe (unsigned long, long, ppc_cpu_t, const char **);
 static long extract_mbe (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_mb6 (unsigned long, long, ppc_cpu_t, const char **);
@@ -76,12 +78,17 @@ static long extract_nsi (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_oimm (unsigned long, long, ppc_cpu_t, const char **);
 static long extract_oimm (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_ral (unsigned long, long, ppc_cpu_t, const char **);
+static long extract_ral (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_ram (unsigned long, long, ppc_cpu_t, const char **);
+static long extract_ram (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_raq (unsigned long, long, ppc_cpu_t, const char **);
+static long extract_raq (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_ras (unsigned long, long, ppc_cpu_t, const char **);
+static long extract_ras (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_rbs (unsigned long, long, ppc_cpu_t, const char **);
 static long extract_rbs (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_rbx (unsigned long, long, ppc_cpu_t, const char **);
+static long extract_rbx (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_rx (unsigned long, long, ppc_cpu_t, const char **);
 static long extract_rx (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_ry (unsigned long, long, ppc_cpu_t, const char **);
@@ -462,7 +469,7 @@ const struct powerpc_operand powerpc_operands[] =
   /* The LS or WC field in an X (sync or wait) form instruction.  */
 #define LS LIA + 1
 #define WC LS
-  { 0x3, 21, insert_ls, NULL, PPC_OPERAND_OPTIONAL },
+  { 0x3, 21, insert_ls, extract_ls, PPC_OPERAND_OPTIONAL },
 
   /* The ME field in an M form instruction.  */
 #define ME LS + 1
@@ -519,24 +526,24 @@ const struct powerpc_operand powerpc_operands[] =
      value restrictions.  */
 #define RAQ RA0 + 1
 #define RAX RAQ
-  { 0x1f, 16, insert_raq, NULL, PPC_OPERAND_GPR_0 },
+  { 0x1f, 16, insert_raq, extract_raq, PPC_OPERAND_GPR_0 },
 
   /* The RA field in a D or X form instruction which is an updating
      load, which means that the RA field may not be zero and may not
      equal the RT field.  */
 #define RAL RAQ + 1
-  { 0x1f, 16, insert_ral, NULL, PPC_OPERAND_GPR_0 },
+  { 0x1f, 16, insert_ral, extract_ral, PPC_OPERAND_GPR_0 },
 
   /* The RA field in an lmw instruction, which has special value
      restrictions.  */
 #define RAM RAL + 1
-  { 0x1f, 16, insert_ram, NULL, PPC_OPERAND_GPR_0 },
+  { 0x1f, 16, insert_ram, extract_ram, PPC_OPERAND_GPR_0 },
 
   /* The RA field in a D or X form instruction which is an updating
      store or an updating floating point load, which means that the RA
      field may not be zero.  */
 #define RAS RAM + 1
-  { 0x1f, 16, insert_ras, NULL, PPC_OPERAND_GPR_0 },
+  { 0x1f, 16, insert_ras, extract_ras, PPC_OPERAND_GPR_0 },
 
   /* The RA field of the tlbwe, dccci and iccci instructions,
      which are optional.  */
@@ -557,7 +564,7 @@ const struct powerpc_operand powerpc_operands[] =
   /* The RB field in an lswx instruction, which has special value
      restrictions.  */
 #define RBX RBS + 1
-  { 0x1f, 11, insert_rbx, NULL, PPC_OPERAND_GPR },
+  { 0x1f, 11, insert_rbx, extract_rbx, PPC_OPERAND_GPR },
 
   /* The RB field of the dccci and iccci instructions, which are optional.  */
 #define RBOPT RBX + 1
@@ -580,6 +587,7 @@ const struct powerpc_operand powerpc_operands[] =
      which have special value restrictions.  */
 #define RSQ RS + 1
 #define RTQ RSQ
+#define Q_MASK (1 << 21)
   { 0x1e, 21, NULL, NULL, PPC_OPERAND_GPR },
 
   /* The RS field of the tlbwe instruction, which is optional.  */
@@ -694,7 +702,7 @@ const struct powerpc_operand powerpc_operands[] =
 
   /* The ESYNC field in an X (sync) form instruction.  */
 #define ESYNC STRM + 1
-  { 0xf, 16, insert_esync, NULL, PPC_OPERAND_OPTIONAL },
+  { 0xf, 16, insert_esync, extract_esync, PPC_OPERAND_OPTIONAL },
 
   /* The SV field in a POWER SC form instruction.  */
 #define SV ESYNC + 1
@@ -1533,6 +1541,22 @@ insert_ls (unsigned long insn,
   return insn | ((value & 0x3) << 21);
 }
 
+static long
+extract_ls (unsigned long insn,
+	    ppc_cpu_t dialect,
+	    int *invalid)
+{
+  unsigned long lvalue = (insn >> 21) & 3;
+
+  if (((insn >> 1) & 0x3ff) == 598)
+    {
+      unsigned long max_lvalue = (dialect & PPC_OPCODE_POWER4) ? 2 : 1;
+      if (lvalue > max_lvalue)
+	*invalid = 1;
+    }
+  return lvalue;
+}
+
 /* The 4-bit E field in a sync instruction that accepts 2 operands.
    If ESYNC is non-zero, then the L field must be either 0 or 1 and
    the complement of ESYNC-bit2.  */
@@ -1560,6 +1584,27 @@ insert_esync (unsigned long insn,
   return insn | ((value & 0xf) << 16);
 }
 
+static long
+extract_esync (unsigned long insn,
+	       ppc_cpu_t dialect,
+	       int *invalid)
+{
+  unsigned long ls = (insn >> 21) & 0x3;
+  unsigned long lvalue = (insn >> 16) & 0xf;
+
+  if (lvalue == 0)
+    {
+      if (((dialect & PPC_OPCODE_E6500) != 0 && ls > 1)
+	  || ((dialect & PPC_OPCODE_POWER9) != 0 && ls > 2))
+	*invalid = 1;
+    }
+  else if ((ls & ~0x1)
+	   || (((lvalue >> 1) & 0x1) ^ ls) == 0)
+    *invalid = 1;
+
+  return lvalue;
+}
+
 /* The MB and ME fields in an M form instruction expressed as a single
    operand which is itself a bitmask.  The extraction function always
    marks it as invalid, since we never want to recognize an
@@ -1743,6 +1788,19 @@ insert_ral (unsigned long insn,
   return insn | ((value & 0x1f) << 16);
 }
 
+static long
+extract_ral (unsigned long insn,
+	     ppc_cpu_t dialect ATTRIBUTE_UNUSED,
+	     int *invalid)
+{
+  long rtvalue = (insn >> 21) & 0x1f;
+  long ravalue = (insn >> 16) & 0x1f;
+
+  if (rtvalue == ravalue || ravalue == 0)
+    *invalid = 1;
+  return ravalue;
+}
+
 /* The RA field in an lmw instruction, which has special value
    restrictions.  */
 
@@ -1757,6 +1815,19 @@ insert_ram (unsigned long insn,
   return insn | ((value & 0x1f) << 16);
 }
 
+static long
+extract_ram (unsigned long insn,
+	     ppc_cpu_t dialect ATTRIBUTE_UNUSED,
+	     int *invalid)
+{
+  unsigned long rtvalue = (insn >> 21) & 0x1f;
+  unsigned long ravalue = (insn >> 16) & 0x1f;
+
+  if (ravalue >= rtvalue)
+    *invalid = 1;
+  return ravalue;
+}
+
 /* The RA field in the DQ form lq or an lswx instruction, which have special
    value restrictions.  */
 
@@ -1773,6 +1844,19 @@ insert_raq (unsigned long insn,
   return insn | ((value & 0x1f) << 16);
 }
 
+static long
+extract_raq (unsigned long insn,
+	     ppc_cpu_t dialect ATTRIBUTE_UNUSED,
+	     int *invalid)
+{
+  unsigned long rtvalue = (insn >> 21) & 0x1f;
+  unsigned long ravalue = (insn >> 16) & 0x1f;
+
+  if (ravalue == rtvalue)
+    *invalid = 1;
+  return ravalue;
+}
+
 /* The RA field in a D or X form instruction which is an updating
    store or an updating floating point load, which means that the RA
    field may not be zero.  */
@@ -1788,6 +1872,18 @@ insert_ras (unsigned long insn,
   return insn | ((value & 0x1f) << 16);
 }
 
+static long
+extract_ras (unsigned long insn,
+	     ppc_cpu_t dialect ATTRIBUTE_UNUSED,
+	     int *invalid)
+{
+  unsigned long ravalue = (insn >> 16) & 0x1f;
+
+  if (ravalue == 0)
+    *invalid = 1;
+  return ravalue;
+}
+
 /* The RB field in an X form instruction when it must be the same as
    the RS field in the instruction.  This is used for extended
    mnemonics like mr.  This operand is marked FAKE.  The insertion
@@ -1829,6 +1925,19 @@ insert_rbx (unsigned long insn,
   return insn | ((value & 0x1f) << 11);
 }
 
+static long
+extract_rbx (unsigned long insn,
+	     ppc_cpu_t dialect ATTRIBUTE_UNUSED,
+	     int *invalid)
+{
+  unsigned long rtvalue = (insn >> 21) & 0x1f;
+  unsigned long rbvalue = (insn >> 11) & 0x1f;
+
+  if (rbvalue == rtvalue)
+    *invalid = 1;
+  return rbvalue;
+}
+
 /* The SCI8 field is made up of SCL and {U,N}I8 fields.  */
 static unsigned long
 insert_sci8 (unsigned long insn,
@@ -2443,6 +2552,8 @@ extract_vleil (unsigned long insn,
 /* An DX form instruction.  */
 #define DX(op, xop) (OP (op) | ((((unsigned long)(xop)) & 0x1f) << 1))
 #define DX_MASK DX (0x3f, 0x1f)
+/* An DX form instruction with the D bits specified.  */
+#define NODX_MASK (DX_MASK | 0x1fffc1)
 
 /* An EVSEL form instruction.  */
 #define EVSEL(op, xop) (OP (op) | (((unsigned long)(xop)) & 0xff) << 3)
@@ -4155,6 +4266,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"mcrf",     XL(19,0), XLBB_MASK|(3<<21)|(3<<16), COM,	PPCVLE,		{BF, BFA}},
 
+{"lnia",     DX(19,2),		NODX_MASK,   POWER9,	PPCVLE,		{RT}},
 {"addpcis",  DX(19,2),		DX_MASK,     POWER9,	PPCVLE,		{RT, DXD}},
 {"subpcis",  DX(19,2),		DX_MASK,     POWER9,	PPCVLE,		{RT, NDXD}},
 
@@ -4974,7 +5086,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"stdux",	X(31,181),	X_MASK,	     PPC64,	0,		{RS, RAS, RB}},
 
-{"stqcx.",	XRC(31,182,1),	X_MASK,	     POWER8,	0,		{RSQ, RA0, RB}},
+{"stqcx.",	XRC(31,182,1), X_MASK|Q_MASK, POWER8,	0,		{RSQ, RA0, RB}},
 {"wchkall",	X(31,182),	X_MASK,	     PPCA2,	0,		{OBF}},
 
 {"stwux",	X(31,183),	X_MASK,	     PPCCOM,	0,		{RS, RAS, RB}},
@@ -5105,7 +5217,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"mfapidi",	X(31,275),	X_MASK,	     BOOKE,	E500|TITAN,	{RT, RA}},
 
-{"lqarx",	X(31,276),	XEH_MASK,    POWER8,	0,		{RTQ, RAX, RBX, EH}},
+{"lqarx",	X(31,276),  XEH_MASK|Q_MASK, POWER8,	0,		{RTQ, RAX, RBX, EH}},
 
 {"lscbx",	XRC(31,277,0),	X_MASK,	     M601,	0,		{RT, RA, RB}},
 {"lscbx.",	XRC(31,277,1),	X_MASK,	     M601,	0,		{RT, RA, RB}},
@@ -6052,7 +6164,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"lhbrx",	X(31,790),	X_MASK,	     COM,	0,		{RT, RA0, RB}},
 
-{"lfdpx",	X(31,791),	X_MASK,	     POWER6,	POWER7,		{FRTp, RA0, RB}},
+{"lfdpx",	X(31,791),    X_MASK|Q_MASK, POWER6,	POWER7,		{FRTp, RA0, RB}},
 {"lfqx",	X(31,791),	X_MASK,	     POWER2,	0,		{FRT, RA, RB}},
 
 {"sraw",	XRC(31,792,0),	X_MASK,	     PPCCOM,	0,		{RA, RS, RB}},
@@ -6167,7 +6279,7 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"sthbrx",	X(31,918),	X_MASK,	     COM,	0,		{RS, RA0, RB}},
 
-{"stfdpx",	X(31,919),	X_MASK,	     POWER6,	POWER7,		{FRSp, RA0, RB}},
+{"stfdpx",	X(31,919),    X_MASK|Q_MASK, POWER6,	POWER7,		{FRSp, RA0, RB}},
 {"stfqx",	X(31,919),	X_MASK,	     POWER2,	0,		{FRS, RA0, RB}},
 
 {"sraq",	XRC(31,920,0),	X_MASK,	     M601,	0,		{RA, RS, RB}},
@@ -6345,13 +6457,13 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"stfdu",	OP(55),		OP_MASK,     COM,	PPCEFS|PPCVLE,	{FRS, D, RAS}},
 
-{"lq",		OP(56),		OP_MASK,     POWER4,	PPC476|PPCVLE,	{RTQ, DQ, RAQ}},
+{"lq",		OP(56),	     OP_MASK|Q_MASK, POWER4,	PPC476|PPCVLE,	{RTQ, DQ, RAQ}},
 {"psq_l",	OP(56),		OP_MASK,     PPCPS,	PPCVLE,		{FRT,PSD,RA,PSW,PSQ}},
 {"lfq",		OP(56),		OP_MASK,     POWER2,	PPCVLE,		{FRT, D, RA0}},
 
 {"lxsd",	DSO(57,2),	DS_MASK,     PPCVSX3,	PPCVLE,		{VD, DS, RA0}},
 {"lxssp",	DSO(57,3),	DS_MASK,     PPCVSX3,	PPCVLE,		{VD, DS, RA0}},
-{"lfdp",	OP(57),		OP_MASK,     POWER6,	POWER7|PPCVLE,	{FRTp, DS, RA0}},
+{"lfdp",	OP(57),	     OP_MASK|Q_MASK, POWER6,	POWER7|PPCVLE,	{FRTp, DS, RA0}},
 {"psq_lu",	OP(57),		OP_MASK,     PPCPS,	PPCVLE,		{FRT,PSD,RA,PSW,PSQ}},
 {"lfqu",	OP(57),		OP_MASK,     POWER2,	PPCVLE,		{FRT, D, RA0}},
 
@@ -6676,21 +6788,21 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"stxv",	DQX(61,5),	DQX_MASK,    PPCVSX3,	PPCVLE,		{XSQ6, DQ, RA0}},
 {"stxsd",	DSO(61,2),	DS_MASK,     PPCVSX3,	PPCVLE,		{VS, DS, RA0}},
 {"stxssp",	DSO(61,3),	DS_MASK,     PPCVSX3,	PPCVLE,		{VS, DS, RA0}},
-{"stfdp",	OP(61),		OP_MASK,     POWER6,	POWER7|PPCVLE,	{FRSp, DS, RA0}},
+{"stfdp",	OP(61),	     OP_MASK|Q_MASK, POWER6,	POWER7|PPCVLE,	{FRSp, DS, RA0}},
 {"psq_stu",	OP(61),		OP_MASK,     PPCPS,	PPCVLE,		{FRS,PSD,RA,PSW,PSQ}},
 {"stfqu",	OP(61),		OP_MASK,     POWER2,	PPCVLE,		{FRS, D, RA}},
 
 {"std",		DSO(62,0),	DS_MASK,     PPC64,	PPCVLE,		{RS, DS, RA0}},
 {"stdu",	DSO(62,1),	DS_MASK,     PPC64,	PPCVLE,		{RS, DS, RAS}},
-{"stq",		DSO(62,2),	DS_MASK,     POWER4,	PPC476|PPCVLE,	{RSQ, DS, RA0}},
+{"stq",		DSO(62,2),   DS_MASK|Q_MASK, POWER4,	PPC476|PPCVLE,	{RSQ, DS, RA0}},
 
 {"fcmpu",	X(63,0),	XBF_MASK,    COM,	PPCEFS|PPCVLE,	{BF, FRA, FRB}},
 
-{"daddq",	XRC(63,2,0),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
-{"daddq.",	XRC(63,2,1),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
+{"daddq",	XRC(63,2,0),  X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
+{"daddq.",	XRC(63,2,1),  X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
 
-{"dquaq",	ZRC(63,3,0),	Z2_MASK,     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp, RMC}},
-{"dquaq.",	ZRC(63,3,1),	Z2_MASK,     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp, RMC}},
+{"dquaq",	ZRC(63,3,0), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp, RMC}},
+{"dquaq.",	ZRC(63,3,1), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp, RMC}},
 
 {"xsaddqp",	XRC(63,4,0),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
 {"xsaddqpo",	XRC(63,4,1),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
@@ -6772,11 +6884,11 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"fcmpo",	X(63,32),	XBF_MASK,    COM,	PPCEFS|PPCVLE,	{BF, FRA, FRB}},
 
-{"dmulq",	XRC(63,34,0),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
-{"dmulq.",	XRC(63,34,1),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
+{"dmulq",	XRC(63,34,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
+{"dmulq.",	XRC(63,34,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
 
-{"drrndq",	ZRC(63,35,0),	Z2_MASK,     POWER6,	PPCVLE,		{FRTp, FRA, FRBp, RMC}},
-{"drrndq.",	ZRC(63,35,1),	Z2_MASK,     POWER6,	PPCVLE,		{FRTp, FRA, FRBp, RMC}},
+{"drrndq",	ZRC(63,35,0), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRA, FRBp, RMC}},
+{"drrndq.",	ZRC(63,35,1), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRA, FRBp, RMC}},
 
 {"xsmulqp",	XRC(63,36,0),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
 {"xsmulqpo",	XRC(63,36,1),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
@@ -6791,11 +6903,11 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 
 {"mcrfs",      X(63,64), XRB_MASK|(3<<21)|(3<<16), COM,	PPCVLE,		{BF, BFA}},
 
-{"dscliq",	ZRC(63,66,0),	Z_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, SH16}},
-{"dscliq.",	ZRC(63,66,1),	Z_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, SH16}},
+{"dscliq",	ZRC(63,66,0), Z_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, SH16}},
+{"dscliq.",	ZRC(63,66,1), Z_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, SH16}},
 
-{"dquaiq",	ZRC(63,67,0),	Z2_MASK,     POWER6,	PPCVLE,		{TE, FRTp, FRBp, RMC}},
-{"dquaiq.",	ZRC(63,67,1),	Z2_MASK,     POWER6,	PPCVLE,		{TE, FRTp, FRBp, RMC}},
+{"dquaiq",	ZRC(63,67,0), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{TE, FRTp, FRBp, RMC}},
+{"dquaiq.",	ZRC(63,67,1), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{TE, FRTp, FRBp, RMC}},
 
 {"mtfsb0",	XRC(63,70,0),	XRARB_MASK,  COM,	PPCVLE,		{BT}},
 {"mtfsb0.",	XRC(63,70,1),	XRARB_MASK,  COM,	PPCVLE,		{BT}},
@@ -6803,11 +6915,11 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"fmr",		XRC(63,72,0),	XRA_MASK,    COM,	PPCEFS|PPCVLE,	{FRT, FRB}},
 {"fmr.",	XRC(63,72,1),	XRA_MASK,    COM,	PPCEFS|PPCVLE,	{FRT, FRB}},
 
-{"dscriq",	ZRC(63,98,0),	Z_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, SH16}},
-{"dscriq.",	ZRC(63,98,1),	Z_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, SH16}},
+{"dscriq",	ZRC(63,98,0), Z_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, SH16}},
+{"dscriq.",	ZRC(63,98,1), Z_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, SH16}},
 
-{"drintxq",	ZRC(63,99,0),	Z2_MASK,     POWER6,	PPCVLE,		{R, FRTp, FRBp, RMC}},
-{"drintxq.",	ZRC(63,99,1),	Z2_MASK,     POWER6,	PPCVLE,		{R, FRTp, FRBp, RMC}},
+{"drintxq",	ZRC(63,99,0), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{R, FRTp, FRBp, RMC}},
+{"drintxq.",	ZRC(63,99,1), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{R, FRTp, FRBp, RMC}},
 
 {"xscpsgnqp",	X(63,100),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
 
@@ -6839,11 +6951,11 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"dtstdcq",	Z(63,194),	Z_MASK,	     POWER6,	PPCVLE,		{BF, FRAp, DCM}},
 {"dtstdgq",	Z(63,226),	Z_MASK,	     POWER6,	PPCVLE,		{BF, FRAp, DGM}},
 
-{"drintnq",	ZRC(63,227,0),	Z2_MASK,     POWER6,	PPCVLE,		{R, FRTp, FRBp, RMC}},
-{"drintnq.",	ZRC(63,227,1),	Z2_MASK,     POWER6,	PPCVLE,		{R, FRTp, FRBp, RMC}},
+{"drintnq",	ZRC(63,227,0), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{R, FRTp, FRBp, RMC}},
+{"drintnq.",	ZRC(63,227,1), Z2_MASK|Q_MASK, POWER6,	PPCVLE,		{R, FRTp, FRBp, RMC}},
 
-{"dctqpq",	XRC(63,258,0),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRB}},
-{"dctqpq.",	XRC(63,258,1),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRB}},
+{"dctqpq",	XRC(63,258,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRB}},
+{"dctqpq.",	XRC(63,258,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRB}},
 
 {"fabs",	XRC(63,264,0),	XRA_MASK,    COM,	PPCEFS|PPCVLE,	{FRT, FRB}},
 {"fabs.",	XRC(63,264,1),	XRA_MASK,    COM,	PPCEFS|PPCVLE,	{FRT, FRB}},
@@ -6851,8 +6963,8 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"dctfixq",	XRC(63,290,0),	X_MASK,	     POWER6,	PPCVLE,		{FRT, FRBp}},
 {"dctfixq.",	XRC(63,290,1),	X_MASK,	     POWER6,	PPCVLE,		{FRT, FRBp}},
 
-{"ddedpdq",	XRC(63,322,0),	X_MASK,	     POWER6,	PPCVLE,		{SP, FRTp, FRBp}},
-{"ddedpdq.",	XRC(63,322,1),	X_MASK,	     POWER6,	PPCVLE,		{SP, FRTp, FRBp}},
+{"ddedpdq",	XRC(63,322,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{SP, FRTp, FRBp}},
+{"ddedpdq.",	XRC(63,322,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{SP, FRTp, FRBp}},
 
 {"dxexq",	XRC(63,354,0),	X_MASK,	     POWER6,	PPCVLE,		{FRT, FRBp}},
 {"dxexq.",	XRC(63,354,1),	X_MASK,	     POWER6,	PPCVLE,		{FRT, FRBp}},
@@ -6881,14 +6993,14 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"frim",	XRC(63,488,0),	XRA_MASK,    POWER5,	PPCVLE,		{FRT, FRB}},
 {"frim.",	XRC(63,488,1),	XRA_MASK,    POWER5,	PPCVLE,		{FRT, FRB}},
 
-{"dsubq",	XRC(63,514,0),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
-{"dsubq.",	XRC(63,514,1),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
+{"dsubq",	XRC(63,514,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
+{"dsubq.",	XRC(63,514,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
 
 {"xssubqp",	XRC(63,516,0),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
 {"xssubqpo",	XRC(63,516,1),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
 
-{"ddivq",	XRC(63,546,0),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
-{"ddivq.",	XRC(63,546,1),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
+{"ddivq",	XRC(63,546,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
+{"ddivq.",	XRC(63,546,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRAp, FRBp}},
 
 {"xsdivqp",	XRC(63,548,0),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
 {"xsdivqpo",	XRC(63,548,1),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
@@ -6917,11 +7029,11 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"mtfsf.",	XFL(63,711,1),	XFL_MASK, POWER6|PPCA2|PPC476, PPCVLE,	{FLM, FRB, XFL_L, W}},
 {"mtfsf.",	XFL(63,711,1),	XFL_MASK,    COM, POWER6|PPCA2|PPC476|PPCEFS|PPCVLE, {FLM, FRB}},
 
-{"drdpq",	XRC(63,770,0),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRBp}},
-{"drdpq.",	XRC(63,770,1),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRBp}},
+{"drdpq",	XRC(63,770,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRBp}},
+{"drdpq.",	XRC(63,770,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRBp}},
 
-{"dcffixq",	XRC(63,802,0),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRB}},
-{"dcffixq.",	XRC(63,802,1),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRB}},
+{"dcffixq",	XRC(63,802,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRB}},
+{"dcffixq.",	XRC(63,802,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRB}},
 
 {"xsabsqp",	XVA(63,804,0),	XVA_MASK,    PPCVSX3,	PPCVLE,		{VD, VB}},
 {"xsxexpqp",	XVA(63,804,2),	XVA_MASK,    PPCVSX3,	PPCVLE,		{VD, VB}},
@@ -6941,8 +7053,8 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"fctidz.",	XRC(63,815,1),	XRA_MASK,    PPC64,	PPCVLE,		{FRT, FRB}},
 {"fctidz.",	XRC(63,815,1),	XRA_MASK,    PPC476,	PPCVLE,		{FRT, FRB}},
 
-{"denbcdq",	XRC(63,834,0),	X_MASK,	     POWER6,	PPCVLE,		{S, FRTp, FRBp}},
-{"denbcdq.",	XRC(63,834,1),	X_MASK,	     POWER6,	PPCVLE,		{S, FRTp, FRBp}},
+{"denbcdq",	XRC(63,834,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{S, FRTp, FRBp}},
+{"denbcdq.",	XRC(63,834,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{S, FRTp, FRBp}},
 
 {"xscvqpuwz",	XVA(63,836,1),	XVA_MASK,    PPCVSX3,	PPCVLE,		{VD, VB}},
 {"xscvudqp",	XVA(63,836,2),	XVA_MASK,    PPCVSX3,	PPCVLE,		{VD, VB}},
@@ -6961,8 +7073,8 @@ const struct powerpc_opcode powerpc_opcodes[] = {
 {"fcfid.",	XRC(63,846,1),	XRA_MASK,    PPC64,	PPCVLE,		{FRT, FRB}},
 {"fcfid.",	XRC(63,846,1),	XRA_MASK,    PPC476,	PPCVLE,		{FRT, FRB}},
 
-{"diexq",	XRC(63,866,0),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRA, FRBp}},
-{"diexq.",	XRC(63,866,1),	X_MASK,	     POWER6,	PPCVLE,		{FRTp, FRA, FRBp}},
+{"diexq",	XRC(63,866,0), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRA, FRBp}},
+{"diexq.",	XRC(63,866,1), X_MASK|Q_MASK, POWER6,	PPCVLE,		{FRTp, FRA, FRBp}},
 
 {"xsiexpqp",	X(63,868),	X_MASK,	     PPCVSX3,	PPCVLE,		{VD, VA, VB}},
 
diff --git a/opcodes/riscv-dis.c b/opcodes/riscv-dis.c
index 070c96ec74..bdc961c317 100644
--- a/opcodes/riscv-dis.c
+++ b/opcodes/riscv-dis.c
@@ -383,7 +383,7 @@ riscv_disassemble_insn (bfd_vma memaddr, insn_t word, disassemble_info *info)
 	pd->hi_addr[i] = -1;
 
       for (i = 0; i < info->symtab_size; i++)
-	if (strcmp (bfd_asymbol_name (info->symtab[i]), "_gp") == 0)
+	if (strcmp (bfd_asymbol_name (info->symtab[i]), RISCV_GP_SYMBOL) == 0)
 	  pd->gp = bfd_asymbol_value (info->symtab[i]);
     }
   else
diff --git a/opcodes/riscv-opc.c b/opcodes/riscv-opc.c
index 867a02682c..8343198366 100644
--- a/opcodes/riscv-opc.c
+++ b/opcodes/riscv-opc.c
@@ -147,7 +147,7 @@ const struct riscv_opcode riscv_opcodes[] =
 {"jal",       "32C", "Ca",  MATCH_C_JAL, MASK_C_JAL, match_opcode, INSN_ALIAS },
 {"jal",       "I",   "a",  MATCH_JAL | (X_RA << OP_SH_RD), MASK_JAL | MASK_RD, match_opcode, INSN_ALIAS },
 {"call",      "I",   "d,c", (X_T1 << OP_SH_RS1), (int) M_CALL,  match_never, INSN_MACRO },
-{"call",      "I",   "c", (X_T1 << OP_SH_RS1) | (X_RA << OP_SH_RD), (int) M_CALL,  match_never, INSN_MACRO },
+{"call",      "I",   "c", (X_RA << OP_SH_RS1) | (X_RA << OP_SH_RD), (int) M_CALL,  match_never, INSN_MACRO },
 {"tail",      "I",   "c", (X_T1 << OP_SH_RS1), (int) M_CALL,  match_never, INSN_MACRO },
 {"jump",      "I",   "c,s", 0, (int) M_CALL,  match_never, INSN_MACRO },
 {"nop",       "C",   "",  MATCH_C_ADDI, 0xffff, match_opcode, INSN_ALIAS },
@@ -210,14 +210,14 @@ const struct riscv_opcode riscv_opcodes[] =
 {"sll",       "C",   "d,CU,C>",  MATCH_C_SLLI, MASK_C_SLLI, match_rd_nonzero, INSN_ALIAS },
 {"sll",       "I",   "d,s,t",   MATCH_SLL, MASK_SLL, match_opcode, 0 },
 {"sll",       "I",   "d,s,>",   MATCH_SLLI, MASK_SLLI, match_opcode, INSN_ALIAS },
-{"srli",      "C",   "Cs,Cw,C>",  MATCH_C_SRLI, MASK_C_SRLI, match_rd_nonzero, INSN_ALIAS },
+{"srli",      "C",   "Cs,Cw,C>",  MATCH_C_SRLI, MASK_C_SRLI, match_opcode, INSN_ALIAS },
 {"srli",      "I",   "d,s,>",   MATCH_SRLI, MASK_SRLI, match_opcode, 0 },
-{"srl",       "C",   "Cs,Cw,C>",  MATCH_C_SRLI, MASK_C_SRLI, match_rd_nonzero, INSN_ALIAS },
+{"srl",       "C",   "Cs,Cw,C>",  MATCH_C_SRLI, MASK_C_SRLI, match_opcode, INSN_ALIAS },
 {"srl",       "I",   "d,s,t",   MATCH_SRL, MASK_SRL, match_opcode, 0 },
 {"srl",       "I",   "d,s,>",   MATCH_SRLI, MASK_SRLI, match_opcode, INSN_ALIAS },
-{"srai",      "C",   "Cs,Cw,C>",  MATCH_C_SRAI, MASK_C_SRAI, match_rd_nonzero, INSN_ALIAS },
+{"srai",      "C",   "Cs,Cw,C>",  MATCH_C_SRAI, MASK_C_SRAI, match_opcode, INSN_ALIAS },
 {"srai",      "I",   "d,s,>",   MATCH_SRAI, MASK_SRAI, match_opcode, 0 },
-{"sra",       "C",   "Cs,Cw,C>",  MATCH_C_SRAI, MASK_C_SRAI, match_rd_nonzero, INSN_ALIAS },
+{"sra",       "C",   "Cs,Cw,C>",  MATCH_C_SRAI, MASK_C_SRAI, match_opcode, INSN_ALIAS },
 {"sra",       "I",   "d,s,t",   MATCH_SRA, MASK_SRA, match_opcode, 0 },
 {"sra",       "I",   "d,s,>",   MATCH_SRAI, MASK_SRAI, match_opcode, INSN_ALIAS },
 {"sub",       "C",   "Cs,Cw,Ct",  MATCH_C_SUB, MASK_C_SUB, match_opcode, INSN_ALIAS },
@@ -562,10 +562,10 @@ const struct riscv_opcode riscv_opcodes[] =
 {"c.nop",     "C",   "",  MATCH_C_ADDI, 0xffff, match_opcode, 0 },
 {"c.mv",      "C",   "d,CV",  MATCH_C_MV, MASK_C_MV, match_c_add, 0 },
 {"c.lui",     "C",   "d,Cu",  MATCH_C_LUI, MASK_C_LUI, match_c_lui, 0 },
-{"c.li",      "C",   "d,Cj",  MATCH_C_LI, MASK_C_LI, match_rd_nonzero, 0 },
+{"c.li",      "C",   "d,Co",  MATCH_C_LI, MASK_C_LI, match_rd_nonzero, 0 },
 {"c.addi4spn","C",   "Ct,Cc,CK", MATCH_C_ADDI4SPN, MASK_C_ADDI4SPN, match_opcode, 0 },
 {"c.addi16sp","C",   "Cc,CL", MATCH_C_ADDI16SP, MASK_C_ADDI16SP, match_opcode, 0 },
-{"c.addi",    "C",   "d,Cj",  MATCH_C_ADDI, MASK_C_ADDI, match_rd_nonzero, 0 },
+{"c.addi",    "C",   "d,Cj",  MATCH_C_ADDI, MASK_C_ADDI, match_opcode, 0 },
 {"c.add",     "C",   "d,CV",  MATCH_C_ADD, MASK_C_ADD, match_c_add, 0 },
 {"c.sub",     "C",   "Cs,Ct",  MATCH_C_SUB, MASK_C_SUB, match_opcode, 0 },
 {"c.and",     "C",   "Cs,Ct",  MATCH_C_AND, MASK_C_AND, match_opcode, 0 },
@@ -574,8 +574,8 @@ const struct riscv_opcode riscv_opcodes[] =
 {"c.slli",    "C",   "d,C>",  MATCH_C_SLLI, MASK_C_SLLI, match_rd_nonzero, 0 },
 {"c.srli",    "C",   "Cs,C>",  MATCH_C_SRLI, MASK_C_SRLI, match_opcode, 0 },
 {"c.srai",    "C",   "Cs,C>",  MATCH_C_SRAI, MASK_C_SRAI, match_opcode, 0 },
-{"c.andi",    "C",   "Cs,Cj",  MATCH_C_ANDI, MASK_C_ANDI, match_opcode, 0 },
-{"c.addiw",   "64C", "d,Cj",  MATCH_C_ADDIW, MASK_C_ADDIW, match_rd_nonzero, 0 },
+{"c.andi",    "C",   "Cs,Co",  MATCH_C_ANDI, MASK_C_ANDI, match_opcode, 0 },
+{"c.addiw",   "64C", "d,Co",  MATCH_C_ADDIW, MASK_C_ADDIW, match_rd_nonzero, 0 },
 {"c.addw",    "64C", "Cs,Ct",  MATCH_C_ADDW, MASK_C_ADDW, match_opcode, 0 },
 {"c.subw",    "64C", "Cs,Ct",  MATCH_C_SUBW, MASK_C_SUBW, match_opcode, 0 },
 {"c.ldsp",    "64C", "d,Cn(Cc)",  MATCH_C_LDSP, MASK_C_LDSP, match_rd_nonzero, 0 },
diff --git a/opcodes/s390-mkopc.c b/opcodes/s390-mkopc.c
index 8e0b332585..68c55a9499 100644
--- a/opcodes/s390-mkopc.c
+++ b/opcodes/s390-mkopc.c
@@ -419,10 +419,6 @@ main (void)
 		&& (str[2] == 0 || str[2] == ',')) {
 	      flag_bits |= S390_INSTR_FLAG_VX;
 	      str += 2;
-	    } else if (strncmp (str, "vx2", 3) == 0
-		&& (str[3] == 0 || str[3] == ',')) {
-	      flag_bits |= S390_INSTR_FLAG_VX2;
-	      str += 3;
 	    } else {
 	      fprintf (stderr, "Couldn't parse flags string %s\n",
 		       flags_string);
diff --git a/opcodes/s390-opc.txt b/opcodes/s390-opc.txt
index b3815873aa..51a17f3b37 100644
--- a/opcodes/s390-opc.txt
+++ b/opcodes/s390-opc.txt
@@ -1685,146 +1685,146 @@ b93c ppno RRE_RR "perform pseudorandom number operation" z13 zarch
 # Vector Enhancements Facility 1
 
 e70000000085 vbperm VRR_VVV "vector bit permute" arch12 zarch
-e70000006004 vllezlf VRX_VRRD "vector load logical word element and zero - left aligned" arch12 zarch vx2
-e700000000b8 vmsl VRR_VVVUU0V "vector multiply sum logical" arch12 zarch vx2
-e700030000b8 vmslg VRR_VVVU0VB "vector multiply sum logical double word" arch12 zarch vx2
-e7000000006c vnx VRR_VVV "vector not exclusive or" arch12 zarch vx2
+e70000006004 vllezlf VRX_VRRD "vector load logical word element and zero - left aligned" arch12 zarch
+e700000000b8 vmsl VRR_VVVUU0V "vector multiply sum logical" arch12 zarch
+e700030000b8 vmslg VRR_VVVU0VB "vector multiply sum logical double word" arch12 zarch
+e7000000006c vnx VRR_VVV "vector not exclusive or" arch12 zarch
 e7000000006e vnn VRR_VVV "vector nand" arch12 zarch
-e7000000006f voc VRR_VVV "vector or with complement" arch12 zarch vx2
-e70000000050 vpopctb VRR_VV "vector population count byte" arch12 zarch vx2
-e70000001050 vpopcth VRR_VV "vector population count halfword" arch12 zarch vx2
-e70000002050 vpopctf VRR_VV "vector population count word" arch12 zarch vx2
-e70000003050 vpopctg VRR_VV "vector population count double word" arch12 zarch vx2
-e700000020e3 vfasb VRR_VVV "vector fp add short" arch12 zarch vx2
-e700000820e3 wfasb VRR_VVV "scalar vector fp add scalar short" arch12 zarch vx2
-e700000840e3 wfaxb VRR_VVV "scalar vector fp add scalar extended" arch12 zarch vx2
-e700000020cb wfcsb VRR_VV "scalar vector fp compare scalar short" arch12 zarch vx2
-e700000040cb wfcxb VRR_VV "scalar vector fp compare scalar extended" arch12 zarch vx2
-e700000020ca wfksb VRR_VV "scalar vector fp compare and signal scalar short" arch12 zarch vx2
-e700000040ca wfkxb VRR_VV "scalar vector fp compare and signal scalar extended" arch12 zarch vx2
+e7000000006f voc VRR_VVV "vector or with complement" arch12 zarch
+e70000000050 vpopctb VRR_VV "vector population count byte" arch12 zarch
+e70000001050 vpopcth VRR_VV "vector population count halfword" arch12 zarch
+e70000002050 vpopctf VRR_VV "vector population count word" arch12 zarch
+e70000003050 vpopctg VRR_VV "vector population count double word" arch12 zarch
+e700000020e3 vfasb VRR_VVV "vector fp add short" arch12 zarch
+e700000820e3 wfasb VRR_VVV "scalar vector fp add scalar short" arch12 zarch
+e700000840e3 wfaxb VRR_VVV "scalar vector fp add scalar extended" arch12 zarch
+e700000020cb wfcsb VRR_VV "scalar vector fp compare scalar short" arch12 zarch
+e700000040cb wfcxb VRR_VV "scalar vector fp compare scalar extended" arch12 zarch
+e700000020ca wfksb VRR_VV "scalar vector fp compare and signal scalar short" arch12 zarch
+e700000040ca wfkxb VRR_VV "scalar vector fp compare and signal scalar extended" arch12 zarch
 
-e700000020e8 vfcesb VRR_VVV "vector fp compare equal short" arch12 zarch vx2
-e700001020e8 vfcesbs VRR_VVV "vector fp compare equal short" arch12 zarch vx2
-e700000820e8 wfcesb VRR_VVV "scalar vector fp compare equal scalar short" arch12 zarch vx2
-e700001820e8 wfcesbs VRR_VVV "scalar fp compare equal scalar short" arch12 zarch vx2
-e700000840e8 wfcexb VRR_VVV "scalar vector fp compare equal scalar extended" arch12 zarch vx2
-e700001840e8 wfcexbs VRR_VVV "scalar vector fp compare equal scalar extended" arch12 zarch vx2
+e700000020e8 vfcesb VRR_VVV "vector fp compare equal short" arch12 zarch
+e700001020e8 vfcesbs VRR_VVV "vector fp compare equal short" arch12 zarch
+e700000820e8 wfcesb VRR_VVV "scalar vector fp compare equal scalar short" arch12 zarch
+e700001820e8 wfcesbs VRR_VVV "scalar fp compare equal scalar short" arch12 zarch
+e700000840e8 wfcexb VRR_VVV "scalar vector fp compare equal scalar extended" arch12 zarch
+e700001840e8 wfcexbs VRR_VVV "scalar vector fp compare equal scalar extended" arch12 zarch
 
-e700000420e8 vfkesb VRR_VVV "vector fp compare and signal equal short" arch12 zarch vx2
-e700001420e8 vfkesbs VRR_VVV "vector fp compare and signal equal short" arch12 zarch vx2
-e700000c20e8 wfkesb VRR_VVV "scalar vector fp compare and signal equal scalar short" arch12 zarch vx2
-e700001c20e8 wfkesbs VRR_VVV "scalar fp compare and signal equal scalar short" arch12 zarch vx2
+e700000420e8 vfkesb VRR_VVV "vector fp compare and signal equal short" arch12 zarch
+e700001420e8 vfkesbs VRR_VVV "vector fp compare and signal equal short" arch12 zarch
+e700000c20e8 wfkesb VRR_VVV "scalar vector fp compare and signal equal scalar short" arch12 zarch
+e700001c20e8 wfkesbs VRR_VVV "scalar fp compare and signal equal scalar short" arch12 zarch
 e700000430e8 vfkedb VRR_VVV "vector fp compare and signal equal long" arch12 zarch vx
 e700001430e8 vfkedbs VRR_VVV "vector fp compare and signal equal long" arch12 zarch vx
 e700000c30e8 wfkedb VRR_VVV "vector fp compare and signal equal long" arch12 zarch vx
 e700001c30e8 wfkedbs VRR_VVV "vector fp compare and signal equal long" arch12 zarch vx
-e700000c40e8 wfkexb VRR_VVV "scalar vector fp compare and signal equal scalar extended" arch12 zarch vx2
-e700001c40e8 wfkexbs VRR_VVV "scalar vector fp compare and signal equal scalar extended" arch12 zarch vx2
+e700000c40e8 wfkexb VRR_VVV "scalar vector fp compare and signal equal scalar extended" arch12 zarch
+e700001c40e8 wfkexbs VRR_VVV "scalar vector fp compare and signal equal scalar extended" arch12 zarch
 
-e700000020eb vfchsb VRR_VVV "vector fp compare high short" arch12 zarch vx2
-e700001020eb vfchsbs VRR_VVV "vector fp compare high short" arch12 zarch vx2
-e700000820eb wfchsb VRR_VVV "scalar vector fp compare high scalar short" arch12 zarch vx2
-e700001820eb wfchsbs VRR_VVV "scalar vector fp compare high scalar short" arch12 zarch vx2
-e700000840eb wfchxb VRR_VVV "scalar vector fp compare high scalar extended" arch12 zarch vx2
-e700001840eb wfchxbs VRR_VVV "scalar vector fp compare high scalar extended" arch12 zarch vx2
+e700000020eb vfchsb VRR_VVV "vector fp compare high short" arch12 zarch
+e700001020eb vfchsbs VRR_VVV "vector fp compare high short" arch12 zarch
+e700000820eb wfchsb VRR_VVV "scalar vector fp compare high scalar short" arch12 zarch
+e700001820eb wfchsbs VRR_VVV "scalar vector fp compare high scalar short" arch12 zarch
+e700000840eb wfchxb VRR_VVV "scalar vector fp compare high scalar extended" arch12 zarch
+e700001840eb wfchxbs VRR_VVV "scalar vector fp compare high scalar extended" arch12 zarch
 
-e700000420eb vfkhsb VRR_VVV "vector fp compare and signal high short" arch12 zarch vx2
-e700001420eb vfkhsbs VRR_VVV "vector fp compare and signal high short" arch12 zarch vx2
-e700000c20eb wfkhsb VRR_VVV "scalar vector fp compare and signal high scalar short" arch12 zarch vx2
-e700001c20eb wfkhsbs VRR_VVV "scalar vector fp compare and signal high scalar short" arch12 zarch vx2
+e700000420eb vfkhsb VRR_VVV "vector fp compare and signal high short" arch12 zarch
+e700001420eb vfkhsbs VRR_VVV "vector fp compare and signal high short" arch12 zarch
+e700000c20eb wfkhsb VRR_VVV "scalar vector fp compare and signal high scalar short" arch12 zarch
+e700001c20eb wfkhsbs VRR_VVV "scalar vector fp compare and signal high scalar short" arch12 zarch
 e700000430eb vfkhdb VRR_VVV "vector fp compare and signal high long" arch12 zarch vx
 e700001430eb vfkhdbs VRR_VVV "vector fp compare and signal high long" arch12 zarch vx
 e700000c30eb wfkhdb VRR_VVV "vector fp compare and signal high long" arch12 zarch vx
 e700001c30eb wfkhdbs VRR_VVV "vector fp compare and signal high long" arch12 zarch vx
-e700000c40eb wfkhxb VRR_VVV "scalar vector fp compare and signal high scalar extended" arch12 zarch vx2
-e700001c40eb wfkhxbs VRR_VVV "scalar vector fp compare and signal high scalar extended" arch12 zarch vx2
+e700000c40eb wfkhxb VRR_VVV "scalar vector fp compare and signal high scalar extended" arch12 zarch
+e700001c40eb wfkhxbs VRR_VVV "scalar vector fp compare and signal high scalar extended" arch12 zarch
 
-e700000020ea vfchesb VRR_VVV "vector fp compare high or equal short" arch12 zarch vx2
-e700001020ea vfchesbs VRR_VVV "vector fp compare high or equal short" arch12 zarch vx2
-e700000820ea wfchesb VRR_VVV "scalar vector fp compare high or equal scalar short" arch12 zarch vx2
-e700001820ea wfchesbs VRR_VVV "scalar vector fp compare high or equal scalar short" arch12 zarch vx2
-e700000840ea wfchexb VRR_VVV "scalar vector fp compare high or equal scalar extended" arch12 zarch vx2
-e700001840ea wfchexbs VRR_VVV "scalar vector fp compare high or equal scalar extended" arch12 zarch vx2
+e700000020ea vfchesb VRR_VVV "vector fp compare high or equal short" arch12 zarch
+e700001020ea vfchesbs VRR_VVV "vector fp compare high or equal short" arch12 zarch
+e700000820ea wfchesb VRR_VVV "scalar vector fp compare high or equal scalar short" arch12 zarch
+e700001820ea wfchesbs VRR_VVV "scalar vector fp compare high or equal scalar short" arch12 zarch
+e700000840ea wfchexb VRR_VVV "scalar vector fp compare high or equal scalar extended" arch12 zarch
+e700001840ea wfchexbs VRR_VVV "scalar vector fp compare high or equal scalar extended" arch12 zarch
 
-e700000420ea vfkhesb VRR_VVV "vector fp compare and signal high or equal short" arch12 zarch vx2
-e700001420ea vfkhesbs VRR_VVV "vector fp compare and signal high or equal short" arch12 zarch vx2
-e700000c20ea wfkhesb VRR_VVV "scalar vector fp compare and signal high or equal scalar short" arch12 zarch vx2
-e700001c20ea wfkhesbs VRR_VVV "scalar vector fp compare and signal high or equal scalar short" arch12 zarch vx2
+e700000420ea vfkhesb VRR_VVV "vector fp compare and signal high or equal short" arch12 zarch
+e700001420ea vfkhesbs VRR_VVV "vector fp compare and signal high or equal short" arch12 zarch
+e700000c20ea wfkhesb VRR_VVV "scalar vector fp compare and signal high or equal scalar short" arch12 zarch
+e700001c20ea wfkhesbs VRR_VVV "scalar vector fp compare and signal high or equal scalar short" arch12 zarch
 e700000430ea vfkhedb VRR_VVV "vector fp compare and signal high or equal long" arch12 zarch vx
 e700001430ea vfkhedbs VRR_VVV "vector fp compare and signal high or equal long" arch12 zarch vx
 e700000c30ea wfkhedb VRR_VVV "vector fp compare and signal high or equal long" arch12 zarch vx
 e700001c30ea wfkhedbs VRR_VVV "vector fp compare and signal high or equal long" arch12 zarch vx
-e700000c40ea wfkhexb VRR_VVV "scalar vector fp compare and signal high or equal scalar extended" arch12 zarch vx2
-e700001c40ea wfkhexbs VRR_VVV "scalar vector fp compare and signal high or equal scalar extended" arch12 zarch vx2
+e700000c40ea wfkhexb VRR_VVV "scalar vector fp compare and signal high or equal scalar extended" arch12 zarch
+e700001c40ea wfkhexbs VRR_VVV "scalar vector fp compare and signal high or equal scalar extended" arch12 zarch
 
-e700000020e5 vfdsb VRR_VVV "vector fp divide short" arch12 zarch vx2
-e700000820e5 wfdsb VRR_VVV "scalar vector fp divide scalar short" arch12 zarch vx2
-e700000840e5 wfdxb VRR_VVV "scalar vector fp divide scalar extended" arch12 zarch vx2
-e700000020c7 vfisb VRR_VV0UU "vector load fp integer short" arch12 zarch vx2
-e700000820c7 wfisb VRR_VV0UU8 "scalar vector load fp integer scalar short" arch12 zarch vx2
-e700000840c7 wfixb VRR_VV0UU8 "scalar vector load fp integer scalar extended" arch12 zarch vx2
-e700000000c4 vfll VRR_VV0UU2 "vector fp load lengthened" arch12 zarch vx2
-e700000020c4 vflls VRR_VV "vector fp load lengthened" arch12 zarch vx2
-e700000820c4 wflls VRR_VV "scalar vector fp load lengthened short" arch12 zarch vx2
-e700000830c4 wflld VRR_VV "scalar vector fp load lengthened long" arch12 zarch vx2
-e700000000c5 vflr VRR_VV0UUU "vector fp load rounded" arch12 zarch vx2
-e700000030c5 vflrd VRR_VV0UU "vector fp load rounded long" arch12 zarch vx2
-e700000830c5 wflrd VRR_VV0UU8 "scalar vector fp load rounded long" arch12 zarch vx2
-e700000840c5 wflrx VRR_VV0UU8 "scalar vector fp load rounded extended" arch12 zarch vx2
-e700000000ef vfmax VRR_VVV0UUU "vector fp maximum" arch12 zarch vx2
-e700000020ef vfmaxsb VRR_VVV0U0 "vector fp maximum short" arch12 zarch vx2
-e700000030ef vfmaxdb VRR_VVV0U0 "vector fp maximum long" arch12 zarch vx2
-e700000820ef wfmaxsb VRR_VVV0U0 "scalar fp maximum scalar short" arch12 zarch vx2
-e700000830ef wfmaxdb VRR_VVV0U0 "scalar fp maximum scalar long" arch12 zarch vx2
-e700000840ef wfmaxxb VRR_VVV0U0 "scalar fp maximum scalar extended" arch12 zarch vx2
-e700000000ee vfmin VRR_VVV0UUU "vector fp minimum" arch12 zarch vx2
-e700000020ee vfminsb VRR_VVV0U0 "vector fp minimum short" arch12 zarch vx2
-e700000030ee vfmindb VRR_VVV0U0 "vector fp minimum long" arch12 zarch vx2
-e700000820ee wfminsb VRR_VVV0U0 "scalar fp minimum scalar short" arch12 zarch vx2
-e700000830ee wfmindb VRR_VVV0U0 "scalar fp minimum scalar long" arch12 zarch vx2
-e700000840ee wfminxb VRR_VVV0U0 "scalar fp minimum scalar extended" arch12 zarch vx2
-e700000020e7 vfmsb VRR_VVV "vector fp multiply short" arch12 zarch vx2
-e700000820e7 wfmsb VRR_VVV "scalar vector fp multiply scalar short" arch12 zarch vx2
-e700000840e7 wfmxb VRR_VVV "scalar vector fp multiply scalar extended" arch12 zarch vx2
-e7000200008f vfmasb VRR_VVVV "vector fp multiply and add short" arch12 zarch vx2
-e7000208008f wfmasb VRR_VVVV "scalar vector fp multiply and add scalar short" arch12 zarch vx2
-e7000408008f wfmaxb VRR_VVVV "scalar vector fp multiply and add scalar extended" arch12 zarch vx2
-e7000200008e vfmssb VRR_VVVV "vector fp multiply and subtract short" arch12 zarch vx2
-e7000208008e wfmssb VRR_VVVV "scalar vector fp multiply and subtract scalar short" arch12 zarch vx2
-e7000408008e wfmsxb VRR_VVVV "scalar vector fp multiply and subtract scalar extended" arch12 zarch vx2
-e7000000009f vfnma VRR_VVVU0UV "vector fp negative multiply and add" arch12 zarch vx2
-e7000200009f vfnmasb VRR_VVVV "vector fp negative multiply and add short" arch12 zarch vx2
-e7000208009f wfnmasb VRR_VVVV "scalar vector fp negative multiply and add scalar short" arch12 zarch vx2
-e7000300009f vfnmadb VRR_VVVV "vector fp negative multiply and add long" arch12 zarch vx2
-e7000308009f wfnmadb VRR_VVVV "scalar vector fp negative multiply and add scalar long" arch12 zarch vx2
-e7000408009f wfnmaxb VRR_VVVV "scalar vector fp negative multiply and add scalar extended" arch12 zarch vx2
-e7000000009e vfnms VRR_VVVU0UV "vector fp negative multiply and subtract" arch12 zarch vx2
-e7000200009e vfnmssb VRR_VVVV "vector fp negative multiply and subtract short" arch12 zarch vx2
-e7000208009e wfnmssb VRR_VVVV "scalar vector fp negative multiply and subtract scalar short" arch12 zarch vx2
-e7000300009e vfnmsdb VRR_VVVV "vector fp negative multiply and subtract long" arch12 zarch vx2
-e7000308009e wfnmsdb VRR_VVVV "scalar vector fp negative multiply and subtract scalar long" arch12 zarch vx2
-e7000408009e wfnmsxb VRR_VVVV "scalar vector fp negative multiply and subtract scalar extended" arch12 zarch vx2
-e700000020cc vfpsosb VRR_VV0U2 "vector fp perform sign operation short" arch12 zarch vx2
-e700000820cc wfpsosb VRR_VV0U2 "scalar vector fp perform sign operation scalar short" arch12 zarch vx2
-e700000020cc vflcsb VRR_VV "vector fp perform sign operation short" arch12 zarch vx2
-e700000820cc wflcsb VRR_VV "scalar vector fp perform sign operation scalar short" arch12 zarch vx2
-e700001020cc vflnsb VRR_VV "vector fp perform sign operation short" arch12 zarch vx2
-e700001820cc wflnsb VRR_VV "scalar vector fp perform sign operation scalar short" arch12 zarch vx2
-e700002020cc vflpsb VRR_VV "vector fp perform sign operation short" arch12 zarch vx2
-e700002820cc wflpsb VRR_VV "scalar vector fp perform sign operation scalar short" arch12 zarch vx2
-e700000840cc wfpsoxb VRR_VV0U2 "scalar vector fp perform sign operation scalar extended" arch12 zarch vx2
-e700000840cc wflcxb VRR_VV "scalar vector fp perform sign operation scalar extended" arch12 zarch vx2
-e700001840cc wflnxb VRR_VV "scalar vector fp perform sign operation scalar extended" arch12 zarch vx2
-e700002840cc wflpxb VRR_VV "scalar vector fp perform sign operation scalar extended" arch12 zarch vx2
-e700000020ce vfsqsb VRR_VV "vector fp square root short" arch12 zarch vx2
-e700000820ce wfsqsb VRR_VV "scalar vector fp square root scalar short" arch12 zarch vx2
-e700000840ce wfsqxb VRR_VV "scalar vector fp square root scalar extended" arch12 zarch vx2
-e700000020e2 vfssb VRR_VVV "vector fp subtract short" arch12 zarch vx2
-e700000820e2 wfssb VRR_VVV "scalar vector fp subtract scalar short" arch12 zarch vx2
-e700000840e2 wfsxb VRR_VVV "scalar vector fp subtract scalar extended" arch12 zarch vx2
-e7000000204a vftcisb VRI_VVU2 "vector fp test data class immediate short" arch12 zarch vx2
-e7000008204a wftcisb VRI_VVU2 "scalar vector fp test data class immediate scalar short" arch12 zarch vx2
-e7000008404a wftcixb VRI_VVU2 "scalar vector fp test data class immediate scalar extended" arch12 zarch vx2
+e700000020e5 vfdsb VRR_VVV "vector fp divide short" arch12 zarch
+e700000820e5 wfdsb VRR_VVV "scalar vector fp divide scalar short" arch12 zarch
+e700000840e5 wfdxb VRR_VVV "scalar vector fp divide scalar extended" arch12 zarch
+e700000020c7 vfisb VRR_VV0UU "vector load fp integer short" arch12 zarch
+e700000820c7 wfisb VRR_VV0UU8 "scalar vector load fp integer scalar short" arch12 zarch
+e700000840c7 wfixb VRR_VV0UU8 "scalar vector load fp integer scalar extended" arch12 zarch
+e700000000c4 vfll VRR_VV0UU2 "vector fp load lengthened" arch12 zarch
+e700000020c4 vflls VRR_VV "vector fp load lengthened" arch12 zarch
+e700000820c4 wflls VRR_VV "scalar vector fp load lengthened short" arch12 zarch
+e700000830c4 wflld VRR_VV "scalar vector fp load lengthened long" arch12 zarch
+e700000000c5 vflr VRR_VV0UUU "vector fp load rounded" arch12 zarch
+e700000030c5 vflrd VRR_VV0UU "vector fp load rounded long" arch12 zarch
+e700000830c5 wflrd VRR_VV0UU8 "scalar vector fp load rounded long" arch12 zarch
+e700000840c5 wflrx VRR_VV0UU8 "scalar vector fp load rounded extended" arch12 zarch
+e700000000ef vfmax VRR_VVV0UUU "vector fp maximum" arch12 zarch
+e700000020ef vfmaxsb VRR_VVV0U0 "vector fp maximum short" arch12 zarch
+e700000030ef vfmaxdb VRR_VVV0U0 "vector fp maximum long" arch12 zarch
+e700000820ef wfmaxsb VRR_VVV0U0 "scalar fp maximum scalar short" arch12 zarch
+e700000830ef wfmaxdb VRR_VVV0U0 "scalar fp maximum scalar long" arch12 zarch
+e700000840ef wfmaxxb VRR_VVV0U0 "scalar fp maximum scalar extended" arch12 zarch
+e700000000ee vfmin VRR_VVV0UUU "vector fp minimum" arch12 zarch
+e700000020ee vfminsb VRR_VVV0U0 "vector fp minimum short" arch12 zarch
+e700000030ee vfmindb VRR_VVV0U0 "vector fp minimum long" arch12 zarch
+e700000820ee wfminsb VRR_VVV0U0 "scalar fp minimum scalar short" arch12 zarch
+e700000830ee wfmindb VRR_VVV0U0 "scalar fp minimum scalar long" arch12 zarch
+e700000840ee wfminxb VRR_VVV0U0 "scalar fp minimum scalar extended" arch12 zarch
+e700000020e7 vfmsb VRR_VVV "vector fp multiply short" arch12 zarch
+e700000820e7 wfmsb VRR_VVV "scalar vector fp multiply scalar short" arch12 zarch
+e700000840e7 wfmxb VRR_VVV "scalar vector fp multiply scalar extended" arch12 zarch
+e7000200008f vfmasb VRR_VVVV "vector fp multiply and add short" arch12 zarch
+e7000208008f wfmasb VRR_VVVV "scalar vector fp multiply and add scalar short" arch12 zarch
+e7000408008f wfmaxb VRR_VVVV "scalar vector fp multiply and add scalar extended" arch12 zarch
+e7000200008e vfmssb VRR_VVVV "vector fp multiply and subtract short" arch12 zarch
+e7000208008e wfmssb VRR_VVVV "scalar vector fp multiply and subtract scalar short" arch12 zarch
+e7000408008e wfmsxb VRR_VVVV "scalar vector fp multiply and subtract scalar extended" arch12 zarch
+e7000000009f vfnma VRR_VVVU0UV "vector fp negative multiply and add" arch12 zarch
+e7000200009f vfnmasb VRR_VVVV "vector fp negative multiply and add short" arch12 zarch
+e7000208009f wfnmasb VRR_VVVV "scalar vector fp negative multiply and add scalar short" arch12 zarch
+e7000300009f vfnmadb VRR_VVVV "vector fp negative multiply and add long" arch12 zarch
+e7000308009f wfnmadb VRR_VVVV "scalar vector fp negative multiply and add scalar long" arch12 zarch
+e7000408009f wfnmaxb VRR_VVVV "scalar vector fp negative multiply and add scalar extended" arch12 zarch
+e7000000009e vfnms VRR_VVVU0UV "vector fp negative multiply and subtract" arch12 zarch
+e7000200009e vfnmssb VRR_VVVV "vector fp negative multiply and subtract short" arch12 zarch
+e7000208009e wfnmssb VRR_VVVV "scalar vector fp negative multiply and subtract scalar short" arch12 zarch
+e7000300009e vfnmsdb VRR_VVVV "vector fp negative multiply and subtract long" arch12 zarch
+e7000308009e wfnmsdb VRR_VVVV "scalar vector fp negative multiply and subtract scalar long" arch12 zarch
+e7000408009e wfnmsxb VRR_VVVV "scalar vector fp negative multiply and subtract scalar extended" arch12 zarch
+e700000020cc vfpsosb VRR_VV0U2 "vector fp perform sign operation short" arch12 zarch
+e700000820cc wfpsosb VRR_VV0U2 "scalar vector fp perform sign operation scalar short" arch12 zarch
+e700000020cc vflcsb VRR_VV "vector fp perform sign operation short" arch12 zarch
+e700000820cc wflcsb VRR_VV "scalar vector fp perform sign operation scalar short" arch12 zarch
+e700001020cc vflnsb VRR_VV "vector fp perform sign operation short" arch12 zarch
+e700001820cc wflnsb VRR_VV "scalar vector fp perform sign operation scalar short" arch12 zarch
+e700002020cc vflpsb VRR_VV "vector fp perform sign operation short" arch12 zarch
+e700002820cc wflpsb VRR_VV "scalar vector fp perform sign operation scalar short" arch12 zarch
+e700000840cc wfpsoxb VRR_VV0U2 "scalar vector fp perform sign operation scalar extended" arch12 zarch
+e700000840cc wflcxb VRR_VV "scalar vector fp perform sign operation scalar extended" arch12 zarch
+e700001840cc wflnxb VRR_VV "scalar vector fp perform sign operation scalar extended" arch12 zarch
+e700002840cc wflpxb VRR_VV "scalar vector fp perform sign operation scalar extended" arch12 zarch
+e700000020ce vfsqsb VRR_VV "vector fp square root short" arch12 zarch
+e700000820ce wfsqsb VRR_VV "scalar vector fp square root scalar short" arch12 zarch
+e700000840ce wfsqxb VRR_VV "scalar vector fp square root scalar extended" arch12 zarch
+e700000020e2 vfssb VRR_VVV "vector fp subtract short" arch12 zarch
+e700000820e2 wfssb VRR_VVV "scalar vector fp subtract scalar short" arch12 zarch
+e700000840e2 wfsxb VRR_VVV "scalar vector fp subtract scalar extended" arch12 zarch
+e7000000204a vftcisb VRI_VVU2 "vector fp test data class immediate short" arch12 zarch
+e7000008204a wftcisb VRI_VVU2 "scalar vector fp test data class immediate scalar short" arch12 zarch
+e7000008404a wftcixb VRI_VVU2 "scalar vector fp test data class immediate scalar extended" arch12 zarch
 
 # Miscellaneous Instruction Extensions Facility 2
 
@@ -1843,28 +1843,28 @@ e30000000039 sgh RXY_RRRD "subtract halfword from 64 bit value" arch12 zarch
 
 # Vector packed decimal facility
 
-e60000000037 vlrlr VRS_RRDV "vector load rightmost with length" arch12 zarch vx2
-e60000000035 vlrl VSI_URDV "vector load rightmost with immediate length" arch12 zarch vx2
-e6000000003f vstrlr VRS_RRDV "vector store rightmost with length" arch12 zarch vx2
-e6000000003d vstrl VSI_URDV "vector store rightmost with immediate length" arch12 zarch vx2
-e60000000071 vap VRI_VVV0UU2 "vector add decimal" arch12 zarch vx2
-e60000000077 vcp VRR_0VV0U "vector compare decimal" arch12 zarch vx2
-e60000000050 vcvb VRR_RV0U "vector convert to binary 32 bit" arch12 zarch vx2
-e60000000052 vcvbg VRR_RV0U "vector convert to binary 64 bit" arch12 zarch vx2
-e60000000058 vcvd VRI_VR0UU "vector convert to decimal 32 bit" arch12 zarch vx2
-e6000000005a vcvdg VRI_VR0UU "vector convert to decimal 64 bit" arch12 zarch vx2
-e6000000007a vdp VRI_VVV0UU2 "vector divide decimal" arch12 zarch vx2
-e60000000049 vlip VRI_V0UU2 "vector load immediate decimal" arch12 zarch vx2
-e60000000078 vmp VRI_VVV0UU2 "vector multiply decimal" arch12 zarch vx2
-e60000000079 vmsp VRI_VVV0UU2 "vector multiply and shift decimal" arch12 zarch vx2
-e60000000034 vpkz VSI_URDV "vector pack zoned" arch12 zarch vx2
-e6000000005b vpsop VRI_VVUUU2 "vector perform sign operation decimal" arch12 zarch vx2
-e6000000007b vrp VRI_VVV0UU2 "vector remainder decimal" arch12 zarch vx2
-e6000000007e vsdp VRI_VVV0UU2 "vector shift and divide decimal" arch12 zarch vx2
-e60000000059 vsrp VRI_VVUUU2 "vector shift and round decimal" arch12 zarch vx2
-e60000000073 vsp VRI_VVV0UU2 "vector subtract decimal" arch12 zarch vx2
-e6000000005f vtp VRR_0V "vector test decimal" arch12 zarch vx2
-e6000000003c vupkz VSI_URDV "vector unpack zoned" arch12 zarch vx2
+e60000000037 vlrlr VRS_RRDV "vector load rightmost with length" arch12 zarch
+e60000000035 vlrl VSI_URDV "vector load rightmost with immediate length" arch12 zarch
+e6000000003f vstrlr VRS_RRDV "vector store rightmost with length" arch12 zarch
+e6000000003d vstrl VSI_URDV "vector store rightmost with immediate length" arch12 zarch
+e60000000071 vap VRI_VVV0UU2 "vector add decimal" arch12 zarch
+e60000000077 vcp VRR_0VV0U "vector compare decimal" arch12 zarch
+e60000000050 vcvb VRR_RV0U "vector convert to binary 32 bit" arch12 zarch
+e60000000052 vcvbg VRR_RV0U "vector convert to binary 64 bit" arch12 zarch
+e60000000058 vcvd VRI_VR0UU "vector convert to decimal 32 bit" arch12 zarch
+e6000000005a vcvdg VRI_VR0UU "vector convert to decimal 64 bit" arch12 zarch
+e6000000007a vdp VRI_VVV0UU2 "vector divide decimal" arch12 zarch
+e60000000049 vlip VRI_V0UU2 "vector load immediate decimal" arch12 zarch
+e60000000078 vmp VRI_VVV0UU2 "vector multiply decimal" arch12 zarch
+e60000000079 vmsp VRI_VVV0UU2 "vector multiply and shift decimal" arch12 zarch
+e60000000034 vpkz VSI_URDV "vector pack zoned" arch12 zarch
+e6000000005b vpsop VRI_VVUUU2 "vector perform sign operation decimal" arch12 zarch
+e6000000007b vrp VRI_VVV0UU2 "vector remainder decimal" arch12 zarch
+e6000000007e vsdp VRI_VVV0UU2 "vector shift and divide decimal" arch12 zarch
+e60000000059 vsrp VRI_VVUUU2 "vector shift and round decimal" arch12 zarch
+e60000000073 vsp VRI_VVV0UU2 "vector subtract decimal" arch12 zarch
+e6000000005f vtp VRR_0V "vector test decimal" arch12 zarch
+e6000000003c vupkz VSI_URDV "vector unpack zoned" arch12 zarch
 
 # Guarded storage facility
 
