diff -rup binutils.orig/bfd/coffgen.c binutils-2.31.1/bfd/coffgen.c
--- binutils.orig/bfd/coffgen.c	2020-01-02 14:32:32.297580290 +0000
+++ binutils-2.31.1/bfd/coffgen.c	2020-01-02 15:48:06.330393858 +0000
@@ -2277,7 +2277,7 @@ coff_find_nearest_line_with_names (bfd *
   /* Also try examining DWARF2 debugging information.  */
   if (_bfd_dwarf2_find_nearest_line (abfd, symbols, NULL, section, offset,
 				     filename_ptr, functionname_ptr,
-				     line_ptr, NULL, debug_sections, 0,
+				     line_ptr, NULL, debug_sections,
 				     &coff_data(abfd)->dwarf2_find_line_info))
     return TRUE;
 
@@ -2317,7 +2317,7 @@ coff_find_nearest_line_with_names (bfd *
 	  && _bfd_dwarf2_find_nearest_line (abfd, symbols, NULL, section,
 					    offset + bias,
 					    filename_ptr, functionname_ptr,
-					    line_ptr, NULL, debug_sections, 0,
+					    line_ptr, NULL, debug_sections,
 					    &coff_data(abfd)->dwarf2_find_line_info))
 	return TRUE;
     }
diff -rup binutils.orig/bfd/dwarf2.c binutils-2.31.1/bfd/dwarf2.c
--- binutils.orig/bfd/dwarf2.c	2020-01-02 14:32:32.308580209 +0000
+++ binutils-2.31.1/bfd/dwarf2.c	2020-01-02 15:42:54.172674397 +0000
@@ -1,5 +1,5 @@
 /* DWARF 2 support.
-   Copyright (C) 1994-2018 Free Software Foundation, Inc.
+   Copyright (C) 1994-2020 Free Software Foundation, Inc.
 
    Adapted from gdb/dwarf2read.c by Gavin Koch of Cygnus Solutions
    (gavin@cygnus.com).
@@ -35,6 +35,7 @@
 #include "libbfd.h"
 #include "elf-bfd.h"
 #include "dwarf2.h"
+#include "hashtab.h"
 
 /* The data in the .debug_line statement prologue looks like this.  */
 
@@ -81,55 +82,23 @@ struct adjusted_section
   bfd_vma adj_vma;
 };
 
-struct dwarf2_debug
+struct dwarf2_debug_file
 {
-  /* A list of all previously read comp_units.  */
-  struct comp_unit *all_comp_units;
-
-  /* Last comp unit in list above.  */
-  struct comp_unit *last_comp_unit;
+  /* The actual bfd from which debug info was loaded.  Might be
+     different to orig_bfd because of gnu_debuglink sections.  */
+  bfd *bfd_ptr;
 
-  /* Names of the debug sections.  */
-  const struct dwarf_debug_section *debug_sections;
+  /* Pointer to the symbol table.  */
+  asymbol **syms;
 
-  /* The next unread compilation unit within the .debug_info section.
-     Zero indicates that the .debug_info section has not been loaded
-     into a buffer yet.  */
+  /* The current info pointer for the .debug_info section being parsed.  */
   bfd_byte *info_ptr;
 
-  /* Pointer to the end of the .debug_info section memory buffer.  */
-  bfd_byte *info_ptr_end;
+  /* A pointer to the memory block allocated for .debug_info sections.  */
+  bfd_byte *dwarf_info_buffer;
 
-  /* Pointer to the original bfd for which debug was loaded.  This is what
-     we use to compare and so check that the cached debug data is still
-     valid - it saves having to possibly dereference the gnu_debuglink each
-     time.  */
-  bfd *orig_bfd;
-
-  /* Pointer to the bfd, section and address of the beginning of the
-     section.  The bfd might be different than expected because of
-     gnu_debuglink sections.  */
-  bfd *bfd_ptr;
-  asection *sec;
-  bfd_byte *sec_info_ptr;
-
-  /* Support for alternate debug info sections created by the DWZ utility:
-     This includes a pointer to an alternate bfd which contains *extra*,
-     possibly duplicate debug sections, and pointers to the loaded
-     .debug_str and .debug_info sections from this bfd.  */
-  bfd *		 alt_bfd_ptr;
-  bfd_byte *	 alt_dwarf_str_buffer;
-  bfd_size_type	 alt_dwarf_str_size;
-  bfd_byte *	 alt_dwarf_info_buffer;
-  bfd_size_type	 alt_dwarf_info_size;
-
-  /* A pointer to the memory block allocated for info_ptr.  Neither
-     info_ptr nor sec_info_ptr are guaranteed to stay pointing to the
-     beginning of the malloc block.  */
-  bfd_byte *info_ptr_memory;
-
-  /* Pointer to the symbol table.  */
-  asymbol **syms;
+  /* Length of the loaded .debug_info sections.  */
+  bfd_size_type dwarf_info_size;
 
   /* Pointer to the .debug_abbrev section loaded into memory.  */
   bfd_byte *dwarf_abbrev_buffer;
@@ -161,6 +130,33 @@ struct dwarf2_debug
   /* Length of the loaded .debug_ranges section.  */
   bfd_size_type dwarf_ranges_size;
 
+  /* A list of all previously read comp_units.  */
+  struct comp_unit *all_comp_units;
+
+  /* Last comp unit in list above.  */
+  struct comp_unit *last_comp_unit;
+
+  /* Line table at line_offset zero.  */
+  struct line_info_table *line_table;
+
+  /* Hash table to map offsets to decoded abbrevs.  */
+  htab_t abbrev_offsets;
+};
+
+struct dwarf2_debug
+{
+  /* Names of the debug sections.  */
+  const struct dwarf_debug_section *debug_sections;
+
+  /* Per-file stuff.  */
+  struct dwarf2_debug_file f, alt;
+
+  /* Pointer to the original bfd for which debug was loaded.  This is what
+     we use to compare and so check that the cached debug data is still
+     valid - it saves having to possibly dereference the gnu_debuglink each
+     time.  */
+  bfd *orig_bfd;
+
   /* If the most recent call to bfd_find_nearest_line was given an
      address in an inlined function, preserve a pointer into the
      calling chain for subsequent calls to bfd_find_inliner_info to
@@ -169,6 +165,8 @@ struct dwarf2_debug
 
   /* Section VMAs at the time the stash was built.  */
   bfd_vma *sec_vma;
+  /* Number of sections in the SEC_VMA table.  */
+  unsigned int sec_vma_count;
 
   /* Number of sections whose VMA we must adjust.  */
   int adjusted_section_count;
@@ -273,8 +271,9 @@ struct comp_unit
   /* A list of the variables found in this comp. unit.  */
   struct varinfo *variable_table;
 
-  /* Pointer to dwarf2_debug structure.  */
+  /* Pointers to dwarf2_debug structures.  */
   struct dwarf2_debug *stash;
+  struct dwarf2_debug_file *file;
 
   /* DWARF format version for this unit - from unit header.  */
   int version;
@@ -345,7 +344,7 @@ const struct dwarf_debug_section dwarf_d
   { NULL,			NULL },
 };
 
-/* NB/ Numbers in this enum must match up with indicies
+/* NB/ Numbers in this enum must match up with indices
    into the dwarf_debug_sections[] array above.  */
 enum dwarf_debug_section_enum
 {
@@ -557,7 +556,6 @@ read_section (bfd *	      abfd,
 	  return FALSE;
 	}
       contents = (bfd_byte *) bfd_malloc (amt);
-
       if (contents == NULL)
 	return FALSE;
       if (syms
@@ -704,6 +702,7 @@ read_indirect_string (struct comp_unit *
 {
   bfd_uint64_t offset;
   struct dwarf2_debug *stash = unit->stash;
+  struct dwarf2_debug_file *file = unit->file;
   char *str;
 
   if (buf + unit->offset_size > buf_end)
@@ -720,13 +719,11 @@ read_indirect_string (struct comp_unit *
   *bytes_read_ptr = unit->offset_size;
 
   if (! read_section (unit->abfd, &stash->debug_sections[debug_str],
-		      stash->syms, offset,
-		      &stash->dwarf_str_buffer, &stash->dwarf_str_size))
+		      file->syms, offset,
+		      &file->dwarf_str_buffer, &file->dwarf_str_size))
     return NULL;
 
-  if (offset >= stash->dwarf_str_size)
-    return NULL;
-  str = (char *) stash->dwarf_str_buffer + offset;
+  str = (char *) file->dwarf_str_buffer + offset;
   if (*str == '\0')
     return NULL;
   return str;
@@ -742,6 +739,7 @@ read_indirect_line_string (struct comp_u
 {
   bfd_uint64_t offset;
   struct dwarf2_debug *stash = unit->stash;
+  struct dwarf2_debug_file *file = unit->file;
   char *str;
 
   if (buf + unit->offset_size > buf_end)
@@ -758,14 +756,12 @@ read_indirect_line_string (struct comp_u
   *bytes_read_ptr = unit->offset_size;
 
   if (! read_section (unit->abfd, &stash->debug_sections[debug_line_str],
-		      stash->syms, offset,
-		      &stash->dwarf_line_str_buffer,
-		      &stash->dwarf_line_str_size))
+		      file->syms, offset,
+		      &file->dwarf_line_str_buffer,
+		      &file->dwarf_line_str_size))
     return NULL;
 
-  if (offset >= stash->dwarf_line_str_size)
-    return NULL;
-  str = (char *) stash->dwarf_line_str_buffer + offset;
+  str = (char *) file->dwarf_line_str_buffer + offset;
   if (*str == '\0')
     return NULL;
   return str;
@@ -798,38 +794,36 @@ read_alt_indirect_string (struct comp_un
 
   *bytes_read_ptr = unit->offset_size;
 
-  if (stash->alt_bfd_ptr == NULL)
+  if (stash->alt.bfd_ptr == NULL)
     {
-      bfd *  debug_bfd;
-      char * debug_filename = bfd_follow_gnu_debugaltlink (unit->abfd, DEBUGDIR);
+      bfd *debug_bfd;
+      char *debug_filename = bfd_follow_gnu_debugaltlink (unit->abfd, DEBUGDIR);
 
       if (debug_filename == NULL)
 	return NULL;
 
-      if ((debug_bfd = bfd_openr (debug_filename, NULL)) == NULL
-	  || ! bfd_check_format (debug_bfd, bfd_object))
-	{
-	  if (debug_bfd)
-	    bfd_close (debug_bfd);
+      debug_bfd = bfd_openr (debug_filename, NULL);
+      free (debug_filename);
+      if (debug_bfd == NULL)
+	/* FIXME: Should we report our failure to follow the debuglink ?  */
+	return NULL;
 
-	  /* FIXME: Should we report our failure to follow the debuglink ?  */
-	  free (debug_filename);
+      if (!bfd_check_format (debug_bfd, bfd_object))
+	{
+	  bfd_close (debug_bfd);
 	  return NULL;
 	}
-      stash->alt_bfd_ptr = debug_bfd;
+      stash->alt.bfd_ptr = debug_bfd;
     }
 
-  if (! read_section (unit->stash->alt_bfd_ptr,
+  if (! read_section (unit->stash->alt.bfd_ptr,
 		      stash->debug_sections + debug_str_alt,
-		      NULL, /* FIXME: Do we need to load alternate symbols ?  */
-		      offset,
-		      &stash->alt_dwarf_str_buffer,
-		      &stash->alt_dwarf_str_size))
+		      stash->alt.syms, offset,
+		      &stash->alt.dwarf_str_buffer,
+		      &stash->alt.dwarf_str_size))
     return NULL;
 
-  if (offset >= stash->alt_dwarf_str_size)
-    return NULL;
-  str = (char *) stash->alt_dwarf_str_buffer + offset;
+  str = (char *) stash->alt.dwarf_str_buffer + offset;
   if (*str == '\0')
     return NULL;
 
@@ -846,38 +840,36 @@ read_alt_indirect_ref (struct comp_unit
 {
   struct dwarf2_debug *stash = unit->stash;
 
-  if (stash->alt_bfd_ptr == NULL)
+  if (stash->alt.bfd_ptr == NULL)
     {
-      bfd *  debug_bfd;
-      char * debug_filename = bfd_follow_gnu_debugaltlink (unit->abfd, DEBUGDIR);
+      bfd *debug_bfd;
+      char *debug_filename = bfd_follow_gnu_debugaltlink (unit->abfd, DEBUGDIR);
 
       if (debug_filename == NULL)
-	return FALSE;
+	return NULL;
 
-      if ((debug_bfd = bfd_openr (debug_filename, NULL)) == NULL
-	  || ! bfd_check_format (debug_bfd, bfd_object))
-	{
-	  if (debug_bfd)
-	    bfd_close (debug_bfd);
+      debug_bfd = bfd_openr (debug_filename, NULL);
+      free (debug_filename);
+      if (debug_bfd == NULL)
+	/* FIXME: Should we report our failure to follow the debuglink ?  */
+	return NULL;
 
-	  /* FIXME: Should we report our failure to follow the debuglink ?  */
-	  free (debug_filename);
+      if (!bfd_check_format (debug_bfd, bfd_object))
+	{
+	  bfd_close (debug_bfd);
 	  return NULL;
 	}
-      stash->alt_bfd_ptr = debug_bfd;
+      stash->alt.bfd_ptr = debug_bfd;
     }
 
-  if (! read_section (unit->stash->alt_bfd_ptr,
+  if (! read_section (unit->stash->alt.bfd_ptr,
 		      stash->debug_sections + debug_info_alt,
-		      NULL, /* FIXME: Do we need to load alternate symbols ?  */
-		      offset,
-		      &stash->alt_dwarf_info_buffer,
-		      &stash->alt_dwarf_info_size))
+		      stash->alt.syms, offset,
+		      &stash->alt.dwarf_info_buffer,
+		      &stash->alt.dwarf_info_size))
     return NULL;
 
-  if (offset >= stash->alt_dwarf_info_size)
-    return NULL;
-  return stash->alt_dwarf_info_buffer + offset;
+  return stash->alt.dwarf_info_buffer + offset;
 }
 
 static bfd_uint64_t
@@ -943,13 +935,59 @@ lookup_abbrev (unsigned int number, stru
   return NULL;
 }
 
+/* We keep a hash table to map .debug_abbrev section offsets to the
+   array of abbrevs, so that compilation units using the same set of
+   abbrevs do not waste memory.  */
+
+struct abbrev_offset_entry
+{
+  size_t offset;
+  struct abbrev_info **abbrevs;
+};
+
+static hashval_t
+hash_abbrev (const void *p)
+{
+  const struct abbrev_offset_entry *ent = p;
+  return htab_hash_pointer ((void *) ent->offset);
+}
+
+static int
+eq_abbrev (const void *pa, const void *pb)
+{
+  const struct abbrev_offset_entry *a = pa;
+  const struct abbrev_offset_entry *b = pb;
+  return a->offset == b->offset;
+}
+
+static void
+del_abbrev (void *p)
+{
+  struct abbrev_offset_entry *ent = p;
+  struct abbrev_info **abbrevs = ent->abbrevs;
+  size_t i;
+
+  for (i = 0; i < ABBREV_HASH_SIZE; i++)
+    {
+      struct abbrev_info *abbrev = abbrevs[i];
+
+      while (abbrev)
+	{
+	  free (abbrev->attrs);
+	  abbrev = abbrev->next;
+	}
+    }
+  free (ent);
+}
+
 /* In DWARF version 2, the description of the debugging information is
    stored in a separate .debug_abbrev section.  Before we read any
    dies from a section we read in all abbreviations and install them
    in a hash table.  */
 
 static struct abbrev_info**
-read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash)
+read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash,
+	      struct dwarf2_debug_file *file)
 {
   struct abbrev_info **abbrevs;
   bfd_byte *abbrev_ptr;
@@ -958,13 +996,22 @@ read_abbrevs (bfd *abfd, bfd_uint64_t of
   unsigned int abbrev_number, bytes_read, abbrev_name;
   unsigned int abbrev_form, hash_number;
   bfd_size_type amt;
+  void **slot;
+  struct abbrev_offset_entry ent = { offset, NULL };
 
-  if (! read_section (abfd, &stash->debug_sections[debug_abbrev],
-		      stash->syms, offset,
-		      &stash->dwarf_abbrev_buffer, &stash->dwarf_abbrev_size))
+  if (ent.offset != offset)
     return NULL;
 
-  if (offset >= stash->dwarf_abbrev_size)
+  slot = htab_find_slot (file->abbrev_offsets, &ent, INSERT);
+  if (slot == NULL)
+    return NULL;
+  if (*slot != NULL)
+    return ((struct abbrev_offset_entry *) (*slot))->abbrevs;
+
+  if (! read_section (abfd, &stash->debug_sections[debug_abbrev],
+		      file->syms, offset,
+		      &file->dwarf_abbrev_buffer,
+		      &file->dwarf_abbrev_size))
     return NULL;
 
   amt = sizeof (struct abbrev_info*) * ABBREV_HASH_SIZE;
@@ -972,8 +1019,8 @@ read_abbrevs (bfd *abfd, bfd_uint64_t of
   if (abbrevs == NULL)
     return NULL;
 
-  abbrev_ptr = stash->dwarf_abbrev_buffer + offset;
-  abbrev_end = stash->dwarf_abbrev_buffer + stash->dwarf_abbrev_size;
+  abbrev_ptr = file->dwarf_abbrev_buffer + offset;
+  abbrev_end = file->dwarf_abbrev_buffer + file->dwarf_abbrev_size;
   abbrev_number = _bfd_safe_read_leb128 (abfd, abbrev_ptr, &bytes_read,
 					 FALSE, abbrev_end);
   abbrev_ptr += bytes_read;
@@ -984,7 +1031,7 @@ read_abbrevs (bfd *abfd, bfd_uint64_t of
       amt = sizeof (struct abbrev_info);
       cur_abbrev = (struct abbrev_info *) bfd_zalloc (abfd, amt);
       if (cur_abbrev == NULL)
-	return NULL;
+	goto fail;
 
       /* Read in abbrev header.  */
       cur_abbrev->number = abbrev_number;
@@ -1026,21 +1073,7 @@ read_abbrevs (bfd *abfd, bfd_uint64_t of
 	      amt *= sizeof (struct attr_abbrev);
 	      tmp = (struct attr_abbrev *) bfd_realloc (cur_abbrev->attrs, amt);
 	      if (tmp == NULL)
-		{
-		  size_t i;
-
-		  for (i = 0; i < ABBREV_HASH_SIZE; i++)
-		    {
-		      struct abbrev_info *abbrev = abbrevs[i];
-
-		      while (abbrev)
-			{
-			  free (abbrev->attrs);
-			  abbrev = abbrev->next;
-			}
-		    }
-		  return NULL;
-		}
+		goto fail;
 	      cur_abbrev->attrs = tmp;
 	    }
 
@@ -1064,8 +1097,8 @@ read_abbrevs (bfd *abfd, bfd_uint64_t of
 	 already read (which means we are about to read the abbreviations
 	 for the next compile unit) or if the end of the abbreviation
 	 table is reached.  */
-      if ((unsigned int) (abbrev_ptr - stash->dwarf_abbrev_buffer)
-	  >= stash->dwarf_abbrev_size)
+      if ((size_t) (abbrev_ptr - file->dwarf_abbrev_buffer)
+	  >= file->dwarf_abbrev_size)
 	break;
       abbrev_number = _bfd_safe_read_leb128 (abfd, abbrev_ptr,
 					     &bytes_read, FALSE, abbrev_end);
@@ -1074,7 +1107,31 @@ read_abbrevs (bfd *abfd, bfd_uint64_t of
 	break;
     }
 
+  *slot = bfd_malloc (sizeof ent);
+  if (!*slot)
+    goto fail;
+  ent.abbrevs = abbrevs;
+  memcpy (*slot, &ent, sizeof ent);
   return abbrevs;
+
+ fail:
+  if (abbrevs != NULL)
+    {
+      size_t i;
+
+      for (i = 0; i < ABBREV_HASH_SIZE; i++)
+	{
+	  struct abbrev_info *abbrev = abbrevs[i];
+
+	  while (abbrev)
+	    {
+	      free (abbrev->attrs);
+	      abbrev = abbrev->next;
+	    }
+	}
+      free (abbrevs);
+    }
+  return NULL;
 }
 
 /* Returns true if the form is one which has a string value.  */
@@ -1409,6 +1466,8 @@ struct lookup_funcinfo
      The highest address of all prior functions after the lookup table is
      sorted, which is used for binary search.  */
   bfd_vma		high_addr;
+  /* Index of this function, used to ensure qsort is stable.  */
+  unsigned int idx;
 };
 
 struct varinfo
@@ -1709,6 +1768,11 @@ compare_sequences (const void* a, const
   if (seq1->last_line->op_index > seq2->last_line->op_index)
     return -1;
 
+  /* num_lines is initially an index, to make the sort stable.  */
+  if (seq1->num_lines < seq2->num_lines)
+    return -1;
+  if (seq1->num_lines > seq2->num_lines)
+    return 1;
   return 0;
 }
 
@@ -1735,12 +1799,14 @@ build_line_info_table (struct line_info_
   for (each_line = seq->last_line; each_line; each_line = each_line->prev_line)
     num_lines++;
 
+  seq->num_lines = num_lines;
   if (num_lines == 0)
     return TRUE;
 
   /* Allocate space for the line information lookup table.  */
   amt = sizeof (struct line_info*) * num_lines;
   line_info_lookup = (struct line_info**) bfd_alloc (table->abfd, amt);
+  seq->line_info_lookup = line_info_lookup;
   if (line_info_lookup == NULL)
     return FALSE;
 
@@ -1750,10 +1816,6 @@ build_line_info_table (struct line_info_
     line_info_lookup[--line_index] = each_line;
 
   BFD_ASSERT (line_index == 0);
-
-  seq->num_lines = num_lines;
-  seq->line_info_lookup = line_info_lookup;
-
   return TRUE;
 }
 
@@ -1789,7 +1851,7 @@ sort_line_sequences (struct line_info_ta
       sequences[n].prev_sequence = NULL;
       sequences[n].last_line = seq->last_line;
       sequences[n].line_info_lookup = NULL;
-      sequences[n].num_lines = 0;
+      sequences[n].num_lines = n;
       seq = seq->prev_sequence;
       free (last_seq);
     }
@@ -2016,9 +2078,11 @@ read_formatted_entries (struct comp_unit
 /* Decode the line number information for UNIT.  */
 
 static struct line_info_table*
-decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
+decode_line_info (struct comp_unit *unit)
 {
   bfd *abfd = unit->abfd;
+  struct dwarf2_debug *stash = unit->stash;
+  struct dwarf2_debug_file *file = unit->file;
   struct line_info_table* table;
   bfd_byte *line_ptr;
   bfd_byte *line_end;
@@ -2029,39 +2093,24 @@ decode_line_info (struct comp_unit *unit
   unsigned int exop_len;
   bfd_size_type amt;
 
-  if (! read_section (abfd, &stash->debug_sections[debug_line],
-		      stash->syms, unit->line_offset,
-		      &stash->dwarf_line_buffer, &stash->dwarf_line_size))
-    return NULL;
+  if (unit->line_offset == 0 && file->line_table)
+    return file->line_table;
 
-  amt = sizeof (struct line_info_table);
-  table = (struct line_info_table *) bfd_alloc (abfd, amt);
-  if (table == NULL)
+  if (! read_section (abfd, &stash->debug_sections[debug_line],
+		      file->syms, unit->line_offset,
+		      &file->dwarf_line_buffer, &file->dwarf_line_size))
     return NULL;
-  table->abfd = abfd;
-  table->comp_dir = unit->comp_dir;
-
-  table->num_files = 0;
-  table->files = NULL;
-
-  table->num_dirs = 0;
-  table->dirs = NULL;
-
-  table->num_sequences = 0;
-  table->sequences = NULL;
-
-  table->lcl_head = NULL;
 
-  if (stash->dwarf_line_size < 16)
+  if (file->dwarf_line_size < 16)
     {
       _bfd_error_handler
 	(_("DWARF error: line info section is too small (%" PRId64 ")"),
-	 (int64_t) stash->dwarf_line_size);
+	 (int64_t) file->dwarf_line_size);
       bfd_set_error (bfd_error_bad_value);
       return NULL;
     }
-  line_ptr = stash->dwarf_line_buffer + unit->line_offset;
-  line_end = stash->dwarf_line_buffer + stash->dwarf_line_size;
+  line_ptr = file->dwarf_line_buffer + unit->line_offset;
+  line_end = file->dwarf_line_buffer + file->dwarf_line_size;
 
   /* Read in the prologue.  */
   lh.total_length = read_4_bytes (abfd, line_ptr, line_end);
@@ -2188,6 +2237,24 @@ decode_line_info (struct comp_unit *unit
       line_ptr += 1;
     }
 
+  amt = sizeof (struct line_info_table);
+  table = (struct line_info_table *) bfd_alloc (abfd, amt);
+  if (table == NULL)
+    return NULL;
+  table->abfd = abfd;
+  table->comp_dir = unit->comp_dir;
+
+  table->num_files = 0;
+  table->files = NULL;
+
+  table->num_dirs = 0;
+  table->dirs = NULL;
+
+  table->num_sequences = 0;
+  table->sequences = NULL;
+
+  table->lcl_head = NULL;
+
   if (lh.version >= 5)
     {
       /* Read directory table.  */
@@ -2387,16 +2454,16 @@ decode_line_info (struct comp_unit *unit
 	      break;
 	    case DW_LNS_set_file:
 	      {
-		unsigned int file;
+		unsigned int filenum;
 
 		/* The file and directory tables are 0
 		   based, the references are 1 based.  */
-		file = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
-					      FALSE, line_end);
+		filenum = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
+						 FALSE, line_end);
 		line_ptr += bytes_read;
 		if (filename)
 		  free (filename);
-		filename = concat_filename (table, file);
+		filename = concat_filename (table, filenum);
 		break;
 	      }
 	    case DW_LNS_set_column:
@@ -2445,6 +2512,8 @@ decode_line_info (struct comp_unit *unit
 	free (filename);
     }
 
+  if (unit->line_offset == 0)
+    file->line_table = table;
   if (sort_line_sequences (table))
     return table;
 
@@ -2540,12 +2609,12 @@ fail:
 static bfd_boolean
 read_debug_ranges (struct comp_unit * unit)
 {
-  struct dwarf2_debug * stash = unit->stash;
+  struct dwarf2_debug *stash = unit->stash;
+  struct dwarf2_debug_file *file = unit->file;
 
   return read_section (unit->abfd, &stash->debug_sections[debug_ranges],
-		       stash->syms, 0,
-		       &stash->dwarf_ranges_buffer,
-		       &stash->dwarf_ranges_size);
+		       file->syms, 0,
+		       &file->dwarf_ranges_buffer, &file->dwarf_ranges_size);
 }
 
 /* Function table functions.  */
@@ -2565,6 +2634,10 @@ compare_lookup_funcinfos (const void * a
   if (lookup1->high_addr > lookup2->high_addr)
     return 1;
 
+  if (lookup1->idx < lookup2->idx)
+    return -1;
+  if (lookup1->idx > lookup2->idx)
+    return 1;
   return 0;
 }
 
@@ -2594,6 +2667,7 @@ build_lookup_funcinfo_table (struct comp
     {
       entry = &lookup_funcinfo_table[--func_index];
       entry->funcinfo = each;
+      entry->idx = func_index;
 
       /* Calculate the lowest and highest address for this function entry.  */
       low_addr  = entry->funcinfo->arange.low;
@@ -2803,17 +2877,21 @@ lookup_symbol_in_variable_table (struct
   return FALSE;
 }
 
+static struct comp_unit *stash_comp_unit (struct dwarf2_debug *,
+					  struct dwarf2_debug_file *);
+static bfd_boolean comp_unit_maybe_decode_line_info (struct comp_unit *);
+
 static bfd_boolean
-find_abstract_instance (struct comp_unit *   unit,
-			bfd_byte *           orig_info_ptr,
-			struct attribute *   attr_ptr,
-			const char **        pname,
-			bfd_boolean *        is_linkage,
-			char **              filename_ptr,
-			int *                linenumber_ptr)
+find_abstract_instance (struct comp_unit *unit,
+			struct attribute *attr_ptr,
+			unsigned int recur_count,
+			const char **pname,
+			bfd_boolean *is_linkage,
+			char **filename_ptr,
+			int *linenumber_ptr)
 {
   bfd *abfd = unit->abfd;
-  bfd_byte *info_ptr;
+  bfd_byte *info_ptr = NULL;
   bfd_byte *info_ptr_end;
   unsigned int abbrev_number, bytes_read, i;
   struct abbrev_info *abbrev;
@@ -2821,6 +2899,14 @@ find_abstract_instance (struct comp_unit
   struct attribute attr;
   const char *name = NULL;
 
+  if (recur_count == 100)
+    {
+      _bfd_error_handler
+	(_("DWARF error: abstract instance recursion detected"));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }
+
   /* DW_FORM_ref_addr can reference an entry in a different CU. It
      is an offset from the .debug_info section, not the current CU.  */
   if (attr_ptr->form == DW_FORM_ref_addr)
@@ -2838,14 +2924,16 @@ find_abstract_instance (struct comp_unit
 	 a symbolic reference to a label in any .debug_info section
 	 might be used.  Since we lay out multiple .debug_info
 	 sections at non-zero VMAs (see place_sections), and read
-	 them contiguously into stash->info_ptr_memory, that means
-	 the reference is relative to stash->info_ptr_memory.  */
+	 them contiguously into dwarf_info_buffer, that means the
+	 reference is relative to dwarf_info_buffer.  */
       size_t total;
 
-      info_ptr = unit->stash->info_ptr_memory;
-      info_ptr_end = unit->stash->info_ptr_end;
+      info_ptr = unit->file->dwarf_info_buffer;
+      info_ptr_end = info_ptr + unit->file->dwarf_info_size;
       total = info_ptr_end - info_ptr;
-      if (!die_ref || die_ref >= total)
+      if (!die_ref)
+	return TRUE;
+      else if (die_ref >= total)
 	{
 	  _bfd_error_handler
 	    (_("DWARF error: invalid abstract instance DIE ref"));
@@ -2853,14 +2941,38 @@ find_abstract_instance (struct comp_unit
 	  return FALSE;
 	}
       info_ptr += die_ref;
+    }
+  else if (attr_ptr->form == DW_FORM_GNU_ref_alt)
+    {
+      bfd_boolean first_time = unit->stash->alt.dwarf_info_buffer == NULL;
+
+      info_ptr = read_alt_indirect_ref (unit, die_ref);
+      if (first_time)
+	unit->stash->alt.info_ptr = unit->stash->alt.dwarf_info_buffer;
+      if (info_ptr == NULL)
+	{
+	  _bfd_error_handler
+	    (_("DWARF error: unable to read alt ref %" PRIu64),
+	     (uint64_t) die_ref);
+	  bfd_set_error (bfd_error_bad_value);
+	  return FALSE;
+	}
+      info_ptr_end = (unit->stash->alt.dwarf_info_buffer
+		      + unit->stash->alt.dwarf_info_size);
+      if (unit->stash->alt.all_comp_units)
+	unit = unit->stash->alt.all_comp_units;
+    }
 
+  if (attr_ptr->form == DW_FORM_ref_addr
+      || attr_ptr->form == DW_FORM_GNU_ref_alt)
+    {
       /* Now find the CU containing this pointer.  */
       if (info_ptr >= unit->info_ptr_unit && info_ptr < unit->end_ptr)
 	info_ptr_end = unit->end_ptr;
       else
 	{
 	  /* Check other CUs to see if they contain the abbrev.  */
-	  struct comp_unit * u;
+	  struct comp_unit *u;
 
 	  for (u = unit->prev_unit; u != NULL; u = u->prev_unit)
 	    if (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)
@@ -2871,31 +2983,40 @@ find_abstract_instance (struct comp_unit
 	      if (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)
 		break;
 
-	  if (u)
+	  if (attr_ptr->form == DW_FORM_ref_addr)
+	    while (u == NULL)
+	      {
+		u = stash_comp_unit (unit->stash, &unit->stash->f);
+		if (u == NULL)
+		  break;
+		if (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)
+		  break;
+		u = NULL;
+	      }
+
+	  if (attr_ptr->form == DW_FORM_GNU_ref_alt)
+	    while (u == NULL)
+	      {
+		u = stash_comp_unit (unit->stash, &unit->stash->alt);
+		if (u == NULL)
+		  break;
+		if (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)
+		  break;
+		u = NULL;
+	      }
+
+	  if (u == NULL)
 	    {
-	      unit = u;
-	      info_ptr_end = unit->end_ptr;
+	      _bfd_error_handler
+		(_("DWARF error: unable to locate abstract instance DIE ref %"
+		   PRIu64), (uint64_t) die_ref);
+	      bfd_set_error (bfd_error_bad_value);
+	      return FALSE;
 	    }
-	  /* else FIXME: What do we do now ?  */
+	  unit = u;
+	  info_ptr_end = unit->end_ptr;
 	}
     }
-  else if (attr_ptr->form == DW_FORM_GNU_ref_alt)
-    {
-      info_ptr = read_alt_indirect_ref (unit, die_ref);
-      if (info_ptr == NULL)
-	{
-	  _bfd_error_handler
-	    (_("DWARF error: unable to read alt ref %" PRIu64),
-	     (uint64_t) die_ref);
-	  bfd_set_error (bfd_error_bad_value);
-	  return FALSE;
-	}
-      info_ptr_end = (unit->stash->alt_dwarf_info_buffer
-		      + unit->stash->alt_dwarf_info_size);
-
-      /* FIXME: Do we need to locate the correct CU, in a similar
-	 fashion to the code in the DW_FORM_ref_addr case above ?  */
-    }
   else
     {
       /* DW_FORM_ref1, DW_FORM_ref2, DW_FORM_ref4, DW_FORM_ref8 or
@@ -2938,15 +3059,6 @@ find_abstract_instance (struct comp_unit
 					 info_ptr, info_ptr_end);
 	      if (info_ptr == NULL)
 		break;
-	      /* It doesn't ever make sense for DW_AT_specification to
-		 refer to the same DIE.  Stop simple recursion.  */
-	      if (info_ptr == orig_info_ptr)
-		{
-		  _bfd_error_handler
-		    (_("DWARF error: abstract instance recursion detected"));
-		  bfd_set_error (bfd_error_bad_value);
-		  return FALSE;
-		}
 	      switch (attr.name)
 		{
 		case DW_AT_name:
@@ -2960,8 +3072,8 @@ find_abstract_instance (struct comp_unit
 		    }
 		  break;
 		case DW_AT_specification:
-		  if (!find_abstract_instance (unit, info_ptr, &attr,
-					       pname, is_linkage,
+		  if (!find_abstract_instance (unit, &attr, recur_count + 1,
+					       &name, is_linkage,
 					       filename_ptr, linenumber_ptr))
 		    return FALSE;
 		  break;
@@ -2976,6 +3088,8 @@ find_abstract_instance (struct comp_unit
 		    }
 		  break;
 		case DW_AT_decl_file:
+		  if (!comp_unit_maybe_decode_line_info (unit))
+		    return FALSE;
 		  *filename_ptr = concat_filename (unit->line_table,
 						   attr.u.val);
 		  break;
@@ -3000,16 +3114,16 @@ read_rangelist (struct comp_unit *unit,
   bfd_byte *ranges_end;
   bfd_vma base_address = unit->base_address;
 
-  if (! unit->stash->dwarf_ranges_buffer)
+  if (! unit->file->dwarf_ranges_buffer)
     {
       if (! read_debug_ranges (unit))
 	return FALSE;
     }
 
-  ranges_ptr = unit->stash->dwarf_ranges_buffer + offset;
-  if (ranges_ptr < unit->stash->dwarf_ranges_buffer)
+  ranges_ptr = unit->file->dwarf_ranges_buffer + offset;
+  if (ranges_ptr < unit->file->dwarf_ranges_buffer)
     return FALSE;
-  ranges_end = unit->stash->dwarf_ranges_buffer + unit->stash->dwarf_ranges_size;
+  ranges_end = unit->file->dwarf_ranges_buffer + unit->file->dwarf_ranges_size;
 
   for (;;)
     {
@@ -3049,7 +3163,7 @@ scan_unit_for_symbols (struct comp_unit
 {
   bfd *abfd = unit->abfd;
   bfd_byte *info_ptr = unit->first_child_die_ptr;
-  bfd_byte *info_ptr_end = unit->stash->info_ptr_end;
+  bfd_byte *info_ptr_end = unit->end_ptr;
   int nesting_level = 0;
   struct nest_funcinfo {
     struct funcinfo *func;
@@ -3174,7 +3288,7 @@ scan_unit_for_symbols (struct comp_unit
 
 		case DW_AT_abstract_origin:
 		case DW_AT_specification:
-		  if (!find_abstract_instance (unit, info_ptr, &attr,
+		  if (!find_abstract_instance (unit, &attr, 0,
 					       &func->name,
 					       &func->is_linkage,
 					       &func->file,
@@ -3328,7 +3442,7 @@ scan_unit_for_symbols (struct comp_unit
   return FALSE;
 }
 
-/* Parse a DWARF2 compilation unit starting at INFO_PTR.  This
+/* Parse a DWARF2 compilation unit starting at INFO_PTR.  UNIT_LENGTH
    includes the compilation unit header that proceeds the DIE's, but
    does not include the length field that precedes each compilation
    unit header.  END_PTR points one past the end of this comp unit.
@@ -3339,6 +3453,8 @@ scan_unit_for_symbols (struct comp_unit
 
 static struct comp_unit *
 parse_comp_unit (struct dwarf2_debug *stash,
+		 struct dwarf2_debug_file *file,
+		 bfd_byte *info_ptr,
 		 bfd_vma unit_length,
 		 bfd_byte *info_ptr_unit,
 		 unsigned int offset_size)
@@ -3352,12 +3468,11 @@ parse_comp_unit (struct dwarf2_debug *st
   unsigned int abbrev_number, bytes_read, i;
   struct abbrev_info *abbrev;
   struct attribute attr;
-  bfd_byte *info_ptr = stash->info_ptr;
   bfd_byte *end_ptr = info_ptr + unit_length;
   bfd_size_type amt;
   bfd_vma low_pc = 0;
   bfd_vma high_pc = 0;
-  bfd *abfd = stash->bfd_ptr;
+  bfd *abfd = file->bfd_ptr;
   bfd_boolean high_pc_relative = FALSE;
   enum dwarf_unit_type unit_type;
 
@@ -3434,7 +3549,7 @@ parse_comp_unit (struct dwarf2_debug *st
     }
 
   /* Read the abbrevs for this compilation unit into a table.  */
-  abbrevs = read_abbrevs (abfd, abbrev_offset, stash);
+  abbrevs = read_abbrevs (abfd, abbrev_offset, stash, file);
   if (! abbrevs)
     return NULL;
 
@@ -3470,6 +3585,7 @@ parse_comp_unit (struct dwarf2_debug *st
   unit->abbrevs = abbrevs;
   unit->end_ptr = end_ptr;
   unit->stash = stash;
+  unit->file = file;
   unit->info_ptr_unit = info_ptr_unit;
 
   for (i = 0; i < abbrev->num_attrs; ++i)
@@ -3596,42 +3712,17 @@ comp_unit_find_nearest_line (struct comp
 			     const char **filename_ptr,
 			     struct funcinfo **function_ptr,
 			     unsigned int *linenumber_ptr,
-			     unsigned int *discriminator_ptr,
-			     struct dwarf2_debug *stash)
+			     unsigned int *discriminator_ptr)
 {
   bfd_boolean func_p;
 
-  if (unit->error)
+  if (!comp_unit_maybe_decode_line_info (unit))
     return FALSE;
 
-  if (! unit->line_table)
-    {
-      if (! unit->stmtlist)
-	{
-	  unit->error = 1;
-	  return FALSE;
-	}
-
-      unit->line_table = decode_line_info (unit, stash);
-
-      if (! unit->line_table)
-	{
-	  unit->error = 1;
-	  return FALSE;
-	}
-
-      if (unit->first_child_die_ptr < unit->end_ptr
-	  && ! scan_unit_for_symbols (unit))
-	{
-	  unit->error = 1;
-	  return FALSE;
-	}
-    }
-
   *function_ptr = NULL;
   func_p = lookup_address_in_function_table (unit, addr, function_ptr);
   if (func_p && (*function_ptr)->tag == DW_TAG_inlined_subroutine)
-    stash->inliner_chain = *function_ptr;
+    unit->stash->inliner_chain = *function_ptr;
 
   return lookup_address_in_line_info_table (unit->line_table, addr,
 					    filename_ptr,
@@ -3644,8 +3735,7 @@ comp_unit_find_nearest_line (struct comp
    FALSE otherwise.  */
 
 static bfd_boolean
-comp_unit_maybe_decode_line_info (struct comp_unit *unit,
-				  struct dwarf2_debug *stash)
+comp_unit_maybe_decode_line_info (struct comp_unit *unit)
 {
   if (unit->error)
     return FALSE;
@@ -3658,7 +3748,7 @@ comp_unit_maybe_decode_line_info (struct
 	  return FALSE;
 	}
 
-      unit->line_table = decode_line_info (unit, stash);
+      unit->line_table = decode_line_info (unit);
 
       if (! unit->line_table)
 	{
@@ -3690,10 +3780,9 @@ comp_unit_find_line (struct comp_unit *u
 		     asymbol *sym,
 		     bfd_vma addr,
 		     const char **filename_ptr,
-		     unsigned int *linenumber_ptr,
-		     struct dwarf2_debug *stash)
+		     unsigned int *linenumber_ptr)
 {
-  if (!comp_unit_maybe_decode_line_info (unit, stash))
+  if (!comp_unit_maybe_decode_line_info (unit))
     return FALSE;
 
   if (sym->flags & BSF_FUNCTION)
@@ -3752,7 +3841,7 @@ comp_unit_hash_info (struct dwarf2_debug
 
   BFD_ASSERT (stash->info_hash_status != STASH_INFO_HASH_DISABLED);
 
-  if (!comp_unit_maybe_decode_line_info (unit, stash))
+  if (!comp_unit_maybe_decode_line_info (unit))
     return FALSE;
 
   BFD_ASSERT (!unit->cached);
@@ -3883,6 +3972,41 @@ set_debug_vma (bfd *orig_bfd, bfd *debug
     }
 }
 
+/* If the dwarf2 info was found in a separate debug file, return the
+   debug file section corresponding to the section in the original file
+   and the debug file symbols.  */
+
+static void
+_bfd_dwarf2_stash_syms (struct dwarf2_debug *stash, bfd *abfd,
+			asection **sec, asymbol ***syms)
+{
+  if (stash->f.bfd_ptr != abfd)
+    {
+      asection *s, *d;
+
+      if (*sec == NULL)
+	{
+	  *syms = stash->f.syms;
+	  return;
+	}
+
+      for (s = abfd->sections, d = stash->f.bfd_ptr->sections;
+	   s != NULL && d != NULL;
+	   s = s->next, d = d->next)
+	{
+	  if ((d->flags & SEC_DEBUGGING) != 0)
+	    break;
+	  if (s == *sec
+	      && strcmp (s->name, d->name) == 0)
+	    {
+	      *sec = d;
+	      *syms = stash->f.syms;
+	      break;
+	    }
+	}
+    }
+}
+
 /* Unset vmas for adjusted sections in STASH.  */
 
 static void
@@ -3950,9 +4074,9 @@ place_sections (bfd *orig_bfd, struct dw
 
 	  i++;
 	}
-      if (abfd == stash->bfd_ptr)
+      if (abfd == stash->f.bfd_ptr)
 	break;
-      abfd = stash->bfd_ptr;
+      abfd = stash->f.bfd_ptr;
     }
 
   if (i <= 1)
@@ -4015,14 +4139,14 @@ place_sections (bfd *orig_bfd, struct dw
 	      p->adj_vma = sect->vma;
 	      p++;
 	    }
-	  if (abfd == stash->bfd_ptr)
+	  if (abfd == stash->f.bfd_ptr)
 	    break;
-	  abfd = stash->bfd_ptr;
+	  abfd = stash->f.bfd_ptr;
 	}
     }
 
-  if (orig_bfd != stash->bfd_ptr)
-    set_debug_vma (orig_bfd, stash->bfd_ptr);
+  if (orig_bfd != stash->f.bfd_ptr)
+    set_debug_vma (orig_bfd, stash->f.bfd_ptr);
 
   return TRUE;
 }
@@ -4126,13 +4250,13 @@ stash_maybe_update_info_hash_tables (str
   struct comp_unit *each;
 
   /* Exit if hash tables are up-to-date.  */
-  if (stash->all_comp_units == stash->hash_units_head)
+  if (stash->f.all_comp_units == stash->hash_units_head)
     return TRUE;
 
   if (stash->hash_units_head)
     each = stash->hash_units_head->prev_unit;
   else
-    each = stash->last_comp_unit;
+    each = stash->f.last_comp_unit;
 
   while (each)
     {
@@ -4145,7 +4269,7 @@ stash_maybe_update_info_hash_tables (str
       each = each->prev_unit;
     }
 
-  stash->hash_units_head = stash->all_comp_units;
+  stash->hash_units_head = stash->f.all_comp_units;
   return TRUE;
 }
 
@@ -4160,7 +4284,7 @@ stash_verify_info_hash_table (struct dwa
   struct info_list_node *node;
   bfd_boolean found;
 
-  for (each_unit = stash->all_comp_units;
+  for (each_unit = stash->f.all_comp_units;
        each_unit;
        each_unit = each_unit->next_unit)
     {
@@ -4230,8 +4354,8 @@ stash_maybe_enable_info_hash_tables (bfd
   /* We need a forced update so that the info hash tables will
      be created even though there is no compilation unit.  That
      happens if STASH_INFO_HASH_TRIGGER is 0.  */
-  stash_maybe_update_info_hash_tables (stash);
-  stash->info_hash_status = STASH_INFO_HASH_ON;
+  if (stash_maybe_update_info_hash_tables (stash))
+    stash->info_hash_status = STASH_INFO_HASH_ON;
 }
 
 /* Find the file and line associated with a symbol and address using the
@@ -4268,7 +4392,10 @@ save_section_vma (const bfd *abfd, struc
   stash->sec_vma = bfd_malloc (sizeof (*stash->sec_vma) * abfd->section_count);
   if (stash->sec_vma == NULL)
     return FALSE;
-  for (i = 0, s = abfd->sections; i < abfd->section_count; i++, s = s->next)
+  stash->sec_vma_count = abfd->section_count;
+  for (i = 0, s = abfd->sections;
+       s != NULL && i < abfd->section_count;
+       i++, s = s->next)
     {
       if (s->output_section != NULL)
 	stash->sec_vma[i] = s->output_section->vma + s->output_offset;
@@ -4291,7 +4418,15 @@ section_vma_same (const bfd *abfd, const
   asection *s;
   unsigned int i;
 
-  for (i = 0, s = abfd->sections; i < abfd->section_count; i++, s = s->next)
+  /* PR 24334: If the number of sections in ABFD has changed between
+     when the stash was created and now, then we cannot trust the
+     stashed vma information.  */
+  if (abfd->section_count != stash->sec_vma_count)
+    return FALSE;
+
+  for (i = 0, s = abfd->sections;
+       s != NULL && i < abfd->section_count;
+       i++, s = s->next)
     {
       bfd_vma vma;
 
@@ -4329,7 +4464,7 @@ _bfd_dwarf2_slurp_debug_info (bfd *abfd,
 	{
 	  /* Check that we did previously find some debug information
 	     before attempting to make use of it.  */
-	  if (stash->bfd_ptr != NULL)
+	  if (stash->f.bfd_ptr != NULL)
 	    {
 	      if (do_place && !place_sections (abfd, stash))
 		return FALSE;
@@ -4349,10 +4484,20 @@ _bfd_dwarf2_slurp_debug_info (bfd *abfd,
     }
   stash->orig_bfd = abfd;
   stash->debug_sections = debug_sections;
-  stash->syms = symbols;
+  stash->f.syms = symbols;
   if (!save_section_vma (abfd, stash))
     return FALSE;
 
+  stash->f.abbrev_offsets = htab_create_alloc (10, hash_abbrev, eq_abbrev,
+					       del_abbrev, calloc, free);
+  if (!stash->f.abbrev_offsets)
+    return FALSE;
+
+  stash->alt.abbrev_offsets = htab_create_alloc (10, hash_abbrev, eq_abbrev,
+						 del_abbrev, calloc, free);
+  if (!stash->alt.abbrev_offsets)
+    return FALSE;
+
   *pinfo = stash;
 
   if (debug_bfd == NULL)
@@ -4374,26 +4519,28 @@ _bfd_dwarf2_slurp_debug_info (bfd *abfd,
 	   fail more quickly.  */
 	return FALSE;
 
+      debug_bfd = bfd_openr (debug_filename, NULL);
+      free (debug_filename);
+      if (debug_bfd == NULL)
+	/* FIXME: Should we report our failure to follow the debuglink ?  */
+	return FALSE;
+
       /* Set BFD_DECOMPRESS to decompress debug sections.  */
-      if ((debug_bfd = bfd_openr (debug_filename, NULL)) == NULL
-	  || !(debug_bfd->flags |= BFD_DECOMPRESS,
-	       bfd_check_format (debug_bfd, bfd_object))
+      debug_bfd->flags |= BFD_DECOMPRESS;
+      if (!bfd_check_format (debug_bfd, bfd_object)
 	  || (msec = find_debug_info (debug_bfd,
 				      debug_sections, NULL)) == NULL
 	  || !bfd_generic_link_read_symbols (debug_bfd))
 	{
-	  if (debug_bfd)
-	    bfd_close (debug_bfd);
-	  /* FIXME: Should we report our failure to follow the debuglink ?  */
-	  free (debug_filename);
+	  bfd_close (debug_bfd);
 	  return FALSE;
 	}
 
       symbols = bfd_get_outsymbols (debug_bfd);
-      stash->syms = symbols;
+      stash->f.syms = symbols;
       stash->close_on_cleanup = TRUE;
     }
-  stash->bfd_ptr = debug_bfd;
+  stash->f.bfd_ptr = debug_bfd;
 
   if (do_place
       && !place_sections (abfd, stash))
@@ -4416,7 +4563,7 @@ _bfd_dwarf2_slurp_debug_info (bfd *abfd,
       total_size = msec->size;
       if (! read_section (debug_bfd, &stash->debug_sections[debug_info],
 			  symbols, 0,
-			  &stash->info_ptr_memory, &total_size))
+			  &stash->f.dwarf_info_buffer, &total_size))
 	return FALSE;
     }
   else
@@ -4425,10 +4572,19 @@ _bfd_dwarf2_slurp_debug_info (bfd *abfd,
       for (total_size = 0;
 	   msec;
 	   msec = find_debug_info (debug_bfd, debug_sections, msec))
-	total_size += msec->size;
+	{
+	  /* Catch PR25070 testcase overflowing size calculation here.  */
+	  if (total_size + msec->size < total_size
+	      || total_size + msec->size < msec->size)
+	    {
+	      bfd_set_error (bfd_error_no_memory);
+	      return FALSE;
+	    }
+	  total_size += msec->size;
+	}
 
-      stash->info_ptr_memory = (bfd_byte *) bfd_malloc (total_size);
-      if (stash->info_ptr_memory == NULL)
+      stash->f.dwarf_info_buffer = (bfd_byte *) bfd_malloc (total_size);
+      if (stash->f.dwarf_info_buffer == NULL)
 	return FALSE;
 
       total_size = 0;
@@ -4443,7 +4599,7 @@ _bfd_dwarf2_slurp_debug_info (bfd *abfd,
 	    continue;
 
 	  if (!(bfd_simple_get_relocated_section_contents
-		(debug_bfd, msec, stash->info_ptr_memory + total_size,
+		(debug_bfd, msec, stash->f.dwarf_info_buffer + total_size,
 		 symbols)))
 	    return FALSE;
 
@@ -4451,13 +4607,106 @@ _bfd_dwarf2_slurp_debug_info (bfd *abfd,
 	}
     }
 
-  stash->info_ptr = stash->info_ptr_memory;
-  stash->info_ptr_end = stash->info_ptr + total_size;
-  stash->sec = find_debug_info (debug_bfd, debug_sections, NULL);
-  stash->sec_info_ptr = stash->info_ptr;
+  stash->f.info_ptr = stash->f.dwarf_info_buffer;
+  stash->f.dwarf_info_size = total_size;
   return TRUE;
 }
 
+/* Parse the next DWARF2 compilation unit at FILE->INFO_PTR.  */
+
+static struct comp_unit *
+stash_comp_unit (struct dwarf2_debug *stash, struct dwarf2_debug_file *file)
+{
+  bfd_size_type length;
+  unsigned int offset_size;
+  bfd_byte *info_ptr_unit = file->info_ptr;
+  bfd_byte *info_ptr_end = file->dwarf_info_buffer + file->dwarf_info_size;
+
+  if (file->info_ptr >= info_ptr_end)
+    return NULL;
+
+  length = read_4_bytes (file->bfd_ptr, file->info_ptr, info_ptr_end);
+  /* A 0xffffff length is the DWARF3 way of indicating
+     we use 64-bit offsets, instead of 32-bit offsets.  */
+  if (length == 0xffffffff)
+    {
+      offset_size = 8;
+      length = read_8_bytes (file->bfd_ptr, file->info_ptr + 4,
+			     info_ptr_end);
+      file->info_ptr += 12;
+    }
+  /* A zero length is the IRIX way of indicating 64-bit offsets,
+     mostly because the 64-bit length will generally fit in 32
+     bits, and the endianness helps.  */
+  else if (length == 0)
+    {
+      offset_size = 8;
+      length = read_4_bytes (file->bfd_ptr, file->info_ptr + 4,
+			     info_ptr_end);
+      file->info_ptr += 8;
+    }
+  /* In the absence of the hints above, we assume 32-bit DWARF2
+     offsets even for targets with 64-bit addresses, because:
+     a) most of the time these targets will not have generated
+     more than 2Gb of debug info and so will not need 64-bit
+     offsets,
+     and
+     b) if they do use 64-bit offsets but they are not using
+     the size hints that are tested for above then they are
+     not conforming to the DWARF3 standard anyway.  */
+  else
+    {
+      offset_size = 4;
+      file->info_ptr += 4;
+    }
+
+  if (length != 0
+      && file->info_ptr + length <= info_ptr_end
+      && file->info_ptr + length > file->info_ptr)
+    {
+      struct comp_unit *each = parse_comp_unit (stash, file,
+						file->info_ptr, length,
+						info_ptr_unit, offset_size);
+      if (each)
+	{
+	  if (file->all_comp_units)
+	    file->all_comp_units->prev_unit = each;
+	  else
+	    file->last_comp_unit = each;
+
+	  each->next_unit = file->all_comp_units;
+	  file->all_comp_units = each;
+
+	  file->info_ptr += length;
+	  return each;
+	}
+    }
+
+  /* Don't trust any of the DWARF info after a corrupted length or
+     parse error.  */
+  file->info_ptr = info_ptr_end;
+  return NULL;
+}
+
+/* Hash function for an asymbol.  */
+
+static hashval_t
+hash_asymbol (const void *sym)
+{
+  const asymbol *asym = sym;
+  return htab_hash_string (asym->name);
+}
+
+/* Equality function for asymbols.  */
+
+static int
+eq_asymbol (const void *a, const void *b)
+{
+  const asymbol *sa = a;
+  const asymbol *sb = b;
+  return strcmp (sa->name, sb->name) == 0;
+}
+
 /* Scan the debug information in PINFO looking for a DW_TAG_subprogram
    abbrev with a DW_AT_low_pc attached to it.  Then lookup that same
    symbol in SYMBOLS and return the difference between the low_pc and
@@ -4468,60 +4717,71 @@ _bfd_dwarf2_find_symbol_bias (asymbol **
 {
   struct dwarf2_debug *stash;
   struct comp_unit * unit;
+  htab_t sym_hash;
+  bfd_signed_vma result = 0;
+  asymbol ** psym;
 
   stash = (struct dwarf2_debug *) *pinfo;
 
   if (stash == NULL || symbols == NULL)
     return 0;
 
-  for (unit = stash->all_comp_units; unit; unit = unit->next_unit)
+  sym_hash = htab_create_alloc (10, hash_asymbol, eq_asymbol,
+				NULL, xcalloc, free);
+  for (psym = symbols; * psym != NULL; psym++)
     {
-      struct funcinfo * func;
+      asymbol * sym = * psym;
 
-      if (unit->function_table == NULL)
+      if (sym->flags & BSF_FUNCTION && sym->section != NULL)
 	{
-	  if (unit->line_table == NULL)
-	    unit->line_table = decode_line_info (unit, stash);
-	  if (unit->line_table != NULL)
-	    scan_unit_for_symbols (unit);
+	  void **slot = htab_find_slot (sym_hash, sym, INSERT);
+	  *slot = sym;
 	}
+    }
+
+  for (unit = stash->f.all_comp_units; unit; unit = unit->next_unit)
+    {
+      struct funcinfo * func;
+
+      comp_unit_maybe_decode_line_info (unit);
 
       for (func = unit->function_table; func != NULL; func = func->prev_func)
 	if (func->name && func->arange.low)
 	  {
-	    asymbol ** psym;
+	    asymbol search, *sym;
 
 	    /* FIXME: Do we need to scan the aranges looking for the lowest pc value ?  */
 
-	    for (psym = symbols; * psym != NULL; psym++)
+	    search.name = func->name;
+	    sym = htab_find (sym_hash, &search);
+	    if (sym != NULL)
 	      {
-		asymbol * sym = * psym;
-
-		if (sym->flags & BSF_FUNCTION
-		    && sym->section != NULL
-		    && strcmp (sym->name, func->name) == 0)
-		  return ((bfd_signed_vma) func->arange.low) -
-		    ((bfd_signed_vma) (sym->value + sym->section->vma));
+		result = ((bfd_signed_vma) func->arange.low) -
+		  ((bfd_signed_vma) (sym->value + sym->section->vma));
+		goto done;
 	      }
 	  }
     }
 
-  return 0;
+ done:
+  htab_delete (sym_hash);
+  return result;
 }
 
 /* Find the source code location of SYMBOL.  If SYMBOL is NULL
    then find the nearest source code location corresponding to
    the address SECTION + OFFSET.
-   Returns TRUE if the line is found without error and fills in
+   Returns 1 if the line is found without error and fills in
    FILENAME_PTR and LINENUMBER_PTR.  In the case where SYMBOL was
    NULL the FUNCTIONNAME_PTR is also filled in.
+   Returns 2 if partial information from _bfd_elf_find_function is
+   returned (function and maybe file) by looking at symbols.  DWARF2
+   info is present but not regarding the requested code location.
+   Returns 0 otherwise.
    SYMBOLS contains the symbol table for ABFD.
-   DEBUG_SECTIONS contains the name of the dwarf debug sections.
-   ADDR_SIZE is the number of bytes in the initial .debug_info length
-   field and in the abbreviation offset, or zero to indicate that the
-   default value should be used.  */
+   DEBUG_SECTIONS contains the name of the dwarf debug sections.  */
 
-bfd_boolean
+int
 _bfd_dwarf2_find_nearest_line (bfd *abfd,
 			       asymbol **symbols,
 			       asymbol *symbol,
@@ -4532,7 +4792,6 @@ _bfd_dwarf2_find_nearest_line (bfd *abfd
 			       unsigned int *linenumber_ptr,
 			       unsigned int *discriminator_ptr,
 			       const struct dwarf_debug_section *debug_sections,
-			       unsigned int addr_size,
 			       void **pinfo)
 {
   /* Read each compilation unit from the section .debug_info, and check
@@ -4548,7 +4807,7 @@ _bfd_dwarf2_find_nearest_line (bfd *abfd
   bfd_vma addr;
   struct comp_unit* each;
   struct funcinfo *function = NULL;
-  bfd_boolean found = FALSE;
+  int found = FALSE;
   bfd_boolean do_line;
 
   *filename_ptr = NULL;
@@ -4617,7 +4876,7 @@ _bfd_dwarf2_find_nearest_line (bfd *abfd
 
   /* A null info_ptr indicates that there is no dwarf2 info
      (or that an error occured while setting up the stash).  */
-  if (! stash->info_ptr)
+  if (! stash->f.info_ptr)
     return FALSE;
 
   stash->inliner_chain = NULL;
@@ -4646,13 +4905,13 @@ _bfd_dwarf2_find_nearest_line (bfd *abfd
       else
 	{
 	  /* Check the previously read comp. units first.  */
-	  for (each = stash->all_comp_units; each; each = each->next_unit)
+	  for (each = stash->f.all_comp_units; each; each = each->next_unit)
 	    if ((symbol->flags & BSF_FUNCTION) == 0
 		|| each->arange.high == 0
 		|| comp_unit_contains_address (each, addr))
 	      {
 		found = comp_unit_find_line (each, symbol, addr, filename_ptr,
-					     linenumber_ptr, stash);
+					     linenumber_ptr);
 		if (found)
 		  goto done;
 	      }
@@ -4666,18 +4925,16 @@ _bfd_dwarf2_find_nearest_line (bfd *abfd
       unsigned int local_linenumber = 0;
       unsigned int local_discriminator = 0;
 
-      for (each = stash->all_comp_units; each; each = each->next_unit)
+      for (each = stash->f.all_comp_units; each; each = each->next_unit)
 	{
 	  bfd_vma range = (bfd_vma) -1;
 
 	  found = ((each->arange.high == 0
 		    || comp_unit_contains_address (each, addr))
-		   && (range = comp_unit_find_nearest_line (each, addr,
-							    & local_filename,
-							    & local_function,
-							    & local_linenumber,
-							    & local_discriminator,
-							    stash)) != 0);
+		   && (range = (comp_unit_find_nearest_line
+				(each, addr, &local_filename,
+				 &local_function, &local_linenumber,
+				 &local_discriminator))) != 0);
 	  if (found)
 	    {
 	      /* PRs 15935 15994: Bogus debug information may have provided us
@@ -4713,136 +4970,56 @@ _bfd_dwarf2_find_nearest_line (bfd *abfd
 	}
     }
 
-  /* The DWARF2 spec says that the initial length field, and the
-     offset of the abbreviation table, should both be 4-byte values.
-     However, some compilers do things differently.  */
-  if (addr_size == 0)
-    addr_size = 4;
-  BFD_ASSERT (addr_size == 4 || addr_size == 8);
-
   /* Read each remaining comp. units checking each as they are read.  */
-  while (stash->info_ptr < stash->info_ptr_end)
+  while ((each = stash_comp_unit (stash, &stash->f)) != NULL)
     {
-      bfd_vma length;
-      unsigned int offset_size = addr_size;
-      bfd_byte *info_ptr_unit = stash->info_ptr;
-
-      length = read_4_bytes (stash->bfd_ptr, stash->info_ptr, stash->info_ptr_end);
-      /* A 0xffffff length is the DWARF3 way of indicating
-	 we use 64-bit offsets, instead of 32-bit offsets.  */
-      if (length == 0xffffffff)
-	{
-	  offset_size = 8;
-	  length = read_8_bytes (stash->bfd_ptr, stash->info_ptr + 4, stash->info_ptr_end);
-	  stash->info_ptr += 12;
-	}
-      /* A zero length is the IRIX way of indicating 64-bit offsets,
-	 mostly because the 64-bit length will generally fit in 32
-	 bits, and the endianness helps.  */
-      else if (length == 0)
-	{
-	  offset_size = 8;
-	  length = read_4_bytes (stash->bfd_ptr, stash->info_ptr + 4, stash->info_ptr_end);
-	  stash->info_ptr += 8;
-	}
-      /* In the absence of the hints above, we assume 32-bit DWARF2
-	 offsets even for targets with 64-bit addresses, because:
-	   a) most of the time these targets will not have generated
-	      more than 2Gb of debug info and so will not need 64-bit
-	      offsets,
-	 and
-	   b) if they do use 64-bit offsets but they are not using
-	      the size hints that are tested for above then they are
-	      not conforming to the DWARF3 standard anyway.  */
-      else if (addr_size == 8)
-	{
-	  offset_size = 4;
-	  stash->info_ptr += 4;
-	}
+      /* DW_AT_low_pc and DW_AT_high_pc are optional for
+	 compilation units.  If we don't have them (i.e.,
+	 unit->high == 0), we need to consult the line info table
+	 to see if a compilation unit contains the given
+	 address.  */
+      if (do_line)
+	found = (((symbol->flags & BSF_FUNCTION) == 0
+		  || each->arange.high == 0
+		  || comp_unit_contains_address (each, addr))
+		 && comp_unit_find_line (each, symbol, addr,
+					 filename_ptr, linenumber_ptr));
       else
-	stash->info_ptr += 4;
-
-      if (length > 0)
-	{
-	  bfd_byte * new_ptr;
-
-	  /* PR 21151  */
-	  if (stash->info_ptr + length > stash->info_ptr_end)
-	    return FALSE;
-
-	  each = parse_comp_unit (stash, length, info_ptr_unit,
-				  offset_size);
-	  if (!each)
-	    /* The dwarf information is damaged, don't trust it any
-	       more.  */
-	    break;
-
-	  new_ptr = stash->info_ptr + length;
-	  /* PR 17512: file: 1500698c.  */
-	  if (new_ptr < stash->info_ptr)
-	    {
-	      /* A corrupt length value - do not trust the info any more.  */
-	      found = FALSE;
-	      break;
-	    }
-	  else
-	    stash->info_ptr = new_ptr;
-
-	  if (stash->all_comp_units)
-	    stash->all_comp_units->prev_unit = each;
-	  else
-	    stash->last_comp_unit = each;
-
-	  each->next_unit = stash->all_comp_units;
-	  stash->all_comp_units = each;
-
-	  /* DW_AT_low_pc and DW_AT_high_pc are optional for
-	     compilation units.  If we don't have them (i.e.,
-	     unit->high == 0), we need to consult the line info table
-	     to see if a compilation unit contains the given
-	     address.  */
-	  if (do_line)
-	    found = (((symbol->flags & BSF_FUNCTION) == 0
-		      || each->arange.high == 0
-		      || comp_unit_contains_address (each, addr))
-		     && comp_unit_find_line (each, symbol, addr,
-					     filename_ptr,
-					     linenumber_ptr,
-					     stash));
-	  else
-	    found = ((each->arange.high == 0
-		      || comp_unit_contains_address (each, addr))
-		     && comp_unit_find_nearest_line (each, addr,
-						     filename_ptr,
-						     &function,
-						     linenumber_ptr,
-						     discriminator_ptr,
-						     stash) != 0);
-
-	  if ((bfd_vma) (stash->info_ptr - stash->sec_info_ptr)
-	      == stash->sec->size)
-	    {
-	      stash->sec = find_debug_info (stash->bfd_ptr, debug_sections,
-					    stash->sec);
-	      stash->sec_info_ptr = stash->info_ptr;
-	    }
+	found = ((each->arange.high == 0
+		  || comp_unit_contains_address (each, addr))
+		 && comp_unit_find_nearest_line (each, addr,
+						 filename_ptr,
+						 &function,
+						 linenumber_ptr,
+						 discriminator_ptr) != 0);
 
-	  if (found)
-	    goto done;
-	}
+      if (found)
+	break;
     }
 
  done:
-  if (function)
-    {
-      if (!function->is_linkage)
+  if (functionname_ptr && function && function->is_linkage)
+    *functionname_ptr = function->name;
+  else if (functionname_ptr
+	   && (!*functionname_ptr
+	       || (function && !function->is_linkage)))
+    {
+      asymbol *fun;
+      asymbol **syms = symbols;
+      asection *sec = section;
+
+      _bfd_dwarf2_stash_syms (stash, abfd, &sec, &syms);
+      fun = _bfd_elf_find_function (abfd, syms, sec, offset,
+				    *filename_ptr ? NULL : filename_ptr,
+				    functionname_ptr);
+
+      if (!found && fun != NULL)
+	found = 2;
+
+      if (function && !function->is_linkage)
 	{
-	  asymbol *fun;
 	  bfd_vma sec_vma;
 
-	  fun = _bfd_elf_find_function (abfd, symbols, section, offset,
-					*filename_ptr ? NULL : filename_ptr,
-					functionname_ptr);
 	  sec_vma = section->vma;
 	  if (section->output_section != NULL)
 	    sec_vma = section->output_section->vma + section->output_offset;
@@ -4853,8 +5030,8 @@ _bfd_dwarf2_find_nearest_line (bfd *abfd
 	     to stop a repeated search of symbols.  */
 	  function->is_linkage = TRUE;
 	}
-      *functionname_ptr = function->name;
     }
+
   if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
     unset_sections (stash);
 
@@ -4893,96 +5070,85 @@ _bfd_dwarf2_cleanup_debug_info (bfd *abf
 {
   struct dwarf2_debug *stash = (struct dwarf2_debug *) *pinfo;
   struct comp_unit *each;
+  struct dwarf2_debug_file *file;
 
   if (abfd == NULL || stash == NULL)
     return;
 
-  for (each = stash->all_comp_units; each; each = each->next_unit)
-    {
-      struct abbrev_info **abbrevs = each->abbrevs;
-      struct funcinfo *function_table = each->function_table;
-      struct varinfo *variable_table = each->variable_table;
-      size_t i;
+  if (stash->varinfo_hash_table)
+    bfd_hash_table_free (&stash->varinfo_hash_table->base);
+  if (stash->funcinfo_hash_table)
+    bfd_hash_table_free (&stash->funcinfo_hash_table->base);
 
-      for (i = 0; i < ABBREV_HASH_SIZE; i++)
+  file = &stash->f;
+  while (1)
+    {
+      for (each = file->all_comp_units; each; each = each->next_unit)
 	{
-	  struct abbrev_info *abbrev = abbrevs[i];
+	  struct funcinfo *function_table = each->function_table;
+	  struct varinfo *variable_table = each->variable_table;
 
-	  while (abbrev)
+	  if (each->line_table && each->line_table != file->line_table)
 	    {
-	      free (abbrev->attrs);
-	      abbrev = abbrev->next;
+	      free (each->line_table->files);
+	      free (each->line_table->dirs);
 	    }
-	}
 
-      if (each->line_table)
-	{
-	  free (each->line_table->dirs);
-	  free (each->line_table->files);
-	}
+	  if (each->lookup_funcinfo_table)
+	    {
+	      free (each->lookup_funcinfo_table);
+	      each->lookup_funcinfo_table = NULL;
+	    }
 
-      while (function_table)
-	{
-	  if (function_table->file)
+	  while (function_table)
 	    {
-	      free (function_table->file);
-	      function_table->file = NULL;
+	      if (function_table->file)
+		{
+		  free (function_table->file);
+		  function_table->file = NULL;
+		}
+	      if (function_table->caller_file)
+		{
+		  free (function_table->caller_file);
+		  function_table->caller_file = NULL;
+		}
+	      function_table = function_table->prev_func;
 	    }
 
-	  if (function_table->caller_file)
+	  while (variable_table)
 	    {
-	      free (function_table->caller_file);
-	      function_table->caller_file = NULL;
+	      if (variable_table->file)
+		{
+		  free (variable_table->file);
+		  variable_table->file = NULL;
+		}
+	      variable_table = variable_table->prev_var;
 	    }
-	  function_table = function_table->prev_func;
 	}
 
-      if (each->lookup_funcinfo_table)
+      if (file->line_table)
 	{
-	  free (each->lookup_funcinfo_table);
-	  each->lookup_funcinfo_table = NULL;
+	  free (file->line_table->files);
+	  free (file->line_table->dirs);
 	}
+      htab_delete (file->abbrev_offsets);
 
-      while (variable_table)
-	{
-	  if (variable_table->file)
-	    {
-	      free (variable_table->file);
-	      variable_table->file = NULL;
-	    }
-
-	  variable_table = variable_table->prev_var;
-	}
+      free (file->dwarf_line_str_buffer);
+      free (file->dwarf_str_buffer);
+      free (file->dwarf_ranges_buffer);
+      free (file->dwarf_line_buffer);
+      free (file->dwarf_abbrev_buffer);
+      free (file->dwarf_info_buffer);
+      if (file == &stash->alt)
+	break;
+      file = &stash->alt;
     }
-
-  if (stash->funcinfo_hash_table)
-    bfd_hash_table_free (&stash->funcinfo_hash_table->base);
-  if (stash->varinfo_hash_table)
-    bfd_hash_table_free (&stash->varinfo_hash_table->base);
-  if (stash->dwarf_abbrev_buffer)
-    free (stash->dwarf_abbrev_buffer);
-  if (stash->dwarf_line_buffer)
-    free (stash->dwarf_line_buffer);
-  if (stash->dwarf_str_buffer)
-    free (stash->dwarf_str_buffer);
-  if (stash->dwarf_line_str_buffer)
-    free (stash->dwarf_line_str_buffer);
-  if (stash->dwarf_ranges_buffer)
-    free (stash->dwarf_ranges_buffer);
-  if (stash->info_ptr_memory)
-    free (stash->info_ptr_memory);
+  free (stash->sec_vma);
+  free (stash->adjusted_sections);
   if (stash->close_on_cleanup)
-    bfd_close (stash->bfd_ptr);
-  if (stash->alt_dwarf_str_buffer)
-    free (stash->alt_dwarf_str_buffer);
-  if (stash->alt_dwarf_info_buffer)
-    free (stash->alt_dwarf_info_buffer);
-  if (stash->sec_vma)
-    free (stash->sec_vma);
-  if (stash->adjusted_sections)
-    free (stash->adjusted_sections);
-  if (stash->alt_bfd_ptr)
-    bfd_close (stash->alt_bfd_ptr);
+    bfd_close (stash->f.bfd_ptr);
+  if (stash->alt.bfd_ptr)
+    bfd_close (stash->alt.bfd_ptr);
 }
 
 /* Find the function to a particular section and offset,
diff -rup binutils.orig/bfd/elf.c binutils-2.31.1/bfd/elf.c
--- binutils.orig/bfd/elf.c	2020-01-02 14:32:32.308580209 +0000
+++ binutils-2.31.1/bfd/elf.c	2020-01-02 15:47:37.787602075 +0000
@@ -8796,7 +8796,7 @@ _bfd_elf_find_nearest_line (bfd *abfd,
   if (_bfd_dwarf2_find_nearest_line (abfd, symbols, NULL, section, offset,
 				     filename_ptr, functionname_ptr,
 				     line_ptr, discriminator_ptr,
-				     dwarf_debug_sections, 0,
+				     dwarf_debug_sections,
 				     &elf_tdata (abfd)->dwarf2_find_line_info)
       || _bfd_dwarf1_find_nearest_line (abfd, symbols, section, offset,
 					filename_ptr, functionname_ptr,
@@ -8836,7 +8836,7 @@ _bfd_elf_find_line (bfd *abfd, asymbol *
 {
   return _bfd_dwarf2_find_nearest_line (abfd, symbols, symbol, NULL, 0,
 					filename_ptr, NULL, line_ptr, NULL,
-					dwarf_debug_sections, 0,
+					dwarf_debug_sections,
 					&elf_tdata (abfd)->dwarf2_find_line_info);
 }
 
diff -rup binutils.orig/bfd/libbfd.h binutils-2.31.1/bfd/libbfd.h
--- binutils.orig/bfd/libbfd.h	2020-01-02 14:32:32.314580165 +0000
+++ binutils-2.31.1/bfd/libbfd.h	2020-01-02 15:46:47.466969159 +0000
@@ -589,10 +589,10 @@ struct dwarf_debug_section
 extern const struct dwarf_debug_section dwarf_debug_sections[] ATTRIBUTE_HIDDEN;
 
 /* Find the nearest line using DWARF 2 debugging information.  */
-extern bfd_boolean _bfd_dwarf2_find_nearest_line
+extern int _bfd_dwarf2_find_nearest_line
   (bfd *, asymbol **, asymbol *, asection *, bfd_vma,
    const char **, const char **, unsigned int *, unsigned int *,
-   const struct dwarf_debug_section *, unsigned int, void **) ATTRIBUTE_HIDDEN;
+   const struct dwarf_debug_section *, void **) ATTRIBUTE_HIDDEN;
 
 /* Find the bias between DWARF addresses and real addresses.  */
 extern bfd_signed_vma _bfd_dwarf2_find_symbol_bias
diff -rup binutils.orig/bfd/libbfd-in.h binutils-2.31.1/bfd/libbfd-in.h
--- binutils.orig/bfd/libbfd-in.h	2020-01-02 14:32:32.299580275 +0000
+++ binutils-2.31.1/bfd/libbfd-in.h	2020-01-02 15:44:24.140016525 +0000
@@ -584,10 +584,10 @@ struct dwarf_debug_section
 extern const struct dwarf_debug_section dwarf_debug_sections[] ATTRIBUTE_HIDDEN;
 
 /* Find the nearest line using DWARF 2 debugging information.  */
-extern bfd_boolean _bfd_dwarf2_find_nearest_line
+extern int _bfd_dwarf2_find_nearest_line
   (bfd *, asymbol **, asymbol *, asection *, bfd_vma,
    const char **, const char **, unsigned int *, unsigned int *,
-   const struct dwarf_debug_section *, unsigned int, void **) ATTRIBUTE_HIDDEN;
+   const struct dwarf_debug_section *, void **) ATTRIBUTE_HIDDEN;
 
 /* Find the bias between DWARF addresses and real addresses.  */
 extern bfd_signed_vma _bfd_dwarf2_find_symbol_bias
--- binutils.orig/bfd/elfnn-aarch64.c	2020-01-02 14:32:32.317580143 +0000
+++ binutils-2.31.1/bfd/elfnn-aarch64.c	2020-01-02 16:12:15.072832326 +0000
@@ -7742,7 +7742,7 @@ elfNN_aarch64_find_nearest_line (bfd *ab
   if (_bfd_dwarf2_find_nearest_line (abfd, symbols, NULL, section, offset,
 				     filename_ptr, functionname_ptr,
 				     line_ptr, discriminator_ptr,
-				     dwarf_debug_sections, 0,
+				     dwarf_debug_sections,
 				     &elf_tdata (abfd)->dwarf2_find_line_info))
     {
       if (!*functionname_ptr)
--- binutils.orig/bfd/elf32-arm.c	2020-01-02 14:32:32.295580305 +0000
+++ binutils-2.31.1/bfd/elf32-arm.c	2020-01-02 16:12:52.768557820 +0000
@@ -15817,7 +15817,7 @@ elf32_arm_find_nearest_line (bfd *	    a
   if (_bfd_dwarf2_find_nearest_line (abfd, symbols, NULL, section, offset,
 				     filename_ptr, functionname_ptr,
 				     line_ptr, discriminator_ptr,
-				     dwarf_debug_sections, 0,
+				     dwarf_debug_sections,
 				     & elf_tdata (abfd)->dwarf2_find_line_info))
     {
       if (!*functionname_ptr)
--- binutils.orig/bfd/mach-o.c	2020-01-02 14:32:32.315580158 +0000
+++ binutils-2.31.1/bfd/mach-o.c	2020-01-02 16:12:26.384749951 +0000
@@ -5922,7 +5922,7 @@ bfd_mach_o_find_nearest_line (bfd *abfd,
   return _bfd_dwarf2_find_nearest_line (abfd, symbols, NULL, section, offset,
 					filename_ptr, functionname_ptr,
 					line_ptr, discriminator_ptr,
-					dwarf_debug_sections, 0,
+					dwarf_debug_sections,
 					&mdata->dwarf2_find_line_info);
 }
 
--- binutils.orig/bfd/elfxx-mips.c	2020-01-02 14:32:32.300580268 +0000
+++ binutils-2.31.1/bfd/elfxx-mips.c	2020-01-02 16:12:44.384618873 +0000
@@ -12697,7 +12697,6 @@ _bfd_mips_elf_find_nearest_line (bfd *ab
 				     filename_ptr, functionname_ptr,
 				     line_ptr, discriminator_ptr,
 				     dwarf_debug_sections,
-				     ABI_64_P (abfd) ? 8 : 0,
 				     &elf_tdata (abfd)->dwarf2_find_line_info)
       || _bfd_dwarf1_find_nearest_line (abfd, symbols, section, offset,
 					filename_ptr, functionname_ptr,
--- binutils.orig/bfd/elf64-alpha.c	2020-01-02 14:32:32.301580261 +0000
+++ binutils-2.31.1/bfd/elf64-alpha.c	2020-01-02 16:13:05.631464150 +0000
@@ -1467,7 +1467,7 @@ elf64_alpha_find_nearest_line (bfd *abfd
   if (_bfd_dwarf2_find_nearest_line (abfd, symbols, NULL, section, offset,
 				     filename_ptr, functionname_ptr,
 				     line_ptr, discriminator_ptr,
-				     dwarf_debug_sections, 0,
+				     dwarf_debug_sections,
 				     &elf_tdata (abfd)->dwarf2_find_line_info))
     return TRUE;
 
