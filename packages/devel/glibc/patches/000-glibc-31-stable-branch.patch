commit ae1b6b13d4cbca2396391a376a35d5c1a003f13f
Author: WANG Xuerui <git@xen0n.name>
Date:   Thu Feb 13 00:57:02 2020 +0800

    mips: Use 'long int' and 'long long int' in linux syscall code
    
    Style fixes only, no functional change.
    
    (cherry picked from commit d3fbb18aa3164ca1d11e8acba81e1fc2ca70f43e)

diff --git a/sysdeps/unix/sysv/linux/mips/mips32/mips-syscall5.S b/sysdeps/unix/sysv/linux/mips/mips32/mips-syscall5.S
index b2bbf10181..ff445a5406 100644
--- a/sysdeps/unix/sysv/linux/mips/mips32/mips-syscall5.S
+++ b/sysdeps/unix/sysv/linux/mips/mips32/mips-syscall5.S
@@ -22,9 +22,9 @@
 	.text
 	.set	nomips16
 
-/* long long __mips_syscall5 (long arg1, long arg2, long arg3, long arg4,
-			      long arg5,
-			      long number)  */
+/* long long int __mips_syscall5 (long int arg1, long int arg2, long int arg3,
+				  long int arg4, long int arg5,
+				  long int number)  */
 
 ENTRY(__mips_syscall5)
 	lw	v0, 20(sp)
diff --git a/sysdeps/unix/sysv/linux/mips/mips32/mips-syscall6.S b/sysdeps/unix/sysv/linux/mips/mips32/mips-syscall6.S
index 572d7c1137..2b4a3117d1 100644
--- a/sysdeps/unix/sysv/linux/mips/mips32/mips-syscall6.S
+++ b/sysdeps/unix/sysv/linux/mips/mips32/mips-syscall6.S
@@ -22,9 +22,9 @@
 	.text
 	.set	nomips16
 
-/* long long __mips_syscall6 (long arg1, long arg2, long arg3, long arg4,
-			      long arg5, long arg6,
-			      long number)  */
+/* long long int __mips_syscall6 (long int arg1, long int arg2, long int arg3,
+				  long int arg4, long int arg5, long int arg6,
+				  long int number)  */
 
 ENTRY(__mips_syscall6)
 	lw	v0, 24(sp)
diff --git a/sysdeps/unix/sysv/linux/mips/mips32/mips-syscall7.S b/sysdeps/unix/sysv/linux/mips/mips32/mips-syscall7.S
index 05164cb253..2723bbb138 100644
--- a/sysdeps/unix/sysv/linux/mips/mips32/mips-syscall7.S
+++ b/sysdeps/unix/sysv/linux/mips/mips32/mips-syscall7.S
@@ -22,9 +22,10 @@
 	.text
 	.set	nomips16
 
-/* long long __mips_syscall7 (long arg1, long arg2, long arg3, long arg4,
-			      long arg5, long arg6, long arg7,
-			      long number)  */
+/* long long int __mips_syscall7 (long int arg1, long int arg2, long int arg3,
+				  long int arg4, long int arg5, long int arg6,
+				  long int arg7,
+				  long int number)  */
 
 ENTRY(__mips_syscall7)
 	lw	v0, 28(sp)
diff --git a/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall.h b/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall.h
index 9bf551ace8..f23ede0259 100644
--- a/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall.h
+++ b/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall.h
@@ -19,51 +19,57 @@
 #ifndef MIPS16_SYSCALL_H
 #define MIPS16_SYSCALL_H 1
 
-long long __nomips16 __mips16_syscall0 (long number);
+long long int __nomips16 __mips16_syscall0 (long int number);
 #define __mips16_syscall0(dummy, number)				\
-	__mips16_syscall0 ((long) (number))
+	__mips16_syscall0 ((long int) (number))
 
-long long __nomips16 __mips16_syscall1 (long a0,
-					long number);
+long long int __nomips16 __mips16_syscall1 (long int a0,
+					    long int number);
 #define __mips16_syscall1(a0, number)					\
-	__mips16_syscall1 ((long) (a0),					\
-			   (long) (number))
+	__mips16_syscall1 ((long int) (a0),				\
+			   (long int) (number))
 
-long long __nomips16 __mips16_syscall2 (long a0, long a1,
-					long number);
+long long int __nomips16 __mips16_syscall2 (long int a0, long int a1,
+					    long int number);
 #define __mips16_syscall2(a0, a1, number)				\
-	__mips16_syscall2 ((long) (a0), (long) (a1),			\
-			   (long) (number))
+	__mips16_syscall2 ((long int) (a0), (long int) (a1),		\
+			   (long int) (number))
 
-long long __nomips16 __mips16_syscall3 (long a0, long a1, long a2,
-					long number);
+long long int __nomips16 __mips16_syscall3 (long int a0, long int a1,
+					    long int a2,
+					    long int number);
 #define __mips16_syscall3(a0, a1, a2, number)				\
-	__mips16_syscall3 ((long) (a0), (long) (a1), (long) (a2),	\
-			   (long) (number))
+	__mips16_syscall3 ((long int) (a0), (long int) (a1),		\
+			   (long int) (a2),				\
+			   (long int) (number))
 
-long long __nomips16 __mips16_syscall4 (long a0, long a1, long a2, long a3,
-					long number);
+long long int __nomips16 __mips16_syscall4 (long int a0, long int a1,
+					    long int a2, long int a3,
+					    long int number);
 #define __mips16_syscall4(a0, a1, a2, a3, number)			\
-	__mips16_syscall4 ((long) (a0), (long) (a1), (long) (a2),	\
-			   (long) (a3),					\
-			   (long) (number))
+	__mips16_syscall4 ((long int) (a0), (long int) (a1),		\
+			   (long int) (a2), (long int) (a3),		\
+			   (long int) (number))
 
 /* The remaining ones use regular MIPS wrappers.  */
 
 #define __mips16_syscall5(a0, a1, a2, a3, a4, number)			\
-	__mips_syscall5 ((long) (a0), (long) (a1), (long) (a2),		\
-			 (long) (a3), (long) (a4),			\
-			 (long) (number))
+	__mips_syscall5 ((long int) (a0), (long int) (a1),		\
+			 (long int) (a2), (long int) (a3),		\
+			 (long int) (a4),				\
+			 (long int) (number))
 
 #define __mips16_syscall6(a0, a1, a2, a3, a4, a5, number)		\
-	__mips_syscall6 ((long) (a0), (long) (a1), (long) (a2),		\
-			 (long) (a3), (long) (a4), (long) (a5),		\
-			 (long) (number))
+	__mips_syscall6 ((long int) (a0), (long int) (a1),		\
+			 (long int) (a2), (long int) (a3),		\
+			 (long int) (a4), (long int) (a5),		\
+			 (long int) (number))
 
 #define __mips16_syscall7(a0, a1, a2, a3, a4, a5, a6, number)		\
-	__mips_syscall7 ((long) (a0), (long) (a1), (long) (a2),		\
-			 (long) (a3), (long) (a4), (long) (a5),		\
-			 (long) (a6),					\
-			 (long) (number))
+	__mips_syscall7 ((long int) (a0), (long int) (a1),		\
+			 (long int) (a2), (long int) (a3),		\
+			 (long int) (a4), (long int) (a5),		\
+			 (long int) (a6),				\
+			 (long int) (number))
 
 #endif
diff --git a/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall0.c b/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall0.c
index 92f16e2724..43c05f8050 100644
--- a/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall0.c
+++ b/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall0.c
@@ -20,8 +20,8 @@
 
 #undef __mips16_syscall0
 
-long long __nomips16
-__mips16_syscall0 (long number)
+long long int __nomips16
+__mips16_syscall0 (long int number)
 {
   union __mips_syscall_return ret;
   ret.reg.v0 = INTERNAL_SYSCALL_MIPS16 (number, ret.reg.v1, 0);
diff --git a/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall1.c b/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall1.c
index fa985a96e5..16a567e834 100644
--- a/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall1.c
+++ b/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall1.c
@@ -20,9 +20,9 @@
 
 #undef __mips16_syscall1
 
-long long __nomips16
-__mips16_syscall1 (long a0,
-		   long number)
+long long int __nomips16
+__mips16_syscall1 (long int a0,
+		   long int number)
 {
   union __mips_syscall_return ret;
   ret.reg.v0 = INTERNAL_SYSCALL_MIPS16 (number, ret.reg.v1, 1,
diff --git a/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall2.c b/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall2.c
index f042ac815d..c0a856c344 100644
--- a/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall2.c
+++ b/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall2.c
@@ -20,9 +20,9 @@
 
 #undef __mips16_syscall2
 
-long long __nomips16
-__mips16_syscall2 (long a0, long a1,
-		   long number)
+long long int __nomips16
+__mips16_syscall2 (long int a0, long int a1,
+		   long int number)
 {
   union __mips_syscall_return ret;
   ret.reg.v0 = INTERNAL_SYSCALL_MIPS16 (number, ret.reg.v1, 2,
diff --git a/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall3.c b/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall3.c
index dfe2f7feb5..042768ebf2 100644
--- a/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall3.c
+++ b/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall3.c
@@ -20,9 +20,9 @@
 
 #undef __mips16_syscall3
 
-long long __nomips16
-__mips16_syscall3 (long a0, long a1, long a2,
-		   long number)
+long long int __nomips16
+__mips16_syscall3 (long int a0, long int a1, long int a2,
+		   long int number)
 {
   union __mips_syscall_return ret;
   ret.reg.v0 = INTERNAL_SYSCALL_MIPS16 (number, ret.reg.v1, 3,
diff --git a/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall4.c b/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall4.c
index 39de510357..8658d822ab 100644
--- a/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall4.c
+++ b/sysdeps/unix/sysv/linux/mips/mips32/mips16/mips16-syscall4.c
@@ -20,9 +20,9 @@
 
 #undef __mips16_syscall4
 
-long long __nomips16
-__mips16_syscall4 (long a0, long a1, long a2, long a3,
-		   long number)
+long long int __nomips16
+__mips16_syscall4 (long int a0, long int a1, long int a2, long int a3,
+		   long int number)
 {
   union __mips_syscall_return ret;
   ret.reg.v0 = INTERNAL_SYSCALL_MIPS16 (number, ret.reg.v1, 4,
diff --git a/sysdeps/unix/sysv/linux/mips/mips32/sysdep.h b/sysdeps/unix/sysv/linux/mips/mips32/sysdep.h
index beefcf284b..5cdac96b20 100644
--- a/sysdeps/unix/sysv/linux/mips/mips32/sysdep.h
+++ b/sysdeps/unix/sysv/linux/mips/mips32/sysdep.h
@@ -52,7 +52,7 @@
 #undef INLINE_SYSCALL
 #define INLINE_SYSCALL(name, nr, args...)                               \
   ({ INTERNAL_SYSCALL_DECL (_sc_err);					\
-     long result_var = INTERNAL_SYSCALL (name, _sc_err, nr, args);	\
+     long int result_var = INTERNAL_SYSCALL (name, _sc_err, nr, args);	\
      if ( INTERNAL_SYSCALL_ERROR_P (result_var, _sc_err) )		\
        {								\
 	 __set_errno (INTERNAL_SYSCALL_ERRNO (result_var, _sc_err));	\
@@ -61,10 +61,10 @@
      result_var; })
 
 #undef INTERNAL_SYSCALL_DECL
-#define INTERNAL_SYSCALL_DECL(err) long err __attribute__ ((unused))
+#define INTERNAL_SYSCALL_DECL(err) long int err __attribute__ ((unused))
 
 #undef INTERNAL_SYSCALL_ERROR_P
-#define INTERNAL_SYSCALL_ERROR_P(val, err)   ((void) (val), (long) (err))
+#define INTERNAL_SYSCALL_ERROR_P(val, err)   ((void) (val), (long int) (err))
 
 #undef INTERNAL_SYSCALL_ERRNO
 #define INTERNAL_SYSCALL_ERRNO(val, err)     ((void) (err), val)
@@ -103,11 +103,11 @@
 
 union __mips_syscall_return
   {
-    long long val;
+    long long int val;
     struct
       {
-	long v0;
-	long v1;
+	long int v0;
+	long int v1;
       }
     reg;
   };
@@ -152,13 +152,13 @@ union __mips_syscall_return
 
 #define internal_syscall0(v0_init, input, number, err, dummy...)	\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long __s0 asm ("$16") __attribute__ ((unused))		\
+	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
-	register long __v0 asm ("$2");					\
-	register long __a3 asm ("$7");					\
+	register long int __v0 asm ("$2");				\
+	register long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -175,14 +175,14 @@ union __mips_syscall_return
 
 #define internal_syscall1(v0_init, input, number, err, arg1)		\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long __s0 asm ("$16") __attribute__ ((unused))		\
+	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
-	register long __v0 asm ("$2");					\
-	register long __a0 asm ("$4") = (long) (arg1);			\
-	register long __a3 asm ("$7");					\
+	register long int __v0 asm ("$2");				\
+	register long int __a0 asm ("$4") = (long int) (arg1);		\
+	register long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -199,15 +199,15 @@ union __mips_syscall_return
 
 #define internal_syscall2(v0_init, input, number, err, arg1, arg2)	\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long __s0 asm ("$16") __attribute__ ((unused))		\
+	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
-	register long __v0 asm ("$2");					\
-	register long __a0 asm ("$4") = (long) (arg1);			\
-	register long __a1 asm ("$5") = (long) (arg2);			\
-	register long __a3 asm ("$7");					\
+	register long int __v0 asm ("$2");				\
+	register long int __a0 asm ("$4") = (long int) (arg1);		\
+	register long int __a1 asm ("$5") = (long int) (arg2);		\
+	register long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -225,16 +225,16 @@ union __mips_syscall_return
 #define internal_syscall3(v0_init, input, number, err,			\
 			  arg1, arg2, arg3)				\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long __s0 asm ("$16") __attribute__ ((unused))		\
+	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
-	register long __v0 asm ("$2");					\
-	register long __a0 asm ("$4") = (long) (arg1);			\
-	register long __a1 asm ("$5") = (long) (arg2);			\
-	register long __a2 asm ("$6") = (long) (arg3);			\
-	register long __a3 asm ("$7");					\
+	register long int __v0 asm ("$2");				\
+	register long int __a0 asm ("$4") = (long int) (arg1);		\
+	register long int __a1 asm ("$5") = (long int) (arg2);		\
+	register long int __a2 asm ("$6") = (long int) (arg3);		\
+	register long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -252,16 +252,16 @@ union __mips_syscall_return
 #define internal_syscall4(v0_init, input, number, err,			\
 			  arg1, arg2, arg3, arg4)			\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long __s0 asm ("$16") __attribute__ ((unused))		\
+	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
-	register long __v0 asm ("$2");					\
-	register long __a0 asm ("$4") = (long) (arg1);			\
-	register long __a1 asm ("$5") = (long) (arg2);			\
-	register long __a2 asm ("$6") = (long) (arg3);			\
-	register long __a3 asm ("$7") = (long) (arg4);			\
+	register long int __v0 asm ("$2");				\
+	register long int __a0 asm ("$4") = (long int) (arg1);		\
+	register long int __a1 asm ("$5") = (long int) (arg2);		\
+	register long int __a2 asm ("$6") = (long int) (arg3);		\
+	register long int __a3 asm ("$7") = (long int) (arg4);		\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -285,63 +285,66 @@ union __mips_syscall_return
    compiler specifics required for the stack arguments to be pushed,
    which would be the case if these syscalls were inlined.  */
 
-long long __nomips16 __mips_syscall5 (long arg1, long arg2, long arg3,
-				      long arg4, long arg5,
-				      long number);
+long long int __nomips16 __mips_syscall5 (long int arg1, long int arg2,
+					  long int arg3, long int arg4,
+					  long int arg5,
+					  long int number);
 libc_hidden_proto (__mips_syscall5, nomips16)
 
 #define internal_syscall5(v0_init, input, number, err,			\
 			  arg1, arg2, arg3, arg4, arg5)			\
 ({									\
 	union __mips_syscall_return _sc_ret;				\
-	_sc_ret.val = __mips_syscall5 ((long) (arg1),			\
-				       (long) (arg2),			\
-				       (long) (arg3),			\
-				       (long) (arg4),			\
-				       (long) (arg5),			\
-				       (long) (number));		\
+	_sc_ret.val = __mips_syscall5 ((long int) (arg1),		\
+				       (long int) (arg2),		\
+				       (long int) (arg3),		\
+				       (long int) (arg4),		\
+				       (long int) (arg5),		\
+				       (long int) (number));		\
 	err = _sc_ret.reg.v1;						\
 	_sc_ret.reg.v0;							\
 })
 
-long long __nomips16 __mips_syscall6 (long arg1, long arg2, long arg3,
-				      long arg4, long arg5, long arg6,
-				      long number);
+long long int __nomips16 __mips_syscall6 (long int arg1, long int arg2,
+					  long int arg3, long int arg4,
+					  long int arg5, long int arg6,
+					  long int number);
 libc_hidden_proto (__mips_syscall6, nomips16)
 
 #define internal_syscall6(v0_init, input, number, err,			\
 			  arg1, arg2, arg3, arg4, arg5, arg6)		\
 ({									\
 	union __mips_syscall_return _sc_ret;				\
-	_sc_ret.val = __mips_syscall6 ((long) (arg1),			\
-				       (long) (arg2),			\
-				       (long) (arg3),			\
-				       (long) (arg4),			\
-				       (long) (arg5),			\
-				       (long) (arg6),			\
-				       (long) (number));		\
+	_sc_ret.val = __mips_syscall6 ((long int) (arg1),		\
+				       (long int) (arg2),		\
+				       (long int) (arg3),		\
+				       (long int) (arg4),		\
+				       (long int) (arg5),		\
+				       (long int) (arg6),		\
+				       (long int) (number));		\
 	err = _sc_ret.reg.v1;						\
 	_sc_ret.reg.v0;							\
 })
 
-long long __nomips16 __mips_syscall7 (long arg1, long arg2, long arg3,
-				      long arg4, long arg5, long arg6,
-				      long arg7,
-				      long number);
+long long int __nomips16 __mips_syscall7 (long int arg1, long int arg2,
+					  long int arg3, long int arg4,
+					  long int arg5, long int arg6,
+					  long int arg7,
+					  long int number);
 libc_hidden_proto (__mips_syscall7, nomips16)
 
 #define internal_syscall7(v0_init, input, number, err,			\
 			  arg1, arg2, arg3, arg4, arg5, arg6, arg7)	\
 ({									\
 	union __mips_syscall_return _sc_ret;				\
-	_sc_ret.val = __mips_syscall7 ((long) (arg1),			\
-				       (long) (arg2),			\
-				       (long) (arg3),			\
-				       (long) (arg4),			\
-				       (long) (arg5),			\
-				       (long) (arg6),			\
-				       (long) (arg7),			\
-				       (long) (number));		\
+	_sc_ret.val = __mips_syscall7 ((long int) (arg1),		\
+				       (long int) (arg2),		\
+				       (long int) (arg3),		\
+				       (long int) (arg4),		\
+				       (long int) (arg5),		\
+				       (long int) (arg6),		\
+				       (long int) (arg7),		\
+				       (long int) (number));		\
 	err = _sc_ret.reg.v1;						\
 	_sc_ret.reg.v0;							\
 })
diff --git a/sysdeps/unix/sysv/linux/mips/mips64/n32/sysdep.h b/sysdeps/unix/sysv/linux/mips/mips64/n32/sysdep.h
index f96636538a..bbc6891a1e 100644
--- a/sysdeps/unix/sysv/linux/mips/mips64/n32/sysdep.h
+++ b/sysdeps/unix/sysv/linux/mips/mips64/n32/sysdep.h
@@ -47,14 +47,14 @@
 
 /* Convert X to a long long, without losing any bits if it is one
    already or warning if it is a 32-bit pointer.  */
-#define ARGIFY(X) ((long long) (__typeof__ ((X) - (X))) (X))
+#define ARGIFY(X) ((long long int) (__typeof__ ((X) - (X))) (X))
 
 /* Define a macro which expands into the inline wrapper code for a system
    call.  */
 #undef INLINE_SYSCALL
 #define INLINE_SYSCALL(name, nr, args...)				\
   ({ INTERNAL_SYSCALL_DECL (_sc_err);					\
-     long result_var = INTERNAL_SYSCALL (name, _sc_err, nr, args);	\
+     long int result_var = INTERNAL_SYSCALL (name, _sc_err, nr, args);	\
      if ( INTERNAL_SYSCALL_ERROR_P (result_var, _sc_err) )		\
        {								\
 	 __set_errno (INTERNAL_SYSCALL_ERRNO (result_var, _sc_err));	\
@@ -63,10 +63,10 @@
      result_var; })
 
 #undef INTERNAL_SYSCALL_DECL
-#define INTERNAL_SYSCALL_DECL(err) long err __attribute__ ((unused))
+#define INTERNAL_SYSCALL_DECL(err) long int err __attribute__ ((unused))
 
 #undef INTERNAL_SYSCALL_ERROR_P
-#define INTERNAL_SYSCALL_ERROR_P(val, err)   ((void) (val), (long) (err))
+#define INTERNAL_SYSCALL_ERROR_P(val, err)   ((void) (val), (long int) (err))
 
 #undef INTERNAL_SYSCALL_ERRNO
 #define INTERNAL_SYSCALL_ERRNO(val, err)     ((void) (err), val)
@@ -112,13 +112,13 @@
 
 #define internal_syscall0(v0_init, input, number, err, dummy...)	\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long long __s0 asm ("$16") __attribute__ ((unused))	\
+	register long long int __s0 asm ("$16") __attribute__ ((unused))\
 	  = (number);							\
-	register long long __v0 asm ("$2");				\
-	register long long __a3 asm ("$7");				\
+	register long long int __v0 asm ("$2");				\
+	register long long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -135,14 +135,14 @@
 
 #define internal_syscall1(v0_init, input, number, err, arg1)		\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long long __s0 asm ("$16") __attribute__ ((unused))	\
+	register long long int __s0 asm ("$16") __attribute__ ((unused))\
 	  = (number);							\
-	register long long __v0 asm ("$2");				\
-	register long long __a0 asm ("$4") = ARGIFY (arg1);		\
-	register long long __a3 asm ("$7");				\
+	register long long int __v0 asm ("$2");				\
+	register long long int __a0 asm ("$4") = ARGIFY (arg1);		\
+	register long long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -159,15 +159,15 @@
 
 #define internal_syscall2(v0_init, input, number, err, arg1, arg2)	\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long long __s0 asm ("$16") __attribute__ ((unused))	\
+	register long long int __s0 asm ("$16") __attribute__ ((unused))\
 	  = (number);							\
-	register long long __v0 asm ("$2");				\
-	register long long __a0 asm ("$4") = ARGIFY (arg1);		\
-	register long long __a1 asm ("$5") = ARGIFY (arg2);		\
-	register long long __a3 asm ("$7");				\
+	register long long int __v0 asm ("$2");				\
+	register long long int __a0 asm ("$4") = ARGIFY (arg1);		\
+	register long long int __a1 asm ("$5") = ARGIFY (arg2);		\
+	register long long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -185,16 +185,16 @@
 #define internal_syscall3(v0_init, input, number, err,			\
 			  arg1, arg2, arg3)				\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long long __s0 asm ("$16") __attribute__ ((unused))	\
+	register long long int __s0 asm ("$16") __attribute__ ((unused))\
 	  = (number);							\
-	register long long __v0 asm ("$2");				\
-	register long long __a0 asm ("$4") = ARGIFY (arg1);		\
-	register long long __a1 asm ("$5") = ARGIFY (arg2);		\
-	register long long __a2 asm ("$6") = ARGIFY (arg3);		\
-	register long long __a3 asm ("$7");				\
+	register long long int __v0 asm ("$2");				\
+	register long long int __a0 asm ("$4") = ARGIFY (arg1);		\
+	register long long int __a1 asm ("$5") = ARGIFY (arg2);		\
+	register long long int __a2 asm ("$6") = ARGIFY (arg3);		\
+	register long long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -212,16 +212,16 @@
 #define internal_syscall4(v0_init, input, number, err,			\
 			  arg1, arg2, arg3, arg4)			\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long long __s0 asm ("$16") __attribute__ ((unused))	\
+	register long long int __s0 asm ("$16") __attribute__ ((unused))\
 	  = (number);							\
-	register long long __v0 asm ("$2");				\
-	register long long __a0 asm ("$4") = ARGIFY (arg1);		\
-	register long long __a1 asm ("$5") = ARGIFY (arg2);		\
-	register long long __a2 asm ("$6") = ARGIFY (arg3);		\
-	register long long __a3 asm ("$7") = ARGIFY (arg4);		\
+	register long long int __v0 asm ("$2");				\
+	register long long int __a0 asm ("$4") = ARGIFY (arg1);		\
+	register long long int __a1 asm ("$5") = ARGIFY (arg2);		\
+	register long long int __a2 asm ("$6") = ARGIFY (arg3);		\
+	register long long int __a3 asm ("$7") = ARGIFY (arg4);		\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -239,17 +239,17 @@
 #define internal_syscall5(v0_init, input, number, err,			\
 			  arg1, arg2, arg3, arg4, arg5)			\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long long __s0 asm ("$16") __attribute__ ((unused))	\
+	register long long int __s0 asm ("$16") __attribute__ ((unused))\
 	  = (number);							\
-	register long long __v0 asm ("$2");				\
-	register long long __a0 asm ("$4") = ARGIFY (arg1);		\
-	register long long __a1 asm ("$5") = ARGIFY (arg2);		\
-	register long long __a2 asm ("$6") = ARGIFY (arg3);		\
-	register long long __a3 asm ("$7") = ARGIFY (arg4);		\
-	register long long __a4 asm ("$8") = ARGIFY (arg5);		\
+	register long long int __v0 asm ("$2");				\
+	register long long int __a0 asm ("$4") = ARGIFY (arg1);		\
+	register long long int __a1 asm ("$5") = ARGIFY (arg2);		\
+	register long long int __a2 asm ("$6") = ARGIFY (arg3);		\
+	register long long int __a3 asm ("$7") = ARGIFY (arg4);		\
+	register long long int __a4 asm ("$8") = ARGIFY (arg5);		\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -267,18 +267,18 @@
 #define internal_syscall6(v0_init, input, number, err,			\
 			  arg1, arg2, arg3, arg4, arg5, arg6)		\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long long __s0 asm ("$16") __attribute__ ((unused))	\
+	register long long int __s0 asm ("$16") __attribute__ ((unused))\
 	  = (number);							\
-	register long long __v0 asm ("$2");				\
-	register long long __a0 asm ("$4") = ARGIFY (arg1);		\
-	register long long __a1 asm ("$5") = ARGIFY (arg2);		\
-	register long long __a2 asm ("$6") = ARGIFY (arg3);		\
-	register long long __a3 asm ("$7") = ARGIFY (arg4);		\
-	register long long __a4 asm ("$8") = ARGIFY (arg5);		\
-	register long long __a5 asm ("$9") = ARGIFY (arg6);		\
+	register long long int __v0 asm ("$2");				\
+	register long long int __a0 asm ("$4") = ARGIFY (arg1);		\
+	register long long int __a1 asm ("$5") = ARGIFY (arg2);		\
+	register long long int __a2 asm ("$6") = ARGIFY (arg3);		\
+	register long long int __a3 asm ("$7") = ARGIFY (arg4);		\
+	register long long int __a4 asm ("$8") = ARGIFY (arg5);		\
+	register long long int __a5 asm ("$9") = ARGIFY (arg6);		\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
diff --git a/sysdeps/unix/sysv/linux/mips/mips64/n64/sysdep.h b/sysdeps/unix/sysv/linux/mips/mips64/n64/sysdep.h
index 9d30291f84..db0e0b4044 100644
--- a/sysdeps/unix/sysv/linux/mips/mips64/n64/sysdep.h
+++ b/sysdeps/unix/sysv/linux/mips/mips64/n64/sysdep.h
@@ -50,7 +50,7 @@
 #undef INLINE_SYSCALL
 #define INLINE_SYSCALL(name, nr, args...)				\
   ({ INTERNAL_SYSCALL_DECL (_sc_err);					\
-     long result_var = INTERNAL_SYSCALL (name, _sc_err, nr, args);	\
+     long int result_var = INTERNAL_SYSCALL (name, _sc_err, nr, args);	\
      if ( INTERNAL_SYSCALL_ERROR_P (result_var, _sc_err) )		\
        {								\
 	 __set_errno (INTERNAL_SYSCALL_ERRNO (result_var, _sc_err));	\
@@ -59,10 +59,10 @@
      result_var; })
 
 #undef INTERNAL_SYSCALL_DECL
-#define INTERNAL_SYSCALL_DECL(err) long err __attribute__ ((unused))
+#define INTERNAL_SYSCALL_DECL(err) long int err __attribute__ ((unused))
 
 #undef INTERNAL_SYSCALL_ERROR_P
-#define INTERNAL_SYSCALL_ERROR_P(val, err)   ((void) (val), (long) (err))
+#define INTERNAL_SYSCALL_ERROR_P(val, err)   ((void) (val), (long int) (err))
 
 #undef INTERNAL_SYSCALL_ERRNO
 #define INTERNAL_SYSCALL_ERRNO(val, err)     ((void) (err), val)
@@ -108,13 +108,13 @@
 
 #define internal_syscall0(v0_init, input, number, err, dummy...)	\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long __s0 asm ("$16") __attribute__ ((unused))		\
+	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
-	register long __v0 asm ("$2");					\
-	register long __a3 asm ("$7");					\
+	register long int __v0 asm ("$2");				\
+	register long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -131,14 +131,14 @@
 
 #define internal_syscall1(v0_init, input, number, err, arg1)		\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long __s0 asm ("$16") __attribute__ ((unused))		\
+	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
-	register long __v0 asm ("$2");					\
-	register long __a0 asm ("$4") = (long) (arg1);			\
-	register long __a3 asm ("$7");					\
+	register long int __v0 asm ("$2");				\
+	register long int __a0 asm ("$4") = (long int) (arg1);		\
+	register long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -155,15 +155,15 @@
 
 #define internal_syscall2(v0_init, input, number, err, arg1, arg2)	\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long __s0 asm ("$16") __attribute__ ((unused))		\
+	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
-	register long __v0 asm ("$2");					\
-	register long __a0 asm ("$4") = (long) (arg1);			\
-	register long __a1 asm ("$5") = (long) (arg2);			\
-	register long __a3 asm ("$7");					\
+	register long int __v0 asm ("$2");				\
+	register long int __a0 asm ("$4") = (long int) (arg1);		\
+	register long int __a1 asm ("$5") = (long int) (arg2);		\
+	register long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -181,16 +181,16 @@
 #define internal_syscall3(v0_init, input, number, err,			\
 			  arg1, arg2, arg3)				\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long __s0 asm ("$16") __attribute__ ((unused))		\
+	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
-	register long __v0 asm ("$2");					\
-	register long __a0 asm ("$4") = (long) (arg1);			\
-	register long __a1 asm ("$5") = (long) (arg2);			\
-	register long __a2 asm ("$6") = (long) (arg3);			\
-	register long __a3 asm ("$7");					\
+	register long int __v0 asm ("$2");				\
+	register long int __a0 asm ("$4") = (long int) (arg1);		\
+	register long int __a1 asm ("$5") = (long int) (arg2);		\
+	register long int __a2 asm ("$6") = (long int) (arg3);		\
+	register long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -208,16 +208,16 @@
 #define internal_syscall4(v0_init, input, number, err,			\
 			  arg1, arg2, arg3, arg4)			\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long __s0 asm ("$16") __attribute__ ((unused))		\
+	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
-	register long __v0 asm ("$2");					\
-	register long __a0 asm ("$4") = (long) (arg1);			\
-	register long __a1 asm ("$5") = (long) (arg2);			\
-	register long __a2 asm ("$6") = (long) (arg3);			\
-	register long __a3 asm ("$7") = (long) (arg4);			\
+	register long int __v0 asm ("$2");				\
+	register long int __a0 asm ("$4") = (long int) (arg1);		\
+	register long int __a1 asm ("$5") = (long int) (arg2);		\
+	register long int __a2 asm ("$6") = (long int) (arg3);		\
+	register long int __a3 asm ("$7") = (long int) (arg4);		\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -235,17 +235,17 @@
 #define internal_syscall5(v0_init, input, number, err,			\
 			  arg1, arg2, arg3, arg4, arg5)			\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long __s0 asm ("$16") __attribute__ ((unused))		\
+	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
-	register long __v0 asm ("$2");					\
-	register long __a0 asm ("$4") = (long) (arg1);			\
-	register long __a1 asm ("$5") = (long) (arg2);			\
-	register long __a2 asm ("$6") = (long) (arg3);			\
-	register long __a3 asm ("$7") = (long) (arg4);			\
-	register long __a4 asm ("$8") = (long) (arg5);			\
+	register long int __v0 asm ("$2");				\
+	register long int __a0 asm ("$4") = (long int) (arg1);		\
+	register long int __a1 asm ("$5") = (long int) (arg2);		\
+	register long int __a2 asm ("$6") = (long int) (arg3);		\
+	register long int __a3 asm ("$7") = (long int) (arg4);		\
+	register long int __a4 asm ("$8") = (long int) (arg5);		\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -263,18 +263,18 @@
 #define internal_syscall6(v0_init, input, number, err,			\
 			  arg1, arg2, arg3, arg4, arg5, arg6)		\
 ({									\
-	long _sys_result;						\
+	long int _sys_result;						\
 									\
 	{								\
-	register long __s0 asm ("$16") __attribute__ ((unused))		\
+	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
-	register long __v0 asm ("$2");					\
-	register long __a0 asm ("$4") = (long) (arg1);			\
-	register long __a1 asm ("$5") = (long) (arg2);			\
-	register long __a2 asm ("$6") = (long) (arg3);			\
-	register long __a3 asm ("$7") = (long) (arg4);			\
-	register long __a4 asm ("$8") = (long) (arg5);			\
-	register long __a5 asm ("$9") = (long) (arg6);			\
+	register long int __v0 asm ("$2");				\
+	register long int __a0 asm ("$4") = (long int) (arg1);		\
+	register long int __a1 asm ("$5") = (long int) (arg2);		\
+	register long int __a2 asm ("$6") = (long int) (arg3);		\
+	register long int __a3 asm ("$7") = (long int) (arg4);		\
+	register long int __a4 asm ("$8") = (long int) (arg5);		\
+	register long int __a5 asm ("$9") = (long int) (arg6);		\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
diff --git a/sysdeps/unix/sysv/linux/mips/mips64/syscall.S b/sysdeps/unix/sysv/linux/mips/mips64/syscall.S
index 26adf2cd04..a9baff3c17 100644
--- a/sysdeps/unix/sysv/linux/mips/mips64/syscall.S
+++ b/sysdeps/unix/sysv/linux/mips/mips64/syscall.S
@@ -20,7 +20,7 @@
 #include <sys/asm.h>
 
 /* Usage:
-   long syscall (syscall_number, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
+   long int syscall (syscall_number, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
 
    We need to do some arg shifting, syscall_number will be in v0.  */
 
diff --git a/sysdeps/unix/sysv/linux/mips/sysdep.h b/sysdeps/unix/sysv/linux/mips/sysdep.h
index cdfc0b1b58..a4cf1540fe 100644
--- a/sysdeps/unix/sysv/linux/mips/sysdep.h
+++ b/sysdeps/unix/sysv/linux/mips/sysdep.h
@@ -36,8 +36,8 @@
    the INTERNAL_SYSCALL_{ERROR_P,ERRNO} macros work correctly.  */
 #define INTERNAL_VSYSCALL_CALL(funcptr, err, nr, args...)		\
   ({									\
-    long _ret = funcptr (args);						\
-    err = ((unsigned long) (_ret) >= (unsigned long) -4095L);		\
+    long int _ret = funcptr (args);					\
+    err = ((unsigned long int) (_ret) >= (unsigned long int) -4095L);	\
     if (err)								\
       _ret = -_ret;							\
     _ret;								\

commit aa638b86b222fcc9f9cdf1d2cb49a36ea681b469
Author: WANG Xuerui <git@xen0n.name>
Date:   Thu Feb 13 00:57:03 2020 +0800

    mips: Fix argument passing for inlined syscalls on Linux [BZ #25523]
    
    According to [gcc documentation][1], temporary variables must be used for
    the desired content to not be call-clobbered.
    
    Fix the Linux inline syscall templates by adding temporary variables,
    much like what x86 did before
    (commit 381a0c26d73e0f074c962e0ab53b99a6c327066d).
    
    Tested with gcc 9.2.0, both cross-compiled and natively on Loongson
    3A4000.
    
    [1]: https://gcc.gnu.org/onlinedocs/gcc/Local-Register-Variables.html
    
    (cherry picked from commit 4fbba6fe904d0094ddc4284066b3860d119cbd4a)

diff --git a/NEWS b/NEWS
index 292fbc595a..64e21b1c50 100644
--- a/NEWS
+++ b/NEWS
@@ -4,6 +4,12 @@ See the end for copying conditions.
 
 Please send GNU C library bug reports via <https://sourceware.org/bugzilla/>
 using `glibc' in the "product" field.
+
+Version 2.31.1
+
+The following bugs are resolved with this release:
+  [25523] MIPS/Linux inline syscall template is miscompiled
+
 
 Version 2.31
 
diff --git a/sysdeps/unix/sysv/linux/mips/mips32/sysdep.h b/sysdeps/unix/sysv/linux/mips/mips32/sysdep.h
index 5cdac96b20..0c6a83e9b3 100644
--- a/sysdeps/unix/sysv/linux/mips/mips32/sysdep.h
+++ b/sysdeps/unix/sysv/linux/mips/mips32/sysdep.h
@@ -178,10 +178,11 @@ union __mips_syscall_return
 	long int _sys_result;						\
 									\
 	{								\
+	long int _arg1 = (long int) (arg1);				\
 	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
 	register long int __v0 asm ("$2");				\
-	register long int __a0 asm ("$4") = (long int) (arg1);		\
+	register long int __a0 asm ("$4") = _arg1;			\
 	register long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
@@ -202,11 +203,13 @@ union __mips_syscall_return
 	long int _sys_result;						\
 									\
 	{								\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
 	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
 	register long int __v0 asm ("$2");				\
-	register long int __a0 asm ("$4") = (long int) (arg1);		\
-	register long int __a1 asm ("$5") = (long int) (arg2);		\
+	register long int __a0 asm ("$4") = _arg1;			\
+	register long int __a1 asm ("$5") = _arg2;			\
 	register long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
@@ -228,12 +231,15 @@ union __mips_syscall_return
 	long int _sys_result;						\
 									\
 	{								\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
+	long int _arg3 = (long int) (arg3);				\
 	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
 	register long int __v0 asm ("$2");				\
-	register long int __a0 asm ("$4") = (long int) (arg1);		\
-	register long int __a1 asm ("$5") = (long int) (arg2);		\
-	register long int __a2 asm ("$6") = (long int) (arg3);		\
+	register long int __a0 asm ("$4") = _arg1;			\
+	register long int __a1 asm ("$5") = _arg2;			\
+	register long int __a2 asm ("$6") = _arg3;			\
 	register long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
@@ -255,13 +261,17 @@ union __mips_syscall_return
 	long int _sys_result;						\
 									\
 	{								\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
+	long int _arg3 = (long int) (arg3);				\
+	long int _arg4 = (long int) (arg4);				\
 	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
 	register long int __v0 asm ("$2");				\
-	register long int __a0 asm ("$4") = (long int) (arg1);		\
-	register long int __a1 asm ("$5") = (long int) (arg2);		\
-	register long int __a2 asm ("$6") = (long int) (arg3);		\
-	register long int __a3 asm ("$7") = (long int) (arg4);		\
+	register long int __a0 asm ("$4") = _arg1;			\
+	register long int __a1 asm ("$5") = _arg2;			\
+	register long int __a2 asm ("$6") = _arg3;			\
+	register long int __a3 asm ("$7") = _arg4;			\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
diff --git a/sysdeps/unix/sysv/linux/mips/mips64/n32/sysdep.h b/sysdeps/unix/sysv/linux/mips/mips64/n32/sysdep.h
index bbc6891a1e..4a9d7054f9 100644
--- a/sysdeps/unix/sysv/linux/mips/mips64/n32/sysdep.h
+++ b/sysdeps/unix/sysv/linux/mips/mips64/n32/sysdep.h
@@ -138,10 +138,11 @@
 	long int _sys_result;						\
 									\
 	{								\
+	long long int _arg1 = ARGIFY (arg1);				\
 	register long long int __s0 asm ("$16") __attribute__ ((unused))\
 	  = (number);							\
 	register long long int __v0 asm ("$2");				\
-	register long long int __a0 asm ("$4") = ARGIFY (arg1);		\
+	register long long int __a0 asm ("$4") = _arg1;			\
 	register long long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
@@ -162,11 +163,13 @@
 	long int _sys_result;						\
 									\
 	{								\
+	long long int _arg1 = ARGIFY (arg1);				\
+	long long int _arg2 = ARGIFY (arg2);				\
 	register long long int __s0 asm ("$16") __attribute__ ((unused))\
 	  = (number);							\
 	register long long int __v0 asm ("$2");				\
-	register long long int __a0 asm ("$4") = ARGIFY (arg1);		\
-	register long long int __a1 asm ("$5") = ARGIFY (arg2);		\
+	register long long int __a0 asm ("$4") = _arg1;			\
+	register long long int __a1 asm ("$5") = _arg2;			\
 	register long long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
@@ -188,12 +191,15 @@
 	long int _sys_result;						\
 									\
 	{								\
+	long long int _arg1 = ARGIFY (arg1);				\
+	long long int _arg2 = ARGIFY (arg2);				\
+	long long int _arg3 = ARGIFY (arg3);				\
 	register long long int __s0 asm ("$16") __attribute__ ((unused))\
 	  = (number);							\
 	register long long int __v0 asm ("$2");				\
-	register long long int __a0 asm ("$4") = ARGIFY (arg1);		\
-	register long long int __a1 asm ("$5") = ARGIFY (arg2);		\
-	register long long int __a2 asm ("$6") = ARGIFY (arg3);		\
+	register long long int __a0 asm ("$4") = _arg1;			\
+	register long long int __a1 asm ("$5") = _arg2;			\
+	register long long int __a2 asm ("$6") = _arg3;			\
 	register long long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
@@ -215,13 +221,17 @@
 	long int _sys_result;						\
 									\
 	{								\
+	long long int _arg1 = ARGIFY (arg1);				\
+	long long int _arg2 = ARGIFY (arg2);				\
+	long long int _arg3 = ARGIFY (arg3);				\
+	long long int _arg4 = ARGIFY (arg4);				\
 	register long long int __s0 asm ("$16") __attribute__ ((unused))\
 	  = (number);							\
 	register long long int __v0 asm ("$2");				\
-	register long long int __a0 asm ("$4") = ARGIFY (arg1);		\
-	register long long int __a1 asm ("$5") = ARGIFY (arg2);		\
-	register long long int __a2 asm ("$6") = ARGIFY (arg3);		\
-	register long long int __a3 asm ("$7") = ARGIFY (arg4);		\
+	register long long int __a0 asm ("$4") = _arg1;			\
+	register long long int __a1 asm ("$5") = _arg2;			\
+	register long long int __a2 asm ("$6") = _arg3;			\
+	register long long int __a3 asm ("$7") = _arg4;			\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -242,14 +252,19 @@
 	long int _sys_result;						\
 									\
 	{								\
+	long long int _arg1 = ARGIFY (arg1);				\
+	long long int _arg2 = ARGIFY (arg2);				\
+	long long int _arg3 = ARGIFY (arg3);				\
+	long long int _arg4 = ARGIFY (arg4);				\
+	long long int _arg5 = ARGIFY (arg5);				\
 	register long long int __s0 asm ("$16") __attribute__ ((unused))\
 	  = (number);							\
 	register long long int __v0 asm ("$2");				\
-	register long long int __a0 asm ("$4") = ARGIFY (arg1);		\
-	register long long int __a1 asm ("$5") = ARGIFY (arg2);		\
-	register long long int __a2 asm ("$6") = ARGIFY (arg3);		\
-	register long long int __a3 asm ("$7") = ARGIFY (arg4);		\
-	register long long int __a4 asm ("$8") = ARGIFY (arg5);		\
+	register long long int __a0 asm ("$4") = _arg1;			\
+	register long long int __a1 asm ("$5") = _arg2;			\
+	register long long int __a2 asm ("$6") = _arg3;			\
+	register long long int __a3 asm ("$7") = _arg4;			\
+	register long long int __a4 asm ("$8") = _arg5;			\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -270,15 +285,21 @@
 	long int _sys_result;						\
 									\
 	{								\
+	long long int _arg1 = ARGIFY (arg1);				\
+	long long int _arg2 = ARGIFY (arg2);				\
+	long long int _arg3 = ARGIFY (arg3);				\
+	long long int _arg4 = ARGIFY (arg4);				\
+	long long int _arg5 = ARGIFY (arg5);				\
+	long long int _arg6 = ARGIFY (arg6);				\
 	register long long int __s0 asm ("$16") __attribute__ ((unused))\
 	  = (number);							\
 	register long long int __v0 asm ("$2");				\
-	register long long int __a0 asm ("$4") = ARGIFY (arg1);		\
-	register long long int __a1 asm ("$5") = ARGIFY (arg2);		\
-	register long long int __a2 asm ("$6") = ARGIFY (arg3);		\
-	register long long int __a3 asm ("$7") = ARGIFY (arg4);		\
-	register long long int __a4 asm ("$8") = ARGIFY (arg5);		\
-	register long long int __a5 asm ("$9") = ARGIFY (arg6);		\
+	register long long int __a0 asm ("$4") = _arg1;			\
+	register long long int __a1 asm ("$5") = _arg2;			\
+	register long long int __a2 asm ("$6") = _arg3;			\
+	register long long int __a3 asm ("$7") = _arg4;			\
+	register long long int __a4 asm ("$8") = _arg5;			\
+	register long long int __a5 asm ("$9") = _arg6;			\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
diff --git a/sysdeps/unix/sysv/linux/mips/mips64/n64/sysdep.h b/sysdeps/unix/sysv/linux/mips/mips64/n64/sysdep.h
index db0e0b4044..3e1f1cc3c5 100644
--- a/sysdeps/unix/sysv/linux/mips/mips64/n64/sysdep.h
+++ b/sysdeps/unix/sysv/linux/mips/mips64/n64/sysdep.h
@@ -134,10 +134,11 @@
 	long int _sys_result;						\
 									\
 	{								\
+	long int _arg1 = (long int) (arg1);				\
 	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
 	register long int __v0 asm ("$2");				\
-	register long int __a0 asm ("$4") = (long int) (arg1);		\
+	register long int __a0 asm ("$4") = _arg1;			\
 	register long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
@@ -158,11 +159,13 @@
 	long int _sys_result;						\
 									\
 	{								\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
 	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
 	register long int __v0 asm ("$2");				\
-	register long int __a0 asm ("$4") = (long int) (arg1);		\
-	register long int __a1 asm ("$5") = (long int) (arg2);		\
+	register long int __a0 asm ("$4") = _arg1;			\
+	register long int __a1 asm ("$5") = _arg2;			\
 	register long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
@@ -184,12 +187,15 @@
 	long int _sys_result;						\
 									\
 	{								\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
+	long int _arg3 = (long int) (arg3);				\
 	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
 	register long int __v0 asm ("$2");				\
-	register long int __a0 asm ("$4") = (long int) (arg1);		\
-	register long int __a1 asm ("$5") = (long int) (arg2);		\
-	register long int __a2 asm ("$6") = (long int) (arg3);		\
+	register long int __a0 asm ("$4") = _arg1;			\
+	register long int __a1 asm ("$5") = _arg2;			\
+	register long int __a2 asm ("$6") = _arg3;			\
 	register long int __a3 asm ("$7");				\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
@@ -211,13 +217,17 @@
 	long int _sys_result;						\
 									\
 	{								\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
+	long int _arg3 = (long int) (arg3);				\
+	long int _arg4 = (long int) (arg4);				\
 	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
 	register long int __v0 asm ("$2");				\
-	register long int __a0 asm ("$4") = (long int) (arg1);		\
-	register long int __a1 asm ("$5") = (long int) (arg2);		\
-	register long int __a2 asm ("$6") = (long int) (arg3);		\
-	register long int __a3 asm ("$7") = (long int) (arg4);		\
+	register long int __a0 asm ("$4") = _arg1;			\
+	register long int __a1 asm ("$5") = _arg2;			\
+	register long int __a2 asm ("$6") = _arg3;			\
+	register long int __a3 asm ("$7") = _arg4;			\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -238,14 +248,19 @@
 	long int _sys_result;						\
 									\
 	{								\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
+	long int _arg3 = (long int) (arg3);				\
+	long int _arg4 = (long int) (arg4);				\
+	long int _arg5 = (long int) (arg5);				\
 	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
 	register long int __v0 asm ("$2");				\
-	register long int __a0 asm ("$4") = (long int) (arg1);		\
-	register long int __a1 asm ("$5") = (long int) (arg2);		\
-	register long int __a2 asm ("$6") = (long int) (arg3);		\
-	register long int __a3 asm ("$7") = (long int) (arg4);		\
-	register long int __a4 asm ("$8") = (long int) (arg5);		\
+	register long int __a0 asm ("$4") = _arg1;			\
+	register long int __a1 asm ("$5") = _arg2;			\
+	register long int __a2 asm ("$6") = _arg3;			\
+	register long int __a3 asm ("$7") = _arg4;			\
+	register long int __a4 asm ("$8") = _arg5;			\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\
@@ -266,15 +281,21 @@
 	long int _sys_result;						\
 									\
 	{								\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
+	long int _arg3 = (long int) (arg3);				\
+	long int _arg4 = (long int) (arg4);				\
+	long int _arg5 = (long int) (arg5);				\
+	long int _arg6 = (long int) (arg6);				\
 	register long int __s0 asm ("$16") __attribute__ ((unused))	\
 	  = (number);							\
 	register long int __v0 asm ("$2");				\
-	register long int __a0 asm ("$4") = (long int) (arg1);		\
-	register long int __a1 asm ("$5") = (long int) (arg2);		\
-	register long int __a2 asm ("$6") = (long int) (arg3);		\
-	register long int __a3 asm ("$7") = (long int) (arg4);		\
-	register long int __a4 asm ("$8") = (long int) (arg5);		\
-	register long int __a5 asm ("$9") = (long int) (arg6);		\
+	register long int __a0 asm ("$4") = _arg1;			\
+	register long int __a1 asm ("$5") = _arg2;			\
+	register long int __a2 asm ("$6") = _arg3;			\
+	register long int __a3 asm ("$7") = _arg4;			\
+	register long int __a4 asm ("$8") = _arg5;			\
+	register long int __a5 asm ("$9") = _arg6;			\
 	__asm__ volatile (						\
 	".set\tnoreorder\n\t"						\
 	v0_init								\

commit f4f884351533601863351dd8a0d79e59471372da
Author: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date:   Mon Feb 10 10:19:29 2020 -0300

    microblaze: Avoid clobbering register parameters in syscall
    
    The microblaze INTERNAL_SYSCALL macro might clobber the register
    parameter if the argument itself might clobber any register (a function
    call for instance).
    
    This patch fixes it by using temporary variables for the expressions
    between the register assignments (as indicated by GCC documentation,
    6.47.5.2 Specifying Registers for Local Variables).
    
    It is similar to the fix done for MIPS (bug 25523).
    
    Checked with microblaze-linux-gnu and microblazeel-linux-gnu build.
    
    (cherry picked from commit 6cc8fc7c1506e8084d65b078ff5b05a92e17a28a)

diff --git a/sysdeps/unix/sysv/linux/microblaze/sysdep.h b/sysdeps/unix/sysv/linux/microblaze/sysdep.h
index ed873d9dd4..796663a23a 100644
--- a/sysdeps/unix/sysv/linux/microblaze/sysdep.h
+++ b/sysdeps/unix/sysv/linux/microblaze/sysdep.h
@@ -209,8 +209,8 @@ SYSCALL_ERROR_LABEL_DCL:                            \
 
 # define inline_syscall0(name,dummy)                                          \
   ({                                                                          \
-    register long __ret __asm__("r3");                                        \
-    register long __r12 __asm__("r12") = name;                                \
+    register long int __ret __asm__("r3");                                    \
+    register long int __r12 __asm__("r12") = name;                            \
     __asm__ __volatile__( "brki r14,8; nop;"                                  \
       : "=r"(__ret)                                                           \
       : "r"(__r12)                                                            \
@@ -219,9 +219,10 @@ SYSCALL_ERROR_LABEL_DCL:                            \
 
 # define inline_syscall1(name,arg1)                                           \
   ({                                                                          \
-    register long __ret __asm__("r3");                                        \
-    register long __r12 __asm__("r12") = name;                                \
-    register long __r5 __asm__("r5") = (long)(arg1);                          \
+    long int __arg1 = (long int) (arg1);                                      \
+    register long int __ret __asm__("r3");                                    \
+    register long int __r12 __asm__("r12") = name;                            \
+    register long int __r5 __asm__("r5") = __arg1;                            \
     __asm__ __volatile__( "brki r14,8; nop;"                                  \
       : "=r"(__ret)                                                           \
       : "r"(__r5), "r"(__r12)                                                 \
@@ -230,10 +231,12 @@ SYSCALL_ERROR_LABEL_DCL:                            \
 
 # define inline_syscall2(name,arg1,arg2)                                      \
   ({                                                                          \
-    register long __ret __asm__("r3");                                        \
-    register long __r12 __asm__("r12") = name;                                \
-    register long __r5 __asm__("r5") = (long)(arg1);                          \
-    register long __r6 __asm__("r6") = (long)(arg2);                          \
+    long int __arg1 = (long int) (arg1);                                      \
+    long int __arg2 = (long int) (arg2);                                      \
+    register long int __ret __asm__("r3");                                    \
+    register long int __r12 __asm__("r12") = name;                            \
+    register long int __r5 __asm__("r5") = __arg1;                            \
+    register long int __r6 __asm__("r6") = __arg2;                            \
     __asm__ __volatile__( "brki r14,8; nop;"                                  \
       : "=r"(__ret)                                                           \
       : "r"(__r5), "r"(__r6), "r"(__r12)                                      \
@@ -243,11 +246,14 @@ SYSCALL_ERROR_LABEL_DCL:                            \
 
 # define inline_syscall3(name,arg1,arg2,arg3)                                 \
   ({                                                                          \
-    register long __ret __asm__("r3");                                        \
-    register long __r12 __asm__("r12") = name;                                \
-    register long __r5 __asm__("r5") = (long)(arg1);                          \
-    register long __r6 __asm__("r6") = (long)(arg2);                          \
-    register long __r7 __asm__("r7") = (long)(arg3);                          \
+    long int __arg1 = (long int) (arg1);                                      \
+    long int __arg2 = (long int) (arg2);                                      \
+    long int __arg3 = (long int) (arg3);                                      \
+    register long int __ret __asm__("r3");                                    \
+    register long int __r12 __asm__("r12") = name;                            \
+    register long int __r5 __asm__("r5") = __arg1;                            \
+    register long int __r6 __asm__("r6") = __arg2;                            \
+    register long int __r7 __asm__("r7") = __arg3;                            \
     __asm__ __volatile__( "brki r14,8; nop;"                                  \
       : "=r"(__ret)                                                           \
       : "r"(__r5), "r"(__r6), "r"(__r7), "r"(__r12)                           \
@@ -257,12 +263,16 @@ SYSCALL_ERROR_LABEL_DCL:                            \
 
 # define inline_syscall4(name,arg1,arg2,arg3,arg4)                            \
   ({                                                                          \
-    register long __ret __asm__("r3");                                        \
-    register long __r12 __asm__("r12") = name;                                \
-    register long __r5 __asm__("r5") = (long)(arg1);                          \
-    register long __r6 __asm__("r6") = (long)(arg2);                          \
-    register long __r7 __asm__("r7") = (long)(arg3);                          \
-    register long __r8 __asm__("r8") = (long)(arg4);                          \
+    long int __arg1 = (long int) (arg1);                                      \
+    long int __arg2 = (long int) (arg2);                                      \
+    long int __arg3 = (long int) (arg3);                                      \
+    long int __arg4 = (long int) (arg4);                                      \
+    register long int __ret __asm__("r3");                                    \
+    register long int __r12 __asm__("r12") = name;                            \
+    register long int __r5 __asm__("r5") = __arg1;                            \
+    register long int __r6 __asm__("r6") = __arg2;                            \
+    register long int __r7 __asm__("r7") = __arg3;                            \
+    register long int __r8 __asm__("r8") = __arg4;                            \
     __asm__ __volatile__( "brki r14,8; nop;"                                  \
       : "=r"(__ret)                                                           \
       : "r"(__r5), "r"(__r6), "r"(__r7), "r"(__r8),"r"(__r12)                 \
@@ -272,13 +282,18 @@ SYSCALL_ERROR_LABEL_DCL:                            \
 
 # define inline_syscall5(name,arg1,arg2,arg3,arg4,arg5)                       \
   ({                                                                          \
-    register long __ret __asm__("r3");                                        \
-    register long __r12 __asm__("r12") = name;                                \
-    register long __r5 __asm__("r5") = (long)(arg1);                          \
-    register long __r6 __asm__("r6") = (long)(arg2);                          \
-    register long __r7 __asm__("r7") = (long)(arg3);                          \
-    register long __r8 __asm__("r8") = (long)(arg4);                          \
-    register long __r9 __asm__("r9") = (long)(arg5);                          \
+    long int __arg1 = (long int) (arg1);                                      \
+    long int __arg2 = (long int) (arg2);                                      \
+    long int __arg3 = (long int) (arg3);                                      \
+    long int __arg4 = (long int) (arg4);                                      \
+    long int __arg5 = (long int) (arg5);                                      \
+    register long int __ret __asm__("r3");                                    \
+    register long int __r12 __asm__("r12") = name;                            \
+    register long int __r5 __asm__("r5") = __arg1;                            \
+    register long int __r6 __asm__("r6") = __arg2;                            \
+    register long int __r7 __asm__("r7") = __arg3;                            \
+    register long int __r8 __asm__("r8") = __arg4;                            \
+    register long int __r9 __asm__("r9") = __arg5;                            \
     __asm__ __volatile__( "brki r14,8; nop;"                                  \
       : "=r"(__ret)                                                           \
       : "r"(__r5), "r"(__r6), "r"(__r7), "r"(__r8),"r"(__r9), "r"(__r12)      \
@@ -288,14 +303,20 @@ SYSCALL_ERROR_LABEL_DCL:                            \
 
 # define inline_syscall6(name,arg1,arg2,arg3,arg4,arg5,arg6)                  \
   ({                                                                          \
-    register long __ret __asm__("r3");                                        \
-    register long __r12 __asm__("r12") = name;                                \
-    register long __r5 __asm__("r5") = (long)(arg1);                          \
-    register long __r6 __asm__("r6") = (long)(arg2);                          \
-    register long __r7 __asm__("r7") = (long)(arg3);                          \
-    register long __r8 __asm__("r8") = (long)(arg4);                          \
-    register long __r9 __asm__("r9") = (long)(arg5);                          \
-    register long __r10 __asm__("r10") = (long)(arg6);                        \
+    long int __arg1 = (long int) (arg1);                                      \
+    long int __arg2 = (long int) (arg2);                                      \
+    long int __arg3 = (long int) (arg3);                                      \
+    long int __arg4 = (long int) (arg4);                                      \
+    long int __arg5 = (long int) (arg5);                                      \
+    long int __arg6 = (long int) (arg6);                                      \
+    register long int __ret __asm__("r3");                                    \
+    register long int __r12 __asm__("r12") = name;                            \
+    register long int __r5 __asm__("r5") = __arg1;                            \
+    register long int __r6 __asm__("r6") = __arg2;                            \
+    register long int __r7 __asm__("r7") = __arg3;                            \
+    register long int __r8 __asm__("r8") = __arg4;                            \
+    register long int __r9 __asm__("r9") = __arg5;                            \
+    register long int __r10 __asm__("r10") = __arg6;                          \
     __asm__ __volatile__( "brki r14,8; nop;"                                  \
       : "=r"(__ret)                                                           \
       : "r"(__r5), "r"(__r6), "r"(__r7), "r"(__r8),"r"(__r9), "r"(__r10),     \

commit 5d31b083e41ce2492f3c1d4061dc610cdcdcfaa9
Author: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date:   Mon Feb 10 10:32:14 2020 -0300

    riscv: Avoid clobbering register parameters in syscall
    
    The riscv INTERNAL_SYSCALL macro might clobber the register
    parameter if the argument itself might clobber any register (a function
    call for instance).
    
    This patch fixes it by using temporary variables for the expressions
    between the register assignments (as indicated by GCC documentation,
    6.47.5.2 Specifying Registers for Local Variables).
    
    It is similar to the fix done for MIPS (bug 25523).
    
    Checked with riscv64-linux-gnu-rv64imafdc-lp64d build.
    
    (cherry picked from commit be74b42ee2a97009a6cd4fc90126add4a41c583b)

diff --git a/sysdeps/unix/sysv/linux/riscv/sysdep.h b/sysdeps/unix/sysv/linux/riscv/sysdep.h
index 201bf9a91b..2bd9b16f32 100644
--- a/sysdeps/unix/sysv/linux/riscv/sysdep.h
+++ b/sysdeps/unix/sysv/linux/riscv/sysdep.h
@@ -176,10 +176,11 @@
 # define internal_syscall1(number, err, arg0)				\
 ({ 									\
 	long int _sys_result;						\
+	long int _arg0 = (long int) (arg0);				\
 									\
 	{								\
 	register long int __a7 asm ("a7") = number;			\
-	register long int __a0 asm ("a0") = (long int) (arg0);		\
+	register long int __a0 asm ("a0") = _arg0;			\
 	__asm__ volatile ( 						\
 	"scall\n\t" 							\
 	: "+r" (__a0)							\
@@ -193,11 +194,13 @@
 # define internal_syscall2(number, err, arg0, arg1)	    		\
 ({ 									\
 	long int _sys_result;						\
+	long int _arg0 = (long int) (arg0);				\
+	long int _arg1 = (long int) (arg1);				\
 									\
 	{								\
 	register long int __a7 asm ("a7") = number;			\
-	register long int __a0 asm ("a0") = (long int) (arg0);		\
-	register long int __a1 asm ("a1") = (long int) (arg1);		\
+	register long int __a0 asm ("a0") = _arg0;			\
+	register long int __a1 asm ("a1") = _arg1;			\
 	__asm__ volatile ( 						\
 	"scall\n\t" 							\
 	: "+r" (__a0)							\
@@ -211,12 +214,15 @@
 # define internal_syscall3(number, err, arg0, arg1, arg2)      		\
 ({ 									\
 	long int _sys_result;						\
+	long int _arg0 = (long int) (arg0);				\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
 									\
 	{								\
 	register long int __a7 asm ("a7") = number;			\
-	register long int __a0 asm ("a0") = (long int) (arg0);		\
-	register long int __a1 asm ("a1") = (long int) (arg1);		\
-	register long int __a2 asm ("a2") = (long int) (arg2);		\
+	register long int __a0 asm ("a0") = _arg0;			\
+	register long int __a1 asm ("a1") = _arg1;			\
+	register long int __a2 asm ("a2") = _arg2;			\
 	__asm__ volatile ( 						\
 	"scall\n\t" 							\
 	: "+r" (__a0)							\
@@ -230,13 +236,17 @@
 # define internal_syscall4(number, err, arg0, arg1, arg2, arg3)	  \
 ({ 									\
 	long int _sys_result;						\
+	long int _arg0 = (long int) (arg0);				\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
+	long int _arg3 = (long int) (arg3);				\
 									\
 	{								\
 	register long int __a7 asm ("a7") = number;			\
-	register long int __a0 asm ("a0") = (long int) (arg0);		\
-	register long int __a1 asm ("a1") = (long int) (arg1);		\
-	register long int __a2 asm ("a2") = (long int) (arg2);		\
-	register long int __a3 asm ("a3") = (long int) (arg3);		\
+	register long int __a0 asm ("a0") = _arg0;			\
+	register long int __a1 asm ("a1") = _arg1;			\
+	register long int __a2 asm ("a2") = _arg2;			\
+	register long int __a3 asm ("a3") = _arg3;			\
 	__asm__ volatile ( 						\
 	"scall\n\t" 							\
 	: "+r" (__a0)							\
@@ -250,14 +260,19 @@
 # define internal_syscall5(number, err, arg0, arg1, arg2, arg3, arg4)   \
 ({ 									\
 	long int _sys_result;						\
+	long int _arg0 = (long int) (arg0);				\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
+	long int _arg3 = (long int) (arg3);				\
+	long int _arg4 = (long int) (arg4);				\
 									\
 	{								\
 	register long int __a7 asm ("a7") = number;			\
-	register long int __a0 asm ("a0") = (long int) (arg0);		\
-	register long int __a1 asm ("a1") = (long int) (arg1);		\
-	register long int __a2 asm ("a2") = (long int) (arg2);		\
-	register long int __a3 asm ("a3") = (long int) (arg3);		\
-	register long int __a4 asm ("a4") = (long int) (arg4);		\
+	register long int __a0 asm ("a0") = _arg0;			\
+	register long int __a1 asm ("a1") = _arg1;			\
+	register long int __a2 asm ("a2") = _arg2;			\
+	register long int __a3 asm ("a3") = _arg3;			\
+	register long int __a4 asm ("a4") = _arg4;			\
 	__asm__ volatile ( 						\
 	"scall\n\t" 							\
 	: "+r" (__a0)							\
@@ -271,15 +286,21 @@
 # define internal_syscall6(number, err, arg0, arg1, arg2, arg3, arg4, arg5) \
 ({ 									\
 	long int _sys_result;						\
+	long int _arg0 = (long int) (arg0);				\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
+	long int _arg3 = (long int) (arg3);				\
+	long int _arg4 = (long int) (arg4);				\
+	long int _arg5 = (long int) (arg5);				\
 									\
 	{								\
 	register long int __a7 asm ("a7") = number;			\
-	register long int __a0 asm ("a0") = (long int) (arg0);		\
-	register long int __a1 asm ("a1") = (long int) (arg1);		\
-	register long int __a2 asm ("a2") = (long int) (arg2);		\
-	register long int __a3 asm ("a3") = (long int) (arg3);		\
-	register long int __a4 asm ("a4") = (long int) (arg4);		\
-	register long int __a5 asm ("a5") = (long int) (arg5);		\
+	register long int __a0 asm ("a0") = _arg0;			\
+	register long int __a1 asm ("a1") = _arg1;			\
+	register long int __a2 asm ("a2") = _arg2;			\
+	register long int __a3 asm ("a3") = _arg3;			\
+	register long int __a4 asm ("a4") = _arg4;			\
+	register long int __a5 asm ("a5") = _arg5;			\
 	__asm__ volatile ( 						\
 	"scall\n\t" 							\
 	: "+r" (__a0)							\
@@ -294,16 +315,23 @@
 # define internal_syscall7(number, err, arg0, arg1, arg2, arg3, arg4, arg5, arg6) \
 ({ 									\
 	long int _sys_result;						\
+	long int _arg0 = (long int) (arg0);				\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
+	long int _arg3 = (long int) (arg3);				\
+	long int _arg4 = (long int) (arg4);				\
+	long int _arg5 = (long int) (arg5);				\
+	long int _arg6 = (long int) (arg6);				\
 									\
 	{								\
 	register long int __a7 asm ("a7") = number;			\
-	register long int __a0 asm ("a0") = (long int) (arg0);		\
-	register long int __a1 asm ("a1") = (long int) (arg1);		\
-	register long int __a2 asm ("a2") = (long int) (arg2);		\
-	register long int __a3 asm ("a3") = (long int) (arg3);		\
-	register long int __a4 asm ("a4") = (long int) (arg4);		\
-	register long int __a5 asm ("a5") = (long int) (arg5);		\
-	register long int __a6 asm ("a6") = (long int) (arg6);		\
+	register long int __a0 asm ("a0") = _arg0;			\
+	register long int __a1 asm ("a1") = _arg1;			\
+	register long int __a2 asm ("a2") = _arg2;			\
+	register long int __a3 asm ("a3") = _arg3;			\
+	register long int __a4 asm ("a4") = _arg4;			\
+	register long int __a5 asm ("a5") = _arg5;			\
+	register long int __a6 asm ("a6") = _arg6;			\
 	__asm__ volatile ( 						\
 	"scall\n\t" 							\
 	: "+r" (__a0)							\

commit 71f2b249a28e17eac0e47c53af44d5c5b65101aa
Author: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date:   Thu Feb 20 14:37:04 2020 -0300

    malloc/tst-mallocfork2: Kill lingering process for unexpected failures
    
    If the test fails due some unexpected failure after the children
    creation, either in the signal handler by calling abort or in the main
    loop; the created children might not be killed properly.
    
    This patches fixes it by:
    
      * Avoid aborting in the signal handler by setting a flag that
        an error has occured and add a check in the main loop.
    
      * Add a atexit handler to handle kill child processes.
    
    Checked on x86_64-linux-gnu.

diff --git a/malloc/tst-mallocfork2.c b/malloc/tst-mallocfork2.c
index 0602a94895..fc1fd64b21 100644
--- a/malloc/tst-mallocfork2.c
+++ b/malloc/tst-mallocfork2.c
@@ -62,6 +62,9 @@ static volatile sig_atomic_t sigusr1_received;
    progress.  Checked by liveness_signal_handler.  */
 static volatile sig_atomic_t progress_indicator = 1;
 
+/* Set to 1 if an error occurs in the signal handler.  */
+static volatile sig_atomic_t error_indicator = 0;
+
 static void
 sigusr1_handler (int signo)
 {
@@ -72,7 +75,8 @@ sigusr1_handler (int signo)
   if (pid == -1)
     {
       write_message ("error: fork\n");
-      abort ();
+      error_indicator = 1;
+      return;
     }
   if (pid == 0)
     _exit (0);
@@ -81,12 +85,14 @@ sigusr1_handler (int signo)
   if (ret < 0)
     {
       write_message ("error: waitpid\n");
-      abort ();
+      error_indicator = 1;
+      return;
     }
   if (status != 0)
     {
       write_message ("error: unexpected exit status from subprocess\n");
-      abort ();
+      error_indicator = 1;
+      return;
     }
 }
 
@@ -122,9 +128,25 @@ signal_sender (int signo, bool sleep)
     }
 }
 
+/* Children processes.  */
+static pid_t sigusr1_sender_pids[5] = { 0 };
+static pid_t sigusr2_sender_pid = 0;
+
+static void
+kill_children (void)
+{
+  for (size_t i = 0; i < array_length (sigusr1_sender_pids); ++i)
+    if (sigusr1_sender_pids[i] > 0)
+      kill (sigusr1_sender_pids[i], SIGKILL);
+  if (sigusr2_sender_pid > 0)
+    kill (sigusr2_sender_pid, SIGKILL);
+}
+
 static int
 do_test (void)
 {
+  atexit (kill_children);
+
   /* shared->barrier is intialized along with sigusr1_sender_pids
      below.  */
   shared = support_shared_allocate (sizeof (*shared));
@@ -148,14 +170,13 @@ do_test (void)
       return 1;
     }
 
-  pid_t sigusr2_sender_pid = xfork ();
+  sigusr2_sender_pid = xfork ();
   if (sigusr2_sender_pid == 0)
     signal_sender (SIGUSR2, true);
 
   /* Send SIGUSR1 signals from several processes.  Hopefully, one
      signal will hit one of the ciritical functions.  Use a barrier to
      avoid sending signals while not running fork/free/malloc.  */
-  pid_t sigusr1_sender_pids[5];
   {
     pthread_barrierattr_t attr;
     xpthread_barrierattr_init (&attr);
@@ -166,7 +187,7 @@ do_test (void)
   }
   for (size_t i = 0; i < array_length (sigusr1_sender_pids); ++i)
     {
-      sigusr1_sender_pids[i] = fork ();
+      sigusr1_sender_pids[i] = xfork ();
       if (sigusr1_sender_pids[i] == 0)
         signal_sender (SIGUSR1, false);
     }
@@ -211,7 +232,7 @@ do_test (void)
         ++malloc_signals;
       xpthread_barrier_wait (&shared->barrier);
 
-      if (objects[slot] == NULL)
+      if (objects[slot] == NULL || error_indicator != 0)
         {
           printf ("error: malloc: %m\n");
           for (size_t i = 0; i < array_length (sigusr1_sender_pids); ++i)
@@ -225,10 +246,6 @@ do_test (void)
   for (int slot = 0; slot < malloc_objects; ++slot)
     free (objects[slot]);
 
-  for (size_t i = 0; i < array_length (sigusr1_sender_pids); ++i)
-    kill (sigusr1_sender_pids[i], SIGKILL);
-  kill (sigusr2_sender_pid, SIGKILL);
-
   printf ("info: signals received during fork: %u\n", fork_signals);
   printf ("info: signals received during free: %u\n", free_signals);
   printf ("info: signals received during malloc: %u\n", malloc_signals);

commit 9f997ceca28f0634ad78a1ca95b84265f7801ff4
Author: Joseph Myers <joseph@codesourcery.com>
Date:   Wed Feb 12 23:31:56 2020 +0000

    Avoid ldbl-96 stack corruption from range reduction of pseudo-zero (bug 25487).
    
    Bug 25487 reports stack corruption in ldbl-96 sinl on a pseudo-zero
    argument (an representation where all the significand bits, including
    the explicit high bit, are zero, but the exponent is not zero, which
    is not a valid representation for the long double type).
    
    Although this is not a valid long double representation, existing
    practice in this area (see bug 4586, originally marked invalid but
    subsequently fixed) is that we still seek to avoid invalid memory
    accesses as a result, in case of programs that treat arbitrary binary
    data as long double representations, although the invalid
    representations of the ldbl-96 format do not need to be consistently
    handled the same as any particular valid representation.
    
    This patch makes the range reduction detect pseudo-zero and unnormal
    representations that would otherwise go to __kernel_rem_pio2, and
    returns a NaN for them instead of continuing with the range reduction
    process.  (Pseudo-zero and unnormal representations whose unbiased
    exponent is less than -1 have already been safely returned from the
    function before this point without going through the rest of range
    reduction.)  Pseudo-zero representations would previously result in
    the value passed to __kernel_rem_pio2 being all-zero, which is
    definitely unsafe; unnormal representations would previously result in
    a value passed whose high bit is zero, which might well be unsafe
    since that is not a form of input expected by __kernel_rem_pio2.
    
    Tested for x86_64.
    
    (cherry picked from commit 9333498794cde1d5cca518badf79533a24114b6f)

diff --git a/NEWS b/NEWS
index 64e21b1c50..d0ad1693f2 100644
--- a/NEWS
+++ b/NEWS
@@ -8,8 +8,13 @@ using `glibc' in the "product" field.
 Version 2.31.1
 
 The following bugs are resolved with this release:
+  [25487] sinl() stack corruption from crafted input (CVE-2020-10029)
   [25523] MIPS/Linux inline syscall template is miscompiled
 
+Security related changes:
+
+ CVE-2020-10029
+
 
 Version 2.31
 
diff --git a/sysdeps/ieee754/ldbl-96/Makefile b/sysdeps/ieee754/ldbl-96/Makefile
index 995e90d6da..318628aed6 100644
--- a/sysdeps/ieee754/ldbl-96/Makefile
+++ b/sysdeps/ieee754/ldbl-96/Makefile
@@ -17,5 +17,6 @@
 # <https://www.gnu.org/licenses/>.
 
 ifeq ($(subdir),math)
-tests += test-canonical-ldbl-96 test-totalorderl-ldbl-96
+tests += test-canonical-ldbl-96 test-totalorderl-ldbl-96 test-sinl-pseudo
+CFLAGS-test-sinl-pseudo.c += -fstack-protector-all
 endif
diff --git a/sysdeps/ieee754/ldbl-96/e_rem_pio2l.c b/sysdeps/ieee754/ldbl-96/e_rem_pio2l.c
index 5f742321ae..bcdf20179f 100644
--- a/sysdeps/ieee754/ldbl-96/e_rem_pio2l.c
+++ b/sysdeps/ieee754/ldbl-96/e_rem_pio2l.c
@@ -210,6 +210,18 @@ __ieee754_rem_pio2l (long double x, long double *y)
       return 0;
     }
 
+  if ((i0 & 0x80000000) == 0)
+    {
+      /* Pseudo-zero and unnormal representations are not valid
+	 representations of long double.  We need to avoid stack
+	 corruption in __kernel_rem_pio2, which expects input in a
+	 particular normal form, but those representations do not need
+	 to be consistently handled like any particular floating-point
+	 value.  */
+      y[1] = y[0] = __builtin_nanl ("");
+      return 0;
+    }
+
   /* Split the 64 bits of the mantissa into three 24-bit integers
      stored in a double array.  */
   exp = j0 - 23;
diff --git a/sysdeps/ieee754/ldbl-96/test-sinl-pseudo.c b/sysdeps/ieee754/ldbl-96/test-sinl-pseudo.c
new file mode 100644
index 0000000000..f59b97769d
--- /dev/null
+++ b/sysdeps/ieee754/ldbl-96/test-sinl-pseudo.c
@@ -0,0 +1,41 @@
+/* Test sinl for pseudo-zeros and unnormals for ldbl-96 (bug 25487).
+   Copyright (C) 2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <math.h>
+#include <math_ldbl.h>
+#include <stdint.h>
+
+static int
+do_test (void)
+{
+  for (int i = 0; i < 64; i++)
+    {
+      uint64_t sig = i == 63 ? 0 : 1ULL << i;
+      long double ld;
+      SET_LDOUBLE_WORDS (ld, 0x4141,
+			 sig >> 32, sig & 0xffffffffULL);
+      /* The requirement is that no stack overflow occurs when the
+	 pseudo-zero or unnormal goes through range reduction.  */
+      volatile long double ldr;
+      ldr = sinl (ld);
+      (void) ldr;
+    }
+  return 0;
+}
+
+#include <support/test-driver.c>

commit f2d95cf030ff57a7cc067f770d2afbb4e85aa26b
Author: Fangrui Song <maskray@google.com>
Date:   Tue Feb 4 21:55:44 2020 -0800

    Improve IFUNC check [BZ #25506]
    
    GNU ld's RISCV port does not support IFUNC. ld -no-pie produces no
    relocation and the test passed incorrectly. Be more rigid by testing
    IRELATIVE explicitly.
    
    Tested-by: Aurelien Jarno <aurelien@aurel32.net>
    Reviewed-by: Adhemerval Zanella <adhemerval.zanella@linaro.org>
    (cherry picked from commit 87a698a21646b7ee620923ef5ffa9735471a8ddd)

diff --git a/configure b/configure
index b959d2d988..3b98ec312f 100755
--- a/configure
+++ b/configure
@@ -4035,7 +4035,7 @@ if ${CC-cc} $CFLAGS $CPPFLAGS $LDFLAGS \
 	    -o conftest conftest.S 1>&5 2>&5; then
   # Do a link to see if the backend supports IFUNC relocs.
   $READELF -r conftest 1>&5
-  LC_ALL=C $READELF -r conftest | grep 'no relocations' >/dev/null || {
+  LC_ALL=C $READELF -Wr conftest | grep -q 'IRELATIVE\|R_SPARC_JMP_IREL' && {
     libc_cv_ld_gnu_indirect_function=yes
   }
 fi
diff --git a/configure.ac b/configure.ac
index 49b900c1ed..e20034f301 100644
--- a/configure.ac
+++ b/configure.ac
@@ -649,7 +649,7 @@ if ${CC-cc} $CFLAGS $CPPFLAGS $LDFLAGS \
 	    -o conftest conftest.S 1>&AS_MESSAGE_LOG_FD 2>&AS_MESSAGE_LOG_FD; then
   # Do a link to see if the backend supports IFUNC relocs.
   $READELF -r conftest 1>&AS_MESSAGE_LOG_FD
-  LC_ALL=C $READELF -r conftest | grep 'no relocations' >/dev/null || {
+  LC_ALL=C $READELF -Wr conftest | grep -q 'IRELATIVE\|R_SPARC_JMP_IREL' && {
     libc_cv_ld_gnu_indirect_function=yes
   }
 fi

commit 44f2c26ee4f6b0b04ba33811d87d69a1a8708837
Author: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date:   Fri Feb 28 10:46:14 2020 -0300

    i386: Use comdat instead of .gnu.linkonce for i386 setup pic register (BZ #20543)
    
    GCC has moved from using .gnu.linkonce for i386 setup pic register with
    minimum current version (as for binutils minimum binutils that support
    comdat).
    
    Trying to pinpoint when binutils has added comdat support for i686, it
    seems it was around 2004 [1].  I also checking with some ancient
    binutils older than 2.16 I see:
    
    test.o: In function `__x86.get_pc_thunk.bx':
    test.o(.text.__x86.get_pc_thunk.bx+0x0): multiple definition of `__x86.get_pc_thunk.bx'
    /usr/lib/gcc/x86_64-linux-gnu/5/../../../i386-linux-gnu/crti.o(.gnu.linkonce.t.__x86.get_pc_thunk.bx+0x0): first defined here
    
    Which seems that such version can not handle either comdat at all or
    a mix of linkonce and comdat.  For binutils 2.16.1 I am getting a
    different issue trying to link a binary with and more recent
    ctri.o (unrecognized relocation (0x2b) in section `.init', which is
    R_386_GOT32X and old binutils won't generate it anyway).
    
    So I think that either unlikely someone will use an older binutils than
    the one used to glibc and even this scenario may fail with some issue
    as the R_386_GOT32X.  Also, 2.16.1 is quite old and not really supported
    (glibc itself required 2.25).
    
    Checked on i686-linux-gnu.
    
    [1] https://gcc.gnu.org/ml/gcc/2004-05/msg00030.html
    
    (cherry picked from commit 35200fd3892f6caf867bf89bc8048e553906af28)

diff --git a/sysdeps/i386/sysdep.h b/sysdeps/i386/sysdep.h
index b4bcd8fb6c..6094af8fec 100644
--- a/sysdeps/i386/sysdep.h
+++ b/sysdeps/i386/sysdep.h
@@ -61,7 +61,7 @@ lose: SYSCALL_PIC_SETUP							      \
 
 # define SETUP_PIC_REG(reg) \
   .ifndef GET_PC_THUNK(reg);						      \
-  .section .gnu.linkonce.t.GET_PC_THUNK(reg),"ax",@progbits;		      \
+  .section .text.GET_PC_THUNK(reg),"axG",@progbits,GET_PC_THUNK(reg),comdat;  \
   .globl GET_PC_THUNK(reg);						      \
   .hidden GET_PC_THUNK(reg);						      \
   .p2align 4;								      \
@@ -97,7 +97,8 @@ GET_PC_THUNK(reg):							      \
 
 # define SETUP_PIC_REG_STR(reg)						\
   ".ifndef " GET_PC_THUNK_STR (reg) "\n"				\
-  ".section .gnu.linkonce.t." GET_PC_THUNK_STR (reg) ",\"ax\",@progbits\n" \
+  ".section .text." GET_PC_THUNK_STR (reg) ",\"axG\",@progbits,"	\
+    GET_PC_THUNK_STR (reg) ",comdat\n"					\
   ".globl " GET_PC_THUNK_STR (reg) "\n"					\
   ".hidden " GET_PC_THUNK_STR (reg) "\n"				\
   ".p2align 4\n"							\

commit 9db2970506ca56732ae55f420c48f0c57ac6eb37
Author: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date:   Tue Mar 3 14:59:13 2020 -0300

    linux: Clear mode_t padding bits (BZ#25623)
    
    The kernel might not clear the padding value for the ipc_perm mode
    fields in compat mode (32 bit running on a 64 bit kernel).  It was
    fixed on v4.14 when the ipc compat code was refactored to move
    (commits 553f770ef71b, 469391684626, c0ebccb6fa1e).
    
    Although it is most likely a kernel issue, it was shown only due
    BZ#18231 fix which made all the SysVIPC mode_t 32-bit regardless of
    the kABI.
    
    This patch fixes it by explicitly zeroing the upper bits for such
    cases.  The __ASSUME_SYSVIPC_BROKEN_MODE_T case already handles
    it with the shift.
    
    (The aarch64 ipc_priv.h is superflous since
    __ASSUME_SYSVIPC_DEFAULT_IPC_64 is now defined as default).
    
    Checked on i686-linux-gnu on 3.10 and on 4.15 kernel.
    
    (cherry picked from commit 82025bad80429c67a4d75f098155b5e02b5112b4)

diff --git a/sysdeps/unix/sysv/linux/msgctl.c b/sysdeps/unix/sysv/linux/msgctl.c
index 27879e76cd..eb28835b3a 100644
--- a/sysdeps/unix/sysv/linux/msgctl.c
+++ b/sysdeps/unix/sysv/linux/msgctl.c
@@ -61,7 +61,6 @@ __new_msgctl (int msqid, int cmd, struct msqid_ds *buf)
 
   int ret = msgctl_syscall (msqid, cmd, buf);
 
-#ifdef __ASSUME_SYSVIPC_BROKEN_MODE_T
   if (ret >= 0)
     {
       switch (cmd)
@@ -69,10 +68,16 @@ __new_msgctl (int msqid, int cmd, struct msqid_ds *buf)
 	case IPC_STAT:
 	case MSG_STAT:
 	case MSG_STAT_ANY:
+#ifdef __ASSUME_SYSVIPC_BROKEN_MODE_T
 	  buf->msg_perm.mode >>= 16;
+#else
+	  /* Old Linux kernel versions might not clear the mode padding.  */
+	  if (sizeof ((struct msqid_ds){0}.msg_perm.mode)
+	      != sizeof (__kernel_mode_t))
+	    buf->msg_perm.mode &= 0xFFFF;
+#endif
 	}
     }
-#endif
 
   return ret;
 }
diff --git a/sysdeps/unix/sysv/linux/semctl.c b/sysdeps/unix/sysv/linux/semctl.c
index 0c3eb0932f..0a79e8e4f5 100644
--- a/sysdeps/unix/sysv/linux/semctl.c
+++ b/sysdeps/unix/sysv/linux/semctl.c
@@ -92,7 +92,6 @@ __new_semctl (int semid, int semnum, int cmd, ...)
 
   int ret = semctl_syscall (semid, semnum, cmd, arg);
 
-#ifdef __ASSUME_SYSVIPC_BROKEN_MODE_T
   if (ret >= 0)
     {
       switch (cmd)
@@ -100,10 +99,16 @@ __new_semctl (int semid, int semnum, int cmd, ...)
         case IPC_STAT:
         case SEM_STAT:
         case SEM_STAT_ANY:
+#ifdef __ASSUME_SYSVIPC_BROKEN_MODE_T
           arg.buf->sem_perm.mode >>= 16;
+#else
+	  /* Old Linux kernel versions might not clear the mode padding.  */
+	  if (sizeof ((struct semid_ds){0}.sem_perm.mode)
+	      != sizeof (__kernel_mode_t))
+	    arg.buf->sem_perm.mode &= 0xFFFF;
+#endif
 	}
     }
-#endif
 
   return ret;
 }
diff --git a/sysdeps/unix/sysv/linux/shmctl.c b/sysdeps/unix/sysv/linux/shmctl.c
index 39fa861e17..aed9e5260e 100644
--- a/sysdeps/unix/sysv/linux/shmctl.c
+++ b/sysdeps/unix/sysv/linux/shmctl.c
@@ -63,7 +63,6 @@ __new_shmctl (int shmid, int cmd, struct shmid_ds *buf)
 
   int ret = shmctl_syscall (shmid, cmd, buf);
 
-#ifdef __ASSUME_SYSVIPC_BROKEN_MODE_T
   if (ret >= 0)
     {
       switch (cmd)
@@ -71,10 +70,16 @@ __new_shmctl (int shmid, int cmd, struct shmid_ds *buf)
         case IPC_STAT:
         case SHM_STAT:
         case SHM_STAT_ANY:
+#ifdef __ASSUME_SYSVIPC_BROKEN_MODE_T
           buf->shm_perm.mode >>= 16;
+#else
+	  /* Old Linux kernel versions might not clear the mode padding.  */
+	  if (sizeof ((struct shmid_ds){0}.shm_perm.mode)
+	      != sizeof (__kernel_mode_t))
+	    buf->shm_perm.mode &= 0xFFFF;
+#endif
 	}
     }
-#endif
 
   return ret;
 }

commit da6ce60e3cb8a4f74b0cb87eae4951a40b8595df
Author: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date:   Fri Mar 6 09:25:32 2020 -0300

    linux/sysipc: Include linux/posix_types.h for __kernel_mode_t
    
    The posix_types.h (where __kernel_mode_t is defined) is included
    implicitly, which might not happen on older kernels.
    
    (cherry picked from commit 7aec9f4e5e0313772d123ba4daa96ea921a50aec)

diff --git a/sysdeps/unix/sysv/linux/msgctl.c b/sysdeps/unix/sysv/linux/msgctl.c
index eb28835b3a..fd46aec1a0 100644
--- a/sysdeps/unix/sysv/linux/msgctl.c
+++ b/sysdeps/unix/sysv/linux/msgctl.c
@@ -21,6 +21,7 @@
 #include <sysdep.h>
 #include <shlib-compat.h>
 #include <errno.h>
+#include <linux/posix_types.h>  /* For __kernel_mode_t.  */
 
 #ifndef DEFAULT_VERSION
 # ifndef __ASSUME_SYSVIPC_BROKEN_MODE_T
diff --git a/sysdeps/unix/sysv/linux/semctl.c b/sysdeps/unix/sysv/linux/semctl.c
index 0a79e8e4f5..30571af49f 100644
--- a/sysdeps/unix/sysv/linux/semctl.c
+++ b/sysdeps/unix/sysv/linux/semctl.c
@@ -22,6 +22,7 @@
 #include <sysdep.h>
 #include <shlib-compat.h>
 #include <errno.h>
+#include <linux/posix_types.h>  /* For __kernel_mode_t.  */
 
 /* Define a `union semun' suitable for Linux here.  */
 union semun
diff --git a/sysdeps/unix/sysv/linux/shmctl.c b/sysdeps/unix/sysv/linux/shmctl.c
index aed9e5260e..f41b359b8b 100644
--- a/sysdeps/unix/sysv/linux/shmctl.c
+++ b/sysdeps/unix/sysv/linux/shmctl.c
@@ -22,6 +22,7 @@
 #include <sysdep.h>
 #include <shlib-compat.h>
 #include <errno.h>
+#include <linux/posix_types.h>  /* For __kernel_mode_t.  */
 
 #ifndef DEFAULT_VERSION
 # ifndef __ASSUME_SYSVIPC_BROKEN_MODE_T

commit a9ae2062d5738247fb5af82e5ed52beae2757982
Author: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date:   Thu Mar 5 13:14:41 2020 +0000

    arm: Fix softp-fp Implies (BZ #25635)
    
    The commit "arm: Split BE/LE abilist"
    (1673ba87fefe019c834c09d33673d1d453ea698d) changed the soft-fp order for
    ARM selection when __SOFTFP__ is defined by the compiler.
    
    On 2.30 the sysdeps order is:
    
    2.30
    sysdeps/unix/sysv/linux/arm
    sysdeps/arm/nptl
    sysdeps/unix/sysv/linux
    sysdeps/nptl
    sysdeps/pthread
    sysdeps/gnu
    sysdeps/unix/inet
    sysdeps/unix/sysv
    sysdeps/unix/arm
    sysdeps/unix
    sysdeps/posix
    sysdeps/arm/nofpu
    sysdeps/ieee754/soft-fp
    sysdeps/arm
    sysdeps/wordsize-32
    sysdeps/ieee754/flt-32
    sysdeps/ieee754/dbl-64
    sysdeps/ieee754
    sysdeps/generic
    
    While on master is:
    
    sysdeps/unix/sysv/linux/arm/le
    sysdeps/unix/sysv/linux/arm
    sysdeps/arm/nptl
    sysdeps/unix/sysv/linux
    sysdeps/nptl
    sysdeps/pthread
    sysdeps/gnu
    sysdeps/unix/inet
    sysdeps/unix/sysv
    sysdeps/unix/arm
    sysdeps/unix
    sysdeps/posix
    sysdeps/arm/le
    sysdeps/arm
    sysdeps/wordsize-32
    sysdeps/ieee754/flt-32
    sysdeps/ieee754/dbl-64
    sysdeps/arm/nofpu
    sysdeps/ieee754/soft-fp
    sysdeps/ieee754
    sysdeps/generic
    
    It make the build select some routines (fadd, fdiv, fmul, fsub, and fma)
    on ieee754/flt-32 and ieee754/dbl-64 that requires fenv support to be
    correctly rounded which in turns lead to math failures since the
    __SOFTFP__ does not have fenv support.
    
    With this patch the order is now:
    
    sysdeps/unix/sysv/linux/arm/le
    sysdeps/unix/sysv/linux/arm
    sysdeps/arm/nptl
    sysdeps/unix/sysv/linux
    sysdeps/nptlsysdeps/pthread
    sysdeps/gnu
    sysdeps/unix/inet
    sysdeps/unix/sysv
    sysdeps/unix/arm
    sysdeps/unix
    sysdeps/posix
    sysdeps/arm/le/nofpu
    sysdeps/arm/nofpu
    sysdeps/ieee754/soft-fp
    sysdeps/arm/le
    sysdeps/arm
    sysdeps/wordsize-32
    sysdeps/ieee754/flt-32
    sysdeps/ieee754/dbl-64
    sysdeps/ieee754
    sysdeps/generic
    
    Checked on arm-linux-gnuaebi.
    
    (cherry picked from commit af09e5e5d9ec3ca20891e61a6922eac984fcbdc4)

diff --git a/sysdeps/arm/be/nofpu/Implies b/sysdeps/arm/be/nofpu/Implies
new file mode 100644
index 0000000000..c90dd7fd5c
--- /dev/null
+++ b/sysdeps/arm/be/nofpu/Implies
@@ -0,0 +1 @@
+arm/nofpu
diff --git a/sysdeps/arm/le/nofpu/Implies b/sysdeps/arm/le/nofpu/Implies
new file mode 100644
index 0000000000..c90dd7fd5c
--- /dev/null
+++ b/sysdeps/arm/le/nofpu/Implies
@@ -0,0 +1 @@
+arm/nofpu

commit e85a88e00c1cc6e299414a6cd10ce046df07f85b
Author: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date:   Thu Mar 5 13:38:24 2020 -0300

    sparc: Move sigreturn stub to assembly
    
    It seems that some gcc versions might generates a stack frame for the
    sigreturn stub requires on sparc signal handling.  For instance:
    
      $ cat test.c
      #define _GNU_SOURCE
      #include <sys/syscall.h>
    
      __attribute__ ((__optimize__ ("-fno-stack-protector")))
      void
      __sigreturn_stub (void)
      {
        __asm__ ("mov %0, %%g1\n\t"
                "ta  0x10\n\t"
                : /* no outputs */
                : "i" (SYS_rt_sigreturn));
      }
      $ gcc -v
      [...]
      gcc version 9.2.1 20200224 (Debian 9.2.1-30)
      $ gcc -O2 -m64 test.c -S -o -
      [...]
        __sigreturn_stub:
              save    %sp, -176, %sp
      #APP
      ! 9 "t.c" 1
              mov 101, %g1
              ta  0x10
    
      ! 0 "" 2
      #NO_APP
              .size   __sigreturn_stub, .-__sigreturn_stub
    
    As indicated by kernel developers [1], the sigreturn stub can not change
    the register window or the stack pointer since the kernel has setup the
    restore frame at a precise location relative to the stack pointer when
    the stub is invoked.
    
    I tried to play with some compiler flags and even with _Noreturn and
    __builtin_unreachable after the asm does not help (and Sparc does not
    support naked functions).
    
    To avoid similar issues, as the stack-protector support also have
    stumbled, this patch moves the implementation of the sigreturn stubs to
    assembly.
    
    Checked on sparcv9-linux-gnu and sparc64-linux-gnu with gcc 9.2.1
    and gcc 7.5.0.
    
    [1] https://lkml.org/lkml/2016/5/27/465

diff --git a/sysdeps/unix/sysv/linux/sparc/Makefile b/sysdeps/unix/sysv/linux/sparc/Makefile
index b0d182a439..1475039677 100644
--- a/sysdeps/unix/sysv/linux/sparc/Makefile
+++ b/sysdeps/unix/sysv/linux/sparc/Makefile
@@ -11,8 +11,12 @@ ifeq ($(subdir),sysvipc)
 sysdep_routines += getshmlba
 endif
 
+ifeq ($(subdir),signal)
+sysdep_routines += sigreturn_stub
+endif
+
 ifeq ($(subdir),nptl)
 # pull in __syscall_error routine
-libpthread-routines += sysdep
-libpthread-shared-only-routines += sysdep
+libpthread-routines += sysdep sigreturn_stub
+libpthread-shared-only-routines += sysdep sigreturn_stub
 endif
diff --git a/sysdeps/unix/sysv/linux/sparc/sparc32/sigaction.c b/sysdeps/unix/sysv/linux/sparc/sparc32/sigaction.c
index 6b2f664226..938aa7aa8c 100644
--- a/sysdeps/unix/sysv/linux/sparc/sparc32/sigaction.c
+++ b/sysdeps/unix/sysv/linux/sparc/sparc32/sigaction.c
@@ -24,8 +24,8 @@
 #include <kernel_sigaction.h>
 #include <sysdep.h>
 
-static void __rt_sigreturn_stub (void);
-static void __sigreturn_stub (void);
+void __rt_sigreturn_stub (void);
+void __sigreturn_stub (void);
 
 #define STUB(act, sigsetsize) \
   (act) ? ((unsigned long)((act->sa_flags & SA_SIGINFO)	\
@@ -35,25 +35,3 @@ static void __sigreturn_stub (void);
   (sigsetsize)
 
 #include <sysdeps/unix/sysv/linux/sigaction.c>
-
-static
-inhibit_stack_protector
-void
-__rt_sigreturn_stub (void)
-{
-  __asm__ ("mov %0, %%g1\n\t"
-	   "ta	0x10\n\t"
-	   : /* no outputs */
-	   : "i" (__NR_rt_sigreturn));
-}
-
-static
-inhibit_stack_protector
-void
-__sigreturn_stub (void)
-{
-  __asm__ ("mov %0, %%g1\n\t"
-	   "ta	0x10\n\t"
-	   : /* no outputs */
-	   : "i" (__NR_sigreturn));
-}
diff --git a/sysdeps/unix/sysv/linux/sparc/sparc32/sigreturn_stub.S b/sysdeps/unix/sysv/linux/sparc/sparc32/sigreturn_stub.S
new file mode 100644
index 0000000000..727cc94737
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sparc/sparc32/sigreturn_stub.S
@@ -0,0 +1,34 @@
+/* Sigreturn stub function used on sa_restore field.
+   Copyright (C) 2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+/* These functions must not change the register window or the stack
+   pointer [1].
+
+   [1] https://lkml.org/lkml/2016/5/27/465  */
+
+ENTRY (__rt_sigreturn_stub)
+	mov	__NR_rt_sigreturn, %g1
+	ta	0x10
+END (__rt_sigreturn_stub)
+
+ENTRY (__sigreturn_stub)
+	mov	__NR_sigreturn, %g1
+	ta	0x10
+END (__sigreturn_stub)
diff --git a/sysdeps/unix/sysv/linux/sparc/sparc64/sigaction.c b/sysdeps/unix/sysv/linux/sparc/sparc64/sigaction.c
index 9c0dc2a630..4e26172321 100644
--- a/sysdeps/unix/sysv/linux/sparc/sparc64/sigaction.c
+++ b/sysdeps/unix/sysv/linux/sparc/sparc64/sigaction.c
@@ -22,21 +22,11 @@
 #include <syscall.h>
 #include <sysdep.h>
 
-static void __rt_sigreturn_stub (void);
+/* Defined on sigreturn_stub.S.  */
+void __rt_sigreturn_stub (void);
 
 #define STUB(act, sigsetsize) \
   (((unsigned long) &__rt_sigreturn_stub) - 8),	\
   (sigsetsize)
 
 #include <sysdeps/unix/sysv/linux/sigaction.c>
-
-static
-inhibit_stack_protector
-void
-__rt_sigreturn_stub (void)
-{
-  __asm__ ("mov %0, %%g1\n\t"
-	   "ta	0x6d\n\t"
-	   : /* no outputs */
-	   : "i" (__NR_rt_sigreturn));
-}
diff --git a/sysdeps/unix/sysv/linux/sparc/sparc64/sigreturn_stub.S b/sysdeps/unix/sysv/linux/sparc/sparc64/sigreturn_stub.S
new file mode 100644
index 0000000000..add4766831
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sparc/sparc64/sigreturn_stub.S
@@ -0,0 +1,29 @@
+/* Sigreturn stub function used on sa_restore field.
+   Copyright (C) 2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+/* This function must not change the register window or the stack
+   pointer [1].
+
+   [1] https://lkml.org/lkml/2016/5/27/465  */
+
+ENTRY (__rt_sigreturn_stub)
+	mov	__NR_rt_sigreturn, %g1
+	ta	0x6d
+END (__rt_sigreturn_stub)

commit 03f44ce093844d391b9e53879fb1f45cf4f05f62
Author: Florian Weimer <fweimer@redhat.com>
Date:   Thu Feb 13 17:01:15 2020 +0100

    math/test-sinl-pseudo: Use stack protector only if available
    
    This fixes commit 9333498794cde1d5cca518bad ("Avoid ldbl-96 stack
    corruption from range reduction of pseudo-zero (bug 25487).").
    
    (cherry picked from commit c10acd40262486dac597001aecc20ad9d3bd0e4a)

diff --git a/sysdeps/ieee754/ldbl-96/Makefile b/sysdeps/ieee754/ldbl-96/Makefile
index 318628aed6..6030adf7e7 100644
--- a/sysdeps/ieee754/ldbl-96/Makefile
+++ b/sysdeps/ieee754/ldbl-96/Makefile
@@ -18,5 +18,7 @@
 
 ifeq ($(subdir),math)
 tests += test-canonical-ldbl-96 test-totalorderl-ldbl-96 test-sinl-pseudo
+ifeq ($(have-ssp),yes)
 CFLAGS-test-sinl-pseudo.c += -fstack-protector-all
 endif
+endif # $(subdir) == math

commit 123d48b33a5a0e7827dd21373f7f5db330b3bb7b
Author: Aurelien Jarno <aurelien@aurel32.net>
Date:   Wed Mar 4 22:32:32 2020 +0100

    Add NEWS entry for CVE-2020-10029 (bug 25487)
    
    (cherry picked from commit 15ab195229dc288d1d49612c3de14a33b88065ed)

diff --git a/NEWS b/NEWS
index d0ad1693f2..f614cf5b61 100644
--- a/NEWS
+++ b/NEWS
@@ -13,7 +13,9 @@ The following bugs are resolved with this release:
 
 Security related changes:
 
- CVE-2020-10029
+  CVE-2020-10029: Trigonometric functions on x86 targets suffered from stack
+  corruption when they were passed a pseudo-zero argument.  Reported by Guido
+  Vranken / ForAllSecure Mayhem.
 
 
 Version 2.31

commit 05c08d5aea92a280b124b907ceb042c2d6e5b19e
Author: Aurelien Jarno <aurelien@aurel32.net>
Date:   Wed Mar 11 12:55:36 2020 +0100

    NEWS: update list of bugs fixed on the 2.31 branch

diff --git a/NEWS b/NEWS
index f614cf5b61..472cba8cda 100644
--- a/NEWS
+++ b/NEWS
@@ -8,8 +8,12 @@ using `glibc' in the "product" field.
 Version 2.31.1
 
 The following bugs are resolved with this release:
+  [20543] Please move from .gnu.linkonce to comdat
   [25487] sinl() stack corruption from crafted input (CVE-2020-10029)
   [25523] MIPS/Linux inline syscall template is miscompiled
+  [25623] test-sysvmsg, test-sysvsem, test-sysvshm fail with 2.31 on 32 bit and
+    old kernel
+  [25635] arm: Wrong sysdep order selection for soft-fp
 
 Security related changes:
 

commit a3189fb15b41a5de65d94e91512ea50930d7f6ef
Author: Joseph Myers <joseph@codesourcery.com>
Date:   Fri Feb 7 13:54:58 2020 +0000

    Update syscall lists for Linux 5.5.
    
    Linux 5.5 has no new syscalls to add to syscall-names.list, but it
    does newly enable the clone3 syscall for AArch64.  This patch updates
    the kernel version listed in syscall-names.list and regenerates the
    AArch64 arch-syscall.h.
    
    Tested with build-many-glibcs.py.
    
    (cherry picked from commit 5828bc4523230685ac29a4a882967913255f5666)

diff --git a/sysdeps/unix/sysv/linux/aarch64/arch-syscall.h b/sysdeps/unix/sysv/linux/aarch64/arch-syscall.h
index 9378387747..c8471947b9 100644
--- a/sysdeps/unix/sysv/linux/aarch64/arch-syscall.h
+++ b/sysdeps/unix/sysv/linux/aarch64/arch-syscall.h
@@ -17,6 +17,7 @@
 #define __NR_clock_nanosleep 115
 #define __NR_clock_settime 112
 #define __NR_clone 220
+#define __NR_clone3 435
 #define __NR_close 57
 #define __NR_connect 203
 #define __NR_copy_file_range 285
diff --git a/sysdeps/unix/sysv/linux/syscall-names.list b/sysdeps/unix/sysv/linux/syscall-names.list
index 36e087d8f4..3d89814003 100644
--- a/sysdeps/unix/sysv/linux/syscall-names.list
+++ b/sysdeps/unix/sysv/linux/syscall-names.list
@@ -21,8 +21,8 @@
 # This file can list all potential system calls.  The names are only
 # used if the installed kernel headers also provide them.
 
-# The list of system calls is current as of Linux 5.4.
-kernel 5.4
+# The list of system calls is current as of Linux 5.5.
+kernel 5.5
 
 FAST_atomic_update
 FAST_cmpxchg

commit ab029a2801d4ddfeade8f64a6e46ee7e47fde710
Author: Andreas Schwab <schwab@suse.de>
Date:   Wed Feb 19 17:21:46 2020 +0100

    Fix use-after-free in glob when expanding ~user (bug 25414)
    
    The value of `end_name' points into the value of `dirname', thus don't
    deallocate the latter before the last use of the former.
    
    (cherry picked from commit ddc650e9b3dc916eab417ce9f79e67337b05035c)

diff --git a/posix/glob.c b/posix/glob.c
index cba9cd1819..4580cefb9f 100644
--- a/posix/glob.c
+++ b/posix/glob.c
@@ -827,31 +827,32 @@ __glob (const char *pattern, int flags, int (*errfunc) (const char *, int),
 	      {
 		size_t home_len = strlen (p->pw_dir);
 		size_t rest_len = end_name == NULL ? 0 : strlen (end_name);
-		char *d;
+		char *d, *newp;
+		bool use_alloca = glob_use_alloca (alloca_used,
+						   home_len + rest_len + 1);
 
-		if (__glibc_unlikely (malloc_dirname))
-		  free (dirname);
-		malloc_dirname = 0;
-
-		if (glob_use_alloca (alloca_used, home_len + rest_len + 1))
-		  dirname = alloca_account (home_len + rest_len + 1,
-					    alloca_used);
+		if (use_alloca)
+		  newp = alloca_account (home_len + rest_len + 1, alloca_used);
 		else
 		  {
-		    dirname = malloc (home_len + rest_len + 1);
-		    if (dirname == NULL)
+		    newp = malloc (home_len + rest_len + 1);
+		    if (newp == NULL)
 		      {
 			scratch_buffer_free (&pwtmpbuf);
 			retval = GLOB_NOSPACE;
 			goto out;
 		      }
-		    malloc_dirname = 1;
 		  }
-		d = mempcpy (dirname, p->pw_dir, home_len);
+		d = mempcpy (newp, p->pw_dir, home_len);
 		if (end_name != NULL)
 		  d = mempcpy (d, end_name, rest_len);
 		*d = '\0';
 
+		if (__glibc_unlikely (malloc_dirname))
+		  free (dirname);
+		dirname = newp;
+		malloc_dirname = !use_alloca;
+
 		dirlen = home_len + rest_len;
 		dirname_modified = 1;
 	      }

commit 3937f6806d9de4bbd25ff6e6dc4df8f47ad47573
Author: Aurelien Jarno <aurelien@aurel32.net>
Date:   Thu Mar 19 22:53:00 2020 +0100

    Add NEWS entry for CVE-2020-1752 (bug 25414)
    
    (cherry picked from commit 39a05214fe14ff722d4d92e697fb71ff15e84e70)

diff --git a/NEWS b/NEWS
index 472cba8cda..918e9ebbaf 100644
--- a/NEWS
+++ b/NEWS
@@ -21,6 +21,9 @@ Security related changes:
   corruption when they were passed a pseudo-zero argument.  Reported by Guido
   Vranken / ForAllSecure Mayhem.
 
+  CVE-2020-1752: A use-after-free vulnerability in the glob function when
+  expanding ~user has been fixed.
+
 
 Version 2.31
 

commit 46bbbd4622351528ae22c2d3397ab090f5099e82
Author: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date:   Mon Mar 23 15:23:20 2020 -0300

    posix: Fix system error return value [BZ #25715]
    
    It fixes 5fb7fc9635 when posix_spawn fails.
    
    Checked on x86_64-linux-gnu and i686-linux-gnu.
    
    Reviewed-by: Carlos O'Donell <carlos@redhat.com>
    
    (cheery picked from commit f09542c584b121da0322fde4b55306d512b85d93)

diff --git a/NEWS b/NEWS
index 918e9ebbaf..1595866b51 100644
--- a/NEWS
+++ b/NEWS
@@ -14,6 +14,7 @@ The following bugs are resolved with this release:
   [25623] test-sysvmsg, test-sysvsem, test-sysvshm fail with 2.31 on 32 bit and
     old kernel
   [25635] arm: Wrong sysdep order selection for soft-fp
+  [25715] system() returns wrong errors when posix_spawn fails
 
 Security related changes:
 
diff --git a/stdlib/tst-system.c b/stdlib/tst-system.c
index b6c5aea08f..c8c1811349 100644
--- a/stdlib/tst-system.c
+++ b/stdlib/tst-system.c
@@ -17,14 +17,128 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <signal.h>
+#include <paths.h>
 
+#include <support/capture_subprocess.h>
+#include <support/check.h>
+#include <support/temp_file.h>
+#include <support/support.h>
+
+static char *tmpdir;
+static long int namemax;
+
+static void
+do_prepare (int argc, char *argv[])
+{
+  tmpdir = support_create_temp_directory ("tst-system-");
+  /* Include the last '/0'.  */
+  namemax = pathconf (tmpdir, _PC_NAME_MAX) + 1;
+  TEST_VERIFY_EXIT (namemax != -1);
+}
+#define PREPARE do_prepare
+
+struct args
+{
+  const char *command;
+  int exit_status;
+  int term_sig;
+  const char *path;
+};
+
+static void
+call_system (void *closure)
+{
+  struct args *args = (struct args *) closure;
+  int ret;
+
+  if (args->path != NULL)
+    TEST_COMPARE (setenv ("PATH", args->path, 1), 0);
+  ret = system (args->command);
+  if (args->term_sig == 0)
+    {
+      /* Expect regular termination.  */
+      TEST_VERIFY (WIFEXITED (ret) != 0);
+      TEST_COMPARE (WEXITSTATUS (ret), args->exit_status);
+    }
+  else
+    {
+      /* status_or_signal < 0.  Expect termination by signal.  */
+      TEST_VERIFY (WIFSIGNALED (ret) != 0);
+      TEST_COMPARE (WTERMSIG (ret), args->term_sig);
+    }
+}
 
 static int
 do_test (void)
 {
-  return system (":");
-}
+  TEST_VERIFY (system (NULL) != 0);
 
+  {
+    char cmd[namemax];
+    memset (cmd, 'a', sizeof(cmd));
+    cmd[sizeof(cmd) - 1] = '\0';
+
+    struct support_capture_subprocess result;
+    result = support_capture_subprocess (call_system,
+					 &(struct args) {
+					   cmd, 127, 0, tmpdir
+					 });
+    support_capture_subprocess_check (&result, "system", 0, sc_allow_stderr);
+
+    char *returnerr = xasprintf ("%s: 1: %s: not found\n",
+				 basename(_PATH_BSHELL), cmd);
+    TEST_COMPARE_STRING (result.err.buffer, returnerr);
+    free (returnerr);
+  }
+
+  {
+    char cmd[namemax + 1];
+    memset (cmd, 'a', sizeof(cmd));
+    cmd[sizeof(cmd) - 1] = '\0';
+
+    struct support_capture_subprocess result;
+    result = support_capture_subprocess (call_system,
+					 &(struct args) {
+					   cmd, 127, 0, tmpdir
+					 });
+    support_capture_subprocess_check (&result, "system", 0, sc_allow_stderr);
+
+    char *returnerr = xasprintf ("%s: 1: %s: File name too long\n",
+				 basename(_PATH_BSHELL), cmd);
+    TEST_COMPARE_STRING (result.err.buffer, returnerr);
+    free (returnerr);
+  }
+
+  {
+    struct support_capture_subprocess result;
+    result = support_capture_subprocess (call_system,
+					 &(struct args) {
+					   "kill -USR1 $$", 0, SIGUSR1
+					 });
+    support_capture_subprocess_check (&result, "system", 0, sc_allow_none);
+  }
+
+  {
+    struct support_capture_subprocess result;
+    result = support_capture_subprocess (call_system,
+					 &(struct args) { "echo ...", 0 });
+    support_capture_subprocess_check (&result, "system", 0, sc_allow_stdout);
+    TEST_COMPARE_STRING (result.out.buffer, "...\n");
+  }
+
+  {
+    struct support_capture_subprocess result;
+    result = support_capture_subprocess (call_system,
+					 &(struct args) { "exit 1", 1 });
+    support_capture_subprocess_check (&result, "system", 0, sc_allow_none);
+  }
+
+  TEST_COMPARE (system (":"), 0);
+
+  return 0;
+}
 
-#define TEST_FUNCTION do_test ()
-#include "../test-skeleton.c"
+#include <support/test-driver.c>
diff --git a/sysdeps/posix/system.c b/sysdeps/posix/system.c
index e613e6a344..a03f478fc7 100644
--- a/sysdeps/posix/system.c
+++ b/sysdeps/posix/system.c
@@ -101,7 +101,8 @@ cancel_handler (void *arg)
 static int
 do_system (const char *line)
 {
-  int status;
+  int status = -1;
+  int ret;
   pid_t pid;
   struct sigaction sa;
 #ifndef _LIBC_REENTRANT
@@ -144,14 +145,14 @@ do_system (const char *line)
   __posix_spawnattr_setflags (&spawn_attr,
 			      POSIX_SPAWN_SETSIGDEF | POSIX_SPAWN_SETSIGMASK);
 
-  status = __posix_spawn (&pid, SHELL_PATH, 0, &spawn_attr,
-			  (char *const[]){ (char*) SHELL_NAME,
-					   (char*) "-c",
-					   (char *) line, NULL },
-			  __environ);
+  ret = __posix_spawn (&pid, SHELL_PATH, 0, &spawn_attr,
+		       (char *const[]){ (char *) SHELL_NAME,
+					(char *) "-c",
+					(char *) line, NULL },
+		       __environ);
   __posix_spawnattr_destroy (&spawn_attr);
 
-  if (status == 0)
+  if (ret == 0)
     {
       /* Cancellation results in cleanup handlers running as exceptions in
 	 the block where they were installed, so it is safe to reference
@@ -186,6 +187,9 @@ do_system (const char *line)
     }
   DO_UNLOCK ();
 
+  if (ret != 0)
+    __set_errno (ret);
+
   return status;
 }
 

commit d39fb022c26cf6ad832f6ad0e94ff5b5e4b511cf
Author: Aurelien Jarno <aurelien@aurel32.net>
Date:   Tue Mar 24 22:49:10 2020 +0100

    Add NEWS entry for CVE-2020-1751 (bug 25423)
    
    Reviewed-by: Carlos O'Donell <carlos@redhat.com>
    
    (cherry picked from commit 07d16a6debc830ebcf9533da5396edd2eff688e0)

diff --git a/NEWS b/NEWS
index 1595866b51..15c040a83e 100644
--- a/NEWS
+++ b/NEWS
@@ -22,6 +22,9 @@ Security related changes:
   corruption when they were passed a pseudo-zero argument.  Reported by Guido
   Vranken / ForAllSecure Mayhem.
 
+  CVE-2020-1751: A defect in the PowerPC backtrace function could cause an
+  out-of-bounds write when executed in a signal frame context.
+
   CVE-2020-1752: A use-after-free vulnerability in the glob function when
   expanding ~user has been fixed.
 

commit 5810e6d75fffa62cdf8a37592ed1be7f262eac98
Author: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date:   Tue Mar 24 15:36:23 2020 -0300

    support/shell-container.c: Return 127 if execve fails
    
    Reviewed-by: DJ Delorie <dj@redhat.com>
    
    (cherry picked from commit 5fce0e095bc413f908f472074c2235198cd76bf4)

diff --git a/support/shell-container.c b/support/shell-container.c
index 509e0d69b1..0f4568ed0c 100644
--- a/support/shell-container.c
+++ b/support/shell-container.c
@@ -238,7 +238,7 @@ run_command_array (char **argv)
 
       fprintf (stderr, "sh: execing %s failed: %s",
 	       argv[0], strerror (errno));
-      exit (1);
+      exit (127);
     }
 
   waitpid (pid, &status, 0);

commit 2448ba1d724bec8cd162084fc51aaecea3929727
Author: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date:   Tue Mar 24 15:40:36 2020 -0300

    support/shell-container.c: Add builtin exit
    
    Reviewed-by: DJ Delorie <dj@redhat.com>
    
    (cherry picked from commit 5a5a3a3234bc220a5192d620e0cbc5360da46f14)

diff --git a/support/shell-container.c b/support/shell-container.c
index 0f4568ed0c..6540f8ac47 100644
--- a/support/shell-container.c
+++ b/support/shell-container.c
@@ -135,6 +135,18 @@ copy_func (char **argv)
 
 }
 
+/* Emulate the 'exit' builtin.  The exit value is optional.  */
+static int
+exit_func (char **argv)
+{
+  int exit_val = 0;
+
+  if (argv[0] != 0)
+    exit_val = atoi (argv[0]) & 0xff;
+  exit (exit_val);
+  return 0;
+}
+
 /* This is a list of all the built-in commands we understand.  */
 static struct {
   const char *name;
@@ -143,6 +155,7 @@ static struct {
   { "true", true_func },
   { "echo", echo_func },
   { "cp", copy_func },
+  { "exit", exit_func },
   { NULL, NULL }
 };
 

commit ad9b0037ccc588804ef4c5e58feeab370543cf5a
Author: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date:   Tue Mar 24 15:47:13 2020 -0300

    support/shell-container.c: Add builtin kill
    
    No options supported.
    
    Reviewed-by: DJ Delorie <dj@redhat.com>
    
    (cherry picked from commit 1c17100c43c0913ec94f3bcc966bf3792236c690)

diff --git a/support/shell-container.c b/support/shell-container.c
index 6540f8ac47..201536d24e 100644
--- a/support/shell-container.c
+++ b/support/shell-container.c
@@ -147,6 +147,25 @@ exit_func (char **argv)
   return 0;
 }
 
+/* Emulate the "/bin/kill" command.  Options are ignored.  */
+static int
+kill_func (char **argv)
+{
+  int signum = SIGTERM;
+  int i;
+
+  for (i = 0; argv[i]; i++)
+    {
+      pid_t pid;
+      if (strcmp (argv[i], "$$") == 0)
+	pid = getpid ();
+      else
+	pid = atoi (argv[i]);
+      kill (pid, signum);
+    }
+  return 0;
+}
+
 /* This is a list of all the built-in commands we understand.  */
 static struct {
   const char *name;
@@ -156,6 +175,7 @@ static struct {
   { "echo", echo_func },
   { "cp", copy_func },
   { "exit", exit_func },
+  { "kill", kill_func },
   { NULL, NULL }
 };
 
@@ -264,6 +284,11 @@ run_command_array (char **argv)
       if (rv)
 	exit (rv);
     }
+  else if (WIFSIGNALED (status))
+    {
+      int sig = WTERMSIG (status);
+      raise (sig);
+    }
   else
     exit (1);
 }

commit 83d3eec6728d1df6e7c436540671b9747e85079a
Author: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date:   Tue Mar 24 15:48:34 2020 -0300

    stdlib: Move tst-system to tests-container
    
    Fix some issues with different shell and error messages.
    
    Checked on x86_64-linux-gnu and i686-linux-gnu.
    
    (cherry picked from commit 4eda036f5b897fa8bc20ddd2099b5a6ed4239dc9)

diff --git a/stdlib/Makefile b/stdlib/Makefile
index 45214b59e4..4615f6dfe7 100644
--- a/stdlib/Makefile
+++ b/stdlib/Makefile
@@ -70,7 +70,7 @@ tests		:= tst-strtol tst-strtod testmb testrand testsort testdiv   \
 		   test-canon test-canon2 tst-strtoll tst-environ	    \
 		   tst-xpg-basename tst-random tst-random2 tst-bsearch	    \
 		   tst-limits tst-rand48 bug-strtod tst-setcontext	    \
-		   tst-setcontext2 test-a64l tst-qsort tst-system testmb2   \
+		   tst-setcontext2 test-a64l tst-qsort testmb2              \
 		   bug-strtod2 tst-atof1 tst-atof2 tst-strtod2		    \
 		   tst-rand48-2 tst-makecontext tst-strtod5		    \
 		   tst-qsort2 tst-makecontext2 tst-strtod6 tst-unsetenv1    \
@@ -92,6 +92,7 @@ tests		:= tst-strtol tst-strtod testmb testrand testsort testdiv   \
 tests-internal	:= tst-strtod1i tst-strtod3 tst-strtod4 tst-strtod5i \
 		   tst-tls-atexit tst-tls-atexit-nodelete
 tests-static	:= tst-secure-getenv
+tests-container := tst-system
 
 ifeq ($(build-hardcoded-path-in-tests),yes)
 tests += tst-empty-env
diff --git a/stdlib/tst-system.c b/stdlib/tst-system.c
index c8c1811349..eddea33f4c 100644
--- a/stdlib/tst-system.c
+++ b/stdlib/tst-system.c
@@ -88,7 +88,8 @@ do_test (void)
 					 });
     support_capture_subprocess_check (&result, "system", 0, sc_allow_stderr);
 
-    char *returnerr = xasprintf ("%s: 1: %s: not found\n",
+    char *returnerr = xasprintf ("%s: execing %s failed: "
+				 "No such file or directory",
 				 basename(_PATH_BSHELL), cmd);
     TEST_COMPARE_STRING (result.err.buffer, returnerr);
     free (returnerr);
@@ -106,7 +107,8 @@ do_test (void)
 					 });
     support_capture_subprocess_check (&result, "system", 0, sc_allow_stderr);
 
-    char *returnerr = xasprintf ("%s: 1: %s: File name too long\n",
+    char *returnerr = xasprintf ("%s: execing %s failed: "
+				 "File name too long",
 				 basename(_PATH_BSHELL), cmd);
     TEST_COMPARE_STRING (result.err.buffer, returnerr);
     free (returnerr);
@@ -116,7 +118,7 @@ do_test (void)
     struct support_capture_subprocess result;
     result = support_capture_subprocess (call_system,
 					 &(struct args) {
-					   "kill -USR1 $$", 0, SIGUSR1
+					   "kill $$", 0, SIGTERM
 					 });
     support_capture_subprocess_check (&result, "system", 0, sc_allow_none);
   }
@@ -136,7 +138,7 @@ do_test (void)
     support_capture_subprocess_check (&result, "system", 0, sc_allow_none);
   }
 
-  TEST_COMPARE (system (":"), 0);
+  TEST_COMPARE (system (""), 0);
 
   return 0;
 }

commit 54ba2541b3a76441a9cbe5dd14c963bf874fd5e9
Author: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date:   Mon Feb 17 10:57:56 2020 -0300

    mips: Fix bracktrace result for signal frames
    
    MIPS fallback code handle a frame where its FDE can not be obtained
    (for instance a signal frame) by reading the kernel allocated signal frame
    and adding '2' to the value of 'sc_pc' [1].  The added value is used to
    recognize an end of an EH region on mips16 [2].
    
    The fix adjust the obtained signal frame value and remove the libgcc added
    value by checking if the previous frame is a signal frame one.
    
    Checked with backtrace and tst-sigcontext-get_pc tests on mips-linux-gnu
    and mips64-linux-gnu.
    
    [1] libgcc/config/mips/linux-unwind.h from gcc code.
    [2] gcc/config/mips/mips.h from gcc code.  */
    
    (cherry picked from commit 6e05978f0c30e52420e086cc3156655471e6fb0a)

diff --git a/debug/backtrace.c b/debug/backtrace.c
index cc4b9a5c90..69cf4c23c8 100644
--- a/debug/backtrace.c
+++ b/debug/backtrace.c
@@ -23,6 +23,7 @@
 #include <gnu/lib-names.h>
 #include <stdlib.h>
 #include <unwind.h>
+#include <unwind-arch.h>
 
 struct trace_arg
 {
@@ -78,6 +79,10 @@ backtrace_helper (struct _Unwind_Context *ctx, void *a)
   if (arg->cnt != -1)
     {
       arg->array[arg->cnt] = (void *) unwind_getip (ctx);
+      if (arg->cnt > 0)
+	arg->array[arg->cnt]
+	  = unwind_arch_adjustment (arg->array[arg->cnt - 1],
+				    arg->array[arg->cnt]);
 
       /* Check whether we make any progress.  */
       _Unwind_Word cfa = unwind_getcfa (ctx);
diff --git a/sysdeps/generic/unwind-arch.h b/sysdeps/generic/unwind-arch.h
new file mode 100644
index 0000000000..d712e5e11d
--- /dev/null
+++ b/sysdeps/generic/unwind-arch.h
@@ -0,0 +1,30 @@
+/* Return backtrace of current program state.  Arch-specific bits.
+   Copyright (C) 2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _UNWIND_ARCH_H
+#define _UNWIND_ARCH_H
+
+#include <unwind.h>
+
+static inline void *
+unwind_arch_adjustment (void *prev, void *addr)
+{
+  return addr;
+}
+
+#endif
diff --git a/sysdeps/unix/sysv/linux/mips/unwind-arch.h b/sysdeps/unix/sysv/linux/mips/unwind-arch.h
new file mode 100644
index 0000000000..a009899983
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/mips/unwind-arch.h
@@ -0,0 +1,67 @@
+/* Return backtrace of current program state.  Arch-specific bits.
+   Copyright (C) 2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _UNWIND_ARCH_H
+#define _UNWIND_ARCH_H
+
+#include <stdint.h>
+
+/* MIPS fallback code handle a frame where its FDE can not be obtained
+   (for instance a signal frame) by reading the kernel allocated signal frame
+   and adding '2' to the value of 'sc_pc' [1].  The added value is used to
+   recognize an end of an EH region on mips16 [2].
+
+   The idea here is to adjust the obtained signal frame ADDR value and remove
+   the libgcc added value by checking if the previous frame is a signal frame
+   one.
+
+   [1] libgcc/config/mips/linux-unwind.h from gcc code.
+   [2] gcc/config/mips/mips.h from gcc code.  */
+
+static inline void *
+unwind_arch_adjustment (void *prev, void *addr)
+{
+  uint32_t *pc = (uint32_t *) prev;
+
+  if (pc == NULL)
+    return addr;
+
+  /* For MIPS16 or microMIPS frame libgcc makes no adjustment.  */
+  if ((uintptr_t) pc & 0x3)
+    return addr;
+
+  /* The vDSO containes either
+
+     24021061 li v0, 0x1061 (rt_sigreturn)
+     0000000c syscall
+	or
+     24021017 li v0, 0x1017 (sigreturn)
+     0000000c syscall  */
+  if (pc[1] != 0x0000000c)
+    return addr;
+#if _MIPS_SIM == _ABIO32
+  if (pc[0] == (0x24020000 | __NR_sigreturn))
+    return (void *) ((uintptr_t) addr - 2);
+#endif
+  if (pc[0] == (0x24020000 | __NR_rt_sigreturn))
+    return (void *) ((uintptr_t) addr - 2);
+
+  return addr;
+}
+
+#endif
