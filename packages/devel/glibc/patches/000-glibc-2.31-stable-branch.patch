commit be9a328c93834648e0bec106a1f86357d1a8c7e1
Author: Florian Weimer <fweimer@redhat.com>
Date:   Thu Aug 1 16:48:12 2019 +0200

    malloc: Remove unwanted leading whitespace in malloc_info [BZ #24867]
    
    It was introduced in commit 6c8dbf00f536d78b1937b5af6f57be47fd376344
    ("Reformat malloc to gnu style.").
    
    Reviewed-by: Carlos O'Donell <carlos@redhat.com>
    (cherry picked from commit b0f6679bcd738ea244a14acd879d974901e56c8e)

diff --git a/ChangeLog b/ChangeLog
index cdb9e14881..a2bf94f6e9 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,9 @@
+2019-08-01  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #24867]
+	* malloc/malloc.c (__malloc_info): Remove unwanted leading
+	whitespace.
+
 2019-08-01  Carlos O'Donell <carlos@redhat.com>
 
 	* version.h (RELEASE): Set to "stable".
diff --git a/NEWS b/NEWS
index ee9ed4de5a..2a57721d72 100644
--- a/NEWS
+++ b/NEWS
@@ -4,6 +4,13 @@ See the end for copying conditions.
 
 Please send GNU C library bug reports via <https://sourceware.org/bugzilla/>
 using `glibc' in the "product" field.
+
+Version 2.30.1
+
+The following bugs are resolved with this release:
+
+  [24867] malloc: Remove unwanted leading whitespace in malloc_info
+
 
 Version 2.30
 
diff --git a/malloc/malloc.c b/malloc/malloc.c
index 00ce48cf58..343d89f489 100644
--- a/malloc/malloc.c
+++ b/malloc/malloc.c
@@ -5491,7 +5491,7 @@ __malloc_info (int options, FILE *fp)
 
       for (size_t i = 0; i < nsizes; ++i)
 	if (sizes[i].count != 0 && i != NFASTBINS)
-	  fprintf (fp, "							      \
+	  fprintf (fp, "\
   <size from=\"%zu\" to=\"%zu\" total=\"%zu\" count=\"%zu\"/>\n",
 		   sizes[i].from, sizes[i].to, sizes[i].total, sizes[i].count);
 

commit d74461fa348de4176894f98672cb9ce721e26676
Author: Rafal Luzynski <digitalfreak@lingonborough.com>
Date:   Thu Aug 22 23:50:04 2019 +0200

    Chinese locales: Set first_weekday to 2 (bug 24682).
    
    The first day of the week in China (Mainland) should be Monday according
    to the national standard GB/T 7408-2005.  References:
    
    * https://www.doc88.com/p-1166696540287.html
    * https://unicode-org.atlassian.net/browse/CLDR-11510
    
            [BZ #24682]
            * NEWS: Mention this bug fixed.
            * localedata/locales/bo_CN (first_weekday): Add, set to 2 (Monday).
            * localedata/locales/ug_CN (first_weekday): Likewise.
            * localedata/locales/zh_CN (first_weekday): Likewise.
    
    (cherry picked from commit c0fd3244e71db39cef1e2d1d8ba12bb8b7375ce4)

diff --git a/ChangeLog b/ChangeLog
index a2bf94f6e9..e3da8f9a76 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,11 @@
+2019-08-28  Rafal Luzynski  <digitalfreak@lingonborough.com>
+
+	[BZ #24682]
+	* NEWS: Mention this bug fixed.
+	* localedata/locales/bo_CN (first_weekday): Add, set to 2 (Monday).
+	* localedata/locales/ug_CN (first_weekday): Likewise.
+	* localedata/locales/zh_CN (first_weekday): Likewise.
+
 2019-08-01  Florian Weimer  <fweimer@redhat.com>
 
 	[BZ #24867]
diff --git a/NEWS b/NEWS
index 2a57721d72..09f2ce9752 100644
--- a/NEWS
+++ b/NEWS
@@ -9,6 +9,8 @@ Version 2.30.1
 
 The following bugs are resolved with this release:
 
+  [24682] localedata: zh_CN first weekday should be Monday per GB/T
+    7408-2005
   [24867] malloc: Remove unwanted leading whitespace in malloc_info
 
 
diff --git a/localedata/locales/bo_CN b/localedata/locales/bo_CN
index 90cbc7807b..9df91a1721 100644
--- a/localedata/locales/bo_CN
+++ b/localedata/locales/bo_CN
@@ -128,6 +128,7 @@ t_fmt_ampm        "<U0F46><U0F74><U0F0B><U0F5A><U0F7C><U0F51>/
 <U0025><U0070>"
 
 week 7;19971130;1
+first_weekday 2
 END LC_TIME
 
 LC_MESSAGES
diff --git a/localedata/locales/ug_CN b/localedata/locales/ug_CN
index 1ba583c588..83d15c90e4 100644
--- a/localedata/locales/ug_CN
+++ b/localedata/locales/ug_CN
@@ -165,6 +165,7 @@ am_pm    "";""
 date_fmt "%a<U060C> %d-%m-%Y<U060C> %T"
 
 week 7;19971130;1
+first_weekday 2
 END LC_TIME
 
 LC_MESSAGES
diff --git a/localedata/locales/zh_CN b/localedata/locales/zh_CN
index 62a46415c1..cd4b33602a 100644
--- a/localedata/locales/zh_CN
+++ b/localedata/locales/zh_CN
@@ -139,6 +139,7 @@ t_fmt_ampm "%p %I<U65F6>%M<U5206>%S<U79D2>"
 
 date_fmt       "%Y<U5E74> %m<U6708> %d<U65E5> %A %H:%M:%S %Z"
 week 7;19971130;1
+first_weekday 2
 END LC_TIME
 
 LC_MESSAGES

commit 5438639cffe9323a5b766aff505f8f0462e10bd2
Author: Aurelien Jarno <aurelien@aurel32.net>
Date:   Tue Sep 3 21:35:51 2019 +0200

    Update Alpha libm-test-ulps
    
    Changelog:
    
            * sysdeps/alpha/fpu/libm-test-ulps: Regenerated using GCC 9.2.
    
    (cherry picked from commit b5367a08ae810e3c648fb036f2e5766204f9d83f)

diff --git a/ChangeLog b/ChangeLog
index e3da8f9a76..3ae73ace06 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,7 @@
+2019-09-03  Aurelien Jarno  <aurelien@aurel32.net>
+
+	* sysdeps/alpha/fpu/libm-test-ulps: Regenerated using GCC 9.2.
+
 2019-08-28  Rafal Luzynski  <digitalfreak@lingonborough.com>
 
 	[BZ #24682]
diff --git a/sysdeps/alpha/fpu/libm-test-ulps b/sysdeps/alpha/fpu/libm-test-ulps
index 0f77dd2ed0..89c4527a81 100644
--- a/sysdeps/alpha/fpu/libm-test-ulps
+++ b/sysdeps/alpha/fpu/libm-test-ulps
@@ -1084,10 +1084,10 @@ ildouble: 1
 ldouble: 1
 
 Function: Real part of "cpow_downward":
-double: 2
-float: 4
-idouble: 2
-ifloat: 4
+double: 5
+float: 8
+idouble: 5
+ifloat: 8
 ildouble: 6
 ldouble: 6
 
@@ -1100,10 +1100,10 @@ ildouble: 2
 ldouble: 2
 
 Function: Real part of "cpow_towardzero":
-double: 2
-float: 4
-idouble: 2
-ifloat: 4
+double: 5
+float: 8
+idouble: 5
+ifloat: 8
 ildouble: 6
 ldouble: 6
 

commit 3c3f8dc307a08f586718ded347bfc11a27becc1e
Author: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date:   Thu Aug 1 09:19:34 2019 -0300

    hppa: Update libm-tests-ulps
    
    The make regen-ulps was done on a PA8900 with 8.3.0.
    
            * sysdeps/hppa/fpu/libm-test-ulps: Update.
    
    (cherry picked from commit 3175dcc1e67425ad471caddc3d3cfae357de26ff)

diff --git a/ChangeLog b/ChangeLog
index 3ae73ace06..8e29a549b9 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,7 @@
+2019-09-08  Adhemerval Zanella  <adhemerval.zanella@linaro.org>
+
+	* sysdeps/hppa/fpu/libm-test-ulps: Update.
+
 2019-09-03  Aurelien Jarno  <aurelien@aurel32.net>
 
 	* sysdeps/alpha/fpu/libm-test-ulps: Regenerated using GCC 9.2.
diff --git a/sysdeps/hppa/fpu/libm-test-ulps b/sysdeps/hppa/fpu/libm-test-ulps
index d0c4dea001..2c61a7ae91 100644
--- a/sysdeps/hppa/fpu/libm-test-ulps
+++ b/sysdeps/hppa/fpu/libm-test-ulps
@@ -544,9 +544,9 @@ idouble: 1
 ifloat: 1
 
 Function: Imaginary part of "ccos_downward":
-double: 2
+double: 3
 float: 3
-idouble: 2
+idouble: 3
 ifloat: 3
 
 Function: Real part of "ccos_towardzero":
@@ -556,9 +556,9 @@ idouble: 1
 ifloat: 2
 
 Function: Imaginary part of "ccos_towardzero":
-double: 2
+double: 3
 float: 3
-idouble: 2
+idouble: 3
 ifloat: 3
 
 Function: Real part of "ccos_upward":
@@ -588,27 +588,27 @@ idouble: 1
 ifloat: 1
 
 Function: Real part of "ccosh_downward":
-double: 1
+double: 2
 float: 3
-idouble: 1
+idouble: 2
 ifloat: 3
 
 Function: Imaginary part of "ccosh_downward":
-double: 2
+double: 3
 float: 3
-idouble: 2
+idouble: 3
 ifloat: 3
 
 Function: Real part of "ccosh_towardzero":
-double: 1
+double: 2
 float: 3
-idouble: 1
+idouble: 2
 ifloat: 3
 
 Function: Imaginary part of "ccosh_towardzero":
-double: 2
+double: 3
 float: 3
-idouble: 2
+idouble: 3
 ifloat: 3
 
 Function: Real part of "ccosh_upward":
@@ -636,27 +636,27 @@ idouble: 1
 ifloat: 2
 
 Function: Real part of "cexp_downward":
-double: 1
+double: 2
 float: 2
-idouble: 1
+idouble: 2
 ifloat: 2
 
 Function: Imaginary part of "cexp_downward":
-double: 1
+double: 3
 float: 3
-idouble: 1
+idouble: 3
 ifloat: 3
 
 Function: Real part of "cexp_towardzero":
-double: 1
+double: 2
 float: 2
-idouble: 1
+idouble: 2
 ifloat: 2
 
 Function: Imaginary part of "cexp_towardzero":
-double: 1
+double: 3
 float: 3
-idouble: 1
+idouble: 3
 ifloat: 3
 
 Function: Real part of "cexp_upward":
@@ -666,9 +666,9 @@ idouble: 1
 ifloat: 2
 
 Function: Imaginary part of "cexp_upward":
-double: 1
+double: 3
 float: 2
-idouble: 1
+idouble: 3
 ifloat: 2
 
 Function: Real part of "clog":
@@ -800,21 +800,21 @@ idouble: 1
 ifloat: 1
 
 Function: "cosh_downward":
-double: 1
+double: 2
 float: 1
-idouble: 1
+idouble: 2
 ifloat: 1
 
 Function: "cosh_towardzero":
-double: 1
+double: 2
 float: 1
-idouble: 1
+idouble: 2
 ifloat: 1
 
 Function: "cosh_upward":
-double: 1
+double: 2
 float: 2
-idouble: 1
+idouble: 2
 ifloat: 2
 
 Function: Real part of "cpow":
@@ -834,9 +834,9 @@ ildouble: 2
 ldouble: 2
 
 Function: Real part of "cpow_downward":
-double: 4
+double: 5
 float: 8
-idouble: 4
+idouble: 5
 ifloat: 8
 
 Function: Imaginary part of "cpow_downward":
@@ -846,9 +846,9 @@ idouble: 2
 ifloat: 2
 
 Function: Real part of "cpow_towardzero":
-double: 4
+double: 5
 float: 8
-idouble: 4
+idouble: 5
 ifloat: 8
 
 Function: Imaginary part of "cpow_towardzero":
@@ -876,9 +876,9 @@ idouble: 1
 ifloat: 1
 
 Function: Real part of "csin_downward":
-double: 2
+double: 3
 float: 3
-idouble: 2
+idouble: 3
 ifloat: 3
 
 Function: Imaginary part of "csin_downward":
@@ -888,9 +888,9 @@ idouble: 1
 ifloat: 2
 
 Function: Real part of "csin_towardzero":
-double: 2
+double: 3
 float: 3
-idouble: 2
+idouble: 3
 ifloat: 3
 
 Function: Imaginary part of "csin_towardzero":
@@ -930,9 +930,9 @@ idouble: 2
 ifloat: 2
 
 Function: Imaginary part of "csinh_downward":
-double: 2
+double: 3
 float: 3
-idouble: 2
+idouble: 3
 ifloat: 3
 
 Function: Real part of "csinh_towardzero":
@@ -942,9 +942,9 @@ idouble: 2
 ifloat: 2
 
 Function: Imaginary part of "csinh_towardzero":
-double: 2
+double: 3
 float: 3
-idouble: 2
+idouble: 3
 ifloat: 3
 
 Function: Real part of "csinh_upward":
@@ -1172,15 +1172,15 @@ ildouble: 6
 ldouble: 6
 
 Function: "exp10_downward":
-double: 2
+double: 3
 float: 1
-idouble: 2
+idouble: 3
 ifloat: 1
 
 Function: "exp10_towardzero":
-double: 2
+double: 3
 float: 1
-idouble: 2
+idouble: 3
 ifloat: 1
 
 Function: "exp10_upward":

commit b1299aab223503e3ba2b447c3ec4f6f0197aa824
Author: Aurelien Jarno <aurelien@aurel32.net>
Date:   Sat Sep 14 18:22:52 2019 +0200

    alpha: force old OSF1 syscalls for getegid, geteuid and getppid [BZ #24986]
    
    On alpha, Linux kernel 5.1 added the standard getegid, geteuid and
    getppid syscalls (commit ecf7e0a4ad15287). Up to now alpha was using
    the corresponding OSF1 syscalls through:
     - sysdeps/unix/alpha/getegid.S
     - sysdeps/unix/alpha/geteuid.S
     - sysdeps/unix/alpha/getppid.S
    
    When building against kernel headers >= 5.1, the glibc now use the new
    syscalls through sysdeps/unix/sysv/linux/syscalls.list. When it is then
    used with an older kernel, the corresponding 3 functions fail.
    
    A quick fix is to move the OSF1 wrappers under the
    sysdeps/unix/sysv/linux/alpha directory so they override the standard
    linux ones. A better fix would be to try the new syscalls and fallback
    to the old OSF1 in case the new ones fail. This can be implemented in
    a later commit.
    
    Changelog:
            [BZ #24986]
            * sysdeps/unix/alpha/getegid.S: Move to ...
            * sysdeps/unix/sysv/linux/alpha/getegid.S: ... here.
            * sysdeps/unix/alpha/geteuid.S: Move to ...
            * sysdeps/unix/sysv/linux/alpha/geteuid.S: ... here.
            * sysdeps/unix/alpha/getppid.S: Move to ...
            * sysdeps/unix/sysv/linux/alpha/getppid.S: ... here
    (cherry picked from commit 1a6566094d3097f4a3037ab5555cddc6cb11c3a3)

diff --git a/ChangeLog b/ChangeLog
index 8e29a549b9..3ea022b738 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,13 @@
+2019-09-14  Aurelien Jarno  <aurelien@aurel32.net>
+
+	[BZ #24986]
+        * sysdeps/unix/alpha/getegid.S: Move to ...
+	* sysdeps/unix/sysv/linux/alpha/getegid.S: ... here.
+        * sysdeps/unix/alpha/geteuid.S: Move to ...
+	* sysdeps/unix/sysv/linux/alpha/geteuid.S: ... here.
+        * sysdeps/unix/alpha/getppid.S: Move to ...
+	* sysdeps/unix/sysv/linux/alpha/getppid.S: ... here
+
 2019-09-08  Adhemerval Zanella  <adhemerval.zanella@linaro.org>
 
 	* sysdeps/hppa/fpu/libm-test-ulps: Update.
diff --git a/NEWS b/NEWS
index 09f2ce9752..5f1ade1c49 100644
--- a/NEWS
+++ b/NEWS
@@ -12,6 +12,8 @@ The following bugs are resolved with this release:
   [24682] localedata: zh_CN first weekday should be Monday per GB/T
     7408-2005
   [24867] malloc: Remove unwanted leading whitespace in malloc_info
+  [24986] alpha: new getegid, geteuid and getppid syscalls used
+    unconditionally
 
 
 Version 2.30
diff --git a/sysdeps/unix/alpha/getegid.S b/sysdeps/unix/sysv/linux/alpha/getegid.S
similarity index 100%
rename from sysdeps/unix/alpha/getegid.S
rename to sysdeps/unix/sysv/linux/alpha/getegid.S
diff --git a/sysdeps/unix/alpha/geteuid.S b/sysdeps/unix/sysv/linux/alpha/geteuid.S
similarity index 100%
rename from sysdeps/unix/alpha/geteuid.S
rename to sysdeps/unix/sysv/linux/alpha/geteuid.S
diff --git a/sysdeps/unix/alpha/getppid.S b/sysdeps/unix/sysv/linux/alpha/getppid.S
similarity index 100%
rename from sysdeps/unix/alpha/getppid.S
rename to sysdeps/unix/sysv/linux/alpha/getppid.S

commit a6aaabd036d735a1b412f441bf6c706832655598
Author: Joseph Myers <joseph@codesourcery.com>
Date:   Wed Sep 18 13:22:24 2019 +0000

    Fix RISC-V vfork build with Linux 5.3 kernel headers.
    
    Building glibc for RISC-V with Linux 5.3 kernel headers fails because
    <linux/sched.h>, included in vfork.S for CLONE_* constants, contains a
    structure definition not safe for inclusion in assembly code.
    
    All other architectures already avoid use of that header in vfork.S,
    either defining the CLONE_* constants locally or embedding the
    required values directly in the relevant instruction, where they
    implement vfork using the clone syscall (see the implementations for
    aarch64, ia64, mips and nios2).  This patch makes the RISC-V version
    define the constants locally like the other architectures.
    
    Tested build for all three RISC-V configurations in
    build-many-glibcs.py with Linux 5.3 headers.
    
            * sysdeps/unix/sysv/linux/riscv/vfork.S: Do not include
            <linux/sched.h>.
            (CLONE_VM): New macro.
            (CLONE_VFORK): Likewise.
    
    (cherry picked from commit 8cacbcf4a984ccac24efedb795d9c8a7f149d17b)

diff --git a/ChangeLog b/ChangeLog
index 3ea022b738..29c864868a 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,10 @@
+2019-09-20  Joseph Myers  <joseph@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/riscv/vfork.S: Do not include
+	<linux/sched.h>.
+	(CLONE_VM): New macro.
+	(CLONE_VFORK): Likewise.
+
 2019-09-14  Aurelien Jarno  <aurelien@aurel32.net>
 
 	[BZ #24986]
diff --git a/sysdeps/unix/sysv/linux/riscv/vfork.S b/sysdeps/unix/sysv/linux/riscv/vfork.S
index 67373f181b..dc173d6b47 100644
--- a/sysdeps/unix/sysv/linux/riscv/vfork.S
+++ b/sysdeps/unix/sysv/linux/riscv/vfork.S
@@ -21,9 +21,12 @@
 #include <sys/asm.h>
 #include <sysdep.h>
 #define __ASSEMBLY__
-#include <linux/sched.h>
 #include <asm/signal.h>
 
+#define CLONE_VM      0x00000100 /* Set if VM shared between processes.  */
+#define CLONE_VFORK   0x00004000 /* Set if the parent wants the child to
+				    wake it up on mm_release.  */
+
 	.text
 LEAF (__libc_vfork)
 

commit 5397c399f9604f4e0d0b17f5600e7bc756577549
Author: Stefan Liebler <stli@linux.ibm.com>
Date:   Fri Oct 18 14:57:14 2019 +0200

    S390: Add new s390 platform z15.
    
    The new IBM z15 is added to platform string array.
    The macro _DL_PLATFORMS_COUNT is incremented.
    
    (cherry picked from commit 2901743568452403849be7295c8732faa7732339)

diff --git a/sysdeps/s390/dl-procinfo.c b/sysdeps/s390/dl-procinfo.c
index 44c9901800..1307ec41de 100644
--- a/sysdeps/s390/dl-procinfo.c
+++ b/sysdeps/s390/dl-procinfo.c
@@ -63,11 +63,11 @@ PROCINFO_CLASS const char _dl_s390_cap_flags[19][9]
 #if !defined PROCINFO_DECL && defined SHARED
   ._dl_s390_platforms
 #else
-PROCINFO_CLASS const char _dl_s390_platforms[9][7]
+PROCINFO_CLASS const char _dl_s390_platforms[10][7]
 #endif
 #ifndef PROCINFO_DECL
 = {
-    "g5", "z900", "z990", "z9-109", "z10", "z196", "zEC12", "z13", "z14"
+    "g5", "z900", "z990", "z9-109", "z10", "z196", "zEC12", "z13", "z14", "z15"
   }
 #endif
 #if !defined SHARED || defined PROCINFO_DECL
diff --git a/sysdeps/s390/dl-procinfo.h b/sysdeps/s390/dl-procinfo.h
index 3b1f6a642b..689e961ced 100644
--- a/sysdeps/s390/dl-procinfo.h
+++ b/sysdeps/s390/dl-procinfo.h
@@ -23,7 +23,7 @@
 
 #define _DL_HWCAP_COUNT 19
 
-#define _DL_PLATFORMS_COUNT	9
+#define _DL_PLATFORMS_COUNT	10
 
 /* The kernel provides up to 32 capability bits with elf_hwcap.  */
 #define _DL_FIRST_PLATFORM	32

commit fca2d6186af873cb8355e216c07f4b4874ec5d3a
Author: Gabriel F. T. Gomes <gabrielftg@linux.ibm.com>
Date:   Tue Oct 8 14:32:17 2019 -0300

    Make tst-strftime2 and tst-strftime3 depend on locale generation
    
    Building the test cases in parallel might make tst-strftime2 and
    tst-strftime3 fail.  Simply re-running the test case (or building
    serially) makes the problem go away.  This patch adds the necessary
    dependency to allow parallel builds in the time subdirectory.
    
    Tested for powerpc64le.
    
    Reviewed-by: Florian Weimer <fweimer@redhat.com>
    Reviewed-by: Tulio Magno Quites Machado Filho <tuliom@linux.ibm.com>
    (cherry picked from commit 52151051b39293dac9fc3181cfd6240d7ce86ca1)

diff --git a/ChangeLog b/ChangeLog
index 29c864868a..4472d6c59d 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,9 @@
+2019-10-08  Gabriel F. T. Gomes  <gabrielftg@linux.ibm.com>
+
+	* Makefile: Fix locale dependency for a couple of tests.
+	($(objpfx)tst-strftime2.out): New rule.
+	($(objpfx)tst-strftime3.out): Likewise.
+
 2019-09-20  Joseph Myers  <joseph@codesourcery.com>
 
 	* sysdeps/unix/sysv/linux/riscv/vfork.S: Do not include
diff --git a/time/Makefile b/time/Makefile
index a428f55245..63b8d735ea 100644
--- a/time/Makefile
+++ b/time/Makefile
@@ -57,6 +57,8 @@ include ../gen-locales.mk
 
 $(objpfx)tst-ftime_l.out: $(gen-locales)
 $(objpfx)tst-strptime.out: $(gen-locales)
+$(objpfx)tst-strftime2.out: $(gen-locales)
+$(objpfx)tst-strftime3.out: $(gen-locales)
 endif
 
 tz-cflags = -DTZDIR='"$(zonedir)"' \

commit c347431fb5fd3f124c05e82fb7a661b396e86f82
Author: Dragan Mladjenovic <dmladjenovic@wavecomp.com>
Date:   Fri Aug 23 16:38:04 2019 +0000

    mips: Force RWX stack for hard-float builds that can run on pre-4.8 kernels
    
    Linux/Mips kernels prior to 4.8 could potentially crash the user
    process when doing FPU emulation while running on non-executable
    user stack.
    
    Currently, gcc doesn't emit .note.GNU-stack for mips, but that will
    change in the future. To ensure that glibc can be used with such
    future gcc, without silently resulting in binaries that might crash
    in runtime, this patch forces RWX stack for all built objects if
    configured to run against minimum kernel version less than 4.8.
    
            * sysdeps/unix/sysv/linux/mips/Makefile
            (test-xfail-check-execstack):
            Move under mips-has-gnustack != yes.
            (CFLAGS-.o*, ASFLAGS-.o*): New rules.
            Apply -Wa,-execstack if mips-force-execstack == yes.
            * sysdeps/unix/sysv/linux/mips/configure: Regenerated.
            * sysdeps/unix/sysv/linux/mips/configure.ac
            (mips-force-execstack): New var.
            Set to yes for hard-float builds with minimum_kernel < 4.8.0
            or minimum_kernel not set at all.
            (mips-has-gnustack): New var.
            Use value of libc_cv_as_noexecstack
            if mips-force-execstack != yes, otherwise set to no.
    
    (cherry picked from commit 33bc9efd91de1b14354291fc8ebd5bce96379f12)

diff --git a/ChangeLog b/ChangeLog
index 4472d6c59d..43c9a70ed1 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,19 @@
+2019-11-01  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	* sysdeps/unix/sysv/linux/mips/Makefile
+	(test-xfail-check-execstack):
+	Move under mips-has-gnustack != yes.
+	(CFLAGS-.o*, ASFLAGS-.o*): New rules.
+	Apply -Wa,-execstack if mips-force-execstack == yes.
+	* sysdeps/unix/sysv/linux/mips/configure: Regenerated.
+	* sysdeps/unix/sysv/linux/mips/configure.ac
+	(mips-force-execstack): New var.
+	Set to yes for hard-float builds with minimum_kernel < 4.8.0
+	or minimum_kernel not set at all.
+	(mips-has-gnustack): New var.
+	Use value of libc_cv_as_noexecstack
+	if mips-force-execstack != yes, otherwise set to no.
+
 2019-10-08  Gabriel F. T. Gomes  <gabrielftg@linux.ibm.com>
 
 	* Makefile: Fix locale dependency for a couple of tests.
diff --git a/sysdeps/unix/sysv/linux/mips/Makefile b/sysdeps/unix/sysv/linux/mips/Makefile
index 8217f42e75..03044e7365 100644
--- a/sysdeps/unix/sysv/linux/mips/Makefile
+++ b/sysdeps/unix/sysv/linux/mips/Makefile
@@ -63,14 +63,25 @@ sysdep-dl-routines += dl-static
 
 sysdep_routines += dl-vdso
 endif
-
-# Supporting non-executable stacks on MIPS requires changes to both
-# the Linux kernel and glibc.  See
-# <https://sourceware.org/ml/libc-alpha/2016-01/msg00567.html> and
-# <https://sourceware.org/ml/libc-alpha/2016-01/msg00719.html>.
+# If the compiler doesn't use GNU.stack note,
+# this test is expected to fail.
+ifneq ($(mips-has-gnustack),yes)
 test-xfail-check-execstack = yes
 endif
+endif
 
 ifeq ($(subdir),stdlib)
 gen-as-const-headers += ucontext_i.sym
 endif
+
+ifeq ($(mips-force-execstack),yes)
+CFLAGS-.o += -Wa,-execstack
+CFLAGS-.os += -Wa,-execstack
+CFLAGS-.op += -Wa,-execstack
+CFLAGS-.oS += -Wa,-execstack
+
+ASFLAGS-.o += -Wa,-execstack
+ASFLAGS-.os += -Wa,-execstack
+ASFLAGS-.op += -Wa,-execstack
+ASFLAGS-.oS += -Wa,-execstack
+endif
diff --git a/sysdeps/unix/sysv/linux/mips/configure b/sysdeps/unix/sysv/linux/mips/configure
index 1ee7f41a36..25f98e0c7b 100644
--- a/sysdeps/unix/sysv/linux/mips/configure
+++ b/sysdeps/unix/sysv/linux/mips/configure
@@ -475,3 +475,44 @@ if test -z "$arch_minimum_kernel"; then
     arch_minimum_kernel=4.5.0
   fi
 fi
+
+# Check if we are supposed to run on kernels older than 4.8.0. If so,
+# force executable stack to avoid potential runtime problems with fpu
+# emulation.
+# NOTE: The check below assumes that in absence of user-provided minumum_kernel
+# we will default to arch_minimum_kernel which is currently less than 4.8.0 for
+# all known configurations. If this changes, the check must be updated.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler must use executable stack" >&5
+$as_echo_n "checking whether the compiler must use executable stack... " >&6; }
+if ${libc_cv_mips_force_execstack+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  libc_cv_mips_force_execstack=no
+  if test $libc_mips_float = hard; then
+    if test -n "$minimum_kernel"; then
+
+       min_version=$((`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 65536 + \2 \* 256 + \3/'`))
+
+       if test $min_version -lt 264192; then
+         libc_cv_mips_force_execstack=yes
+       fi
+    else
+      libc_cv_mips_force_execstack=yes
+    fi
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $libc_cv_mips_force_execstack" >&5
+$as_echo "$libc_cv_mips_force_execstack" >&6; }
+
+libc_mips_has_gnustack=$libc_cv_as_noexecstack
+
+if test $libc_cv_mips_force_execstack = yes; then
+  libc_mips_has_gnustack=no
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: forcing executable stack for pre-4.8.0 Linux kernels" >&5
+$as_echo "$as_me: WARNING: forcing executable stack for pre-4.8.0 Linux kernels" >&2;}
+fi
+
+config_vars="$config_vars
+mips-force-execstack = ${libc_cv_mips_force_execstack}"
+config_vars="$config_vars
+mips-has-gnustack = ${libc_mips_has_gnustack}"
diff --git a/sysdeps/unix/sysv/linux/mips/configure.ac b/sysdeps/unix/sysv/linux/mips/configure.ac
index 9147aa4582..3db1b32b08 100644
--- a/sysdeps/unix/sysv/linux/mips/configure.ac
+++ b/sysdeps/unix/sysv/linux/mips/configure.ac
@@ -134,3 +134,35 @@ if test -z "$arch_minimum_kernel"; then
     arch_minimum_kernel=4.5.0
   fi
 fi
+
+# Check if we are supposed to run on kernels older than 4.8.0. If so,
+# force executable stack to avoid potential runtime problems with fpu
+# emulation.
+# NOTE: The check below assumes that in absence of user-provided minumum_kernel
+# we will default to arch_minimum_kernel which is currently less than 4.8.0 for
+# all known configurations. If this changes, the check must be updated.
+AC_CACHE_CHECK([whether the compiler must use executable stack],
+        libc_cv_mips_force_execstack, [dnl
+libc_cv_mips_force_execstack=no
+  if test $libc_mips_float = hard; then
+    if test -n "$minimum_kernel"; then
+       changequote(,)
+       min_version=$((`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 65536 + \2 \* 256 + \3/'`))
+       changequote([,])
+       if test $min_version -lt 264192; then
+         libc_cv_mips_force_execstack=yes
+       fi
+    else
+      libc_cv_mips_force_execstack=yes
+    fi
+  fi])
+
+libc_mips_has_gnustack=$libc_cv_as_noexecstack
+
+if test $libc_cv_mips_force_execstack = yes; then
+  libc_mips_has_gnustack=no
+  AC_MSG_WARN([forcing executable stack for pre-4.8.0 Linux kernels])
+fi
+
+LIBC_CONFIG_VAR([mips-force-execstack],[${libc_cv_mips_force_execstack}])
+LIBC_CONFIG_VAR([mips-has-gnustack],[${libc_mips_has_gnustack}])

commit 5f620768fbdae75f71af78852be228ad5577623d
Author: Niklas Hambüchen <mail@nh2.me>
Date:   Thu Aug 8 22:02:27 2019 +0200

    malloc: Fix missing accounting of top chunk in malloc_info [BZ #24026]
    
    Fixes `<total type="rest" size="..."> incorrectly showing as 0 most
    of the time.
    
    The rest value being wrong is significant because to compute the
    actual amount of memory handed out via malloc, the user must subtract
    it from <system type="current" size="...">. That result being wrong
    makes investigating memory fragmentation issues like
    <https://bugzilla.redhat.com/show_bug.cgi?id=843478> close to
    impossible.
    
    (cherry picked from commit b6d2c4475d5abc05dd009575b90556bdd3c78ad0)

diff --git a/ChangeLog b/ChangeLog
index 43c9a70ed1..e1d8fd3c66 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,9 @@
+2019-08-08  Niklas Hambüchen  <mail@nh2.me>
+	    Carlos O'Donell  <carlos@redhat.com>
+
+	[BZ #24026]
+	* malloc/malloc.c (__malloc_info): Account for top chunk.
+
 2019-11-01  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
 
 	* sysdeps/unix/sysv/linux/mips/Makefile
diff --git a/malloc/malloc.c b/malloc/malloc.c
index 343d89f489..0e65d636cd 100644
--- a/malloc/malloc.c
+++ b/malloc/malloc.c
@@ -5406,6 +5406,12 @@ __malloc_info (int options, FILE *fp)
 
       __libc_lock_lock (ar_ptr->mutex);
 
+      /* Account for top chunk.  The top-most available chunk is
+	 treated specially and is never in any bin. See "initial_top"
+	 comments.  */
+      avail = chunksize (ar_ptr->top);
+      nblocks = 1;  /* Top always exists.  */
+
       for (size_t i = 0; i < NFASTBINS; ++i)
 	{
 	  mchunkptr p = fastbin (ar_ptr, i);

commit 09b81b2bab71c1a41872ba8de43115e3bdbe3d98
Author: DJ Delorie <dj@redhat.com>
Date:   Thu Aug 8 19:09:43 2019 -0400

    Add glibc.malloc.mxfast tunable
    
    * elf/dl-tunables.list: Add glibc.malloc.mxfast.
    * manual/tunables.texi: Document it.
    * malloc/malloc.c (do_set_mxfast): New.
    (__libc_mallopt): Call it.
    * malloc/arena.c: Add mxfast tunable.
    * malloc/tst-mxfast.c: New.
    * malloc/Makefile: Add it.
    
    Reviewed-by: Carlos O'Donell <carlos@redhat.com>
    (cherry picked from commit c48d92b430c480de06762f80c104922239416826)

diff --git a/ChangeLog b/ChangeLog
index e1d8fd3c66..7a94be9097 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,13 @@
+2019-08-09  DJ Delorie  <dj@redhat.com>
+
+	* elf/dl-tunables.list: Add glibc.malloc.mxfast.
+	* manual/tunables.texi: Document it.
+	* malloc/malloc.c (do_set_mxfast): New.
+	(__libc_mallopt): Call it.
+	* malloc/arena.c: Add mxfast tunable.
+	* malloc/tst-mxfast.c: New.
+	* malloc/Makefile: Add it.
+
 2019-08-08  Niklas Hambüchen  <mail@nh2.me>
 	    Carlos O'Donell  <carlos@redhat.com>
 
diff --git a/elf/dl-tunables.list b/elf/dl-tunables.list
index 1fc2d8886b..525c3767b5 100644
--- a/elf/dl-tunables.list
+++ b/elf/dl-tunables.list
@@ -85,6 +85,11 @@ glibc {
     tcache_unsorted_limit {
       type: SIZE_T
     }
+    mxfast {
+      type: SIZE_T
+      minval: 0
+      security_level: SXID_IGNORE
+    }
   }
   cpu {
     hwcap_mask {
diff --git a/malloc/Makefile b/malloc/Makefile
index d2fba29953..94b74b5c45 100644
--- a/malloc/Makefile
+++ b/malloc/Makefile
@@ -39,6 +39,7 @@ tests := mallocbug tst-malloc tst-valloc tst-calloc tst-obstack \
 	 tst-malloc-too-large \
 	 tst-malloc-stats-cancellation \
 	 tst-tcfree1 tst-tcfree2 tst-tcfree3 \
+	 tst-mxfast \
 
 tests-static := \
 	 tst-interpose-static-nothread \
@@ -196,6 +197,8 @@ tst-malloc-usable-static-ENV = $(tst-malloc-usable-ENV)
 tst-malloc-usable-tunables-ENV = GLIBC_TUNABLES=glibc.malloc.check=3
 tst-malloc-usable-static-tunables-ENV = $(tst-malloc-usable-tunables-ENV)
 
+tst-mxfast-ENV = GLIBC_TUNABLES=glibc.malloc.tcache_count=0:glibc.malloc.mxfast=0
+
 ifeq ($(experimental-malloc),yes)
 CPPFLAGS-malloc.c += -DUSE_TCACHE=1
 else
diff --git a/malloc/arena.c b/malloc/arena.c
index 8309c1334c..a32eb403ec 100644
--- a/malloc/arena.c
+++ b/malloc/arena.c
@@ -236,6 +236,7 @@ TUNABLE_CALLBACK_FNDECL (set_tcache_max, size_t)
 TUNABLE_CALLBACK_FNDECL (set_tcache_count, size_t)
 TUNABLE_CALLBACK_FNDECL (set_tcache_unsorted_limit, size_t)
 #endif
+TUNABLE_CALLBACK_FNDECL (set_mxfast, size_t)
 #else
 /* Initialization routine. */
 #include <string.h>
@@ -323,6 +324,7 @@ ptmalloc_init (void)
   TUNABLE_GET (tcache_unsorted_limit, size_t,
 	       TUNABLE_CALLBACK (set_tcache_unsorted_limit));
 # endif
+  TUNABLE_GET (mxfast, size_t, TUNABLE_CALLBACK (set_mxfast));
 #else
   const char *s = NULL;
   if (__glibc_likely (_environ != NULL))
diff --git a/malloc/malloc.c b/malloc/malloc.c
index 0e65d636cd..fe973770a6 100644
--- a/malloc/malloc.c
+++ b/malloc/malloc.c
@@ -5115,6 +5115,19 @@ do_set_tcache_unsorted_limit (size_t value)
 }
 #endif
 
+static inline int
+__always_inline
+do_set_mxfast (size_t value)
+{
+  if (value >= 0 && value <= MAX_FAST_SIZE)
+    {
+      LIBC_PROBE (memory_mallopt_mxfast, 2, value, get_max_fast ());
+      set_max_fast (value);
+      return 1;
+    }
+  return 0;
+}
+
 int
 __libc_mallopt (int param_number, int value)
 {
@@ -5134,13 +5147,7 @@ __libc_mallopt (int param_number, int value)
   switch (param_number)
     {
     case M_MXFAST:
-      if (value >= 0 && value <= MAX_FAST_SIZE)
-        {
-          LIBC_PROBE (memory_mallopt_mxfast, 2, value, get_max_fast ());
-          set_max_fast (value);
-        }
-      else
-        res = 0;
+      do_set_mxfast (value);
       break;
 
     case M_TRIM_THRESHOLD:
diff --git a/malloc/tst-mxfast.c b/malloc/tst-mxfast.c
new file mode 100644
index 0000000000..7a371d2f9d
--- /dev/null
+++ b/malloc/tst-mxfast.c
@@ -0,0 +1,50 @@
+/* Test that glibc.malloc.mxfast tunable works.
+   Copyright (C) 2018, 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This test verifies that setting the glibc.malloc.mxfast tunable to
+   zero results in free'd blocks being returned to the small bins, not
+   the fast bins.  */
+
+#include <malloc.h>
+#include <assert.h>
+
+int
+do_test(void)
+{
+  struct mallinfo m;
+  char * volatile p1;
+  char * volatile p2;
+
+  /* Arbitrary value; must be in default fastbin range.  */
+  p1 = malloc (3);
+  /* Something large so that p1 isn't a "top block" */
+  p2 = malloc (512);
+  free (p1);
+
+  m = mallinfo();
+
+  /* This will fail if there are any blocks in the fastbins.  */
+  assert (m.smblks == 0);
+
+  /* To keep gcc happy.  */
+  free (p2);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/manual/tunables.texi b/manual/tunables.texi
index ee0fdf28d1..1687f9c939 100644
--- a/manual/tunables.texi
+++ b/manual/tunables.texi
@@ -214,6 +214,18 @@ pre-fill the per-thread cache with.  The default, or when set to zero,
 is no limit.
 @end deftp
 
+@deftp Tunable glibc.malloc.mxfast
+One of the optimizations malloc uses is to maintain a series of ``fast
+bins'' that hold chunks up to a specific size.  The default and
+maximum size which may be held this way is 80 bytes on 32-bit systems
+or 160 bytes on 64-bit systems.  Applications which value size over
+speed may choose to reduce the size of requests which are serviced
+from fast bins with this tunable.  Note that the value specified
+includes malloc's internal overhead, which is normally the size of one
+pointer, so add 4 on 32-bit systems or 8 on 64-bit systems to the size
+passed to @code{malloc} for the largest bin size to enable.
+@end deftp
+
 @node Elision Tunables
 @section Elision Tunables
 @cindex elision tunables

commit 09abef31a59e6a524d1d4142ad4eb40ad0a41ccd
Author: Florian Weimer <fweimer@redhat.com>
Date:   Thu Aug 15 11:37:18 2019 +0200

    malloc: Various cleanups for malloc/tst-mxfast
    
    (cherry picked from commit f9769a239784772453d595bc2f4bed8739810e06)

diff --git a/ChangeLog b/ChangeLog
index 7a94be9097..c4687dfd4c 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,11 @@
+2019-08-15  Florian Weimer  <fweimer@redhat.com>
+
+	* malloc/Makefile (tests): Only add tst-mxfast for
+	$(have-tunables).
+	* malloc/tst-mxfast.c: Fix copyright year.
+	(do_test): Fix GNU style issues.  Use TEST_COMPARE instead of
+	assert for checks.
+
 2019-08-09  DJ Delorie  <dj@redhat.com>
 
 	* elf/dl-tunables.list: Add glibc.malloc.mxfast.
diff --git a/malloc/Makefile b/malloc/Makefile
index 94b74b5c45..742c515eb2 100644
--- a/malloc/Makefile
+++ b/malloc/Makefile
@@ -39,7 +39,6 @@ tests := mallocbug tst-malloc tst-valloc tst-calloc tst-obstack \
 	 tst-malloc-too-large \
 	 tst-malloc-stats-cancellation \
 	 tst-tcfree1 tst-tcfree2 tst-tcfree3 \
-	 tst-mxfast \
 
 tests-static := \
 	 tst-interpose-static-nothread \
@@ -55,7 +54,7 @@ tests-internal += \
 	 tst-dynarray-at-fail \
 
 ifneq (no,$(have-tunables))
-tests += tst-malloc-usable-tunables
+tests += tst-malloc-usable-tunables tst-mxfast
 tests-static += tst-malloc-usable-static-tunables
 endif
 
diff --git a/malloc/tst-mxfast.c b/malloc/tst-mxfast.c
index 7a371d2f9d..7a7750bc71 100644
--- a/malloc/tst-mxfast.c
+++ b/malloc/tst-mxfast.c
@@ -1,5 +1,5 @@
 /* Test that glibc.malloc.mxfast tunable works.
-   Copyright (C) 2018, 2019 Free Software Foundation, Inc.
+   Copyright (C) 2019 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,14 +21,14 @@
    the fast bins.  */
 
 #include <malloc.h>
-#include <assert.h>
+#include <support/check.h>
 
 int
-do_test(void)
+do_test (void)
 {
   struct mallinfo m;
-  char * volatile p1;
-  char * volatile p2;
+  char *volatile p1;
+  char *volatile p2;
 
   /* Arbitrary value; must be in default fastbin range.  */
   p1 = malloc (3);
@@ -36,10 +36,10 @@ do_test(void)
   p2 = malloc (512);
   free (p1);
 
-  m = mallinfo();
+  m = mallinfo ();
 
   /* This will fail if there are any blocks in the fastbins.  */
-  assert (m.smblks == 0);
+  TEST_COMPARE (m.smblks, 0);
 
   /* To keep gcc happy.  */
   free (p2);

commit 919af705eef416f4469341dfdf4ca23450f30236
Author: DJ Delorie <dj@redhat.com>
Date:   Wed Oct 30 18:03:14 2019 -0400

    Base max_fast on alignment, not width, of bins (Bug 24903)
    
    set_max_fast sets the "impossibly small" value based on,
    eventually, MALLOC_ALIGNMENT.  The comparisons for the smallest
    chunk used is, eventually, MIN_CHUNK_SIZE.  Note that i386
    is the only platform where these are the same, so a smallest
    chunk *would* be put in a no-fastbins fastbin.
    
    This change calculates the "impossibly small" value
    based on MIN_CHUNK_SIZE instead, so that we can know it will
    always be impossibly small.
    
    (cherry picked from commit ff12e0fb91b9072800f031cb21fb2651ee7b6251)

diff --git a/malloc/malloc.c b/malloc/malloc.c
index fe973770a6..8c68b21b2b 100644
--- a/malloc/malloc.c
+++ b/malloc/malloc.c
@@ -1621,7 +1621,7 @@ static INTERNAL_SIZE_T global_max_fast;
 
 #define set_max_fast(s) \
   global_max_fast = (((s) == 0)						      \
-                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) & ~MALLOC_ALIGN_MASK))
+                     ? MIN_CHUNK_SIZE / 2 : ((s + SIZE_SZ) & ~MALLOC_ALIGN_MASK))
 
 static inline INTERNAL_SIZE_T
 get_max_fast (void)

commit a4b3bbf71e8a608ac6ee4f423b5e2db50e06b846
Author: Emilio Cobos Álvarez <emilio@crisal.io>
Date:   Tue Nov 12 19:18:32 2019 +0100

    Don't use a custom wrapper macro around __has_include (bug 25189).
    
    This causes issues when using clang with -frewrite-includes to e.g.,
    submit the translation unit to a distributed compiler.
    
    In my case, I was building Firefox using sccache.
    
    See [1] for a reduced test-case since I initially thought this was a
    clang bug, and [2] for more context.
    
    Apparently doing this is invalid C++ per [cpp.cond], which mentions [3]:
    
    > The #ifdef and #ifndef directives, and the defined conditional
    > inclusion operator, shall treat __has_include and __has_cpp_attribute
    > as if they were the names of defined macros.  The identifiers
    > __has_include and __has_cpp_attribute shall not appear in any context
    > not mentioned in this subclause.
    
    [1]: https://bugs.llvm.org/show_bug.cgi?id=43982
    [2]: https://bugs.llvm.org/show_bug.cgi?id=37990
    [3]: http://eel.is/c++draft/cpp.cond#7.sentence-2
    
    Change-Id: Id4b8ee19176a9e4624b533087ba870c418f27e60
    (cherry picked from commit bfa864e1645e140da2e1aae3cf0d0ba0674f6eb5)

diff --git a/NEWS b/NEWS
index 5f1ade1c49..c7dcb54bb2 100644
--- a/NEWS
+++ b/NEWS
@@ -14,6 +14,7 @@ The following bugs are resolved with this release:
   [24867] malloc: Remove unwanted leading whitespace in malloc_info
   [24986] alpha: new getegid, geteuid and getppid syscalls used
     unconditionally
+  [25189] Don't use a custom wrapper macro around __has_include
 
 
 Version 2.30
diff --git a/misc/sys/cdefs.h b/misc/sys/cdefs.h
index f1bd994a10..b1695376dc 100644
--- a/misc/sys/cdefs.h
+++ b/misc/sys/cdefs.h
@@ -412,14 +412,6 @@
 # define __glibc_has_attribute(attr)	0
 #endif
 
-#ifdef __has_include
-/* Do not use a function-like macro, so that __has_include can inhibit
-   macro expansion.  */
-# define __glibc_has_include __has_include
-#else
-# define __glibc_has_include(header)	0
-#endif
-
 #if (!defined _Noreturn \
      && (defined __STDC_VERSION__ ? __STDC_VERSION__ : 0) < 201112 \
      &&  !__GNUC_PREREQ (4,7))
diff --git a/sysdeps/unix/sysv/linux/bits/statx.h b/sysdeps/unix/sysv/linux/bits/statx.h
index 206878723f..aaccfdc2dc 100644
--- a/sysdeps/unix/sysv/linux/bits/statx.h
+++ b/sysdeps/unix/sysv/linux/bits/statx.h
@@ -26,11 +26,13 @@
 
 /* Use "" to work around incorrect macro expansion of the
    __has_include argument (GCC PR 80005).  */
-#if __glibc_has_include ("linux/stat.h")
-# include "linux/stat.h"
-# ifdef STATX_TYPE
-#  define __statx_timestamp_defined 1
-#  define __statx_defined 1
+#ifdef __has_include
+# if __has_include ("linux/stat.h")
+#  include "linux/stat.h"
+#  ifdef STATX_TYPE
+#   define __statx_timestamp_defined 1
+#   define __statx_defined 1
+#  endif
 # endif
 #endif
 

commit 37c90e117310728a4ad1eb998c0bbe7d79c4a398
Author: Marcin Kościelnicki <mwk@0x04.net>
Date:   Thu Nov 21 00:20:15 2019 +0100

    rtld: Check __libc_enable_secure before honoring LD_PREFER_MAP_32BIT_EXEC (CVE-2019-19126) [BZ #25204]
    
    The problem was introduced in glibc 2.23, in commit
    b9eb92ab05204df772eb4929eccd018637c9f3e9
    ("Add Prefer_MAP_32BIT_EXEC to map executable pages with MAP_32BIT").
    
    (cherry picked from commit d5dfad4326fc683c813df1e37bbf5cf920591c8e)

diff --git a/NEWS b/NEWS
index c7dcb54bb2..b0d2167a60 100644
--- a/NEWS
+++ b/NEWS
@@ -7,6 +7,14 @@ using `glibc' in the "product" field.
 
 Version 2.30.1
 
+Security related changes:
+
+CVE-2019-19126: ld.so failed to ignore the LD_PREFER_MAP_32BIT_EXEC
+  environment variable during program execution after a security
+  transition, allowing local attackers to restrict the possible mapping
+  addresses for loaded libraries and thus bypass ASLR for a setuid
+  program.  Reported by Marcin Kościelnicki.
+
 The following bugs are resolved with this release:
 
   [24682] localedata: zh_CN first weekday should be Monday per GB/T
@@ -15,6 +23,7 @@ The following bugs are resolved with this release:
   [24986] alpha: new getegid, geteuid and getppid syscalls used
     unconditionally
   [25189] Don't use a custom wrapper macro around __has_include
+  [25204] Ignore LD_PREFER_MAP_32BIT_EXEC for SUID programs
 
 
 Version 2.30
diff --git a/sysdeps/unix/sysv/linux/x86_64/64/dl-librecon.h b/sysdeps/unix/sysv/linux/x86_64/64/dl-librecon.h
index 975cbe2950..df2cdfdb6b 100644
--- a/sysdeps/unix/sysv/linux/x86_64/64/dl-librecon.h
+++ b/sysdeps/unix/sysv/linux/x86_64/64/dl-librecon.h
@@ -31,7 +31,8 @@
    environment variable, LD_PREFER_MAP_32BIT_EXEC.  */
 #define EXTRA_LD_ENVVARS \
   case 21:								  \
-    if (memcmp (envline, "PREFER_MAP_32BIT_EXEC", 21) == 0)		  \
+    if (!__libc_enable_secure						  \
+	&& memcmp (envline, "PREFER_MAP_32BIT_EXEC", 21) == 0)		  \
       GLRO(dl_x86_cpu_features).feature[index_arch_Prefer_MAP_32BIT_EXEC] \
 	|= bit_arch_Prefer_MAP_32BIT_EXEC;				  \
     break;

commit f4419b0d0181da28f18cba40068f2e75300f5020
Author: Stefan Liebler <stli@linux.ibm.com>
Date:   Wed Nov 27 12:35:40 2019 +0100

    S390: Fix handling of needles crossing a page in strstr z15 ifunc-variant. [BZ #25226]
    
    If the specified needle crosses a page-boundary, the s390-z15 ifunc variant of
    strstr truncates the needle which results in invalid results.
    
    This is fixed by loading the needle beyond the page boundary to v18 instead of v16.
    The bug is sometimes observable in test-strstr.c in check1 and check2 as the
    haystack and needle is stored on stack. Thus the needle can be on a page boundary.
    
    check2 is now extended to test haystack / needles located on stack, at end of page
    and on two pages.
    
    This bug was introduced with commit 6f47401bd5fc71209219779a0426170a9a7395b0
    ("S390: Add arch13 strstr ifunc variant.") and is already released in glibc 2.30.
    
    (cherry picked from commit bfdb731438206b0f70fe7afa890681155c30b419)

diff --git a/string/test-strstr.c b/string/test-strstr.c
index df6dbc251e..daed9a2705 100644
--- a/string/test-strstr.c
+++ b/string/test-strstr.c
@@ -139,16 +139,45 @@ check1 (void)
 static void
 check2 (void)
 {
-  const char s1[] = ", enable_static, \0, enable_shared, ";
+  const char s1_stack[] = ", enable_static, \0, enable_shared, ";
+  const size_t s1_byte_count = 18;
+  const char *s2_stack = &(s1_stack[s1_byte_count]);
+  const size_t s2_byte_count = 18;
   char *exp_result;
-  char *s2 = (void *) buf1 + page_size - 18;
+  const size_t page_size_real = getpagesize ();
 
-  strcpy (s2, s1);
-  exp_result = stupid_strstr (s1, s1 + 18);
+  /* Haystack at end of page.  The following page is protected.  */
+  char *s1_page_end = (void *) buf1 + page_size - s1_byte_count;
+  strcpy (s1_page_end, s1_stack);
+
+  /* Haystack which crosses a page boundary.
+     Note: page_size is at least 2 * getpagesize.  See test_init.  */
+  char *s1_page_cross = (void *) buf1 + page_size_real - 8;
+  strcpy (s1_page_cross, s1_stack);
+
+  /* Needle at end of page.  The following page is protected.  */
+  char *s2_page_end = (void *) buf2 + page_size - s2_byte_count;
+  strcpy (s2_page_end, s2_stack);
+
+  /* Needle which crosses a page boundary.
+     Note: page_size is at least 2 * getpagesize.  See test_init.  */
+  char *s2_page_cross = (void *) buf2 + page_size_real - 8;
+  strcpy (s2_page_cross, s2_stack);
+
+  exp_result = stupid_strstr (s1_stack, s2_stack);
   FOR_EACH_IMPL (impl, 0)
     {
-      check_result (impl, s1, s1 + 18, exp_result);
-      check_result (impl, s2, s1 + 18, exp_result);
+      check_result (impl, s1_stack, s2_stack, exp_result);
+      check_result (impl, s1_stack, s2_page_end, exp_result);
+      check_result (impl, s1_stack, s2_page_cross, exp_result);
+
+      check_result (impl, s1_page_end, s2_stack, exp_result);
+      check_result (impl, s1_page_end, s2_page_end, exp_result);
+      check_result (impl, s1_page_end, s2_page_cross, exp_result);
+
+      check_result (impl, s1_page_cross, s2_stack, exp_result);
+      check_result (impl, s1_page_cross, s2_page_end, exp_result);
+      check_result (impl, s1_page_cross, s2_page_cross, exp_result);
     }
 }
 
diff --git a/sysdeps/s390/strstr-arch13.S b/sysdeps/s390/strstr-arch13.S
index 929b026adf..faa969849e 100644
--- a/sysdeps/s390/strstr-arch13.S
+++ b/sysdeps/s390/strstr-arch13.S
@@ -164,7 +164,7 @@ ENTRY(STRSTR_ARCH13)
 	vfenezb	%v19,%v18,%v18	/* Search zero in loaded needle bytes.  */
 	veclb	%v19,%v21	/* Zero index <= max loaded byte index?  */
 	jle	.Lneedle_loaded	/* -> v18 contains full needle.  */
-	vl	%v16,0(%r3)	/* Load needle beyond page boundary.  */
+	vl	%v18,0(%r3)	/* Load needle beyond page boundary.  */
 	vfenezb	%v19,%v18,%v18
 	j	.Lneedle_loaded
 END(STRSTR_ARCH13)

commit 5a08bdb1e73e87afc1ada7b7b95d43ae470ce7e1
Author: Florian Weimer <fweimer@redhat.com>
Date:   Thu Nov 28 14:18:12 2019 +0100

    libio: Disable vtable validation for pre-2.1 interposed handles [BZ #25203]
    
    Commit c402355dfa7807b8e0adb27c009135a7e2b9f1b0 ("libio: Disable
    vtable validation in case of interposition [BZ #23313]") only covered
    the interposable glibc 2.1 handles, in libio/stdfiles.c.  The
    parallel code in libio/oldstdfiles.c needs similar detection logic.
    
    Fixes (again) commit db3476aff19b75c4fdefbe65fcd5f0a90588ba51
    ("libio: Implement vtable verification [BZ #20191]").
    
    Change-Id: Ief6f9f17e91d1f7263421c56a7dc018f4f595c21
    (cherry picked from commit cb61630ed712d033f54295f776967532d3f4b46a)

diff --git a/NEWS b/NEWS
index b0d2167a60..1f60f3eb19 100644
--- a/NEWS
+++ b/NEWS
@@ -23,6 +23,7 @@ The following bugs are resolved with this release:
   [24986] alpha: new getegid, geteuid and getppid syscalls used
     unconditionally
   [25189] Don't use a custom wrapper macro around __has_include
+  [25203] libio: Disable vtable validation for pre-2.1 interposed handles
   [25204] Ignore LD_PREFER_MAP_32BIT_EXEC for SUID programs
 
 
diff --git a/libio/oldstdfiles.c b/libio/oldstdfiles.c
index 2b861cd754..7503cdd62d 100644
--- a/libio/oldstdfiles.c
+++ b/libio/oldstdfiles.c
@@ -83,6 +83,11 @@ _IO_check_libio (void)
 	= stderr->_vtable_offset =
 	((int) sizeof (struct _IO_FILE)
 	 - (int) sizeof (struct _IO_FILE_complete));
+
+      if (_IO_stdin_.vtable != &_IO_old_file_jumps
+	  || _IO_stdout_.vtable != &_IO_old_file_jumps
+	  || _IO_stderr_.vtable != &_IO_old_file_jumps)
+	IO_set_accept_foreign_vtables (&_IO_vtable_check);
     }
 }
 

commit 761452f12781f2d15a50f2dcd9f40c53bc0ff040
Author: Florian Weimer <fweimer@redhat.com>
Date:   Tue Dec 3 20:26:28 2019 +0100

    x86: Assume --enable-cet if GCC defaults to CET [BZ #25225]
    
    This links in CET support if GCC defaults to CET.  Otherwise, __CET__
    is defined, yet CET functionality is not compiled and linked into the
    dynamic loader, resulting in a linker failure due to undefined
    references to _dl_cet_check and _dl_open_check.

diff --git a/NEWS b/NEWS
index 1f60f3eb19..a02fa10df9 100644
--- a/NEWS
+++ b/NEWS
@@ -25,6 +25,7 @@ The following bugs are resolved with this release:
   [25189] Don't use a custom wrapper macro around __has_include
   [25203] libio: Disable vtable validation for pre-2.1 interposed handles
   [25204] Ignore LD_PREFER_MAP_32BIT_EXEC for SUID programs
+  [25225] ld.so fails to link on x86 if GCC defaults to -fcf-protection
 
 
 Version 2.30
diff --git a/configure b/configure
index c773c487b5..6d26b8246f 100755
--- a/configure
+++ b/configure
@@ -3777,11 +3777,32 @@ else
 fi
 
 
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+#ifndef __CET__
+#error no CET compiler support
+#endif
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  libc_cv_compiler_default_cet=yes
+else
+  libc_cv_compiler_default_cet=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
 # Check whether --enable-cet was given.
 if test "${enable_cet+set}" = set; then :
   enableval=$enable_cet; enable_cet=$enableval
 else
-  enable_cet=no
+  enable_cet=$libc_cv_compiler_default_cet
 fi
 
 
diff --git a/configure.ac b/configure.ac
index 598ba6c4ae..7436485419 100644
--- a/configure.ac
+++ b/configure.ac
@@ -472,11 +472,18 @@ AC_ARG_ENABLE([mathvec],
 	      [build_mathvec=$enableval],
 	      [build_mathvec=notset])
 
+AC_TRY_COMPILE([], [
+#ifndef __CET__
+# error no CET compiler support
+#endif],
+	       [libc_cv_compiler_default_cet=yes],
+	       [libc_cv_compiler_default_cet=no])
+
 AC_ARG_ENABLE([cet],
 	      AC_HELP_STRING([--enable-cet],
 			     [enable Intel Control-flow Enforcement Technology (CET), x86 only]),
 	      [enable_cet=$enableval],
-	      [enable_cet=no])
+	      [enable_cet=$libc_cv_compiler_default_cet])
 
 # We keep the original values in `$config_*' and never modify them, so we
 # can write them unchanged into config.make.  Everything else uses

commit 4719e1851cd1101e555f314497504a54ba3fb99a
Author: Kamlesh Kumar <kamleshbhalui@gmail.com>
Date:   Thu Dec 5 16:54:47 2019 +0100

    <string.h>: Define __CORRECT_ISO_CPP_STRING_H_PROTO for Clang [BZ #25232]
    
    Without the asm redirects, strchr et al. are not const-correct.
    
    libc++ has a wrapper header that works with and without
    __CORRECT_ISO_CPP_STRING_H_PROTO (using a Clang extension).  But when
    Clang is used with libstdc++ or just C headers, the overloaded functions
    with the correct types are not declared.
    
    This change does not impact current GCC (with libstdc++ or libc++).
    
    (cherry picked from commit 953ceff17a4a15b10cfdd5edc3c8cae4884c8ec3)

diff --git a/NEWS b/NEWS
index a02fa10df9..74826b9eb8 100644
--- a/NEWS
+++ b/NEWS
@@ -26,6 +26,7 @@ The following bugs are resolved with this release:
   [25203] libio: Disable vtable validation for pre-2.1 interposed handles
   [25204] Ignore LD_PREFER_MAP_32BIT_EXEC for SUID programs
   [25225] ld.so fails to link on x86 if GCC defaults to -fcf-protection
+  [25232] No const correctness for strchr et al. for Clang++
 
 
 Version 2.30
diff --git a/string/string.h b/string/string.h
index c38eea971f..608ed496b9 100644
--- a/string/string.h
+++ b/string/string.h
@@ -33,7 +33,8 @@ __BEGIN_DECLS
 #include <stddef.h>
 
 /* Tell the caller that we provide correct C++ prototypes.  */
-#if defined __cplusplus && __GNUC_PREREQ (4, 4)
+#if defined __cplusplus && (__GNUC_PREREQ (4, 4) \
+			    || __glibc_clang_prereq (3, 5))
 # define __CORRECT_ISO_CPP_STRING_H_PROTO
 #endif
 

commit 50f20fe506abb8853641006a7b90a81af21d7b91
Author: Florian Weimer <fweimer@redhat.com>
Date:   Thu Dec 5 17:29:42 2019 +0100

    misc/test-errno-linux: Handle EINVAL from quotactl
    
    In commit 3dd4d40b420846dd35869ccc8f8627feef2cff32 ("xfs: Sanity check
    flags of Q_XQUOTARM call"), Linux 5.4 added checking for the flags
    argument, causing the test to fail due to too restrictive test
    expectations.
    
    Reviewed-by: Adhemerval Zanella <adhemerval.zanella@linaro.org>
    (cherry picked from commit 1f7525d924b608a3e43b10fcfb3d46b8a6e9e4f9)

diff --git a/sysdeps/unix/sysv/linux/test-errno-linux.c b/sysdeps/unix/sysv/linux/test-errno-linux.c
index cb979d44bd..aaa9eadc0a 100644
--- a/sysdeps/unix/sysv/linux/test-errno-linux.c
+++ b/sysdeps/unix/sysv/linux/test-errno-linux.c
@@ -160,8 +160,9 @@ do_test (void)
   fails |= test_wrp (EINVAL, poll, &pollfd, -1, 0);
   /* quotactl returns ENOSYS for kernels not configured with
      CONFIG_QUOTA, and may return EPERM if called within certain types
-     of containers.  */
-  fails |= test_wrp2 (LIST (ENODEV, ENOSYS, EPERM),
+     of containers.  Linux 5.4 added additional argument validation
+     and can return EINVAL.  */
+  fails |= test_wrp2 (LIST (ENODEV, ENOSYS, EPERM, EINVAL),
 		      quotactl, Q_GETINFO, NULL, -1, (caddr_t) &dqblk);
   fails |= test_wrp (EINVAL, sched_getparam, -1, &sch_param);
   fails |= test_wrp (EINVAL, sched_getscheduler, -1);

commit b90aefd4ac44e9353d45170282c01f0bfdeeaf1c
Author: Florian Weimer <fweimer@redhat.com>
Date:   Mon Aug 5 15:54:10 2019 +0200

    login: Remove utmp backend jump tables [BZ #23518]
    
    There is just one file-based implementation, so this dispatch
    mechanism is unnecessary.  Instead of the vtable pointer
    __libc_utmp_jump_table, use a non-negative file_fd as the indicator
    that the backend is initialized.
    
    (cherry picked from commit 1a7fe2ebe52b3c8bf465d1756e69452d05c1c103)

diff --git a/ChangeLog b/ChangeLog
index c4687dfd4c..01037bff1f 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,43 @@
+2019-08-05  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #23518]
+	* login/uptmp-private.h (struct ufuncs): Remove definition.
+	(__libc_utmp_file_functions, __libc_utmp_unknown_functions)
+	(__libc_utmp_jump_table): Remove declarations.
+	(__libc_setutent, __libc_getutent_r, __libc_getutid_r)
+	(__libc_getutline_r, __libc_pututline, __libc_endutent)
+	(__libc_updwtmp): Declare.
+	* login/getutent_r.c (__libc_utmp_unknown_functions)
+	(__libc_utmp_jump_table, setutent_unknown, getutent_r_unknown)
+	(getutid_r_unknown, getutline_r_unknown, pututline_unknown)
+	(endutent_unknown): Remove definitions.
+	(__setutent): Call __libc_setutent.
+	(__getutent_r): Call __libc_getutent_r.
+	(__pututline): Call __libc_pututline.
+	(__endutent): Call __libc_endutent.
+	* login/getutid_r.c (__getutid_r): Call __libc_getutid_r.
+	* login/getutline_r.c (__getutline_r): Call __libc_getutline_r.
+	* login/updwtmp.c (__updwtmp): Call __libc_updwtmp.
+	* login/utmp_file.c (__libc_utmp_file_functions): Remove definition
+	(__libc_setutent): Rename from stetutent_file.  Drop static.
+	(maybe_setutent): New function.
+	(__libc_getutent_r): Rename from getutent_r_file.  Drop static.
+	Check for initialization.
+	(__libc_getutid_r): Rename from getutid_r_file.  Drop static.
+	Check for initialization.
+	(__libc_getutline_r): Rename from getutline_r_file.  Drop static.
+	Check for initialization.
+	(__libc_pututline): Rename from pututline_file.  Drop static.
+	Check for initialization.
+	(__libc_endutent): Rename from endutent_file.  Drop static.  Check
+	for initialization.
+	(__libc_updwtmp): Rename from updwtmp_file.  Drop static.
+	* login/utmpname.c (__utmpname): Call __libc_endutent.
+	* sysdeps/unix/getlogin_r (__getlogin_r): Call __libc_setutent,
+	__libc_getutlien_r, __libc_endutent.
+	* manual/users.texi (Who Logged In, Manipulating the Database):
+	Adjust.
+
 2019-08-15  Florian Weimer  <fweimer@redhat.com>
 
 	* malloc/Makefile (tests): Only add tst-mxfast for
diff --git a/NEWS b/NEWS
index 74826b9eb8..4d26e01248 100644
--- a/NEWS
+++ b/NEWS
@@ -17,6 +17,7 @@ CVE-2019-19126: ld.so failed to ignore the LD_PREFER_MAP_32BIT_EXEC
 
 The following bugs are resolved with this release:
 
+  [23518] login: Remove utmp backend jump tables
   [24682] localedata: zh_CN first weekday should be Monday per GB/T
     7408-2005
   [24867] malloc: Remove unwanted leading whitespace in malloc_info
diff --git a/login/getutent_r.c b/login/getutent_r.c
index 98ffc5d1c6..fd13be8a1e 100644
--- a/login/getutent_r.c
+++ b/login/getutent_r.c
@@ -23,115 +23,16 @@
 
 #include "utmp-private.h"
 
-
-/* Functions defined here.  */
-static int setutent_unknown (void);
-static int getutent_r_unknown (struct utmp *buffer, struct utmp **result);
-static int getutid_r_unknown (const struct utmp *line, struct utmp *buffer,
-			      struct utmp **result);
-static int getutline_r_unknown (const struct utmp *id, struct utmp *buffer,
-				struct utmp **result);
-static struct utmp *pututline_unknown (const struct utmp *data);
-static void endutent_unknown (void);
-
-/* Initial Jump table.  */
-const struct utfuncs __libc_utmp_unknown_functions =
-{
-  setutent_unknown,
-  getutent_r_unknown,
-  getutid_r_unknown,
-  getutline_r_unknown,
-  pututline_unknown,
-  endutent_unknown,
-  NULL
-};
-
-/* Currently selected backend.  */
-const struct utfuncs *__libc_utmp_jump_table = &__libc_utmp_unknown_functions;
-
 /* We need to protect the opening of the file.  */
 __libc_lock_define_initialized (, __libc_utmp_lock attribute_hidden)
 
 
-static int
-setutent_unknown (void)
-{
-  int result;
-
-  result = (*__libc_utmp_file_functions.setutent) ();
-  if (result)
-    __libc_utmp_jump_table = &__libc_utmp_file_functions;
-
-  return result;
-}
-
-
-static int
-getutent_r_unknown (struct utmp *buffer, struct utmp **result)
-{
-  /* The backend was not yet initialized.  */
-  if (setutent_unknown ())
-    return (*__libc_utmp_jump_table->getutent_r) (buffer, result);
-
-  /* Not available.  */
-  *result = NULL;
-  return -1;
-}
-
-
-static int
-getutid_r_unknown (const struct utmp *id, struct utmp *buffer,
-		   struct utmp **result)
-{
-  /* The backend was not yet initialized.  */
-  if (setutent_unknown ())
-    return (*__libc_utmp_jump_table->getutid_r) (id, buffer, result);
-
-  /* Not available.  */
-  *result = NULL;
-  return -1;
-}
-
-
-static int
-getutline_r_unknown (const struct utmp *line, struct utmp *buffer,
-		     struct utmp **result)
-{
-  /* The backend was not yet initialized.  */
-  if (setutent_unknown ())
-    return (*__libc_utmp_jump_table->getutline_r) (line, buffer, result);
-
-  /* Not available.  */
-  *result = NULL;
-  return -1;
-}
-
-
-static struct utmp *
-pututline_unknown (const struct utmp *data)
-{
-  /* The backend was not yet initialized.  */
-  if (setutent_unknown ())
-    return (*__libc_utmp_jump_table->pututline) (data);
-
-  /* Not available.  */
-  return NULL;
-}
-
-
-static void
-endutent_unknown (void)
-{
-  /* Nothing to do.  */
-}
-
-
 void
 __setutent (void)
 {
   __libc_lock_lock (__libc_utmp_lock);
 
-  (*__libc_utmp_jump_table->setutent) ();
+  __libc_setutent ();
 
   __libc_lock_unlock (__libc_utmp_lock);
 }
@@ -145,7 +46,7 @@ __getutent_r (struct utmp *buffer, struct utmp **result)
 
   __libc_lock_lock (__libc_utmp_lock);
 
-  retval = (*__libc_utmp_jump_table->getutent_r) (buffer, result);
+  retval = __libc_getutent_r (buffer, result);
 
   __libc_lock_unlock (__libc_utmp_lock);
 
@@ -162,7 +63,7 @@ __pututline (const struct utmp *data)
 
   __libc_lock_lock (__libc_utmp_lock);
 
-  buffer = (*__libc_utmp_jump_table->pututline) (data);
+  buffer = __libc_pututline (data);
 
   __libc_lock_unlock (__libc_utmp_lock);
 
@@ -177,8 +78,7 @@ __endutent (void)
 {
   __libc_lock_lock (__libc_utmp_lock);
 
-  (*__libc_utmp_jump_table->endutent) ();
-  __libc_utmp_jump_table = &__libc_utmp_unknown_functions;
+  __libc_endutent ();
 
   __libc_lock_unlock (__libc_utmp_lock);
 }
diff --git a/login/getutid_r.c b/login/getutid_r.c
index 34ea61d8f4..86ffc85b01 100644
--- a/login/getutid_r.c
+++ b/login/getutid_r.c
@@ -49,7 +49,7 @@ __getutid_r (const struct utmp *id, struct utmp *buffer, struct utmp **result)
 
   __libc_lock_lock (__libc_utmp_lock);
 
-  retval = (*__libc_utmp_jump_table->getutid_r) (id, buffer, result);
+  retval = __libc_getutid_r (id, buffer, result);
 
   __libc_lock_unlock (__libc_utmp_lock);
 
diff --git a/login/getutline_r.c b/login/getutline_r.c
index 110b89e438..f03255dbbd 100644
--- a/login/getutline_r.c
+++ b/login/getutline_r.c
@@ -36,7 +36,7 @@ __getutline_r (const struct utmp *line, struct utmp *buffer,
 
   __libc_lock_lock (__libc_utmp_lock);
 
-  retval = (*__libc_utmp_jump_table->getutline_r) (line, buffer, result);
+  retval = __libc_getutline_r (line, buffer, result);
 
   __libc_lock_unlock (__libc_utmp_lock);
 
diff --git a/login/updwtmp.c b/login/updwtmp.c
index b9bccd9b67..387e580828 100644
--- a/login/updwtmp.c
+++ b/login/updwtmp.c
@@ -29,7 +29,7 @@ __updwtmp (const char *wtmp_file, const struct utmp *utmp)
 {
   const char *file_name = TRANSFORM_UTMP_FILE_NAME (wtmp_file);
 
-  (*__libc_utmp_file_functions.updwtmp) (file_name, utmp);
+  __libc_updwtmp (file_name, utmp);
 }
 libc_hidden_def (__updwtmp)
 weak_alias (__updwtmp, updwtmp)
diff --git a/login/utmp-private.h b/login/utmp-private.h
index a82a923657..d60461d644 100644
--- a/login/utmp-private.h
+++ b/login/utmp-private.h
@@ -24,24 +24,17 @@
 #include <utmp.h>
 #include <libc-lock.h>
 
-/* The structure describing the functions in a backend.  */
-struct utfuncs
-{
-  int (*setutent) (void);
-  int (*getutent_r) (struct utmp *, struct utmp **);
-  int (*getutid_r) (const struct utmp *, struct utmp *, struct utmp **);
-  int (*getutline_r) (const struct utmp *, struct utmp *, struct utmp **);
-  struct utmp *(*pututline) (const struct utmp *);
-  void (*endutent) (void);
-  int (*updwtmp) (const char *, const struct utmp *);
-};
-
-/* The tables from the services.  */
-extern const struct utfuncs __libc_utmp_file_functions attribute_hidden;
-extern const struct utfuncs __libc_utmp_unknown_functions attribute_hidden;
-
-/* Currently selected backend.  */
-extern const struct utfuncs *__libc_utmp_jump_table attribute_hidden;
+/* These functions check for initialization, but not perform any
+   locking.  */
+int __libc_setutent (void) attribute_hidden;
+int __libc_getutent_r (struct utmp *, struct utmp **) attribute_hidden;
+int __libc_getutid_r (const struct utmp *, struct utmp *, struct utmp **)
+  attribute_hidden;
+int __libc_getutline_r (const struct utmp *, struct utmp *, struct utmp **)
+  attribute_hidden;
+struct utmp *__libc_pututline (const struct utmp *) attribute_hidden;
+void __libc_endutent (void) attribute_hidden;
+int __libc_updwtmp (const char *, const struct utmp *) attribute_hidden;
 
 /* Current file name.  */
 extern const char *__libc_utmp_file_name attribute_hidden;
diff --git a/login/utmp_file.c b/login/utmp_file.c
index b19d3caf0d..cb8a02825c 100644
--- a/login/utmp_file.c
+++ b/login/utmp_file.c
@@ -105,37 +105,12 @@ static void timeout_handler (int signum) {};
     alarm (old_timeout);						      \
 } while (0)
 
-
-/* Functions defined here.  */
-static int setutent_file (void);
-static int getutent_r_file (struct utmp *buffer, struct utmp **result);
-static int getutid_r_file (const struct utmp *key, struct utmp *buffer,
-			   struct utmp **result);
-static int getutline_r_file (const struct utmp *key, struct utmp *buffer,
-			     struct utmp **result);
-static struct utmp *pututline_file (const struct utmp *data);
-static void endutent_file (void);
-static int updwtmp_file (const char *file, const struct utmp *utmp);
-
-/* Jump table for file functions.  */
-const struct utfuncs __libc_utmp_file_functions =
-{
-  setutent_file,
-  getutent_r_file,
-  getutid_r_file,
-  getutline_r_file,
-  pututline_file,
-  endutent_file,
-  updwtmp_file
-};
-
-
 #ifndef TRANSFORM_UTMP_FILE_NAME
 # define TRANSFORM_UTMP_FILE_NAME(file_name) (file_name)
 #endif
 
-static int
-setutent_file (void)
+int
+__libc_setutent (void)
 {
   if (file_fd < 0)
     {
@@ -166,15 +141,19 @@ setutent_file (void)
   return 1;
 }
 
+/* Preform initialization if necessary.  */
+static bool
+maybe_setutent (void)
+{
+  return file_fd >= 0 || __libc_setutent ();
+}
 
-static int
-getutent_r_file (struct utmp *buffer, struct utmp **result)
+int
+__libc_getutent_r (struct utmp *buffer, struct utmp **result)
 {
   ssize_t nbytes;
 
-  assert (file_fd >= 0);
-
-  if (file_offset == -1l)
+  if (!maybe_setutent () || file_offset == -1l)
     {
       /* Not available.  */
       *result = NULL;
@@ -279,13 +258,11 @@ unlock_return:
 
 /* For implementing this function we don't use the getutent_r function
    because we can avoid the reposition on every new entry this way.  */
-static int
-getutid_r_file (const struct utmp *id, struct utmp *buffer,
-		struct utmp **result)
+int
+__libc_getutid_r (const struct utmp *id, struct utmp *buffer,
+		  struct utmp **result)
 {
-  assert (file_fd >= 0);
-
-  if (file_offset == -1l)
+  if (!maybe_setutent () || file_offset == -1l)
     {
       *result = NULL;
       return -1;
@@ -309,13 +286,11 @@ getutid_r_file (const struct utmp *id, struct utmp *buffer,
 
 /* For implementing this function we don't use the getutent_r function
    because we can avoid the reposition on every new entry this way.  */
-static int
-getutline_r_file (const struct utmp *line, struct utmp *buffer,
-		  struct utmp **result)
+int
+__libc_getutline_r (const struct utmp *line, struct utmp *buffer,
+		    struct utmp **result)
 {
-  assert (file_fd >= 0);
-
-  if (file_offset == -1l)
+  if (!maybe_setutent () || file_offset == -1l)
     {
       *result = NULL;
       return -1;
@@ -361,15 +336,16 @@ unlock_return:
 }
 
 
-static struct utmp *
-pututline_file (const struct utmp *data)
+struct utmp *
+__libc_pututline (const struct utmp *data)
 {
+  if (!maybe_setutent ())
+    return NULL;
+
   struct utmp buffer;
   struct utmp *pbuf;
   int found;
 
-  assert (file_fd >= 0);
-
   if (! file_writable)
     {
       /* We must make the file descriptor writable before going on.  */
@@ -467,18 +443,19 @@ pututline_file (const struct utmp *data)
 }
 
 
-static void
-endutent_file (void)
+void
+__libc_endutent (void)
 {
-  assert (file_fd >= 0);
-
-  __close_nocancel_nostatus (file_fd);
-  file_fd = -1;
+  if (file_fd >= 0)
+    {
+      __close_nocancel_nostatus (file_fd);
+      file_fd = -1;
+    }
 }
 
 
-static int
-updwtmp_file (const char *file, const struct utmp *utmp)
+int
+__libc_updwtmp (const char *file, const struct utmp *utmp)
 {
   int result = -1;
   off64_t offset;
diff --git a/login/utmpname.c b/login/utmpname.c
index c3da183d5b..8f94b19caf 100644
--- a/login/utmpname.c
+++ b/login/utmpname.c
@@ -42,8 +42,7 @@ __utmpname (const char *file)
   __libc_lock_lock (__libc_utmp_lock);
 
   /* Close the old file.  */
-  (*__libc_utmp_jump_table->endutent) ();
-  __libc_utmp_jump_table = &__libc_utmp_unknown_functions;
+  __libc_endutent ();
 
   if (strcmp (file, __libc_utmp_file_name) != 0)
     {
diff --git a/manual/users.texi b/manual/users.texi
index 96ed2065b7..ec22ce6c1c 100644
--- a/manual/users.texi
+++ b/manual/users.texi
@@ -894,9 +894,9 @@ The @code{getlogin} function is declared in @file{unistd.h}, while
 @c   ttyname_r dup @ascuheap @acsmem @acsfd
 @c   strncpy dup ok
 @c   libc_lock_lock dup @asulock @aculock
-@c   *libc_utmp_jump_table->setutent dup @mtasurace:utent @acsfd
-@c   *libc_utmp_jump_table->getutline_r dup @mtasurace:utent @mtascusig:ALRM @mtascutimer
-@c   *libc_utmp_jump_table->endutent dup @mtasurace:utent @asulock @aculock
+@c   __libc_setutent dup @mtasurace:utent @acsfd
+@c   __libc_getutline_r dup @mtasurace:utent @mtascusig:ALRM @mtascutimer
+@c   __libc_endutent dup @mtasurace:utent @asulock @aculock
 @c   libc_lock_unlock dup ok
 @c   strlen dup ok
 @c   memcpy dup ok
@@ -1111,7 +1111,7 @@ compatibility only, @file{utmp.h} defines @code{ut_time} as an alias for
 
 @c setutent @mtasurace:utent @asulock @aculock @acsfd
 @c  libc_lock_lock dup @asulock @aculock
-@c  *libc_utmp_jump_table->setutent @mtasurace:utent @acsfd
+@c  __libc_setutent @mtasurace:utent @acsfd
 @c   setutent_unknown @mtasurace:utent @acsfd
 @c    *libc_utmp_file_functions.setutent = setutent_file @mtasurace:utent @acsfd
 @c      open_not_cancel_2 dup @acsfd
@@ -1152,7 +1152,7 @@ A null pointer is returned in case no further entry is available.
 @safety{@prelim{}@mtunsafe{@mtasurace{:utent}}@asunsafe{@asulock{}}@acunsafe{@aculock{} @acsfd{}}}
 @c endutent @mtasurace:utent @asulock @aculock @acsfd
 @c  libc_lock_lock dup @asulock @aculock
-@c  *libc_utmp_jump_table->endutent @mtasurace:utent @acsfd
+@c  __libc_endutent @mtasurace:utent @acsfd
 @c   endutent_unknown ok
 @c   endutent_file @mtasurace:utent @acsfd
 @c    close_not_cancel_no_status dup @acsfd
@@ -1230,7 +1230,7 @@ over again.
 @safety{@prelim{}@mtunsafe{@mtasurace{:utent} @mtascusig{:ALRM} @mtascutimer{}}@asunsafe{@asulock{}}@acunsafe{@aculock{} @acsfd{}}}
 @c pututline @mtasurace:utent @mtascusig:ALRM @mtascutimer @asulock @aculock @acsfd
 @c  libc_lock_lock dup @asulock @aculock
-@c  *libc_utmp_jump_table->pututline @mtasurace:utent @mtascusig:ALRM @mtascutimer @acsfd
+@c  __libc_pututline @mtasurace:utent @mtascusig:ALRM @mtascutimer @acsfd
 @c   pututline_unknown @mtasurace:utent @acsfd
 @c    setutent_unknown dup @mtasurace:utent @acsfd
 @c   pututline_file @mtascusig:ALRM @mtascutimer @acsfd
@@ -1282,7 +1282,7 @@ user-provided buffer.
 @safety{@prelim{}@mtunsafe{@mtasurace{:utent} @mtascusig{:ALRM} @mtascutimer{}}@asunsafe{@asulock{}}@acunsafe{@aculock{} @acsfd{}}}
 @c getutent_r @mtasurace:utent @mtascusig:ALRM @mtascutimer @asulock @aculock @acsfd
 @c  libc_lock_lock dup @asulock @aculock
-@c  *libc_utmp_jump_table->getutent_r @mtasurace:utent @mtascusig:ALRM @mtascutimer @acsfd
+@c  __libc_getutent_r @mtasurace:utent @mtascusig:ALRM @mtascutimer @acsfd
 @c   getutent_r_unknown @mtasurace:utent @acsfd
 @c    setutent_unknown dup @mtasurace:utent @acsfd
 @c   getutent_r_file @mtasurace:utent @mtascusig:ALRM @mtascutimer
@@ -1319,7 +1319,7 @@ This function is a GNU extension.
 @safety{@prelim{}@mtunsafe{@mtasurace{:utent} @mtascusig{:ALRM} @mtascutimer{}}@asunsafe{@asulock{}}@acunsafe{@aculock{} @acsfd{}}}
 @c getutid_r @mtasurace:utent @mtascusig:ALRM @mtascutimer @asulock @aculock @acsfd
 @c  libc_lock_lock dup @asulock @aculock
-@c  *libc_utmp_jump_table->getutid_r @mtasurace:utent @mtascusig:ALRM @mtascutimer @acsfd
+@c  __libc_getutid_r @mtasurace:utent @mtascusig:ALRM @mtascutimer @acsfd
 @c   getutid_r_unknown @mtasurace:utent @acsfd
 @c    setutent_unknown dup @mtasurace:utent @acsfd
 @c   getutid_r_file @mtascusig:ALRM @mtascutimer
@@ -1349,7 +1349,7 @@ This function is a GNU extension.
 @safety{@prelim{}@mtunsafe{@mtasurace{:utent} @mtascusig{:ALRM} @mtascutimer{}}@asunsafe{@asulock{}}@acunsafe{@aculock{} @acsfd{}}}
 @c getutline_r @mtasurace:utent @mtascusig:ALRM @mtascutimer @asulock @aculock @acsfd
 @c  libc_lock_lock dup @asulock @aculock
-@c  *libc_utmp_jump_table->getutline_r @mtasurace:utent @mtascusig:ALRM @mtascutimer @acsfd
+@c  __libc_getutline_r @mtasurace:utent @mtascusig:ALRM @mtascutimer @acsfd
 @c   getutline_r_unknown @mtasurace:utent @acsfd
 @c    setutent_unknown dup @mtasurace:utent @acsfd
 @c   getutline_r_file @mtasurace:utent @mtascusig:ALRM @mtascutimer
@@ -1393,7 +1393,7 @@ be used.
 @safety{@prelim{}@mtunsafe{@mtasurace{:utent}}@asunsafe{@asulock{} @ascuheap{}}@acunsafe{@aculock{} @acsmem{}}}
 @c utmpname @mtasurace:utent @asulock @ascuheap @aculock @acsmem
 @c  libc_lock_lock dup @asulock @aculock
-@c  *libc_utmp_jump_table->endutent dup @mtasurace:utent
+@c  __libc_endutent dup @mtasurace:utent
 @c  strcmp dup ok
 @c  free dup @ascuheap @acsmem
 @c  strdup dup @ascuheap @acsmem
diff --git a/sysdeps/unix/getlogin_r.c b/sysdeps/unix/getlogin_r.c
index 6c564d3b59..88971a9931 100644
--- a/sysdeps/unix/getlogin_r.c
+++ b/sysdeps/unix/getlogin_r.c
@@ -64,8 +64,8 @@ __getlogin_r (char *name, size_t name_len)
      held so that our search is thread-safe.  */
 
   __libc_lock_lock (__libc_utmp_lock);
-  (*__libc_utmp_jump_table->setutent) ();
-  result = (*__libc_utmp_jump_table->getutline_r) (&line, &buffer, &ut);
+  __libc_setutent ();
+  result = __libc_getutline_r (&line, &buffer, &ut);
   if (result < 0)
     {
       if (errno == ESRCH)
@@ -74,8 +74,7 @@ __getlogin_r (char *name, size_t name_len)
       else
 	result = errno;
     }
-  (*__libc_utmp_jump_table->endutent) ();
-  __libc_utmp_jump_table = &__libc_utmp_unknown_functions;
+  __libc_endutent ();
   __libc_lock_unlock (__libc_utmp_lock);
 
   if (result == 0)

commit 799f4baa1d81070573bff947f7ce204e50d44a42
Author: Florian Weimer <fweimer@redhat.com>
Date:   Tue Aug 13 12:09:32 2019 +0200

    login: Assume that _HAVE_UT_* constants are true
    
    Make the GNU version of bits/utmp.h the generic version because
    all remaining ports use it (with a sysdeps override for
    Linux s390/s390x).
    
    (cherry picked from commit a33b817f13170b5c24263b92e7e09880fe797d7e)

diff --git a/ChangeLog b/ChangeLog
index 01037bff1f..0941108937 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,29 @@
+2019-08-13  Florian Weimer  <fweimer@redhat.com>
+
+	* login/getutid_r.c (__getutid_r): _HAVE_UT_ID and _HAVE_UT_TYPE
+	are always true.
+	* login/getutmp.c (getutmp): _HAVE_UT_TYPE, _HAVE_UT_PID,
+	_HAVE_UT_ID, _HAVE_UT_HOST, _HAVE_UT_TV are always true.
+	* login/getutmpx.c (getutmpx): Likewise.
+	* login/login.c (login): _HAVE_UT_TYPE, _HAVE_UT_PID are always
+	true.
+	* login/logout.c (logout): _HAVE_UT_TYPE, _HAVE_UT_HOST,
+	_HAVE_UT_TV are always true.
+	* login/logwtmp.c (logwtmp): _HAVE_UT_PID, _HAVE_UT_TYPE,
+	_HAVE_UT_HOST, _HAVE_UT_TV are always true.
+	* login/tst-utmp.c: _HAVE_UT_TYPE, _HAVE_UT_TV are always true.
+	* login/utmp_file.c (__libc_setutent): _HAVE_UT_TYPE, _HAVE_UT_ID
+	are always true.
+	(internal_getut_r): _HAVE_UT_TYPE is always true.
+	(__libc_pututline): Likewise.
+	* login/programs/utmpdump.c (print_entry): Assume that
+	_HAVE_UT_TYPE, _HAVE_UT_PID, _HAVE_UT_ID, _HAVE_UT_HOST,
+	_HAVE_UT_TV are always true.
+	* sysdeps/generic/utmp-equal.h (__utmp_equal): _HAVE_UT_TYPE,
+	_HAVE_UT_ID are always true.
+	* sysdeps/gnu/bits/utmp.h: Move to ...
+	* bits/utmp.h: ... here, replacing the old file.
+
 2019-08-05  Florian Weimer  <fweimer@redhat.com>
 
 	[BZ #23518]
diff --git a/bits/utmp.h b/bits/utmp.h
index 4c36ca19ce..3c02dd4f3f 100644
--- a/bits/utmp.h
+++ b/bits/utmp.h
@@ -1,4 +1,4 @@
-/* The `struct utmp' type, describing entries in the utmp file.  Generic/BSDish
+/* The `struct utmp' type, describing entries in the utmp file.
    Copyright (C) 1993-2019 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -21,29 +21,106 @@
 #endif
 
 #include <paths.h>
-#include <time.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <bits/wordsize.h>
 
 
-#define	UT_NAMESIZE	8
-#define	UT_LINESIZE	8
-#define	UT_HOSTSIZE	16
+#define UT_LINESIZE	32
+#define UT_NAMESIZE	32
+#define UT_HOSTSIZE	256
 
 
+/* The structure describing an entry in the database of
+   previous logins.  */
 struct lastlog
   {
-    time_t ll_time;
+#if __WORDSIZE_TIME64_COMPAT32
+    int32_t ll_time;
+#else
+    __time_t ll_time;
+#endif
     char ll_line[UT_LINESIZE];
     char ll_host[UT_HOSTSIZE];
   };
 
-struct utmp
+
+/* The structure describing the status of a terminated process.  This
+   type is used in `struct utmp' below.  */
+struct exit_status
   {
-    char ut_line[UT_LINESIZE];
-    char ut_user[UT_NAMESIZE];
-#define ut_name ut_user
-    char ut_host[UT_HOSTSIZE];
-    long int ut_time;
+    short int e_termination;	/* Process termination status.  */
+    short int e_exit;		/* Process exit status.  */
   };
 
 
-#define _HAVE_UT_HOST 1		/* We have the ut_host field.  */
+/* The structure describing an entry in the user accounting database.  */
+struct utmp
+{
+  short int ut_type;		/* Type of login.  */
+  pid_t ut_pid;			/* Process ID of login process.  */
+  char ut_line[UT_LINESIZE]
+    __attribute_nonstring__;	/* Devicename.  */
+  char ut_id[4];		/* Inittab ID.  */
+  char ut_user[UT_NAMESIZE]
+    __attribute_nonstring__;	/* Username.  */
+  char ut_host[UT_HOSTSIZE]
+    __attribute_nonstring__;	/* Hostname for remote login.  */
+  struct exit_status ut_exit;	/* Exit status of a process marked
+				   as DEAD_PROCESS.  */
+/* The ut_session and ut_tv fields must be the same size when compiled
+   32- and 64-bit.  This allows data files and shared memory to be
+   shared between 32- and 64-bit applications.  */
+#if __WORDSIZE_TIME64_COMPAT32
+  int32_t ut_session;		/* Session ID, used for windowing.  */
+  struct
+  {
+    int32_t tv_sec;		/* Seconds.  */
+    int32_t tv_usec;		/* Microseconds.  */
+  } ut_tv;			/* Time entry was made.  */
+#else
+  long int ut_session;		/* Session ID, used for windowing.  */
+  struct timeval ut_tv;		/* Time entry was made.  */
+#endif
+
+  int32_t ut_addr_v6[4];	/* Internet address of remote host.  */
+  char __glibc_reserved[20];		/* Reserved for future use.  */
+};
+
+/* Backwards compatibility hacks.  */
+#define ut_name		ut_user
+#ifndef _NO_UT_TIME
+/* We have a problem here: `ut_time' is also used otherwise.  Define
+   _NO_UT_TIME if the compiler complains.  */
+# define ut_time	ut_tv.tv_sec
+#endif
+#define ut_xtime	ut_tv.tv_sec
+#define ut_addr		ut_addr_v6[0]
+
+
+/* Values for the `ut_type' field of a `struct utmp'.  */
+#define EMPTY		0	/* No valid user accounting information.  */
+
+#define RUN_LVL		1	/* The system's runlevel.  */
+#define BOOT_TIME	2	/* Time of system boot.  */
+#define NEW_TIME	3	/* Time after system clock changed.  */
+#define OLD_TIME	4	/* Time when system clock changed.  */
+
+#define INIT_PROCESS	5	/* Process spawned by the init process.  */
+#define LOGIN_PROCESS	6	/* Session leader of a logged in user.  */
+#define USER_PROCESS	7	/* Normal process.  */
+#define DEAD_PROCESS	8	/* Terminated process.  */
+
+#define ACCOUNTING	9
+
+/* Old Linux name for the EMPTY type.  */
+#define UT_UNKNOWN	EMPTY
+
+
+/* Tell the user that we have a modern system with UT_HOST, UT_PID,
+   UT_TYPE, UT_ID and UT_TV fields.  */
+#define _HAVE_UT_TYPE	1
+#define _HAVE_UT_PID	1
+#define _HAVE_UT_ID	1
+#define _HAVE_UT_TV	1
+#define _HAVE_UT_HOST	1
diff --git a/login/getutid_r.c b/login/getutid_r.c
index 86ffc85b01..460d94be0c 100644
--- a/login/getutid_r.c
+++ b/login/getutid_r.c
@@ -32,7 +32,6 @@ __libc_lock_define (extern, __libc_utmp_lock attribute_hidden)
 int
 __getutid_r (const struct utmp *id, struct utmp *buffer, struct utmp **result)
 {
-#if (_HAVE_UT_ID - 0) && (_HAVE_UT_TYPE - 0)
   int retval;
 
   /* Test whether ID has any of the legal types.  */
@@ -54,10 +53,6 @@ __getutid_r (const struct utmp *id, struct utmp *buffer, struct utmp **result)
   __libc_lock_unlock (__libc_utmp_lock);
 
   return retval;
-#else	/* !_HAVE_UT_ID && !_HAVE_UT_TYPE */
-  __set_errno (ENOSYS);
-  return -1;
-#endif
 }
 libc_hidden_def (__getutid_r)
 weak_alias (__getutid_r, getutid_r)
diff --git a/login/getutmp.c b/login/getutmp.c
index 73bc15d781..4e3be11216 100644
--- a/login/getutmp.c
+++ b/login/getutmp.c
@@ -23,23 +23,11 @@
 void
 getutmp (const struct utmpx *utmpx, struct utmp *utmp)
 {
-#if _HAVE_UT_TYPE - 0
   utmp->ut_type = utmpx->ut_type;
-#endif
-#if _HAVE_UT_PID - 0
   utmp->ut_pid = utmpx->ut_pid;
-#endif
   memcpy (utmp->ut_line, utmpx->ut_line, sizeof (utmp->ut_line));
   memcpy (utmp->ut_user, utmpx->ut_user, sizeof (utmp->ut_user));
-#if _HAVE_UT_ID - 0
   memcpy (utmp->ut_id, utmpx->ut_id, sizeof (utmp->ut_id));
-#endif
-#if _HAVE_UT_HOST - 0
   memcpy (utmp->ut_host, utmpx->ut_host, sizeof (utmp->ut_host));
-#endif
-#if _HAVE_UT_TV - 0
   utmp->ut_tv = utmpx->ut_tv;
-#else
-  utmp->ut_time = utmpx->ut_time;
-#endif
 }
diff --git a/login/getutmpx.c b/login/getutmpx.c
index b181d9bc30..da28d339ab 100644
--- a/login/getutmpx.c
+++ b/login/getutmpx.c
@@ -24,24 +24,11 @@ void
 getutmpx (const struct utmp *utmp, struct utmpx *utmpx)
 {
   memset (utmpx, 0, sizeof (struct utmpx));
-
-#if _HAVE_UT_TYPE - 0
   utmpx->ut_type = utmp->ut_type;
-#endif
-#if _HAVE_UT_PID - 0
   utmpx->ut_pid = utmp->ut_pid;
-#endif
   memcpy (utmpx->ut_line, utmp->ut_line, sizeof (utmp->ut_line));
   memcpy (utmpx->ut_user, utmp->ut_user, sizeof (utmp->ut_user));
-#if _HAVE_UT_ID - 0
   memcpy (utmpx->ut_id, utmp->ut_id, sizeof (utmp->ut_id));
-#endif
-#if _HAVE_UT_HOST - 0
   memcpy (utmpx->ut_host, utmp->ut_host, sizeof (utmp->ut_host));
-#endif
-#if _HAVE_UT_TV - 0
   utmpx->ut_tv = utmp->ut_tv;
-#else
-  utmpx->ut_time = utmp->ut_time;
-#endif
 }
diff --git a/login/login.c b/login/login.c
index 09ef3f75a5..b7d638c692 100644
--- a/login/login.c
+++ b/login/login.c
@@ -91,12 +91,8 @@ login (const struct utmp *ut)
   struct utmp copy = *ut;
 
   /* Fill in those fields we supply.  */
-#if _HAVE_UT_TYPE - 0
   copy.ut_type = USER_PROCESS;
-#endif
-#if _HAVE_UT_PID - 0
   copy.ut_pid = getpid ();
-#endif
 
   /* Seek tty.  */
   found_tty = tty_name (STDIN_FILENO, &tty, sizeof (_tty));
diff --git a/login/logout.c b/login/logout.c
index 85254d0324..5015c1af0b 100644
--- a/login/logout.c
+++ b/login/logout.c
@@ -36,9 +36,7 @@ logout (const char *line)
   setutent ();
 
   /* Fill in search information.  */
-#if _HAVE_UT_TYPE - 0
   tmp.ut_type = USER_PROCESS;
-#endif
   strncpy (tmp.ut_line, line, sizeof tmp.ut_line);
 
   /* Read the record.  */
@@ -46,20 +44,12 @@ logout (const char *line)
     {
       /* Clear information about who & from where.  */
       memset (ut->ut_name, '\0', sizeof ut->ut_name);
-#if _HAVE_UT_HOST - 0
       memset (ut->ut_host, '\0', sizeof ut->ut_host);
-#endif
-#if _HAVE_UT_TV - 0
       struct timeval tv;
       __gettimeofday (&tv, NULL);
       ut->ut_tv.tv_sec = tv.tv_sec;
       ut->ut_tv.tv_usec = tv.tv_usec;
-#else
-      ut->ut_time = time (NULL);
-#endif
-#if _HAVE_UT_TYPE - 0
       ut->ut_type = DEAD_PROCESS;
-#endif
 
       if (pututline (ut) != NULL)
 	result = 1;
diff --git a/login/logwtmp.c b/login/logwtmp.c
index f53187121c..50d14976c7 100644
--- a/login/logwtmp.c
+++ b/login/logwtmp.c
@@ -30,26 +30,16 @@ logwtmp (const char *line, const char *name, const char *host)
 
   /* Set information in new entry.  */
   memset (&ut, 0, sizeof (ut));
-#if _HAVE_UT_PID - 0
   ut.ut_pid = getpid ();
-#endif
-#if _HAVE_UT_TYPE - 0
   ut.ut_type = name[0] ? USER_PROCESS : DEAD_PROCESS;
-#endif
   strncpy (ut.ut_line, line, sizeof ut.ut_line);
   strncpy (ut.ut_name, name, sizeof ut.ut_name);
-#if _HAVE_UT_HOST - 0
   strncpy (ut.ut_host, host, sizeof ut.ut_host);
-#endif
 
-#if _HAVE_UT_TV - 0
   struct timeval tv;
   __gettimeofday (&tv, NULL);
   ut.ut_tv.tv_sec = tv.tv_sec;
   ut.ut_tv.tv_usec = tv.tv_usec;
-#else
-  ut.ut_time = time (NULL);
-#endif
 
   updwtmp (_PATH_WTMP, &ut);
 }
diff --git a/login/programs/utmpdump.c b/login/programs/utmpdump.c
index 4c312f0939..85d8e31b43 100644
--- a/login/programs/utmpdump.c
+++ b/login/programs/utmpdump.c
@@ -37,47 +37,11 @@ print_entry (struct utmp *up)
   temp_tv.tv_sec = up->ut_tv.tv_sec;
   temp_tv.tv_usec = up->ut_tv.tv_usec;
 
-  (printf) (
-	    /* The format string.  */
-#if _HAVE_UT_TYPE
-	    "[%d] "
-#endif
-#if _HAVE_UT_PID
-	    "[%05d] "
-#endif
-#if _HAVE_UT_ID
-	    "[%-4.4s] "
-#endif
-	    "[%-8.8s] [%-12.12s]"
-#if _HAVE_UT_HOST
-	    " [%-16.16s]"
-#endif
-	    " [%-15.15s]"
-#if _HAVE_UT_TV
-	    " [%ld]"
-#endif
-	    "\n"
-	    /* The arguments.  */
-#if _HAVE_UT_TYPE
-	    , up->ut_type
-#endif
-#if _HAVE_UT_PID
-	    , up->ut_pid
-#endif
-#if _HAVE_UT_ID
-	    , up->ut_id
-#endif
-	    , up->ut_user, up->ut_line
-#if _HAVE_UT_HOST
-	    , up->ut_host
-#endif
-#if _HAVE_UT_TV
-	    , 4 + ctime (&temp_tv.tv_sec)
-	    , (long int) temp_tv.tv_usec
-#else
-	    , 4 + ctime (&up->ut_time)
-#endif
-	   );
+  printf ("[%d] [%05d] [%-4.4s] [%-8.8s] [%-12.12s] [%-16.16s] [%-15.15s]"
+	  " [%ld]\n",
+	  up->ut_type, up->ut_pid, up->ut_id, up->ut_user, up->ut_line,
+	  up->ut_host, 4 + ctime (&temp_tv.tv_sec),
+	  (long int) temp_tv.tv_usec);
 }
 
 int
diff --git a/login/tst-utmp.c b/login/tst-utmp.c
index ce48e8326e..02d0c1fe8c 100644
--- a/login/tst-utmp.c
+++ b/login/tst-utmp.c
@@ -39,8 +39,6 @@
 #endif
 
 
-#if defined UTMPX || _HAVE_UT_TYPE
-
 /* Prototype for our test function.  */
 static int do_test (int argc, char *argv[]);
 
@@ -75,11 +73,7 @@ do_prepare (int argc, char *argv[])
 
 struct utmp entry[] =
 {
-#if defined UTMPX || _HAVE_UT_TV
 #define UT(a)  .ut_tv = { .tv_sec = (a)}
-#else
-#define UT(a)  .ut_time = (a)
-#endif
 
   { .ut_type = BOOT_TIME, .ut_pid = 1, UT(1000) },
   { .ut_type = RUN_LVL, .ut_pid = 1, UT(2000) },
@@ -167,11 +161,7 @@ simulate_login (const char *line, const char *user)
 	    entry[n].ut_pid = (entry_pid += 27);
 	  entry[n].ut_type = USER_PROCESS;
 	  strncpy (entry[n].ut_user, user, sizeof (entry[n].ut_user));
-#if defined UTMPX || _HAVE_UT_TV - 0
 	  entry[n].ut_tv.tv_sec = (entry_time += 1000);
-#else
-          entry[n].ut_time = (entry_time += 1000);
-#endif
 	  setutent ();
 
 	  if (pututline (&entry[n]) == NULL)
@@ -201,11 +191,7 @@ simulate_logout (const char *line)
 	{
 	  entry[n].ut_type = DEAD_PROCESS;
 	  strncpy (entry[n].ut_user, "", sizeof (entry[n].ut_user));
-#if defined UTMPX || _HAVE_UT_TV - 0
           entry[n].ut_tv.tv_sec = (entry_time += 1000);
-#else
-          entry[n].ut_time = (entry_time += 1000);
-#endif
 	  setutent ();
 
 	  if (pututline (&entry[n]) == NULL)
@@ -390,14 +376,3 @@ do_test (int argc, char *argv[])
 
   return result;
 }
-
-#else
-
-/* No field 'ut_type' in struct utmp.  */
-int
-main (void)
-{
-  return 0;
-}
-
-#endif
diff --git a/login/utmp_file.c b/login/utmp_file.c
index cb8a02825c..9badf11fb3 100644
--- a/login/utmp_file.c
+++ b/login/utmp_file.c
@@ -129,14 +129,7 @@ __libc_setutent (void)
   file_offset = 0;
 
   /* Make sure the entry won't match.  */
-#if _HAVE_UT_TYPE - 0
   last_entry.ut_type = -1;
-#else
-  last_entry.ut_line[0] = '\177';
-# if _HAVE_UT_ID - 0
-  last_entry.ut_id[0] = '\0';
-# endif
-#endif
 
   return 1;
 }
@@ -201,7 +194,6 @@ internal_getut_r (const struct utmp *id, struct utmp *buffer,
       LOCKING_FAILED ();
     }
 
-#if _HAVE_UT_TYPE - 0
   if (id->ut_type == RUN_LVL || id->ut_type == BOOT_TIME
       || id->ut_type == OLD_TIME || id->ut_type == NEW_TIME)
     {
@@ -225,7 +217,6 @@ internal_getut_r (const struct utmp *id, struct utmp *buffer,
 	}
     }
   else
-#endif /* _HAVE_UT_TYPE */
     {
       /* Search for the next entry with the specified ID and with type
 	 INIT_PROCESS, LOGIN_PROCESS, USER_PROCESS, or DEAD_PROCESS.  */
@@ -316,13 +307,10 @@ __libc_getutline_r (const struct utmp *line, struct utmp *buffer,
       file_offset += sizeof (struct utmp);
 
       /* Stop if we found a user or login entry.  */
-      if (
-#if _HAVE_UT_TYPE - 0
-	  (last_entry.ut_type == USER_PROCESS
+      if ((last_entry.ut_type == USER_PROCESS
 	   || last_entry.ut_type == LOGIN_PROCESS)
-	  &&
-#endif
-	  !strncmp (line->ut_line, last_entry.ut_line, sizeof line->ut_line))
+	  && (strncmp (line->ut_line, last_entry.ut_line, sizeof line->ut_line)
+	      == 0))
 	break;
     }
 
@@ -368,16 +356,12 @@ __libc_pututline (const struct utmp *data)
 
   /* Find the correct place to insert the data.  */
   if (file_offset > 0
-      && (
-#if _HAVE_UT_TYPE - 0
-	  (last_entry.ut_type == data->ut_type
+      && ((last_entry.ut_type == data->ut_type
 	   && (last_entry.ut_type == RUN_LVL
 	       || last_entry.ut_type == BOOT_TIME
 	       || last_entry.ut_type == OLD_TIME
 	       || last_entry.ut_type == NEW_TIME))
-	  ||
-#endif
-	  __utmp_equal (&last_entry, data)))
+	  || __utmp_equal (&last_entry, data)))
     found = 1;
   else
     {
diff --git a/sysdeps/generic/utmp-equal.h b/sysdeps/generic/utmp-equal.h
index d077147a7a..d61cbb3300 100644
--- a/sysdeps/generic/utmp-equal.h
+++ b/sysdeps/generic/utmp-equal.h
@@ -27,26 +27,16 @@
 static int
 __utmp_equal (const struct utmp *entry, const struct utmp *match)
 {
-  return
-    (
-#if _HAVE_UT_TYPE - 0
-     (entry->ut_type == INIT_PROCESS
-      || entry->ut_type == LOGIN_PROCESS
-      || entry->ut_type == USER_PROCESS
-      || entry->ut_type == DEAD_PROCESS)
-     &&
-     (match->ut_type == INIT_PROCESS
-      || match->ut_type == LOGIN_PROCESS
-      || match->ut_type == USER_PROCESS
-      || match->ut_type == DEAD_PROCESS)
-     &&
-#endif
-#if _HAVE_UT_ID - 0
-     (entry->ut_id[0] && match->ut_id[0]
-      ? strncmp (entry->ut_id, match->ut_id, sizeof match->ut_id) == 0
-      : strncmp (entry->ut_line, match->ut_line, sizeof match->ut_line) == 0)
-#else
-     strncmp (entry->ut_line, match->ut_line, sizeof match->ut_line) == 0
-#endif
-     );
+  return (entry->ut_type == INIT_PROCESS
+          || entry->ut_type == LOGIN_PROCESS
+          || entry->ut_type == USER_PROCESS
+          || entry->ut_type == DEAD_PROCESS)
+    && (match->ut_type == INIT_PROCESS
+        || match->ut_type == LOGIN_PROCESS
+        || match->ut_type == USER_PROCESS
+        || match->ut_type == DEAD_PROCESS)
+    && (entry->ut_id[0] && match->ut_id[0]
+        ? strncmp (entry->ut_id, match->ut_id, sizeof match->ut_id) == 0
+        : (strncmp (entry->ut_line, match->ut_line, sizeof match->ut_line)
+           == 0));
 }
diff --git a/sysdeps/gnu/bits/utmp.h b/sysdeps/gnu/bits/utmp.h
deleted file mode 100644
index 7357034cb6..0000000000
--- a/sysdeps/gnu/bits/utmp.h
+++ /dev/null
@@ -1,126 +0,0 @@
-/* The `struct utmp' type, describing entries in the utmp file.  GNU version.
-   Copyright (C) 1993-2019 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _UTMP_H
-# error "Never include <bits/utmp.h> directly; use <utmp.h> instead."
-#endif
-
-#include <paths.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <bits/wordsize.h>
-
-
-#define UT_LINESIZE	32
-#define UT_NAMESIZE	32
-#define UT_HOSTSIZE	256
-
-
-/* The structure describing an entry in the database of
-   previous logins.  */
-struct lastlog
-  {
-#if __WORDSIZE_TIME64_COMPAT32
-    int32_t ll_time;
-#else
-    __time_t ll_time;
-#endif
-    char ll_line[UT_LINESIZE];
-    char ll_host[UT_HOSTSIZE];
-  };
-
-
-/* The structure describing the status of a terminated process.  This
-   type is used in `struct utmp' below.  */
-struct exit_status
-  {
-    short int e_termination;	/* Process termination status.  */
-    short int e_exit;		/* Process exit status.  */
-  };
-
-
-/* The structure describing an entry in the user accounting database.  */
-struct utmp
-{
-  short int ut_type;		/* Type of login.  */
-  pid_t ut_pid;			/* Process ID of login process.  */
-  char ut_line[UT_LINESIZE]
-    __attribute_nonstring__;	/* Devicename.  */
-  char ut_id[4];		/* Inittab ID.  */
-  char ut_user[UT_NAMESIZE]
-    __attribute_nonstring__;	/* Username.  */
-  char ut_host[UT_HOSTSIZE]
-    __attribute_nonstring__;	/* Hostname for remote login.  */
-  struct exit_status ut_exit;	/* Exit status of a process marked
-				   as DEAD_PROCESS.  */
-/* The ut_session and ut_tv fields must be the same size when compiled
-   32- and 64-bit.  This allows data files and shared memory to be
-   shared between 32- and 64-bit applications.  */
-#if __WORDSIZE_TIME64_COMPAT32
-  int32_t ut_session;		/* Session ID, used for windowing.  */
-  struct
-  {
-    int32_t tv_sec;		/* Seconds.  */
-    int32_t tv_usec;		/* Microseconds.  */
-  } ut_tv;			/* Time entry was made.  */
-#else
-  long int ut_session;		/* Session ID, used for windowing.  */
-  struct timeval ut_tv;		/* Time entry was made.  */
-#endif
-
-  int32_t ut_addr_v6[4];	/* Internet address of remote host.  */
-  char __glibc_reserved[20];		/* Reserved for future use.  */
-};
-
-/* Backwards compatibility hacks.  */
-#define ut_name		ut_user
-#ifndef _NO_UT_TIME
-/* We have a problem here: `ut_time' is also used otherwise.  Define
-   _NO_UT_TIME if the compiler complains.  */
-# define ut_time	ut_tv.tv_sec
-#endif
-#define ut_xtime	ut_tv.tv_sec
-#define ut_addr		ut_addr_v6[0]
-
-
-/* Values for the `ut_type' field of a `struct utmp'.  */
-#define EMPTY		0	/* No valid user accounting information.  */
-
-#define RUN_LVL		1	/* The system's runlevel.  */
-#define BOOT_TIME	2	/* Time of system boot.  */
-#define NEW_TIME	3	/* Time after system clock changed.  */
-#define OLD_TIME	4	/* Time when system clock changed.  */
-
-#define INIT_PROCESS	5	/* Process spawned by the init process.  */
-#define LOGIN_PROCESS	6	/* Session leader of a logged in user.  */
-#define USER_PROCESS	7	/* Normal process.  */
-#define DEAD_PROCESS	8	/* Terminated process.  */
-
-#define ACCOUNTING	9
-
-/* Old Linux name for the EMPTY type.  */
-#define UT_UNKNOWN	EMPTY
-
-
-/* Tell the user that we have a modern system with UT_HOST, UT_PID,
-   UT_TYPE, UT_ID and UT_TV fields.  */
-#define _HAVE_UT_TYPE	1
-#define _HAVE_UT_PID	1
-#define _HAVE_UT_ID	1
-#define _HAVE_UT_TV	1
-#define _HAVE_UT_HOST	1

commit 2f02abb81cee4f6ba65d9e1c89e8e26558e0dac0
Author: Florian Weimer <fweimer@redhat.com>
Date:   Tue Aug 13 15:53:19 2019 +0200

    login: Replace macro-based control flow with function calls in utmp
    
    (cherry picked from commit 5a3afa9738f3dbbaf8c0a35665318c1af782111b)

diff --git a/ChangeLog b/ChangeLog
index 0941108937..12a55b7ad3 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,15 @@
+2019-08-13  Florian Weimer  <fweimer@redhat.com>
+
+	* login/utmp_file.c (LOCK_FILE, LOCKING_FAILED, UNLOCK_FILE):
+	Remove macros.
+	(struct file_locking): New.
+	(try_file_lock, file_unlock, file_lock_restore): New functions.
+	(__libc_getutent_r): Use the new functions.
+	(internal_getut_r): Likewise.
+	(__libc_getutline_r): Likewise.
+	(__libc_pututline): Likewise.
+	(__libc_updwtmp): Likewise.
+
 2019-08-13  Florian Weimer  <fweimer@redhat.com>
 
 	* login/getutid_r.c (__getutid_r): _HAVE_UT_ID and _HAVE_UT_TYPE
diff --git a/login/utmp_file.c b/login/utmp_file.c
index 9badf11fb3..7bd6034af4 100644
--- a/login/utmp_file.c
+++ b/login/utmp_file.c
@@ -52,58 +52,71 @@ static struct utmp last_entry;
 /* Do-nothing handler for locking timeout.  */
 static void timeout_handler (int signum) {};
 
-/* LOCK_FILE(fd, type) failure_statement
-     attempts to get a lock on the utmp file referenced by FD.  If it fails,
-     the failure_statement is executed, otherwise it is skipped.
-   LOCKING_FAILED()
-     jumps into the UNLOCK_FILE macro and ensures cleanup of LOCK_FILE.
-   UNLOCK_FILE(fd)
-     unlocks the utmp file referenced by FD and performs the cleanup of
-     LOCK_FILE.
- */
-#define LOCK_FILE(fd, type) \
-{									      \
-  struct flock fl;							      \
-  struct sigaction action, old_action;					      \
-  unsigned int old_timeout;						      \
-									      \
-  /* Cancel any existing alarm.  */					      \
-  old_timeout = alarm (0);						      \
-									      \
-  /* Establish signal handler.  */					      \
-  action.sa_handler = timeout_handler;					      \
-  __sigemptyset (&action.sa_mask);					      \
-  action.sa_flags = 0;							      \
-  __sigaction (SIGALRM, &action, &old_action);				      \
-									      \
-  alarm (TIMEOUT);							      \
-									      \
-  /* Try to get the lock.  */						      \
-  memset (&fl, '\0', sizeof (struct flock));				      \
-  fl.l_type = (type);							      \
-  fl.l_whence = SEEK_SET;						      \
-  if (__fcntl64_nocancel ((fd), F_SETLKW, &fl) < 0)
-
-#define LOCKING_FAILED() \
-  goto unalarm_return
-
-#define UNLOCK_FILE(fd) \
-  /* Unlock the file.  */						      \
-  fl.l_type = F_UNLCK;							      \
-  __fcntl64_nocancel ((fd), F_SETLKW, &fl);				      \
-									      \
- unalarm_return:							      \
-  /* Reset the signal handler and alarm.  We must reset the alarm	      \
-     before resetting the handler so our alarm does not generate a	      \
-     spurious SIGALRM seen by the user.  However, we cannot just set	      \
-     the user's old alarm before restoring the handler, because then	      \
-     it's possible our handler could catch the user alarm's SIGARLM	      \
-     and then the user would never see the signal he expected.  */	      \
-  alarm (0);								      \
-  __sigaction (SIGALRM, &old_action, NULL);				      \
-  if (old_timeout != 0)							      \
-    alarm (old_timeout);						      \
-} while (0)
+
+/* try_file_lock (LOCKING, FD, TYPE) returns true if the locking
+   operation failed and recovery needs to be performed.
+   (file_lock_restore (LOCKING) still needs to be called.)
+
+   file_unlock (FD) removes the lock (which must have been
+   acquired).
+
+   file_lock_restore (LOCKING) is needed to clean up in both
+   cases.  */
+
+struct file_locking
+{
+  struct sigaction old_action;
+  unsigned int old_timeout;
+};
+
+static bool
+try_file_lock (struct file_locking *locking, int fd, int type)
+{
+  /* Cancel any existing alarm.  */
+  locking->old_timeout = alarm (0);
+
+  /* Establish signal handler.  */
+  struct sigaction action;
+  action.sa_handler = timeout_handler;
+  __sigemptyset (&action.sa_mask);
+  action.sa_flags = 0;
+  __sigaction (SIGALRM, &action, &locking->old_action);
+
+  alarm (TIMEOUT);
+
+  /* Try to get the lock.  */
+ struct flock fl =
+   {
+    .l_type = type,
+    fl.l_whence = SEEK_SET,
+   };
+ return __fcntl64_nocancel (fd, F_SETLKW, &fl) < 0;
+}
+
+static void
+file_unlock (int fd)
+{
+  struct flock fl =
+    {
+      .l_type = F_UNLCK,
+    };
+  __fcntl64_nocancel (fd, F_SETLKW, &fl);
+}
+
+static void
+file_lock_restore (struct file_locking *locking)
+{
+  /* Reset the signal handler and alarm.  We must reset the alarm
+     before resetting the handler so our alarm does not generate a
+     spurious SIGALRM seen by the user.  However, we cannot just set
+     the user's old alarm before restoring the handler, because then
+     it's possible our handler could catch the user alarm's SIGARLM
+     and then the user would never see the signal he expected.  */
+  alarm (0);
+  __sigaction (SIGALRM, &locking->old_action, NULL);
+  if (locking->old_timeout != 0)
+    alarm (locking->old_timeout);
+}
 
 #ifndef TRANSFORM_UTMP_FILE_NAME
 # define TRANSFORM_UTMP_FILE_NAME(file_name) (file_name)
@@ -153,16 +166,16 @@ __libc_getutent_r (struct utmp *buffer, struct utmp **result)
       return -1;
     }
 
-  LOCK_FILE (file_fd, F_RDLCK)
+  struct file_locking fl;
+  if (try_file_lock (&fl, file_fd, F_RDLCK))
+    nbytes = 0;
+  else
     {
-      nbytes = 0;
-      LOCKING_FAILED ();
+      /* Read the next entry.  */
+      nbytes = __read_nocancel (file_fd, &last_entry, sizeof (struct utmp));
+      file_unlock (file_fd);
     }
-
-  /* Read the next entry.  */
-  nbytes = __read_nocancel (file_fd, &last_entry, sizeof (struct utmp));
-
-  UNLOCK_FILE (file_fd);
+  file_lock_restore (&fl);
 
   if (nbytes != sizeof (struct utmp))
     {
@@ -188,10 +201,12 @@ internal_getut_r (const struct utmp *id, struct utmp *buffer,
 {
   int result = -1;
 
-  LOCK_FILE (file_fd, F_RDLCK)
+  struct file_locking fl;
+  if (try_file_lock (&fl, file_fd, F_RDLCK))
     {
       *lock_failed = true;
-      LOCKING_FAILED ();
+      file_lock_restore (&fl);
+      return -1;
     }
 
   if (id->ut_type == RUN_LVL || id->ut_type == BOOT_TIME
@@ -241,7 +256,8 @@ internal_getut_r (const struct utmp *id, struct utmp *buffer,
   result = 0;
 
 unlock_return:
-  UNLOCK_FILE (file_fd);
+  file_unlock (file_fd);
+  file_lock_restore (&fl);
 
   return result;
 }
@@ -287,10 +303,12 @@ __libc_getutline_r (const struct utmp *line, struct utmp *buffer,
       return -1;
     }
 
-  LOCK_FILE (file_fd, F_RDLCK)
+  struct file_locking fl;
+  if (try_file_lock (&fl, file_fd, F_RDLCK))
     {
       *result = NULL;
-      LOCKING_FAILED ();
+      file_lock_restore (&fl);
+      return -1;
     }
 
   while (1)
@@ -318,7 +336,8 @@ __libc_getutline_r (const struct utmp *line, struct utmp *buffer,
   *result = buffer;
 
 unlock_return:
-  UNLOCK_FILE (file_fd);
+  file_unlock (file_fd);
+  file_lock_restore (&fl);
 
   return ((*result == NULL) ? -1 : 0);
 }
@@ -375,10 +394,11 @@ __libc_pututline (const struct utmp *data)
 	}
     }
 
-  LOCK_FILE (file_fd, F_WRLCK)
+  struct file_locking fl;
+  if (try_file_lock (&fl, file_fd, F_WRLCK))
     {
-      pbuf = NULL;
-      LOCKING_FAILED ();
+      file_lock_restore (&fl);
+      return NULL;
     }
 
   if (found < 0)
@@ -421,7 +441,8 @@ __libc_pututline (const struct utmp *data)
     }
 
  unlock_return:
-  UNLOCK_FILE (file_fd);
+  file_unlock (file_fd);
+  file_lock_restore (&fl);
 
   return pbuf;
 }
@@ -450,8 +471,13 @@ __libc_updwtmp (const char *file, const struct utmp *utmp)
   if (fd < 0)
     return -1;
 
-  LOCK_FILE (fd, F_WRLCK)
-    LOCKING_FAILED ();
+  struct file_locking fl;
+  if (try_file_lock (&fl, fd, F_WRLCK))
+    {
+      file_lock_restore (&fl);
+      __close_nocancel_nostatus (fd);
+      return -1;
+    }
 
   /* Remember original size of log file.  */
   offset = __lseek64 (fd, 0, SEEK_END);
@@ -477,7 +503,8 @@ __libc_updwtmp (const char *file, const struct utmp *utmp)
   result = 0;
 
 unlock_return:
-  UNLOCK_FILE (fd);
+  file_unlock (file_fd);
+  file_lock_restore (&fl);
 
   /* Close WTMP file.  */
   __close_nocancel_nostatus (fd);

commit 16a576504240b287a2d291fa5267ec1c712c7059
Author: Florian Weimer <fweimer@redhat.com>
Date:   Thu Aug 15 10:30:23 2019 +0200

    login: Fix updwtmp, updwtmx unlocking
    
    Commit 5a3afa9738f3dbbaf8c0a35665318c1af782111b (login: Replace
    macro-based control flow with function calls in utmp) introduced
    a regression because after it, __libc_updwtmp attempts to unlock
    the wrong file descriptor.
    
    (cherry picked from commit 341da5b4b6253de9a7581a066f33f89cacb44dec)

diff --git a/ChangeLog b/ChangeLog
index 12a55b7ad3..d734a35b5b 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,10 @@
+2019-08-15  Florian Weimer  <fweimer@redhat.com>
+
+	* login/utmp_file.c (__libc_updwtmp): Unlock the right file
+	descriptor.
+	* login/Makefile (tests): Add tst-updwtmpx.
+	* login/tst-updwtmpx.c: New file.
+
 2019-08-13  Florian Weimer  <fweimer@redhat.com>
 
 	* login/utmp_file.c (LOCK_FILE, LOCKING_FAILED, UNLOCK_FILE):
diff --git a/login/Makefile b/login/Makefile
index 92535f0aec..f9c4264087 100644
--- a/login/Makefile
+++ b/login/Makefile
@@ -43,7 +43,7 @@ endif
 subdir-dirs = programs
 vpath %.c programs
 
-tests := tst-utmp tst-utmpx tst-grantpt tst-ptsname tst-getlogin
+tests := tst-utmp tst-utmpx tst-grantpt tst-ptsname tst-getlogin tst-updwtmpx
 
 # Build the -lutil library with these extra functions.
 extra-libs      := libutil
diff --git a/login/tst-updwtmpx.c b/login/tst-updwtmpx.c
new file mode 100644
index 0000000000..0a4a27daeb
--- /dev/null
+++ b/login/tst-updwtmpx.c
@@ -0,0 +1,112 @@
+/* Basic test coverage for updwtmpx.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <http://www.gnu.org/licenses/>.  */
+
+/* This program runs a series of tests.  Each one calls updwtmpx
+   twice, to write two records, optionally with misalignment in the
+   file, and reads back the results.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <support/check.h>
+#include <support/descriptors.h>
+#include <support/support.h>
+#include <support/temp_file.h>
+#include <support/test-driver.h>
+#include <support/xunistd.h>
+#include <unistd.h>
+#include <utmpx.h>
+
+static int
+do_test (void)
+{
+  /* Two entries filled with an arbitrary bit pattern.  */
+  struct utmpx entries[2];
+  unsigned char pad;
+  {
+    unsigned char *p = (unsigned char *) &entries[0];
+    for (size_t i = 0; i < sizeof (entries); ++i)
+      {
+        p[i] = i;
+      }
+    /* Make sure that the first and second entry and the padding are
+       different.  */
+    p[sizeof (struct utmpx)] = p[0] + 1;
+    pad = p[0] + 2;
+  }
+
+  char *path;
+  int fd = create_temp_file ("tst-updwtmpx-", &path);
+
+  /* Used to check that updwtmpx does not leave an open file
+     descriptor around.  */
+  struct support_descriptors *descriptors = support_descriptors_list ();
+
+  /* updwtmpx is expected to remove misalignment.  Optionally insert
+     one byte of misalignment at the start and in the middle (after
+     the first entry).  */
+  for (int misaligned_start = 0; misaligned_start < 2; ++misaligned_start)
+    for (int misaligned_middle = 0; misaligned_middle < 2; ++misaligned_middle)
+      {
+        if (test_verbose > 0)
+          printf ("info: misaligned_start=%d misaligned_middle=%d\n",
+                  misaligned_start, misaligned_middle);
+
+        xftruncate (fd, 0);
+        TEST_COMPARE (pwrite64 (fd, &pad, misaligned_start, 0),
+                      misaligned_start);
+
+        /* Write first entry and check it.  */
+        errno = 0;
+        updwtmpx (path, &entries[0]);
+        TEST_COMPARE (errno, 0);
+        support_descriptors_check (descriptors);
+        TEST_COMPARE (xlseek (fd, 0, SEEK_END), sizeof (struct utmpx));
+        struct utmpx buffer;
+        TEST_COMPARE (pread64 (fd, &buffer, sizeof (buffer), 0),
+                      sizeof (buffer));
+        TEST_COMPARE_BLOB (&entries[0], sizeof (entries[0]),
+                           &buffer, sizeof (buffer));
+
+        /* Middle mis-alignmet.  */
+        TEST_COMPARE (pwrite64 (fd, &pad, misaligned_middle,
+                                sizeof (struct utmpx)), misaligned_middle);
+
+        /* Write second entry and check both entries.  */
+        errno = 0;
+        updwtmpx (path, &entries[1]);
+        TEST_COMPARE (errno, 0);
+        support_descriptors_check (descriptors);
+        TEST_COMPARE (xlseek (fd, 0, SEEK_END), 2 * sizeof (struct utmpx));
+        TEST_COMPARE (pread64 (fd, &buffer, sizeof (buffer), 0),
+                      sizeof (buffer));
+        TEST_COMPARE_BLOB (&entries[0], sizeof (entries[0]),
+                           &buffer, sizeof (buffer));
+        TEST_COMPARE (pread64 (fd, &buffer, sizeof (buffer), sizeof (buffer)),
+                      sizeof (buffer));
+        TEST_COMPARE_BLOB (&entries[1], sizeof (entries[1]),
+                           &buffer, sizeof (buffer));
+      }
+
+  support_descriptors_free (descriptors);
+  free (path);
+  xclose (fd);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/login/utmp_file.c b/login/utmp_file.c
index 7bd6034af4..5e4e66d1d0 100644
--- a/login/utmp_file.c
+++ b/login/utmp_file.c
@@ -503,7 +503,7 @@ __libc_updwtmp (const char *file, const struct utmp *utmp)
   result = 0;
 
 unlock_return:
-  file_unlock (file_fd);
+  file_unlock (fd);
   file_lock_restore (&fl);
 
   /* Close WTMP file.  */

commit 8baeebad9aa6eca0eba028a9c95cd0867b37aa2d
Author: Florian Weimer <fweimer@redhat.com>
Date:   Thu Aug 15 16:09:05 2019 +0200

    login: Disarm timer after utmp lock acquisition [BZ #24879]
    
    If the file processing takes a long time for some reason, SIGALRM can
    arrive while the file is still being processed.  At that point, file
    access will fail with EINTR.  Disarming the timer after lock
    acquisition avoids that.  (If there was a previous alarm, it is the
    responsibility of the caller to deal with the EINTR error.)
    
    (cherry picked from commit 628598be7e1bfaa04f34df71ef6678f2c5103dfd)

diff --git a/ChangeLog b/ChangeLog
index d734a35b5b..4a89e56249 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,16 @@
+2019-08-15  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #24879]
+	login: Disarm timer after utmp lock acquisition.
+	* login/utmp_file.c (struct file_locking): Remove.
+	(try_file_lock): Adjust.
+	(file_lock_restore): Remove function.
+	(__libc_getutent_r): .
+	(internal_getut_r): Likewise.
+	(__libc_getutline_r): Likewise.
+	(__libc_pututline): Likewise.
+	(__libc_updwtmp): Likewise.
+
 2019-08-15  Florian Weimer  <fweimer@redhat.com>
 
 	* login/utmp_file.c (__libc_updwtmp): Unlock the right file
diff --git a/NEWS b/NEWS
index 4d26e01248..96458cf0b9 100644
--- a/NEWS
+++ b/NEWS
@@ -21,6 +21,7 @@ The following bugs are resolved with this release:
   [24682] localedata: zh_CN first weekday should be Monday per GB/T
     7408-2005
   [24867] malloc: Remove unwanted leading whitespace in malloc_info
+  [24879] login: Disarm timer after utmp lock acquisition
   [24986] alpha: new getegid, geteuid and getppid syscalls used
     unconditionally
   [25189] Don't use a custom wrapper macro around __has_include
diff --git a/login/utmp_file.c b/login/utmp_file.c
index 5e4e66d1d0..f3c528384f 100644
--- a/login/utmp_file.c
+++ b/login/utmp_file.c
@@ -55,32 +55,23 @@ static void timeout_handler (int signum) {};
 
 /* try_file_lock (LOCKING, FD, TYPE) returns true if the locking
    operation failed and recovery needs to be performed.
-   (file_lock_restore (LOCKING) still needs to be called.)
 
    file_unlock (FD) removes the lock (which must have been
-   acquired).
-
-   file_lock_restore (LOCKING) is needed to clean up in both
-   cases.  */
-
-struct file_locking
-{
-  struct sigaction old_action;
-  unsigned int old_timeout;
-};
+   successfully acquired). */
 
 static bool
-try_file_lock (struct file_locking *locking, int fd, int type)
+try_file_lock (int fd, int type)
 {
   /* Cancel any existing alarm.  */
-  locking->old_timeout = alarm (0);
+  int old_timeout = alarm (0);
 
   /* Establish signal handler.  */
+  struct sigaction old_action;
   struct sigaction action;
   action.sa_handler = timeout_handler;
   __sigemptyset (&action.sa_mask);
   action.sa_flags = 0;
-  __sigaction (SIGALRM, &action, &locking->old_action);
+  __sigaction (SIGALRM, &action, &old_action);
 
   alarm (TIMEOUT);
 
@@ -90,7 +81,23 @@ try_file_lock (struct file_locking *locking, int fd, int type)
     .l_type = type,
     fl.l_whence = SEEK_SET,
    };
- return __fcntl64_nocancel (fd, F_SETLKW, &fl) < 0;
+
+ bool status = __fcntl64_nocancel (fd, F_SETLKW, &fl) < 0;
+ int saved_errno = errno;
+
+ /* Reset the signal handler and alarm.  We must reset the alarm
+    before resetting the handler so our alarm does not generate a
+    spurious SIGALRM seen by the user.  However, we cannot just set
+    the user's old alarm before restoring the handler, because then
+    it's possible our handler could catch the user alarm's SIGARLM and
+    then the user would never see the signal he expected.  */
+  alarm (0);
+  __sigaction (SIGALRM, &old_action, NULL);
+  if (old_timeout != 0)
+    alarm (old_timeout);
+
+  __set_errno (saved_errno);
+  return status;
 }
 
 static void
@@ -103,21 +110,6 @@ file_unlock (int fd)
   __fcntl64_nocancel (fd, F_SETLKW, &fl);
 }
 
-static void
-file_lock_restore (struct file_locking *locking)
-{
-  /* Reset the signal handler and alarm.  We must reset the alarm
-     before resetting the handler so our alarm does not generate a
-     spurious SIGALRM seen by the user.  However, we cannot just set
-     the user's old alarm before restoring the handler, because then
-     it's possible our handler could catch the user alarm's SIGARLM
-     and then the user would never see the signal he expected.  */
-  alarm (0);
-  __sigaction (SIGALRM, &locking->old_action, NULL);
-  if (locking->old_timeout != 0)
-    alarm (locking->old_timeout);
-}
-
 #ifndef TRANSFORM_UTMP_FILE_NAME
 # define TRANSFORM_UTMP_FILE_NAME(file_name) (file_name)
 #endif
@@ -166,8 +158,7 @@ __libc_getutent_r (struct utmp *buffer, struct utmp **result)
       return -1;
     }
 
-  struct file_locking fl;
-  if (try_file_lock (&fl, file_fd, F_RDLCK))
+  if (try_file_lock (file_fd, F_RDLCK))
     nbytes = 0;
   else
     {
@@ -175,7 +166,6 @@ __libc_getutent_r (struct utmp *buffer, struct utmp **result)
       nbytes = __read_nocancel (file_fd, &last_entry, sizeof (struct utmp));
       file_unlock (file_fd);
     }
-  file_lock_restore (&fl);
 
   if (nbytes != sizeof (struct utmp))
     {
@@ -201,11 +191,9 @@ internal_getut_r (const struct utmp *id, struct utmp *buffer,
 {
   int result = -1;
 
-  struct file_locking fl;
-  if (try_file_lock (&fl, file_fd, F_RDLCK))
+  if (try_file_lock (file_fd, F_RDLCK))
     {
       *lock_failed = true;
-      file_lock_restore (&fl);
       return -1;
     }
 
@@ -257,7 +245,6 @@ internal_getut_r (const struct utmp *id, struct utmp *buffer,
 
 unlock_return:
   file_unlock (file_fd);
-  file_lock_restore (&fl);
 
   return result;
 }
@@ -303,11 +290,9 @@ __libc_getutline_r (const struct utmp *line, struct utmp *buffer,
       return -1;
     }
 
-  struct file_locking fl;
-  if (try_file_lock (&fl, file_fd, F_RDLCK))
+  if (try_file_lock (file_fd, F_RDLCK))
     {
       *result = NULL;
-      file_lock_restore (&fl);
       return -1;
     }
 
@@ -337,7 +322,6 @@ __libc_getutline_r (const struct utmp *line, struct utmp *buffer,
 
 unlock_return:
   file_unlock (file_fd);
-  file_lock_restore (&fl);
 
   return ((*result == NULL) ? -1 : 0);
 }
@@ -394,12 +378,8 @@ __libc_pututline (const struct utmp *data)
 	}
     }
 
-  struct file_locking fl;
-  if (try_file_lock (&fl, file_fd, F_WRLCK))
-    {
-      file_lock_restore (&fl);
-      return NULL;
-    }
+  if (try_file_lock (file_fd, F_WRLCK))
+    return NULL;
 
   if (found < 0)
     {
@@ -442,7 +422,6 @@ __libc_pututline (const struct utmp *data)
 
  unlock_return:
   file_unlock (file_fd);
-  file_lock_restore (&fl);
 
   return pbuf;
 }
@@ -471,10 +450,8 @@ __libc_updwtmp (const char *file, const struct utmp *utmp)
   if (fd < 0)
     return -1;
 
-  struct file_locking fl;
-  if (try_file_lock (&fl, fd, F_WRLCK))
+  if (try_file_lock (fd, F_WRLCK))
     {
-      file_lock_restore (&fl);
       __close_nocancel_nostatus (fd);
       return -1;
     }
@@ -504,7 +481,6 @@ __libc_updwtmp (const char *file, const struct utmp *utmp)
 
 unlock_return:
   file_unlock (fd);
-  file_lock_restore (&fl);
 
   /* Close WTMP file.  */
   __close_nocancel_nostatus (fd);

commit dbbd748c5f69a2fb4d5d305df2ce15b9e69a46ef
Author: Florian Weimer <fweimer@redhat.com>
Date:   Thu Aug 15 16:09:20 2019 +0200

    login: Use struct flock64 in utmp [BZ #24880]
    
    Commit 06ab719d30b01da401150068054d3b8ea93dd12f ("Fix Linux fcntl OFD
    locks for non-LFS architectures (BZ#20251)") introduced the use of
    fcntl64 into the utmp implementation.  However, the lock file
    structure was not updated to struct flock64 at that point.
    
    (cherry picked from commit 0d5b2917530ccaf8ad312dfbb7bce69d569c23ad)

diff --git a/ChangeLog b/ChangeLog
index 4a89e56249..85d3e195a4 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,9 @@
+2019-08-15  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #24880]
+	* login/utmp_file.c (file_locking_failed): Use struct flock64.
+	(file_locking_unlock): Likewise.
+
 2019-08-15  Florian Weimer  <fweimer@redhat.com>
 
 	[BZ #24879]
diff --git a/NEWS b/NEWS
index 96458cf0b9..8952a8a77d 100644
--- a/NEWS
+++ b/NEWS
@@ -22,6 +22,7 @@ The following bugs are resolved with this release:
     7408-2005
   [24867] malloc: Remove unwanted leading whitespace in malloc_info
   [24879] login: Disarm timer after utmp lock acquisition
+  [24880] login: Use struct flock64 in utmp
   [24986] alpha: new getegid, geteuid and getppid syscalls used
     unconditionally
   [25189] Don't use a custom wrapper macro around __has_include
diff --git a/login/utmp_file.c b/login/utmp_file.c
index f3c528384f..94753e0404 100644
--- a/login/utmp_file.c
+++ b/login/utmp_file.c
@@ -76,7 +76,7 @@ try_file_lock (int fd, int type)
   alarm (TIMEOUT);
 
   /* Try to get the lock.  */
- struct flock fl =
+ struct flock64 fl =
    {
     .l_type = type,
     fl.l_whence = SEEK_SET,
@@ -103,7 +103,7 @@ try_file_lock (int fd, int type)
 static void
 file_unlock (int fd)
 {
-  struct flock fl =
+  struct flock64 fl =
     {
       .l_type = F_UNLCK,
     };

commit f0cd1cfbe37eed659df75cad3b5a58ad386d0fe6
Author: Florian Weimer <fweimer@redhat.com>
Date:   Wed Aug 28 11:59:45 2019 +0200

    login: pututxline could fail to overwrite existing entries [BZ #24902]
    
    The internal_getut_r function updates the file_offset variable and
    therefore must always update last_entry as well.
    
    Previously, if pututxline could not upgrade the read lock to a
    write lock, internal_getut_r would update file_offset only,
    without updating last_entry, and a subsequent call would not
    overwrite the existing utmpx entry at file_offset, instead
    creating a new entry.  This has been observed to cause unbounded
    file growth in high-load situations.
    
    This commit removes the buffer argument to internal_getut_r and
    updates the last_entry variable directly, along with file_offset.
    
    Initially reported and fixed by Ondřej Lysoněk.
    
    Reviewed-by: Gabriel F. T. Gomes <gabrielftg@linux.ibm.com>
    (cherry picked from commit 61d3db428176d9d0822e4e680305fe34285edff2)

diff --git a/ChangeLog b/ChangeLog
index 85d3e195a4..becd26f7d2 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,13 @@
+2019-08-28  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #24902]
+	* login/Makefile (tests): Add tst-pututxline-lockfail.
+	(tst-pututxline-lockfail): Link with -lpthread.
+	* login/utmp_file.c (internal_getut_r): Remove buffer argument.
+	(__libc_getutid_r): Adjust.
+	(__libc_pututline): Likewise.  Check for file_offset == -1.
+	* login/tst-pututxline-lockfail.c: New file.
+
 2019-08-15  Florian Weimer  <fweimer@redhat.com>
 
 	[BZ #24880]
diff --git a/NEWS b/NEWS
index 8952a8a77d..b0ab63a83b 100644
--- a/NEWS
+++ b/NEWS
@@ -25,6 +25,7 @@ The following bugs are resolved with this release:
   [24880] login: Use struct flock64 in utmp
   [24986] alpha: new getegid, geteuid and getppid syscalls used
     unconditionally
+  [24902] login: pututxline could fail to overwrite existing entries
   [25189] Don't use a custom wrapper macro around __has_include
   [25203] libio: Disable vtable validation for pre-2.1 interposed handles
   [25204] Ignore LD_PREFER_MAP_32BIT_EXEC for SUID programs
diff --git a/login/Makefile b/login/Makefile
index f9c4264087..93a3c8edf2 100644
--- a/login/Makefile
+++ b/login/Makefile
@@ -43,7 +43,8 @@ endif
 subdir-dirs = programs
 vpath %.c programs
 
-tests := tst-utmp tst-utmpx tst-grantpt tst-ptsname tst-getlogin tst-updwtmpx
+tests := tst-utmp tst-utmpx tst-grantpt tst-ptsname tst-getlogin tst-updwtmpx \
+  tst-pututxline-lockfail
 
 # Build the -lutil library with these extra functions.
 extra-libs      := libutil
@@ -71,3 +72,5 @@ endif
 $(inst_libexecdir)/pt_chown: $(objpfx)pt_chown $(+force)
 	$(make-target-directory)
 	-$(INSTALL_PROGRAM) -m 4755 -o root $< $@
+
+$(objpfx)tst-pututxline-lockfail: $(shared-thread-library)
diff --git a/login/tst-pututxline-lockfail.c b/login/tst-pututxline-lockfail.c
new file mode 100644
index 0000000000..47c25dc065
--- /dev/null
+++ b/login/tst-pututxline-lockfail.c
@@ -0,0 +1,176 @@
+/* Test the lock upgrade path in tst-pututxline.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <http://www.gnu.org/licenses/>.  */
+
+/* pututxline upgrades the read lock on the file to a write lock.
+   This test verifies that if the lock upgrade fails, the utmp
+   subsystem remains in a consistent state, so that pututxline can be
+   called again.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <support/check.h>
+#include <support/namespace.h>
+#include <support/support.h>
+#include <support/temp_file.h>
+#include <support/xthread.h>
+#include <support/xunistd.h>
+#include <unistd.h>
+#include <utmp.h>
+#include <utmpx.h>
+
+/* Path to the temporary utmp file.   */
+static char *path;
+
+/* Used to synchronize the subprocesses.  The barrier itself is
+   allocated in shared memory.  */
+static pthread_barrier_t *barrier;
+
+/* Use pututxline to write an entry for PID.  */
+static struct utmpx *
+write_entry (pid_t pid)
+{
+  struct utmpx ut =
+    {
+     .ut_type = LOGIN_PROCESS,
+     .ut_id = "1",
+     .ut_user = "root",
+     .ut_pid = pid,
+     .ut_line = "entry",
+     .ut_host = "localhost",
+    };
+  return pututxline (&ut);
+}
+
+/* Create the initial entry in a subprocess, so that the utmp
+   subsystem in the original process is not disturbed.  */
+static void
+subprocess_create_entry (void *closure)
+{
+  TEST_COMPARE (utmpname (path), 0);
+  TEST_VERIFY (write_entry (101) != NULL);
+}
+
+/* Acquire an advisory read lock on PATH.  */
+__attribute__ ((noreturn)) static void
+subprocess_lock_file (void)
+{
+  int fd = xopen (path, O_RDONLY, 0);
+
+  struct flock64 fl =
+    {
+     .l_type = F_RDLCK,
+     fl.l_whence = SEEK_SET,
+    };
+  TEST_COMPARE (fcntl64 (fd, F_SETLKW, &fl), 0);
+
+  /* Signal to the main process that the lock has been acquired.  */
+  xpthread_barrier_wait (barrier);
+
+  /* Wait for the unlock request from the main process.  */
+  xpthread_barrier_wait (barrier);
+
+  /* Implicitly unlock the file.  */
+  xclose (fd);
+
+  /* Overwrite the existing entry.  */
+  TEST_COMPARE (utmpname (path), 0);
+  errno = 0;
+  setutxent ();
+  TEST_COMPARE (errno, 0);
+  TEST_VERIFY (write_entry (102) != NULL);
+  errno = 0;
+  endutxent ();
+  TEST_COMPARE (errno, 0);
+
+  _exit (0);
+}
+
+static int
+do_test (void)
+{
+  xclose (create_temp_file ("tst-pututxline-lockfail-", &path));
+
+  {
+    pthread_barrierattr_t attr;
+    xpthread_barrierattr_init (&attr);
+    xpthread_barrierattr_setpshared (&attr, PTHREAD_SCOPE_PROCESS);
+    barrier = support_shared_allocate (sizeof (*barrier));
+    xpthread_barrier_init (barrier, &attr, 2);
+    xpthread_barrierattr_destroy (&attr);
+  }
+
+  /* Write the initial entry.  */
+  support_isolate_in_subprocess (subprocess_create_entry, NULL);
+
+  pid_t locker_pid = xfork ();
+  if (locker_pid == 0)
+    subprocess_lock_file ();
+
+  /* Wait for the file locking to complete.  */
+  xpthread_barrier_wait (barrier);
+
+  /* Try to add another entry.  This attempt will fail, with EINTR or
+     EAGAIN.  */
+  TEST_COMPARE (utmpname (path), 0);
+  TEST_VERIFY (write_entry (102) == NULL);
+  if (errno != EINTR)
+    TEST_COMPARE (errno, EAGAIN);
+
+  /* Signal the subprocess to overwrite the entry.  */
+  xpthread_barrier_wait (barrier);
+
+  /* Wait for write and unlock to complete.  */
+  {
+    int status;
+    xwaitpid (locker_pid, &status, 0);
+    TEST_COMPARE (status, 0);
+  }
+
+  /* The file is no longer locked, so this operation will succeed.  */
+  TEST_VERIFY (write_entry (103) != NULL);
+  errno = 0;
+  endutxent ();
+  TEST_COMPARE (errno, 0);
+
+  /* Check that there is just one entry with the expected contents.
+     If pututxline becomes desynchronized internally, the entry is not
+     overwritten (bug 24902).  */
+  errno = 0;
+  setutxent ();
+  TEST_COMPARE (errno, 0);
+  struct utmpx *ut = getutxent ();
+  TEST_VERIFY_EXIT (ut != NULL);
+  TEST_COMPARE (ut->ut_type, LOGIN_PROCESS);
+  TEST_COMPARE_STRING (ut->ut_id, "1");
+  TEST_COMPARE_STRING (ut->ut_user, "root");
+  TEST_COMPARE (ut->ut_pid, 103);
+  TEST_COMPARE_STRING (ut->ut_line, "entry");
+  TEST_COMPARE_STRING (ut->ut_host, "localhost");
+  TEST_VERIFY (getutxent () == NULL);
+  errno = 0;
+  endutxent ();
+  TEST_COMPARE (errno, 0);
+
+  xpthread_barrier_destroy (barrier);
+  support_shared_free (barrier);
+  free (path);
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/login/utmp_file.c b/login/utmp_file.c
index 94753e0404..2d0548f6fa 100644
--- a/login/utmp_file.c
+++ b/login/utmp_file.c
@@ -185,9 +185,11 @@ __libc_getutent_r (struct utmp *buffer, struct utmp **result)
 }
 
 
+/* Search for *ID, updating last_entry and file_offset.  Return 0 on
+   success and -1 on failure.  If the locking operation failed, write
+   true to *LOCK_FAILED.  */
 static int
-internal_getut_r (const struct utmp *id, struct utmp *buffer,
-		  bool *lock_failed)
+internal_getut_r (const struct utmp *id, bool *lock_failed)
 {
   int result = -1;
 
@@ -206,7 +208,7 @@ internal_getut_r (const struct utmp *id, struct utmp *buffer,
       while (1)
 	{
 	  /* Read the next entry.  */
-	  if (__read_nocancel (file_fd, buffer, sizeof (struct utmp))
+	  if (__read_nocancel (file_fd, &last_entry, sizeof (struct utmp))
 	      != sizeof (struct utmp))
 	    {
 	      __set_errno (ESRCH);
@@ -215,7 +217,7 @@ internal_getut_r (const struct utmp *id, struct utmp *buffer,
 	    }
 	  file_offset += sizeof (struct utmp);
 
-	  if (id->ut_type == buffer->ut_type)
+	  if (id->ut_type == last_entry.ut_type)
 	    break;
 	}
     }
@@ -227,7 +229,7 @@ internal_getut_r (const struct utmp *id, struct utmp *buffer,
       while (1)
 	{
 	  /* Read the next entry.  */
-	  if (__read_nocancel (file_fd, buffer, sizeof (struct utmp))
+	  if (__read_nocancel (file_fd, &last_entry, sizeof (struct utmp))
 	      != sizeof (struct utmp))
 	    {
 	      __set_errno (ESRCH);
@@ -236,7 +238,7 @@ internal_getut_r (const struct utmp *id, struct utmp *buffer,
 	    }
 	  file_offset += sizeof (struct utmp);
 
-	  if (__utmp_equal (buffer, id))
+	  if (__utmp_equal (&last_entry, id))
 	    break;
 	}
     }
@@ -265,7 +267,7 @@ __libc_getutid_r (const struct utmp *id, struct utmp *buffer,
   /* We don't have to distinguish whether we can lock the file or
      whether there is no entry.  */
   bool lock_failed = false;
-  if (internal_getut_r (id, &last_entry, &lock_failed) < 0)
+  if (internal_getut_r (id, &lock_failed) < 0)
     {
       *result = NULL;
       return -1;
@@ -330,10 +332,9 @@ unlock_return:
 struct utmp *
 __libc_pututline (const struct utmp *data)
 {
-  if (!maybe_setutent ())
+  if (!maybe_setutent () || file_offset == -1l)
     return NULL;
 
-  struct utmp buffer;
   struct utmp *pbuf;
   int found;
 
@@ -369,7 +370,7 @@ __libc_pututline (const struct utmp *data)
   else
     {
       bool lock_failed = false;
-      found = internal_getut_r (data, &buffer, &lock_failed);
+      found = internal_getut_r (data, &lock_failed);
 
       if (__builtin_expect (lock_failed, false))
 	{

commit 143cea84a0e23d5ba0f4e9679f59f72763b46d27
Author: Florian Weimer <fweimer@redhat.com>
Date:   Thu Nov 7 09:53:41 2019 +0100

    login: Remove double-assignment of fl.l_whence in try_file_lock
    
    Since l_whence is the second member of struct flock, it is written
    twice.  The double-assignment is technically undefined behavior due to
    the lack of a sequence point.
    
    Reviewed-by: Carlos O'Donell <carlos@redhat.com>
    Change-Id: I2baf9e70690e723c61051b25ccbd510aec15976c
    (cherry picked from commit b0a83ae71b2588bd2a9e6b40f95191602940e01e)

diff --git a/login/utmp_file.c b/login/utmp_file.c
index 2d0548f6fa..74ec622e96 100644
--- a/login/utmp_file.c
+++ b/login/utmp_file.c
@@ -79,7 +79,7 @@ try_file_lock (int fd, int type)
  struct flock64 fl =
    {
     .l_type = type,
-    fl.l_whence = SEEK_SET,
+    .l_whence = SEEK_SET,
    };
 
  bool status = __fcntl64_nocancel (fd, F_SETLKW, &fl) < 0;

commit 85da102c52517a9bfb0253f7ba65b2ddb893519c
Author: Florian Weimer <fweimer@redhat.com>
Date:   Thu Aug 15 16:09:43 2019 +0200

    login: Add nonstring attributes to struct utmp, struct utmpx [BZ #24899]
    
    Commit 7532837d7b03b3ca5b9a63d77a5bd81dd23f3d9c ("The
    -Wstringop-truncation option new in GCC 8 detects common misuses")
    added __attribute_nonstring__ to bits/utmp.h, but it did not update
    the parallel bits/utmpx.h header.  In struct utmp, the nonstring
    attribute for ut_id was missing.
    
    (cherry picked from commit c2adefbafcdd2519ff43eca6891c77cd7b29ab62)

diff --git a/ChangeLog b/ChangeLog
index becd26f7d2..bc2f4aae69 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,15 @@
+2019-08-15  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #24899]
+	* sysdeps/gnu/bits/utmpx.h (struct utmpx): Add
+	__attribute_nonstring__ to ut_line, ut_id, ut_user, ut_host.
+	* sysdeps/unix/sysv/linux/s390/bits/utmpx.h (struct utmpx):
+	Likewise.
+	* sysdeps/gnu/bits/utmp.h (struct utmp): Add
+	__attribute_nonstring__ to ut_id.
+	* sysdeps/unix/sysv/linux/s390/bits/utmpx.h (struct utmp):
+	Likewise.
+
 2019-08-28  Florian Weimer  <fweimer@redhat.com>
 
 	[BZ #24902]
diff --git a/NEWS b/NEWS
index b0ab63a83b..ae6c815515 100644
--- a/NEWS
+++ b/NEWS
@@ -25,6 +25,7 @@ The following bugs are resolved with this release:
   [24880] login: Use struct flock64 in utmp
   [24986] alpha: new getegid, geteuid and getppid syscalls used
     unconditionally
+  [24899] login: Add nonstring attributes to struct utmp, struct utmpx
   [24902] login: pututxline could fail to overwrite existing entries
   [25189] Don't use a custom wrapper macro around __has_include
   [25203] libio: Disable vtable validation for pre-2.1 interposed handles
diff --git a/bits/utmp.h b/bits/utmp.h
index 3c02dd4f3f..854b342164 100644
--- a/bits/utmp.h
+++ b/bits/utmp.h
@@ -61,7 +61,8 @@ struct utmp
   pid_t ut_pid;			/* Process ID of login process.  */
   char ut_line[UT_LINESIZE]
     __attribute_nonstring__;	/* Devicename.  */
-  char ut_id[4];		/* Inittab ID.  */
+  char ut_id[4]
+    __attribute_nonstring__;	/* Inittab ID.  */
   char ut_user[UT_NAMESIZE]
     __attribute_nonstring__;	/* Username.  */
   char ut_host[UT_HOSTSIZE]
diff --git a/sysdeps/gnu/bits/utmpx.h b/sysdeps/gnu/bits/utmpx.h
index 472a7d57d3..2beadbf587 100644
--- a/sysdeps/gnu/bits/utmpx.h
+++ b/sysdeps/gnu/bits/utmpx.h
@@ -56,10 +56,14 @@ struct utmpx
 {
   short int ut_type;		/* Type of login.  */
   __pid_t ut_pid;		/* Process ID of login process.  */
-  char ut_line[__UT_LINESIZE];	/* Devicename.  */
-  char ut_id[4];		/* Inittab ID. */
-  char ut_user[__UT_NAMESIZE];	/* Username.  */
-  char ut_host[__UT_HOSTSIZE];	/* Hostname for remote login.  */
+  char ut_line[__UT_LINESIZE]
+    __attribute_nonstring__;	/* Devicename.  */
+  char ut_id[4]
+    __attribute_nonstring__;	/* Inittab ID.  */
+  char ut_user[__UT_NAMESIZE]
+    __attribute_nonstring__;	/* Username.  */
+  char ut_host[__UT_HOSTSIZE]
+    __attribute_nonstring__;	/* Hostname for remote login.  */
   struct __exit_status ut_exit;	/* Exit status of a process marked
 				   as DEAD_PROCESS.  */
 
diff --git a/sysdeps/unix/sysv/linux/s390/bits/utmp.h b/sysdeps/unix/sysv/linux/s390/bits/utmp.h
index 862115c6f8..0569c3b784 100644
--- a/sysdeps/unix/sysv/linux/s390/bits/utmp.h
+++ b/sysdeps/unix/sysv/linux/s390/bits/utmp.h
@@ -61,7 +61,8 @@ struct utmp
   pid_t ut_pid;			/* Process ID of login process.  */
   char ut_line[UT_LINESIZE]
      __attribute_nonstring__;	/* Devicename.  */
-  char ut_id[4];		/* Inittab ID.  */
+  char ut_id[4]
+    __attribute_nonstring__;	/* Inittab ID.  */
   char ut_user[UT_NAMESIZE]
      __attribute_nonstring__;	/* Username.  */
   char ut_host[UT_HOSTSIZE]
diff --git a/sysdeps/unix/sysv/linux/s390/bits/utmpx.h b/sysdeps/unix/sysv/linux/s390/bits/utmpx.h
index ea3e860a2d..737d9dca05 100644
--- a/sysdeps/unix/sysv/linux/s390/bits/utmpx.h
+++ b/sysdeps/unix/sysv/linux/s390/bits/utmpx.h
@@ -56,10 +56,14 @@ struct utmpx
 {
   short int ut_type;		/* Type of login.  */
   __pid_t ut_pid;		/* Process ID of login process.  */
-  char ut_line[__UT_LINESIZE];	/* Devicename.  */
-  char ut_id[4];		/* Inittab ID. */
-  char ut_user[__UT_NAMESIZE];	/* Username.  */
-  char ut_host[__UT_HOSTSIZE];	/* Hostname for remote login.  */
+  char ut_line[__UT_LINESIZE]
+    __attribute_nonstring__;	/* Devicename.  */
+  char ut_id[4]
+    __attribute_nonstring__;	/* Inittab ID.  */
+  char ut_user[__UT_NAMESIZE]
+    __attribute_nonstring__;	/* Username.  */
+  char ut_host[__UT_HOSTSIZE]
+    __attribute_nonstring__;	/* Hostname for remote login.  */
   struct __exit_status ut_exit;	/* Exit status of a process marked
 				   as DEAD_PROCESS.  */
 

commit 83f793e6a63c4bdd1b2f39618040a8317562a1f7
Author: Florian Weimer <fweimer@redhat.com>
Date:   Thu Nov 7 18:15:18 2019 +0100

    login: Acquire write lock early in pututline [BZ #24882]
    
    It has been reported that due to lack of fairness in POSIX file
    locking, the current reader-to-writer lock upgrade can result in
    lack of forward progress.  Acquiring the write lock directly
    hopefully avoids this issue if there are only writers.
    
    This also fixes bug 24882 due to the cache revalidation in
    __libc_pututline.
    
    Reviewed-by: Carlos O'Donell <carlos@redhat.com>
    Change-Id: I57e31ae30719e609a53505a0924dda101d46372e
    (cherry picked from commit be6b16d975683e6cca57852cd4cfe715b2a9d8b1)

diff --git a/NEWS b/NEWS
index ae6c815515..1352a339ab 100644
--- a/NEWS
+++ b/NEWS
@@ -23,6 +23,7 @@ The following bugs are resolved with this release:
   [24867] malloc: Remove unwanted leading whitespace in malloc_info
   [24879] login: Disarm timer after utmp lock acquisition
   [24880] login: Use struct flock64 in utmp
+  [24882] login: Acquire write lock early in pututline
   [24986] alpha: new getegid, geteuid and getppid syscalls used
     unconditionally
   [24899] login: Add nonstring attributes to struct utmp, struct utmpx
diff --git a/login/Makefile b/login/Makefile
index 93a3c8edf2..4fd8195e73 100644
--- a/login/Makefile
+++ b/login/Makefile
@@ -44,7 +44,7 @@ subdir-dirs = programs
 vpath %.c programs
 
 tests := tst-utmp tst-utmpx tst-grantpt tst-ptsname tst-getlogin tst-updwtmpx \
-  tst-pututxline-lockfail
+  tst-pututxline-lockfail tst-pututxline-cache
 
 # Build the -lutil library with these extra functions.
 extra-libs      := libutil
@@ -74,3 +74,4 @@ $(inst_libexecdir)/pt_chown: $(objpfx)pt_chown $(+force)
 	-$(INSTALL_PROGRAM) -m 4755 -o root $< $@
 
 $(objpfx)tst-pututxline-lockfail: $(shared-thread-library)
+$(objpfx)tst-pututxline-cache: $(shared-thread-library)
diff --git a/login/tst-pututxline-cache.c b/login/tst-pututxline-cache.c
new file mode 100644
index 0000000000..3f30dd1776
--- /dev/null
+++ b/login/tst-pututxline-cache.c
@@ -0,0 +1,193 @@
+/* Test case for cache invalidation after concurrent write (bug 24882).
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <http://www.gnu.org/licenses/>.  */
+
+/* This test writes an entry to the utmpx file, reads it (so that it
+   is cached) in process1, and overwrites the same entry in process2
+   with something that does not match the search criteria.  At this
+   point, the cache of the first process is stale, and when process1
+   attempts to write a new record which would have gone to the same
+   place (as indicated by the cache), it needs to realize that it has
+   to pick a different slot because the old slot is now used for
+   something else.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <support/check.h>
+#include <support/namespace.h>
+#include <support/support.h>
+#include <support/temp_file.h>
+#include <support/xthread.h>
+#include <support/xunistd.h>
+#include <utmp.h>
+#include <utmpx.h>
+
+/* Set to the path of the utmp file.  */
+static char *utmp_file;
+
+/* Used to synchronize the subprocesses.  The barrier itself is
+   allocated in shared memory.  */
+static pthread_barrier_t *barrier;
+
+/* setutxent with error checking.  */
+static void
+xsetutxent (void)
+{
+  errno = 0;
+  setutxent ();
+  TEST_COMPARE (errno, 0);
+}
+
+/* getutxent with error checking.  */
+static struct utmpx *
+xgetutxent (void)
+{
+  errno = 0;
+  struct utmpx *result = getutxent ();
+  if (result == NULL)
+    FAIL_EXIT1 ("getutxent: %m");
+  return result;
+}
+
+static void
+put_entry (const char *id, pid_t pid, const char *user, const char *line)
+{
+  struct utmpx ut =
+    {
+     .ut_type = LOGIN_PROCESS,
+     .ut_pid = pid,
+     .ut_host = "localhost",
+    };
+  strcpy (ut.ut_id, id);
+  strncpy (ut.ut_user, user, sizeof (ut.ut_user));
+  strncpy (ut.ut_line, line, sizeof (ut.ut_line));
+  TEST_VERIFY (pututxline (&ut) != NULL);
+}
+
+/* Use two cooperating subprocesses to avoid issues related to
+   unlock-on-close semantics of POSIX advisory locks.  */
+
+static __attribute__ ((noreturn)) void
+process1 (void)
+{
+  TEST_COMPARE (utmpname (utmp_file), 0);
+
+  /* Create an entry.  */
+  xsetutxent ();
+  put_entry ("1", 101, "root", "process1");
+
+  /* Retrieve the entry.  This will fill the internal cache.  */
+  {
+    errno = 0;
+    setutxent ();
+    TEST_COMPARE (errno, 0);
+    struct utmpx ut =
+      {
+       .ut_type = LOGIN_PROCESS,
+       .ut_line = "process1",
+      };
+    struct utmpx *result = getutxline (&ut);
+    if (result == NULL)
+      FAIL_EXIT1 ("getutxline (\"process1\"): %m");
+    TEST_COMPARE (result->ut_pid, 101);
+  }
+
+  /* Signal the other process to overwrite the entry.  */
+  xpthread_barrier_wait (barrier);
+
+  /* Wait for the other process to complete the write operation.  */
+  xpthread_barrier_wait (barrier);
+
+  /* Add another entry.  Note: This time, there is no setutxent call.  */
+  put_entry ("1", 103, "root", "process1");
+
+  _exit (0);
+}
+
+static void
+process2 (void *closure)
+{
+  /* Wait for the first process to write its entry.  */
+  xpthread_barrier_wait (barrier);
+
+  /* Truncate the file.  The glibc interface does not support
+     re-purposing records, but an external expiration mechanism may
+     trigger this.  */
+  TEST_COMPARE (truncate64 (utmp_file, 0), 0);
+
+  /* Write the replacement entry.  */
+  TEST_COMPARE (utmpname (utmp_file), 0);
+  xsetutxent ();
+  put_entry ("2", 102, "user", "process2");
+
+  /* Signal the other process that the entry has been replaced.  */
+  xpthread_barrier_wait (barrier);
+}
+
+static int
+do_test (void)
+{
+  xclose (create_temp_file ("tst-tumpx-cache-write-", &utmp_file));
+  {
+    pthread_barrierattr_t attr;
+    xpthread_barrierattr_init (&attr);
+    xpthread_barrierattr_setpshared (&attr, PTHREAD_SCOPE_PROCESS);
+    barrier = support_shared_allocate (sizeof (*barrier));
+    xpthread_barrier_init (barrier, &attr, 2);
+  }
+
+  /* Run both subprocesses in parallel.  */
+  {
+    pid_t pid1 = xfork ();
+    if (pid1 == 0)
+      process1 ();
+    support_isolate_in_subprocess (process2, NULL);
+    int status;
+    xwaitpid (pid1, &status, 0);
+    TEST_COMPARE (status, 0);
+  }
+
+  /* Check that the utmpx database contains the expected records.  */
+  {
+    TEST_COMPARE (utmpname (utmp_file), 0);
+    xsetutxent ();
+
+    struct utmpx *ut = xgetutxent ();
+    TEST_COMPARE_STRING (ut->ut_id, "2");
+    TEST_COMPARE (ut->ut_pid, 102);
+    TEST_COMPARE_STRING (ut->ut_user, "user");
+    TEST_COMPARE_STRING (ut->ut_line, "process2");
+
+    ut = xgetutxent ();
+    TEST_COMPARE_STRING (ut->ut_id, "1");
+    TEST_COMPARE (ut->ut_pid, 103);
+    TEST_COMPARE_STRING (ut->ut_user, "root");
+    TEST_COMPARE_STRING (ut->ut_line, "process1");
+
+    if (getutxent () != NULL)
+      FAIL_EXIT1 ("additional utmpx entry");
+  }
+
+  xpthread_barrier_destroy (barrier);
+  support_shared_free (barrier);
+  free (utmp_file);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/login/utmp_file.c b/login/utmp_file.c
index 74ec622e96..d1612ff2b5 100644
--- a/login/utmp_file.c
+++ b/login/utmp_file.c
@@ -186,19 +186,11 @@ __libc_getutent_r (struct utmp *buffer, struct utmp **result)
 
 
 /* Search for *ID, updating last_entry and file_offset.  Return 0 on
-   success and -1 on failure.  If the locking operation failed, write
-   true to *LOCK_FAILED.  */
+   success and -1 on failure.  Does not perform locking; for that see
+   internal_getut_r below.  */
 static int
-internal_getut_r (const struct utmp *id, bool *lock_failed)
+internal_getut_nolock (const struct utmp *id)
 {
-  int result = -1;
-
-  if (try_file_lock (file_fd, F_RDLCK))
-    {
-      *lock_failed = true;
-      return -1;
-    }
-
   if (id->ut_type == RUN_LVL || id->ut_type == BOOT_TIME
       || id->ut_type == OLD_TIME || id->ut_type == NEW_TIME)
     {
@@ -213,7 +205,7 @@ internal_getut_r (const struct utmp *id, bool *lock_failed)
 	    {
 	      __set_errno (ESRCH);
 	      file_offset = -1l;
-	      goto unlock_return;
+	      return -1;
 	    }
 	  file_offset += sizeof (struct utmp);
 
@@ -234,7 +226,7 @@ internal_getut_r (const struct utmp *id, bool *lock_failed)
 	    {
 	      __set_errno (ESRCH);
 	      file_offset = -1l;
-	      goto unlock_return;
+	      return -1;
 	    }
 	  file_offset += sizeof (struct utmp);
 
@@ -243,15 +235,26 @@ internal_getut_r (const struct utmp *id, bool *lock_failed)
 	}
     }
 
-  result = 0;
+  return 0;
+}
 
-unlock_return:
-  file_unlock (file_fd);
+/* Search for *ID, updating last_entry and file_offset.  Return 0 on
+   success and -1 on failure.  If the locking operation failed, write
+   true to *LOCK_FAILED.  */
+static int
+internal_getut_r (const struct utmp *id, bool *lock_failed)
+{
+  if (try_file_lock (file_fd, F_RDLCK))
+    {
+      *lock_failed = true;
+      return -1;
+    }
 
+  int result = internal_getut_nolock (id);
+  file_unlock (file_fd);
   return result;
 }
 
-
 /* For implementing this function we don't use the getutent_r function
    because we can avoid the reposition on every new entry this way.  */
 int
@@ -279,7 +282,6 @@ __libc_getutid_r (const struct utmp *id, struct utmp *buffer,
   return 0;
 }
 
-
 /* For implementing this function we don't use the getutent_r function
    because we can avoid the reposition on every new entry this way.  */
 int
@@ -336,7 +338,6 @@ __libc_pututline (const struct utmp *data)
     return NULL;
 
   struct utmp *pbuf;
-  int found;
 
   if (! file_writable)
     {
@@ -358,7 +359,12 @@ __libc_pututline (const struct utmp *data)
       file_writable = true;
     }
 
+  /* Exclude other writers before validating the cache.  */
+  if (try_file_lock (file_fd, F_WRLCK))
+    return NULL;
+
   /* Find the correct place to insert the data.  */
+  bool found = false;
   if (file_offset > 0
       && ((last_entry.ut_type == data->ut_type
 	   && (last_entry.ut_type == RUN_LVL
@@ -366,23 +372,30 @@ __libc_pututline (const struct utmp *data)
 	       || last_entry.ut_type == OLD_TIME
 	       || last_entry.ut_type == NEW_TIME))
 	  || __utmp_equal (&last_entry, data)))
-    found = 1;
-  else
     {
-      bool lock_failed = false;
-      found = internal_getut_r (data, &lock_failed);
-
-      if (__builtin_expect (lock_failed, false))
+      if (__lseek64 (file_fd, file_offset, SEEK_SET) < 0)
 	{
-	  __set_errno (EAGAIN);
+	  file_unlock (file_fd);
 	  return NULL;
 	}
+      if (__read_nocancel (file_fd, &last_entry, sizeof (last_entry))
+	  != sizeof (last_entry))
+	{
+	  if (__lseek64 (file_fd, file_offset, SEEK_SET) < 0)
+	    {
+	      file_unlock (file_fd);
+	      return NULL;
+	    }
+	  found = false;
+	}
+      else
+	found = __utmp_equal (&last_entry, data);
     }
 
-  if (try_file_lock (file_fd, F_WRLCK))
-    return NULL;
+  if (!found)
+    found = internal_getut_nolock (data) >= 0;
 
-  if (found < 0)
+  if (!found)
     {
       /* We append the next entry.  */
       file_offset = __lseek64 (file_fd, 0, SEEK_END);
@@ -411,7 +424,7 @@ __libc_pututline (const struct utmp *data)
     {
       /* If we appended a new record this is only partially written.
 	 Remove it.  */
-      if (found < 0)
+      if (!found)
 	(void) __ftruncate64 (file_fd, file_offset);
       pbuf = NULL;
     }

commit dfa1f9fe0df169cd099a6f5cc0c43ccdd73590d0
Author: Florian Weimer <fweimer@redhat.com>
Date:   Tue Nov 12 12:02:57 2019 +0100

    login: Introduce matches_last_entry to utmp processing
    
    This simplifies internal_getut_nolock and fixes a regression,
    introduced in commit be6b16d975683e6cca57852cd4cfe715b2a9d8b1
    ("login: Acquire write lock early in pututline [BZ #24882]")
    in pututxline because __utmp_equal can only compare process-related
    utmp entries.
    
    Fixes: be6b16d975683e6cca57852cd4cfe715b2a9d8b1
    Change-Id: Ib8a85002f7f87ee41590846d16d7e52bdb82f5a5
    (cherry picked from commit 76a7c103eb9060f9e3ba01d073ae4621a17d8b46)

diff --git a/login/utmp_file.c b/login/utmp_file.c
index d1612ff2b5..b28fb762d7 100644
--- a/login/utmp_file.c
+++ b/login/utmp_file.c
@@ -43,6 +43,25 @@ static off64_t file_offset;
 /* Cache for the last read entry.  */
 static struct utmp last_entry;
 
+/* Returns true if *ENTRY matches last_entry, based on
+   data->ut_type.  */
+static bool
+matches_last_entry (const struct utmp *data)
+{
+  if (file_offset <= 0)
+    /* Nothing has been read.  last_entry is stale and cannot match.  */
+    return false;
+
+  if (data->ut_type == RUN_LVL
+      || data->ut_type == BOOT_TIME
+      || data->ut_type == OLD_TIME
+      || data->ut_type == NEW_TIME)
+    /* For some entry types, only a type match is required.  */
+    return data->ut_type == last_entry.ut_type;
+  else
+    /* For the process-related entries, a full match is needed.  */
+    return __utmp_equal (&last_entry, data);
+}
 
 /* Locking timeout.  */
 #ifndef TIMEOUT
@@ -133,9 +152,6 @@ __libc_setutent (void)
   __lseek64 (file_fd, 0, SEEK_SET);
   file_offset = 0;
 
-  /* Make sure the entry won't match.  */
-  last_entry.ut_type = -1;
-
   return 1;
 }
 
@@ -191,48 +207,20 @@ __libc_getutent_r (struct utmp *buffer, struct utmp **result)
 static int
 internal_getut_nolock (const struct utmp *id)
 {
-  if (id->ut_type == RUN_LVL || id->ut_type == BOOT_TIME
-      || id->ut_type == OLD_TIME || id->ut_type == NEW_TIME)
+  while (1)
     {
-      /* Search for next entry with type RUN_LVL, BOOT_TIME,
-	 OLD_TIME, or NEW_TIME.  */
-
-      while (1)
+      /* Read the next entry.  */
+      if (__read_nocancel (file_fd, &last_entry, sizeof (struct utmp))
+	  != sizeof (struct utmp))
 	{
-	  /* Read the next entry.  */
-	  if (__read_nocancel (file_fd, &last_entry, sizeof (struct utmp))
-	      != sizeof (struct utmp))
-	    {
-	      __set_errno (ESRCH);
-	      file_offset = -1l;
-	      return -1;
-	    }
-	  file_offset += sizeof (struct utmp);
-
-	  if (id->ut_type == last_entry.ut_type)
-	    break;
+	  __set_errno (ESRCH);
+	  file_offset = -1l;
+	  return -1;
 	}
-    }
-  else
-    {
-      /* Search for the next entry with the specified ID and with type
-	 INIT_PROCESS, LOGIN_PROCESS, USER_PROCESS, or DEAD_PROCESS.  */
-
-      while (1)
-	{
-	  /* Read the next entry.  */
-	  if (__read_nocancel (file_fd, &last_entry, sizeof (struct utmp))
-	      != sizeof (struct utmp))
-	    {
-	      __set_errno (ESRCH);
-	      file_offset = -1l;
-	      return -1;
-	    }
-	  file_offset += sizeof (struct utmp);
+      file_offset += sizeof (struct utmp);
 
-	  if (__utmp_equal (&last_entry, id))
-	    break;
-	}
+      if (matches_last_entry (id))
+	break;
     }
 
   return 0;
@@ -365,13 +353,7 @@ __libc_pututline (const struct utmp *data)
 
   /* Find the correct place to insert the data.  */
   bool found = false;
-  if (file_offset > 0
-      && ((last_entry.ut_type == data->ut_type
-	   && (last_entry.ut_type == RUN_LVL
-	       || last_entry.ut_type == BOOT_TIME
-	       || last_entry.ut_type == OLD_TIME
-	       || last_entry.ut_type == NEW_TIME))
-	  || __utmp_equal (&last_entry, data)))
+  if (matches_last_entry (data))
     {
       if (__lseek64 (file_fd, file_offset, SEEK_SET) < 0)
 	{
@@ -389,7 +371,7 @@ __libc_pututline (const struct utmp *data)
 	  found = false;
 	}
       else
-	found = __utmp_equal (&last_entry, data);
+	found = matches_last_entry (data);
     }
 
   if (!found)

commit 6359e79b4c1c6c30bcbd536298308d5ec0b01157
Author: Leandro Pereira <leandro.pereira@microsoft.com>
Date:   Wed Oct 2 12:42:28 2019 -0400

    Add nocancel version of pread64()
    
    This is in preparation for changes in the dynamic linker so that
    pread() is used instead of lseek()+read().
    
    Reviewed-by: Carlos O'Donell <carlos@redhat.com>
    (cherry picked from commit fed33b0fb03d1942a6713286176d42869c0f1580)

diff --git a/sysdeps/generic/not-cancel.h b/sysdeps/generic/not-cancel.h
index f3d862651e..724c3e5e71 100644
--- a/sysdeps/generic/not-cancel.h
+++ b/sysdeps/generic/not-cancel.h
@@ -41,6 +41,8 @@
   (void) __close (fd)
 #define __read_nocancel(fd, buf, n) \
   __read (fd, buf, n)
+#define __pread64_nocancel(fd, buf, count, offset) \
+  __pread64 (fd, buf, count, offset)
 #define __write_nocancel(fd, buf, n) \
   __write (fd, buf, n)
 #define __writev_nocancel_nostatus(fd, iov, n) \
diff --git a/sysdeps/unix/sysv/linux/Makefile b/sysdeps/unix/sysv/linux/Makefile
index 1ab6bcbfc8..a7980a60f6 100644
--- a/sysdeps/unix/sysv/linux/Makefile
+++ b/sysdeps/unix/sysv/linux/Makefile
@@ -212,8 +212,8 @@ sysdep_routines += xstatconv internal_statvfs internal_statvfs64 \
 		   close_nocancel fcntl_nocancel nanosleep_nocancel \
 		   open_nocancel open64_nocancel \
 		   openat_nocancel openat64_nocancel \
-		   pause_nocancel read_nocancel waitpid_nocancel \
-		   write_nocancel statx_cp
+		   pause_nocancel read_nocancel pread64_nocancel \
+		   waitpid_nocancel write_nocancel statx_cp
 
 sysdep_headers += bits/fcntl-linux.h
 
diff --git a/sysdeps/unix/sysv/linux/Versions b/sysdeps/unix/sysv/linux/Versions
index 1ca102a9e2..d385085c61 100644
--- a/sysdeps/unix/sysv/linux/Versions
+++ b/sysdeps/unix/sysv/linux/Versions
@@ -182,6 +182,7 @@ libc {
     __syscall_rt_sigqueueinfo;
     __open_nocancel;
     __read_nocancel;
+    __pread64_nocancel;
     __close_nocancel;
     __sigtimedwait;
     # functions used by nscd
diff --git a/sysdeps/unix/sysv/linux/not-cancel.h b/sysdeps/unix/sysv/linux/not-cancel.h
index 16cc31cba5..bf7d80125a 100644
--- a/sysdeps/unix/sysv/linux/not-cancel.h
+++ b/sysdeps/unix/sysv/linux/not-cancel.h
@@ -43,6 +43,9 @@ __typeof (openat64) __openat64_nocancel;
 /* Non cancellable read syscall.  */
 __typeof (__read) __read_nocancel;
 
+/* Non cancellable pread syscall (LFS version).  */
+__typeof (__pread64) __pread64_nocancel;
+
 /* Uncancelable write.  */
 __typeof (__write) __write_nocancel;
 
@@ -84,6 +87,7 @@ hidden_proto (__open64_nocancel)
 hidden_proto (__openat_nocancel)
 hidden_proto (__openat64_nocancel)
 hidden_proto (__read_nocancel)
+hidden_proto (__pread64_nocancel)
 hidden_proto (__write_nocancel)
 hidden_proto (__close_nocancel)
 hidden_proto (__waitpid_nocancel)
diff --git a/sysdeps/unix/sysv/linux/pread64_nocancel.c b/sysdeps/unix/sysv/linux/pread64_nocancel.c
new file mode 100644
index 0000000000..dab61260e5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/pread64_nocancel.c
@@ -0,0 +1,32 @@
+/* Linux pread64() syscall implementation -- non-cancellable.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <unistd.h>
+#include <sysdep-cancel.h>
+#include <not-cancel.h>
+
+#ifndef __NR_pread64
+# define __NR_pread64 __NR_pread
+#endif
+
+ssize_t
+__pread64_nocancel (int fd, void *buf, size_t count, off64_t offset)
+{
+  return INLINE_SYSCALL_CALL (pread64, fd, buf, count, SYSCALL_LL64_PRW (offset));
+}
+hidden_def (__pread64_nocancel)

commit 858069cb60c40c39a65f2d354e518353240d59d0
Author: Florian Weimer <fweimer@redhat.com>
Date:   Tue Nov 12 12:25:49 2019 +0100

    login: Use pread64 in utmp implementation
    
    This reduces the possible error scenarios considerably because
    no longer can file seek fail, leaving the file descriptor in an
    inconsistent state and out of sync with the cache.
    
    As a result, it is possible to avoid setting file_offset to -1
    to make an error persistent.  Instead, subsequent calls will retry
    the operation and report any errors returned by the kernel.
    
    This change also avoids reading the file from the start if pututline
    is called multiple times, to work around lock acquisition failures
    due to timeouts.
    
    Change-Id: If21ea0c162c38830a89331ea93cddec14c0974de
    (cherry picked from commit d4625a19fe64f664119a541b317fb83de01bb273)

diff --git a/login/utmp_file.c b/login/utmp_file.c
index b28fb762d7..e98bc31899 100644
--- a/login/utmp_file.c
+++ b/login/utmp_file.c
@@ -162,12 +162,35 @@ maybe_setutent (void)
   return file_fd >= 0 || __libc_setutent ();
 }
 
+/* Reads the entry at file_offset, storing it in last_entry and
+   updating file_offset on success.  Returns -1 for a read error, 0
+   for EOF, and 1 for a successful read.  last_entry and file_offset
+   are only updated on a successful and complete read.  */
+static ssize_t
+read_last_entry (void)
+{
+  struct utmp buffer;
+  ssize_t nbytes = __pread64_nocancel (file_fd, &buffer, sizeof (buffer),
+				       file_offset);
+  if (nbytes < 0)
+    return -1;
+  else if (nbytes != sizeof (buffer))
+    /* Assume EOF.  */
+    return 0;
+  else
+    {
+      last_entry = buffer;
+      file_offset += sizeof (buffer);
+      return 1;
+    }
+}
+
 int
 __libc_getutent_r (struct utmp *buffer, struct utmp **result)
 {
-  ssize_t nbytes;
+  int saved_errno = errno;
 
-  if (!maybe_setutent () || file_offset == -1l)
+  if (!maybe_setutent ())
     {
       /* Not available.  */
       *result = NULL;
@@ -175,25 +198,22 @@ __libc_getutent_r (struct utmp *buffer, struct utmp **result)
     }
 
   if (try_file_lock (file_fd, F_RDLCK))
-    nbytes = 0;
-  else
-    {
-      /* Read the next entry.  */
-      nbytes = __read_nocancel (file_fd, &last_entry, sizeof (struct utmp));
-      file_unlock (file_fd);
-    }
+    return -1;
 
-  if (nbytes != sizeof (struct utmp))
+  ssize_t nbytes = read_last_entry ();
+  file_unlock (file_fd);
+
+  if (nbytes <= 0)		/* Read error or EOF.  */
     {
-      if (nbytes != 0)
-	file_offset = -1l;
+      if (nbytes == 0)
+	/* errno should be unchanged to indicate success.  A premature
+	   EOF is treated like an EOF (missing complete record at the
+	   end).  */
+	__set_errno (saved_errno);
       *result = NULL;
       return -1;
     }
 
-  /* Update position pointer.  */
-  file_offset += sizeof (struct utmp);
-
   memcpy (buffer, &last_entry, sizeof (struct utmp));
   *result = buffer;
 
@@ -209,15 +229,15 @@ internal_getut_nolock (const struct utmp *id)
 {
   while (1)
     {
-      /* Read the next entry.  */
-      if (__read_nocancel (file_fd, &last_entry, sizeof (struct utmp))
-	  != sizeof (struct utmp))
+      ssize_t nbytes = read_last_entry ();
+      if (nbytes < 0)
+	return -1;
+      if (nbytes == 0)
 	{
+	  /* End of file reached.  */
 	  __set_errno (ESRCH);
-	  file_offset = -1l;
 	  return -1;
 	}
-      file_offset += sizeof (struct utmp);
 
       if (matches_last_entry (id))
 	break;
@@ -249,7 +269,7 @@ int
 __libc_getutid_r (const struct utmp *id, struct utmp *buffer,
 		  struct utmp **result)
 {
-  if (!maybe_setutent () || file_offset == -1l)
+  if (!maybe_setutent ())
     {
       *result = NULL;
       return -1;
@@ -276,7 +296,7 @@ int
 __libc_getutline_r (const struct utmp *line, struct utmp *buffer,
 		    struct utmp **result)
 {
-  if (!maybe_setutent () || file_offset == -1l)
+  if (!maybe_setutent ())
     {
       *result = NULL;
       return -1;
@@ -290,16 +310,21 @@ __libc_getutline_r (const struct utmp *line, struct utmp *buffer,
 
   while (1)
     {
-      /* Read the next entry.  */
-      if (__read_nocancel (file_fd, &last_entry, sizeof (struct utmp))
-	  != sizeof (struct utmp))
+      ssize_t nbytes = read_last_entry ();
+      if (nbytes < 0)
 	{
+	  file_unlock (file_fd);
+	  *result = NULL;
+	  return -1;
+	}
+      if (nbytes == 0)
+	{
+	  /* End of file reached.  */
+	  file_unlock (file_fd);
 	  __set_errno (ESRCH);
-	  file_offset = -1l;
 	  *result = NULL;
-	  goto unlock_return;
+	  return -1;
 	}
-      file_offset += sizeof (struct utmp);
 
       /* Stop if we found a user or login entry.  */
       if ((last_entry.ut_type == USER_PROCESS
@@ -309,20 +334,18 @@ __libc_getutline_r (const struct utmp *line, struct utmp *buffer,
 	break;
     }
 
+  file_unlock (file_fd);
   memcpy (buffer, &last_entry, sizeof (struct utmp));
   *result = buffer;
 
-unlock_return:
-  file_unlock (file_fd);
-
-  return ((*result == NULL) ? -1 : 0);
+  return 0;
 }
 
 
 struct utmp *
 __libc_pututline (const struct utmp *data)
 {
-  if (!maybe_setutent () || file_offset == -1l)
+  if (!maybe_setutent ())
     return NULL;
 
   struct utmp *pbuf;
@@ -337,8 +360,7 @@ __libc_pututline (const struct utmp *data)
       if (new_fd == -1)
 	return NULL;
 
-      if (__lseek64 (new_fd, __lseek64 (file_fd, 0, SEEK_CUR), SEEK_SET) == -1
-	  || __dup2 (new_fd, file_fd) < 0)
+      if (__dup2 (new_fd, file_fd) < 0)
 	{
 	  __close_nocancel_nostatus (new_fd);
 	  return NULL;
@@ -355,69 +377,70 @@ __libc_pututline (const struct utmp *data)
   bool found = false;
   if (matches_last_entry (data))
     {
-      if (__lseek64 (file_fd, file_offset, SEEK_SET) < 0)
+      /* Read back the entry under the write lock.  */
+      file_offset -= sizeof (last_entry);
+      ssize_t nbytes = read_last_entry ();
+      if (nbytes < 0)
 	{
 	  file_unlock (file_fd);
 	  return NULL;
 	}
-      if (__read_nocancel (file_fd, &last_entry, sizeof (last_entry))
-	  != sizeof (last_entry))
-	{
-	  if (__lseek64 (file_fd, file_offset, SEEK_SET) < 0)
-	    {
-	      file_unlock (file_fd);
-	      return NULL;
-	    }
-	  found = false;
-	}
+
+      if (nbytes == 0)
+	/* End of file reached.  */
+	found = false;
       else
 	found = matches_last_entry (data);
     }
 
   if (!found)
+    /* Search forward for the entry.  */
     found = internal_getut_nolock (data) >= 0;
 
+  off64_t write_offset;
   if (!found)
     {
       /* We append the next entry.  */
-      file_offset = __lseek64 (file_fd, 0, SEEK_END);
-      if (file_offset % sizeof (struct utmp) != 0)
-	{
-	  file_offset -= file_offset % sizeof (struct utmp);
-	  __ftruncate64 (file_fd, file_offset);
-
-	  if (__lseek64 (file_fd, 0, SEEK_END) < 0)
-	    {
-	      pbuf = NULL;
-	      goto unlock_return;
-	    }
-	}
+      write_offset = __lseek64 (file_fd, 0, SEEK_END);
+
+      /* Round down to the next multiple of the entry size.  This
+	 ensures any partially-written record is overwritten by the
+	 new record.  */
+      write_offset = (write_offset / sizeof (struct utmp)
+		      * sizeof (struct utmp));
     }
   else
+    /* Overwrite last_entry.  */
+    write_offset = file_offset - sizeof (struct utmp);
+
+  /* Write the new data.  */
+  ssize_t nbytes;
+  if (__lseek64 (file_fd, write_offset, SEEK_SET) < 0
+      || (nbytes = __write_nocancel (file_fd, data, sizeof (struct utmp))) < 0)
     {
-      /* We replace the just read entry.  */
-      file_offset -= sizeof (struct utmp);
-      __lseek64 (file_fd, file_offset, SEEK_SET);
+      /* There is no need to recover the file position because all
+	 reads use pread64, and any future write is preceded by
+	 another seek.  */
+      file_unlock (file_fd);
+      return NULL;
     }
 
-  /* Write the new data.  */
-  if (__write_nocancel (file_fd, data, sizeof (struct utmp))
-      != sizeof (struct utmp))
+  if (nbytes != sizeof (struct utmp))
     {
       /* If we appended a new record this is only partially written.
 	 Remove it.  */
       if (!found)
-	(void) __ftruncate64 (file_fd, file_offset);
-      pbuf = NULL;
-    }
-  else
-    {
-      file_offset += sizeof (struct utmp);
-      pbuf = (struct utmp *) data;
+	(void) __ftruncate64 (file_fd, write_offset);
+      file_unlock (file_fd);
+      /* Assume that the write failure was due to missing disk
+	 space.  */
+      __set_errno (ENOSPC);
+      return NULL;
     }
 
- unlock_return:
   file_unlock (file_fd);
+  file_offset = write_offset + sizeof (struct utmp);
+  pbuf = (struct utmp *) data;
 
   return pbuf;
 }

commit 994e529a37953a057b9e6c80afa03b03fd3724f2
Author: Florian Weimer <fweimer@redhat.com>
Date:   Fri Jan 17 15:11:20 2020 +0100

    Remove incorrect alloc_size attribute from pvalloc [BZ #25401]
    
    pvalloc is guarantueed to round up the allocation size to the page
    size, so applications can assume that the memory region is larger
    than the passed-in argument.  The alloc_size attribute cannot express
    that.
    
    The test case is based on a suggestion from Jakub Jelinek.
    
    This fixes commit 9bf8e29ca136094f73f69f725f15c51facc97206 ("malloc:
    make malloc fail with requests larger than PTRDIFF_MAX (BZ#23741)").
    
    Reviewed-by: Adhemerval Zanella <adhemerval.zanella@linaro.org>
    (cherry picked from commit 768c83b7f60d82db6677e19dc51be9f341e0f3fc)

diff --git a/NEWS b/NEWS
index 1352a339ab..2c707f35ff 100644
--- a/NEWS
+++ b/NEWS
@@ -33,6 +33,7 @@ The following bugs are resolved with this release:
   [25204] Ignore LD_PREFER_MAP_32BIT_EXEC for SUID programs
   [25225] ld.so fails to link on x86 if GCC defaults to -fcf-protection
   [25232] No const correctness for strchr et al. for Clang++
+  [25401] Remove incorrect alloc_size attribute from pvalloc
 
 
 Version 2.30
diff --git a/malloc/Makefile b/malloc/Makefile
index 742c515eb2..9698574bba 100644
--- a/malloc/Makefile
+++ b/malloc/Makefile
@@ -27,7 +27,7 @@ headers := $(dist-headers) obstack.h mcheck.h
 tests := mallocbug tst-malloc tst-valloc tst-calloc tst-obstack \
 	 tst-mcheck tst-mallocfork tst-trim1 \
 	 tst-malloc-usable tst-realloc tst-reallocarray tst-posix_memalign \
-	 tst-pvalloc tst-memalign tst-mallopt \
+	 tst-pvalloc tst-pvalloc-fortify tst-memalign tst-mallopt \
 	 tst-malloc-backtrace tst-malloc-thread-exit \
 	 tst-malloc-thread-fail tst-malloc-fork-deadlock \
 	 tst-mallocfork2 \
diff --git a/malloc/malloc.h b/malloc/malloc.h
index 70d8282bdc..f62c6c594c 100644
--- a/malloc/malloc.h
+++ b/malloc/malloc.h
@@ -71,8 +71,7 @@ extern void *valloc (size_t __size) __THROW __attribute_malloc__
 
 /* Equivalent to valloc(minimum-page-that-holds(n)), that is, round up
    __size to nearest pagesize. */
-extern void *pvalloc (size_t __size) __THROW __attribute_malloc__
-     __attribute_alloc_size__ ((1)) __wur;
+extern void *pvalloc (size_t __size) __THROW __attribute_malloc__ __wur;
 
 /* Underlying allocation function; successive calls should return
    contiguous pieces of memory.  */
diff --git a/malloc/tst-pvalloc-fortify.c b/malloc/tst-pvalloc-fortify.c
new file mode 100644
index 0000000000..391b7fa2f5
--- /dev/null
+++ b/malloc/tst-pvalloc-fortify.c
@@ -0,0 +1,48 @@
+/* Test fortify-source allocation size handling in pvalloc (bug 25401).
+   Copyright (C) 2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <https://www.gnu.org/licenses/>.  */
+
+#undef _FORTIFY_SOURCE
+#define _FORTIFY_SOURCE 2
+#include <malloc.h>
+#include <string.h>
+#include <support/check.h>
+#include <support/xunistd.h>
+#include <unistd.h>
+
+static int
+do_test (void)
+{
+  /* The test below assumes that pvalloc rounds up the allocation size
+     to at least 8.  */
+  TEST_VERIFY (xsysconf (_SC_PAGESIZE) >= 8);
+
+  void *p = pvalloc (5);
+  TEST_VERIFY_EXIT (p != NULL);
+
+  /* This is valid assuming the page size is at least 8 because
+     pvalloc rounds up the allocation size to a multiple of the page
+     size.  Due to bug 25041, this used to trigger a compiler
+     warning.  */
+  strcpy (p, "abcdefg");
+
+  asm ("" : : "g" (p) : "memory"); /* Optimization barrier.  */
+  TEST_VERIFY (malloc_usable_size (p) >= xsysconf (_SC_PAGESIZE));
+  return 0;
+}
+
+#include <support/test-driver.c>

commit 43598ef6e2b1a8226db9f83dac9e93224306e242
Author: John David Anglin <danglin@gcc.gnu.org>
Date:   Sun Nov 3 16:28:01 2019 -0500

    hppa: Align __clone stack argument to 8 bytes (Bug 25066)
    
    The hppa architecture requires strict alignment for loads and stores.
    As a result, the minimum stack alignment that will work is 8 bytes.
    This patch adjusts __clone() to align the stack argument passed to it.
    It also adjusts slightly some formatting.
    
    This fixes the nptl/tst-tls1 test.
    
    (cherry picked from commit e4c23a029a54c8c7788eff9ca771a01cccaaa0ce)

diff --git a/NEWS b/NEWS
index 2c707f35ff..15df670edc 100644
--- a/NEWS
+++ b/NEWS
@@ -28,6 +28,7 @@ The following bugs are resolved with this release:
     unconditionally
   [24899] login: Add nonstring attributes to struct utmp, struct utmpx
   [24902] login: pututxline could fail to overwrite existing entries
+  [25066] FAIL: nptl/tst-tls1 on hppa
   [25189] Don't use a custom wrapper macro around __has_include
   [25203] libio: Disable vtable validation for pre-2.1 interposed handles
   [25204] Ignore LD_PREFER_MAP_32BIT_EXEC for SUID programs
diff --git a/sysdeps/unix/sysv/linux/hppa/clone.S b/sysdeps/unix/sysv/linux/hppa/clone.S
index 79fa4f6147..1c0325e199 100644
--- a/sysdeps/unix/sysv/linux/hppa/clone.S
+++ b/sysdeps/unix/sysv/linux/hppa/clone.S
@@ -73,13 +73,18 @@ ENTRY(__clone)
 #endif
 
 	/* Sanity check arguments.  */
-	comib,=,n  0, %arg0, .LerrorSanity        /* no NULL function pointers */
-	comib,=,n  0, %arg1, .LerrorSanity        /* no NULL stack pointers */
+	comib,=,n	0,%arg0,.LerrorSanity	/* no NULL function pointers */
+	comib,=,n	0,%arg1,.LerrorSanity	/* no NULL stack pointers */
+
+	/* Ensure stack argument is 8-byte aligned.  */
+	ldo		7(%r25),%r25
+	depi		0,31,3,%r25
 
 	/* Save the function pointer, arg, and flags on the new stack.  */
 	stwm    %r26, 64(%r25)
 	stw	%r23, -60(%r25)
 	stw     %r24, -56(%r25)
+
 	/* Clone arguments are (int flags, void * child_stack) */
 	copy	%r24, %r26		/* flags are first */
 	/* User stack pointer is in the correct register already */
