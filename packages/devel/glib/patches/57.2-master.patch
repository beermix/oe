diff --git a/configure.ac b/configure.ac
index 11fde900f..3fd519ecd 100644
--- a/configure.ac
+++ b/configure.ac
@@ -922,20 +922,22 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
         AC_MSG_RESULT(no)
 ])
 
-AC_MSG_CHECKING([if ip_mreq_source.imr_interface has s_addr member])
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
-    [[
-        #include <netinet/in.h>
-    ]],
-    [[
-        struct ip_mreq_source mc_req_src;
-        mc_req_src.imr_interface.s_addr = 0;
-    ]])], [
-        AC_MSG_RESULT(yes)
-    ], [
-        AC_MSG_RESULT(no)
-        AC_DEFINE(BROKEN_IP_MREQ_SOURCE_STRUCT, 1, [struct ip_mreq_source definition is broken on Android NDK <= r16])
-])
+# See https://bugzilla.gnome.org/show_bug.cgi?id=740791
+AS_IF([test $glib_native_android = yes], [
+  AC_MSG_CHECKING([if ip_mreq_source.imr_interface has s_addr member])
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+      [[
+          #include <netinet/in.h>
+      ]],
+      [[
+          struct ip_mreq_source mc_req_src;
+          mc_req_src.imr_interface.s_addr = 0;
+      ]])], [
+          AC_MSG_RESULT(yes)
+      ], [
+          AC_MSG_RESULT(no)
+          AC_DEFINE(BROKEN_IP_MREQ_SOURCE_STRUCT, 1, [struct ip_mreq_source definition is broken on Android NDK <= r16])
+  ])])
 
 AS_IF([test $glib_native_win32 = yes], [
   # <wspiapi.h> in the Windows SDK and in mingw-w64 has wrappers for
diff --git a/docs/reference/glib/cross.xml b/docs/reference/glib/cross.xml
index 35d169b7a..c45200437 100644
--- a/docs/reference/glib/cross.xml
+++ b/docs/reference/glib/cross.xml
@@ -2,7 +2,7 @@
 <!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
 ]>
-<refentry id="glib-cross-compiling" revision="8 Apr 2003">
+<refentry id="glib-cross-compiling" revision="7 Aug 2018">
 <refmeta>
 <refentrytitle>Cross-compiling the GLib package</refentrytitle>
 <manvolnum>3</manvolnum>
@@ -28,181 +28,118 @@ How to cross-compile GLib
       <para>
         These notes cover things specific to cross-compiling GLib;
         for general information about cross-compilation, see the
-        <application>autoconf</application> info pages.
+        <ulink url="http://mesonbuild.com/Cross-compilation.html">meson</ulink>
+        info pages.
       </para>
       <para>
         GLib tries to detect as much information as possible about
         the target system by compiling and linking programs without
         actually running anything; however, some information GLib
         needs is not available this way. This information needs
-        to be provided to the configure script via a "cache file"
-        or by setting the cache variables in your environment.
+        to be provided to meson via a ‘cross file’.
       </para>
       <para>
-        As an example of using a cache file, to cross compile for
-        the "MingW32" Win32 runtime environment on a Linux system,
-        create a file 'win32.cache' with the following contents:
+        As an example of using a cross file, to cross compile for
+        the ‘MingW32’ Win64 runtime environment on a Linux system,
+        create a file <filename>cross_file.txt</filename> with the following
+        contents:
       </para>
       <programlisting> 
-glib_cv_long_long_format=I64
-glib_cv_stack_grows=no
+[host_machine]
+system = 'windows'
+cpu_family = 'x86_64'
+cpu = 'x86_64'
+endian = 'little'
+
+[properties]
+c_args = []
+c_link_args = []
+
+[binaries]
+c = 'x86_64-w64-mingw32-gcc'
+cpp = 'x86_64-w64-mingw32-g++'
+ar = 'x86_64-w64-mingw32-ar'
+strip = 'x86_64-w64-mingw32-strip'
+pkgconfig = 'x86_64-w64-mingw32-pkg-config'
+windres = 'x86_64-w64-mingw32-windres'
       </programlisting>
       <para>
         Then execute the following commands:
       </para>
       <programlisting>
-PATH=/path/to/mingw32-compiler/bin:$PATH
-chmod a-w win32.cache   # prevent configure from changing it
-./configure --cache-file=win32.cache --host=mingw32
+meson --cross_file cross_file.txt builddir
       </programlisting>
       <para>
-        The complete list of cache file variables follows. Most
+        The complete list of cross properties follows. Most
          of these won't need to be set in most cases.
       </para>
     </refsect1>
-    <refsect1 id="cache-file-variables">
-      <title>Cache file variables</title>
+    <refsect1 id="cross-properties">
+      <title>Cross properties</title>
       <formalpara>
-        <title>glib_cv_long_long_format=[ll/q/I64]</title>
-        
-        <para>
-           Format used by <function>printf()</function> and 
-           <function>scanf()</function> for 64 bit integers. "ll" is 
-           the C99 standard, and what is used by the 'trio' library
-           that GLib builds if your <function>printf()</function> is 
-           insufficiently capable.
-           Doesn't need to be set if you are compiling using trio.
-        </para>
-      </formalpara>
-      <formalpara>
-        <title>glib_cv_stack_grows=[yes/no]</title>
+        <title>have_[function]</title>
 
         <para>
-           Whether the stack grows up or down. Most places will want "no",
-           A few architectures, such as PA-RISC need "yes".
+           When meson checks if a function is supported, the test can be
+           overridden by setting the
+           <literal>have_<replaceable>function</replaceable></literal> property
+           to <constant>true</constant> or <constant>false</constant>.
+           For example <programlisting>Checking for function "alloca" : YES</programlisting>
+           can be overridden by setting <programlisting>have_alloca = false</programlisting>
         </para>
       </formalpara>
       <formalpara>
-        <title>glib_cv_working_bcopy=[yes/no]</title>
+        <title>growing_stack=[true/false]</title>
 
         <para>
-           Whether your <function>bcopy()</function> can handle overlapping 
-           copies. Only needs to be set if you don't have 
-           <function>memmove()</function>. (Very unlikely)
-	</para>
-      </formalpara>
-      <formalpara>
-         <title>glib_cv_sane_realloc=[yes/no]</title>
-
-         <para>  
-            Whether your <function>realloc()</function> conforms to ANSI C 
-            and can handle <literal>NULL</literal> as the first argument. 
-            Defaults to "yes" and probably doesn't need to be set.
-	</para>
+           Whether the stack grows up or down. Most places will want
+           <constant>false</constant>.
+           A few architectures, such as PA-RISC need <constant>true</constant>.
+        </para>
       </formalpara>
       <formalpara>
-         <title>glib_cv_have_strlcpy=[yes/no]</title>
+         <title>have_strlcpy=[true/false]</title>
 
          <para>
             Whether you have <function>strlcpy()</function> that matches 
-            OpenBSD. Defaults to "no", which is safe, since GLib uses a 
-            built-in version in that case.
+            OpenBSD. Defaults to <constant>false</constant>, which is safe,
+            since GLib uses a built-in version in that case.
 	</para>
       </formalpara>
       <formalpara>
-         <title>glib_cv_have_qsort_r=[yes/no]</title>
+         <title>va_val_copy=[true/false]</title>
 
-         <para>
-           Whether you have <function>qsort_r()</function> that matches
-           BSD. Defaults to "no", which is safe, since GLib uses a
-           built-in version in that case.
-         </para>
-      </formalpara>
-      <formalpara>
-         <title>glib_cv_va_val_copy=[yes/no]</title>
-   
          <para>
             Whether <type>va_list</type> can be copied as a pointer. If set 
-            to "no", then <function>memcopy()</function> will be used. Only 
-            matters if you don't have <function>va_copy()</function> or 
-            <function>__va_copy()</function>. (So, doesn't matter for GCC.) 
-            Defaults to "yes" which is slightly more common than "no".
-	</para>
-      </formalpara>
-      <formalpara>
-         <title>glib_cv_rtldglobal_broken=[yes/no]</title>
- 
-         <para>
-            Whether you have a bug found in OSF/1 v5.0. Defaults to "no".
-         </para>
-      </formalpara>
-      <formalpara>
-         <title>glib_cv_uscore=[yes/no]</title>
-
-         <para>
-            Whether an underscore needs to be prepended to symbols when
-            looking them up via <function>dlsym()</function>. Only needs to 
-            be set if your system uses
-	    <function>dlopen()</function>/<function>dlsym()</function>.
-	 </para>
-      </formalpara>
-      <formalpara>
-         <title>ac_cv_func_posix_getpwuid_r=[yes/no]</title>
-
-         <para>
-            Whether you have a getpwuid_r function (in your C library,
-	    not your thread library) that conforms to the POSIX spec.
-            (Takes a 'struct passwd **' as the final argument)
-         </para>
-      </formalpara>
-      <formalpara>
-         <title>ac_cv_func_nonposix_getpwuid_r=[yes/no]</title>
- 
-         <para>
-            Whether you have some variant of <function>getpwuid_r()</function>
-            that doesn't conform to to the POSIX spec, but GLib might be able
-            to use (or might segfault.) Only needs to be set if 
-	    <literal>ac_cv_func_posix_getpwuid_r</literal> is not set. It's 
-            safest to set this to "no".
-         </para>
-      </formalpara>
-      <formalpara>
-         <title>ac_cv_func_posix_getgrgid_r=[yes/no]</title>
- 
-         <para>
-            Whether you have a getgrgid_r function that conforms to
-            the POSIX spec.
-         </para>
-      </formalpara>
-      <formalpara>
-         <title>glib_cv_use_pid_surrogate=[yes/no]</title>
-
-         <para>
-            Whether to use a <function>setpriority()</function> on the PID of 
-            the thread as a method for setting the priority of threads. This 
-            only needs to be set when using POSIX threads.
-         </para>
+            to <constant>false</constant>, then <function>memcopy()</function>
+            will be used. Only matters if you don't have
+            <function>va_copy()</function> or <function>__va_copy()</function>.
+            (So, doesn't matter for GCC.)
+            Defaults to <constant>true</constant> which is slightly more common
+            than <constant>false</constant>.
+        </para>
       </formalpara>
       <formalpara>
-         <title>ac_cv_func_printf_unix98=[yes/no]</title>
+         <title>have_c99_vsnprintf=[true/false]</title>
 
          <para>
-           Whether your <function>printf()</function> family supports Unix98 
-           style <literal>%N$</literal> positional parameters. Defaults to
-	"no".
+            Whether you have a <function>vsnprintf()</function> with C99 
+            semantics. (C99 semantics means returning the number of bytes 
+            that would have been written had the output buffer had enough 
+            space.) Defaults to <constant>false</constant>.
          </para>
       </formalpara>
       <formalpara>
-         <title>ac_cv_func_vsnprintf_c99=[yes/no]</title>
+         <title>have_c99_snprintf=[true/false]</title>
 
          <para>
-            Whether you have a <function>vsnprintf()</function> with C99 
+            Whether you have a <function>snprintf()</function> with C99 
             semantics. (C99 semantics means returning the number of bytes 
             that would have been written had the output buffer had enough 
-            space.) Defaults to "no".
+            space.) Defaults to <constant>false</constant>.
          </para>
       </formalpara>
 
-    </refsect1>    
+    </refsect1>
 
 </refentry>
diff --git a/gio/gdbusmessage.c b/gio/gdbusmessage.c
index 68122387b..8de836bf6 100644
--- a/gio/gdbusmessage.c
+++ b/gio/gdbusmessage.c
@@ -1994,7 +1994,7 @@ g_dbus_message_bytes_needed (guchar  *blob,
 
 /**
  * g_dbus_message_new_from_blob:
- * @blob: (array length=blob_len) (element-type guint8): A blob represent a binary D-Bus message.
+ * @blob: (array length=blob_len) (element-type guint8): A blob representing a binary D-Bus message.
  * @blob_len: The length of @blob.
  * @capabilities: A #GDBusCapabilityFlags describing what protocol features are supported.
  * @error: Return location for error or %NULL.
diff --git a/gio/gio-tool-mount.c b/gio/gio-tool-mount.c
index b5aaa1af2..05647d91e 100644
--- a/gio/gio-tool-mount.c
+++ b/gio/gio-tool-mount.c
@@ -39,6 +39,7 @@ typedef enum {
 
 static int outstanding_mounts = 0;
 static GMainLoop *main_loop;
+static GVolumeMonitor *volume_monitor;
 
 static gboolean mount_mountable = FALSE;
 static gboolean mount_unmount = FALSE;
@@ -484,12 +485,9 @@ stop_with_device_file_cb (GObject *object,
 static void
 stop_with_device_file (const char *device_file)
 {
-  GVolumeMonitor *volume_monitor;
   GList *drives;
   GList *l;
 
-  volume_monitor = g_volume_monitor_get ();
-
   drives = g_volume_monitor_get_connected_drives (volume_monitor);
   for (l = drives; l != NULL; l = l->next)
     {
@@ -524,8 +522,6 @@ stop_with_device_file (const char *device_file)
       print_error ("%s: %s", device_file, _("No drive for device file"));
       success = FALSE;
     }
-
-  g_object_unref (volume_monitor);
 }
 
 static gboolean
@@ -905,11 +901,8 @@ list_drives (GList *drives,
 static void
 list_monitor_items (void)
 {
-  GVolumeMonitor *volume_monitor;
   GList *drives, *volumes, *mounts;
 
-  volume_monitor = g_volume_monitor_get();
-
   /* populate gvfs network mounts */
   iterate_gmain();
 
@@ -924,19 +917,14 @@ list_monitor_items (void)
   mounts = g_volume_monitor_get_mounts (volume_monitor);
   list_mounts (mounts, 0, TRUE);
   g_list_free_full (mounts, g_object_unref);
-
-  g_object_unref (volume_monitor);
 }
 
 static void
 unmount_all_with_scheme (const char *scheme)
 {
-  GVolumeMonitor *volume_monitor;
   GList *mounts;
   GList *l;
 
-  volume_monitor = g_volume_monitor_get();
-
   /* populate gvfs network mounts */
   iterate_gmain();
 
@@ -952,8 +940,6 @@ unmount_all_with_scheme (const char *scheme)
     g_object_unref (root);
   }
   g_list_free_full (mounts, g_object_unref);
-
-  g_object_unref (volume_monitor);
 }
 
 static void
@@ -1004,12 +990,9 @@ mount_with_device_file_cb (GObject *object,
 static void
 mount_with_device_file (const char *device_file)
 {
-  GVolumeMonitor *volume_monitor;
   GList *volumes;
   GList *l;
 
-  volume_monitor = g_volume_monitor_get();
-
   volumes = g_volume_monitor_get_volumes (volume_monitor);
   for (l = volumes; l != NULL; l = l->next)
     {
@@ -1044,8 +1027,6 @@ mount_with_device_file (const char *device_file)
       print_error ("%s: %s", device_file, _("No volume for device file"));
       success = FALSE;
     }
-
-  g_object_unref (volume_monitor);
 }
 
 static void
@@ -1199,10 +1180,6 @@ monitor_drive_eject_button (GVolumeMonitor *volume_monitor, GDrive *drive)
 static void
 monitor (void)
 {
-  GVolumeMonitor *volume_monitor;
-
-  volume_monitor = g_volume_monitor_get ();
-
   g_signal_connect (volume_monitor, "mount-added", (GCallback) monitor_mount_added, NULL);
   g_signal_connect (volume_monitor, "mount-removed", (GCallback) monitor_mount_removed, NULL);
   g_signal_connect (volume_monitor, "mount-changed", (GCallback) monitor_mount_changed, NULL);
@@ -1255,6 +1232,7 @@ handle_mount (int argc, char *argv[], gboolean do_help)
     }
 
   main_loop = g_main_loop_new (NULL, FALSE);
+  volume_monitor = g_volume_monitor_get ();
 
   if (mount_list)
     list_monitor_items ();
@@ -1284,6 +1262,7 @@ handle_mount (int argc, char *argv[], gboolean do_help)
     {
       show_help (context, _("No locations given"));
       g_option_context_free (context);
+      g_object_unref (volume_monitor);
       return 1;
     }
 
@@ -1292,5 +1271,7 @@ handle_mount (int argc, char *argv[], gboolean do_help)
   if (outstanding_mounts > 0)
     g_main_loop_run (main_loop);
 
+  g_object_unref (volume_monitor);
+
   return success ? 0 : 2;
 }
diff --git a/gio/glocalfileinfo.c b/gio/glocalfileinfo.c
index b3e29374a..9cf7ff845 100644
--- a/gio/glocalfileinfo.c
+++ b/gio/glocalfileinfo.c
@@ -961,7 +961,8 @@ set_info_from_stat (GFileInfo             *info,
   else if (S_ISLNK (statbuf->st_mode))
     file_type = G_FILE_TYPE_SYMBOLIC_LINK;
 #elif defined (G_OS_WIN32)
-  if (statbuf->reparse_tag == IO_REPARSE_TAG_SYMLINK)
+  if (statbuf->reparse_tag == IO_REPARSE_TAG_SYMLINK ||
+      statbuf->reparse_tag == IO_REPARSE_TAG_MOUNT_POINT)
     file_type = G_FILE_TYPE_SYMBOLIC_LINK;
 #endif
 
@@ -1005,13 +1006,20 @@ set_info_from_stat (GFileInfo             *info,
 #elif defined (HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
   _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_ACCESS_USEC, statbuf->st_atim.tv_nsec / 1000);
 #endif
-  
+
+#ifndef G_OS_WIN32
+  /* Microsoft uses st_ctime for file creation time,
+   * instead of file change time:
+   * https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/stat-functions#generic-text-routine-mappings
+   * Thank you, Microsoft!
+   */
   _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_CHANGED, statbuf->st_ctime);
 #if defined (HAVE_STRUCT_STAT_ST_CTIMENSEC)
   _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_CHANGED_USEC, statbuf->st_ctimensec / 1000);
 #elif defined (HAVE_STRUCT_STAT_ST_CTIM_TV_NSEC)
   _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_CHANGED_USEC, statbuf->st_ctim.tv_nsec / 1000);
 #endif
+#endif
 
 #if defined (HAVE_STRUCT_STAT_ST_BIRTHTIME) && defined (HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC)
   _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_CREATED, statbuf->st_birthtime);
@@ -1023,6 +1031,8 @@ set_info_from_stat (GFileInfo             *info,
   _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_CREATED, statbuf->st_birthtime);
 #elif defined (HAVE_STRUCT_STAT_ST_BIRTHTIM)
   _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_CREATED, statbuf->st_birthtim);
+#elif defined (G_OS_WIN32)
+  _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_CREATED, statbuf->st_ctime);
 #endif
 
   if (_g_file_attribute_matcher_matches_id (attribute_matcher,
@@ -1799,7 +1809,9 @@ _g_local_file_info_get (const char             *basename,
   is_symlink = stat_ok && S_ISLNK (statbuf.st_mode);
 #elif defined (G_OS_WIN32)
   /* glib already checked the FILE_ATTRIBUTE_REPARSE_POINT for us */
-  is_symlink = stat_ok && statbuf.reparse_tag == IO_REPARSE_TAG_SYMLINK; 
+  is_symlink = stat_ok &&
+      (statbuf.reparse_tag == IO_REPARSE_TAG_SYMLINK ||
+       statbuf.reparse_tag == IO_REPARSE_TAG_MOUNT_POINT);
 #else
   is_symlink = FALSE;
 #endif
@@ -2182,7 +2194,9 @@ set_unix_mode (char                       *filename,
     GWin32PrivateStat statbuf;
 
     res = GLIB_PRIVATE_CALL (g_win32_lstat_utf8) (filename, &statbuf);
-    is_symlink = (res == 0 && statbuf.reparse_tag == IO_REPARSE_TAG_SYMLINK);
+    is_symlink = (res == 0 &&
+                  (statbuf.reparse_tag == IO_REPARSE_TAG_SYMLINK ||
+                   statbuf.reparse_tag == IO_REPARSE_TAG_MOUNT_POINT));
 #endif
     if (is_symlink)
       {
diff --git a/gio/gresource-tool.c b/gio/gresource-tool.c
index b25eebf3d..d1de02631 100644
--- a/gio/gresource-tool.c
+++ b/gio/gresource-tool.c
@@ -31,6 +31,9 @@
 #ifdef HAVE_LIBELF
 #include <libelf.h>
 #include <gelf.h>
+#endif
+
+#ifdef HAVE_MMAP
 #include <sys/mman.h>
 #endif
 
@@ -42,6 +45,10 @@
 #include "glib/glib-private.h"
 #endif
 
+#if defined(HAVE_LIBELF) && defined(HAVE_MMAP)
+#define USE_LIBELF
+#endif
+
 /* GResource functions {{{1 */
 static GResource *
 get_resource (const gchar *file)
@@ -133,7 +140,7 @@ extract_resource (GResource   *resource,
 
 /* Elf functions {{{1 */
 
-#ifdef HAVE_LIBELF
+#ifdef USE_LIBELF
 
 static Elf *
 get_elf (const gchar *file,
@@ -353,7 +360,7 @@ print_section_name (GElf_Shdr   *shdr,
   return TRUE;
 }
 
-#endif /* HAVE_LIBELF */
+#endif /* USE_LIBELF */
 
   /* Toplevel commands {{{1 */
 
@@ -365,7 +372,7 @@ cmd_sections (const gchar *file,
 {
   GResource *resource;
 
-#ifdef HAVE_LIBELF
+#ifdef USE_LIBELF
 
   Elf *elf;
   gint fd;
@@ -388,7 +395,7 @@ cmd_sections (const gchar *file,
   else
     {
       g_printerr ("Don't know how to handle %s\n", file);
-#ifndef HAVE_LIBELF
+#ifndef USE_LIBELF
       g_printerr ("gresource is built without elf support\n");
 #endif
     }
@@ -402,7 +409,7 @@ cmd_list (const gchar *file,
 {
   GResource *resource;
 
-#ifdef HAVE_LIBELF
+#ifdef USE_LIBELF
   Elf *elf;
   int fd;
 
@@ -424,7 +431,7 @@ cmd_list (const gchar *file,
   else
     {
       g_printerr ("Don't know how to handle %s\n", file);
-#ifndef HAVE_LIBELF
+#ifndef USE_LIBELF
       g_printerr ("gresource is built without elf support\n");
 #endif
     }
@@ -438,7 +445,7 @@ cmd_extract (const gchar *file,
 {
   GResource *resource;
 
-#ifdef HAVE_LIBELF
+#ifdef USE_LIBELF
 
   Elf *elf;
   int fd;
@@ -461,7 +468,7 @@ cmd_extract (const gchar *file,
   else
     {
       g_printerr ("Don't know how to handle %s\n", file);
-#ifndef HAVE_LIBELF
+#ifndef USE_LIBELF
       g_printerr ("gresource is built without elf support\n");
 #endif
     }
diff --git a/gio/gtask.c b/gio/gtask.c
index df40357dd..4087543e6 100644
--- a/gio/gtask.c
+++ b/gio/gtask.c
@@ -52,7 +52,7 @@
  * where it was created (waiting until the next iteration of the main
  * loop first, if necessary). The caller will pass the #GTask back to
  * the operation's finish function (as a #GAsyncResult), and you can
- * can use g_task_propagate_pointer() or the like to extract the
+ * use g_task_propagate_pointer() or the like to extract the
  * return value.
  *
  * Here is an example for using GTask as a GAsyncResult:
diff --git a/gio/gtlsclientconnection.c b/gio/gtlsclientconnection.c
index f80c62572..b38fad630 100644
--- a/gio/gtlsclientconnection.c
+++ b/gio/gtlsclientconnection.c
@@ -105,14 +105,7 @@ g_tls_client_connection_default_init (GTlsClientConnectionInterface *iface)
    *
    * If %TRUE, forces the connection to use a fallback version of TLS
    * or SSL, rather than trying to negotiate the best version of TLS
-   * to use. This can be used when talking to servers that don't
-   * implement version negotiation correctly and therefore refuse to
-   * handshake at all with a modern TLS handshake.
-   *
-   * Despite the property name, the fallback version is usually not
-   * SSL 3.0, because SSL 3.0 is generally disabled by the #GTlsBackend.
-   * #GTlsClientConnection will use the next-highest available version
-   * as the fallback version.
+   * to use. See g_tls_client_connection_set_use_ssl3().
    *
    * Since: 2.28
    *
@@ -304,14 +297,19 @@ g_tls_client_connection_get_use_ssl3 (GTlsClientConnection *conn)
  * @conn: the #GTlsClientConnection
  * @use_ssl3: whether to use the lowest-supported protocol version
  *
- * If @use_ssl3 is %TRUE, this forces @conn to use the lowest-supported
- * TLS protocol version rather than trying to properly negotiate the
- * highest mutually-supported protocol version with the peer. This can
- * be used when talking to broken TLS servers that exhibit protocol
- * version intolerance.
- *
- * Be aware that SSL 3.0 is generally disabled by the #GTlsBackend, so
- * the lowest-supported protocol version is probably not SSL 3.0.
+ * Since 2.42.1, if @use_ssl3 is %TRUE, this forces @conn to use the
+ * lowest-supported TLS protocol version rather than trying to properly
+ * negotiate the highest mutually-supported protocol version with the
+ * peer. Be aware that SSL 3.0 is generally disabled by the
+ * #GTlsBackend, so the lowest-supported protocol version is probably
+ * not SSL 3.0.
+ *
+ * Since 2.58, this may additionally cause an RFC 7507 fallback SCSV to
+ * be sent to the server, causing modern TLS servers to immediately
+ * terminate the connection. You should generally only use this function
+ * if you need to connect to broken servers that exhibit TLS protocol
+ * version intolerance, and when an initial attempt to connect to a
+ * server normally has already failed.
  *
  * Since: 2.28
  *
diff --git a/gio/gtlsconnection.c b/gio/gtlsconnection.c
index e13d98614..b0353af9d 100644
--- a/gio/gtlsconnection.c
+++ b/gio/gtlsconnection.c
@@ -674,7 +674,8 @@ g_tls_connection_get_require_close_notify (GTlsConnection *conn)
  * @conn: a #GTlsConnection
  * @mode: the rehandshaking mode
  *
- * Sets how @conn behaves with respect to rehandshaking requests.
+ * Sets how @conn behaves with respect to rehandshaking requests, when
+ * TLS 1.2 or older is in use.
  *
  * %G_TLS_REHANDSHAKE_NEVER means that it will never agree to
  * rehandshake after the initial handshake is complete. (For a client,
@@ -756,7 +757,8 @@ g_tls_connection_get_rehandshake_mode (GTlsConnection       *conn)
  * the beginning of the communication, you do not need to call this
  * function explicitly unless you want clearer error reporting.
  * However, you may call g_tls_connection_handshake() later on to
- * renegotiate parameters (encryption methods, etc) with the client.
+ * rehandshake, if TLS 1.2 or older is in use. With TLS 1.3, this will
+ * instead perform a rekey.
  *
  * #GTlsConnection::accept_certificate may be emitted during the
  * handshake.
diff --git a/gio/gunixvolume.c b/gio/gunixvolume.c
index b54d1fd6e..a3768e11d 100644
--- a/gio/gunixvolume.c
+++ b/gio/gunixvolume.c
@@ -274,6 +274,7 @@ eject_mount_done (GObject      *source,
   GTask *task = user_data;
   GError *error = NULL;
   gchar *stderr_str;
+  GUnixVolume *unix_volume;
 
   if (!g_subprocess_communicate_utf8_finish (subprocess, result, NULL, &stderr_str, &error))
     {
@@ -286,8 +287,12 @@ eject_mount_done (GObject      *source,
         /* ...but bad exit code */
         g_task_return_new_error (task, G_IO_ERROR, G_IO_ERROR_FAILED, "%s", stderr_str);
       else
-        /* ...and successful exit code */
-        g_task_return_boolean (task, TRUE);
+        {
+          /* ...and successful exit code */
+          unix_volume = G_UNIX_VOLUME (g_task_get_source_object (task));
+          _g_unix_volume_monitor_update (G_UNIX_VOLUME_MONITOR (unix_volume->volume_monitor));
+          g_task_return_boolean (task, TRUE);
+        }
 
       g_free (stderr_str);
     }
diff --git a/gio/gunixvolumemonitor.c b/gio/gunixvolumemonitor.c
index b7711ff52..4b99423d7 100644
--- a/gio/gunixvolumemonitor.c
+++ b/gio/gunixvolumemonitor.c
@@ -183,15 +183,21 @@ g_unix_volume_monitor_class_init (GUnixVolumeMonitorClass *klass)
   native_class->get_mount_for_mount_path = get_mount_for_mount_path;
 }
 
+void
+_g_unix_volume_monitor_update (GUnixVolumeMonitor *unix_monitor)
+{
+  /* Update both to make sure volumes are created before mounts */
+  update_volumes (unix_monitor);
+  update_mounts (unix_monitor);
+}
+
 static void
 mountpoints_changed (GUnixMountMonitor *mount_monitor,
 		     gpointer           user_data)
 {
   GUnixVolumeMonitor *unix_monitor = user_data;
 
-  /* Update both to make sure volumes are created before mounts */
-  update_volumes (unix_monitor);
-  update_mounts (unix_monitor);
+  _g_unix_volume_monitor_update (unix_monitor);
 }
 
 static void
@@ -200,9 +206,7 @@ mounts_changed (GUnixMountMonitor *mount_monitor,
 {
   GUnixVolumeMonitor *unix_monitor = user_data;
 
-  /* Update both to make sure volumes are created before mounts */
-  update_volumes (unix_monitor);
-  update_mounts (unix_monitor);
+  _g_unix_volume_monitor_update (unix_monitor);
 }
 
 static void
@@ -219,8 +223,7 @@ g_unix_volume_monitor_init (GUnixVolumeMonitor *unix_monitor)
 		    "mountpoints-changed", G_CALLBACK (mountpoints_changed),
 		    unix_monitor);
 		    
-  update_volumes (unix_monitor);
-  update_mounts (unix_monitor);
+  _g_unix_volume_monitor_update (unix_monitor);
 }
 
 GVolumeMonitor *
diff --git a/gio/gunixvolumemonitor.h b/gio/gunixvolumemonitor.h
index 4f54fc23c..14e07fb9f 100644
--- a/gio/gunixvolumemonitor.h
+++ b/gio/gunixvolumemonitor.h
@@ -55,6 +55,7 @@ GType            _g_unix_volume_monitor_get_type                     (void) G_GN
 GVolumeMonitor * _g_unix_volume_monitor_new                          (void);
 GUnixVolume    * _g_unix_volume_monitor_lookup_volume_for_mount_path (GUnixVolumeMonitor *monitor,
                                                                       const char         *mount_path);
+void             _g_unix_volume_monitor_update                       (GUnixVolumeMonitor *monitor);
 
 G_END_DECLS
 
diff --git a/gio/meson.build b/gio/meson.build
index a6af822b5..4b2c8f2ca 100644
--- a/gio/meson.build
+++ b/gio/meson.build
@@ -152,6 +152,11 @@ if host_system != 'windows'
     glib_conf.set('HAVE_SIOCGIFADDR', '/**/')
   endif
 
+endif
+
+if host_system.contains('android')
+  # struct ip_mreq_source definition is broken on Android NDK <= r16
+  # See https://bugzilla.gnome.org/show_bug.cgi?id=740791
   if not cc.compiles('''#include <netinet/in.h>
                         int main(int argc, char ** argv) {
                           struct ip_mreq_source mc_req_src;
@@ -161,7 +166,6 @@ if host_system != 'windows'
                         name : 'ip_mreq_source.imr_interface has s_addr member')
     glib_conf.set('BROKEN_IP_MREQ_SOURCE_STRUCT', 1)
   endif
-
 endif
 
 gnetworking_h_conf.set('WSPIAPI_INCLUDE', gnetworking_h_wspiapi_include)
diff --git a/glib/gbookmarkfile.c b/glib/gbookmarkfile.c
index e6f885e6b..31706ba12 100644
--- a/glib/gbookmarkfile.c
+++ b/glib/gbookmarkfile.c
@@ -863,7 +863,8 @@ parse_application_element (GMarkupParseContext  *context,
       item->metadata->applications = g_list_prepend (item->metadata->applications, ai);
       g_hash_table_replace (item->metadata->apps_by_name, ai->name, ai);
     }
-      
+
+  g_free (ai->exec);
   ai->exec = g_strdup (exec);
   
   if (count)
@@ -915,7 +916,8 @@ parse_mime_type_element (GMarkupParseContext  *context,
     
   if (!item->metadata)
     item->metadata = bookmark_metadata_new ();
-  
+
+  g_free (item->metadata->mime_type);
   item->metadata->mime_type = g_strdup (type);
 }
 
@@ -964,7 +966,9 @@ parse_icon_element (GMarkupParseContext  *context,
     
   if (!item->metadata)
     item->metadata = bookmark_metadata_new ();
-  
+
+  g_free (item->metadata->icon_href);
+  g_free (item->metadata->icon_mime);
   item->metadata->icon_href = g_strdup (href);
   item->metadata->icon_mime = g_strdup (type);
 }
diff --git a/glib/gbytes.c b/glib/gbytes.c
index 74f8148f6..7b72886e5 100644
--- a/glib/gbytes.c
+++ b/glib/gbytes.c
@@ -403,10 +403,18 @@ g_bytes_hash (gconstpointer bytes)
  *
  * Compares the two #GBytes values.
  *
- * This function can be used to sort GBytes instances in lexographical order.
+ * This function can be used to sort GBytes instances in lexicographical order.
+ *
+ * If @bytes1 and @bytes2 have different length but the shorter one is a
+ * prefix of the longer one then the shorter one is considered to be less than
+ * the longer one. Otherwise the first byte where both differ is used for
+ * comparison. If @bytes1 has a smaller value at that position it is
+ * considered less, otherwise greater than @bytes2.
+ *
+ * Returns: a negative value if @bytes1 is less than @bytes2, a positive value
+ *          if @bytes1 is greater than @bytes2, and zero if @bytes1 is equal to
+ *          @bytes2
  *
- * Returns: a negative value if bytes2 is lesser, a positive value if bytes2 is
- *          greater, and zero if bytes2 is equal to bytes1
  *
  * Since: 2.32
  */
diff --git a/glib/gtestutils.c b/glib/gtestutils.c
index da6c7338c..7b29c274e 100644
--- a/glib/gtestutils.c
+++ b/glib/gtestutils.c
@@ -959,7 +959,20 @@ g_test_log (GTestLogType lbit,
       fail = result == G_TEST_RUN_FAILURE;
       if (test_tap_log)
         {
-          g_print ("%s %d %s", fail ? "not ok" : "ok", test_run_count, string1);
+          const gchar *ok;
+
+          /* The TAP representation for an expected failure starts with
+           * "not ok", even though it does not actually count as failing
+           * due to the use of the TODO directive. "ok # TODO" would mean
+           * a test that was expected to fail unexpectedly succeeded,
+           * for which GTestResult does not currently have a
+           * representation. */
+          if (fail || result == G_TEST_RUN_INCOMPLETE)
+            ok = "not ok";
+          else
+            ok = "ok";
+
+          g_print ("%s %d %s", ok, test_run_count, string1);
           if (result == G_TEST_RUN_INCOMPLETE)
             g_print (" # TODO %s\n", string2 ? string2 : "");
           else if (result == G_TEST_RUN_SKIPPED)
@@ -977,7 +990,7 @@ g_test_log (GTestLogType lbit,
             g_print ("Bail out!\n");
           g_abort ();
         }
-      if (result == G_TEST_RUN_SKIPPED)
+      if (result == G_TEST_RUN_SKIPPED || result == G_TEST_RUN_INCOMPLETE)
         test_skipped_count++;
       break;
     case G_TEST_LOG_MIN_RESULT:
@@ -1271,6 +1284,12 @@ parse_args (gint    *argc_p,
  *
  * - `--debug-log`: Debug test logging output.
  *
+ * Since 2.58, if tests are compiled with `G_DISABLE_ASSERT` defined,
+ * g_test_init() will print an error and exit. This is to prevent no-op tests
+ * from being executed, as g_assert() is commonly (erroneously) used in unit
+ * tests, and is a no-op when compiled with `G_DISABLE_ASSERT`. Ensure your
+ * tests are compiled without `G_DISABLE_ASSERT` defined.
+ *
  * Since: 2.16
  */
 void
@@ -1720,11 +1739,13 @@ g_test_get_root (void)
  * particular code runs before or after a given test case, use
  * g_test_add(), which lets you specify setup and teardown functions.
  *
- * If all tests are skipped, this function will return 0 if
- * producing TAP output, or 77 (treated as "skip test" by Automake) otherwise.
+ * If all tests are skipped or marked as incomplete (expected failures),
+ * this function will return 0 if producing TAP output, or 77 (treated
+ * as "skip test" by Automake) otherwise.
  *
  * Returns: 0 on success, 1 on failure (assuming it returns at all),
- *   0 or 77 if all tests were skipped with g_test_skip()
+ *   0 or 77 if all tests were skipped with g_test_skip() and/or
+ *   g_test_incomplete()
  *
  * Since: 2.16
  */
@@ -2325,7 +2346,8 @@ test_case_run (GTestCase *tc)
   test_uri_base = old_base;
 
   return (success == G_TEST_RUN_SUCCESS ||
-          success == G_TEST_RUN_SKIPPED);
+          success == G_TEST_RUN_SKIPPED ||
+          success == G_TEST_RUN_INCOMPLETE);
 }
 
 static gboolean
diff --git a/glib/gtimer.c b/glib/gtimer.c
index e95ac0ead..201225523 100644
--- a/glib/gtimer.c
+++ b/glib/gtimer.c
@@ -345,6 +345,8 @@ mktime_utc (struct tm *tm)
  * zone indicator. (In the absence of any time zone indication, the
  * timestamp is assumed to be in local time.)
  *
+ * Any leading or trailing space in @iso_date is ignored.
+ *
  * Returns: %TRUE if the conversion was successful.
  *
  * Since: 2.12
@@ -355,6 +357,8 @@ g_time_val_from_iso8601 (const gchar *iso_date,
 {
   struct tm tm = {0};
   long val;
+  long mday, mon, year;
+  long hour, min, sec;
 
   g_return_val_if_fail (iso_date != NULL, FALSE);
   g_return_val_if_fail (time_ != NULL, FALSE);
@@ -368,30 +372,42 @@ g_time_val_from_iso8601 (const gchar *iso_date,
   if (*iso_date == '\0')
     return FALSE;
 
-  if (!g_ascii_isdigit (*iso_date) && *iso_date != '-' && *iso_date != '+')
+  if (!g_ascii_isdigit (*iso_date) && *iso_date != '+')
     return FALSE;
 
   val = strtoul (iso_date, (char **)&iso_date, 10);
   if (*iso_date == '-')
     {
       /* YYYY-MM-DD */
-      tm.tm_year = val - 1900;
+      year = val;
       iso_date++;
-      tm.tm_mon = strtoul (iso_date, (char **)&iso_date, 10) - 1;
-      
+
+      mon = strtoul (iso_date, (char **)&iso_date, 10);
       if (*iso_date++ != '-')
         return FALSE;
       
-      tm.tm_mday = strtoul (iso_date, (char **)&iso_date, 10);
+      mday = strtoul (iso_date, (char **)&iso_date, 10);
     }
   else
     {
       /* YYYYMMDD */
-      tm.tm_mday = val % 100;
-      tm.tm_mon = (val % 10000) / 100 - 1;
-      tm.tm_year = val / 10000 - 1900;
+      mday = val % 100;
+      mon = (val % 10000) / 100;
+      year = val / 10000;
     }
 
+  /* Validation. */
+  if (year < 1900 || year > G_MAXINT)
+    return FALSE;
+  if (mon < 1 || mon > 12)
+    return FALSE;
+  if (mday < 1 || mday > 31)
+    return FALSE;
+
+  tm.tm_mday = mday;
+  tm.tm_mon = mon - 1;
+  tm.tm_year = year - 1900;
+
   if (*iso_date != 'T')
     return FALSE;
 
@@ -405,34 +421,50 @@ g_time_val_from_iso8601 (const gchar *iso_date,
   if (*iso_date == ':')
     {
       /* hh:mm:ss */
-      tm.tm_hour = val;
+      hour = val;
       iso_date++;
-      tm.tm_min = strtoul (iso_date, (char **)&iso_date, 10);
+      min = strtoul (iso_date, (char **)&iso_date, 10);
       
       if (*iso_date++ != ':')
         return FALSE;
       
-      tm.tm_sec = strtoul (iso_date, (char **)&iso_date, 10);
+      sec = strtoul (iso_date, (char **)&iso_date, 10);
     }
   else
     {
       /* hhmmss */
-      tm.tm_sec = val % 100;
-      tm.tm_min = (val % 10000) / 100;
-      tm.tm_hour = val / 10000;
+      sec = val % 100;
+      min = (val % 10000) / 100;
+      hour = val / 10000;
     }
 
+  /* Validation. Allow up to 2 leap seconds when validating @sec. */
+  if (hour > 23)
+    return FALSE;
+  if (min > 59)
+    return FALSE;
+  if (sec > 61)
+    return FALSE;
+
+  tm.tm_hour = hour;
+  tm.tm_min = min;
+  tm.tm_sec = sec;
+
   time_->tv_usec = 0;
   
   if (*iso_date == ',' || *iso_date == '.')
     {
       glong mul = 100000;
 
-      while (g_ascii_isdigit (*++iso_date))
+      while (mul >= 1 && g_ascii_isdigit (*++iso_date))
         {
           time_->tv_usec += (*iso_date - '0') * mul;
           mul /= 10;
         }
+
+      /* Skip any remaining digits after we’ve reached our limit of precision. */
+      while (g_ascii_isdigit (*iso_date))
+        iso_date++;
     }
     
   /* Now parse the offset and convert tm to a time_t */
@@ -448,11 +480,24 @@ g_time_val_from_iso8601 (const gchar *iso_date,
       val = strtoul (iso_date + 1, (char **)&iso_date, 10);
       
       if (*iso_date == ':')
-        val = 60 * val + strtoul (iso_date + 1, (char **)&iso_date, 10);
+        {
+          /* hh:mm */
+          hour = val;
+          min = strtoul (iso_date + 1, (char **)&iso_date, 10);
+        }
       else
-        val = 60 * (val / 100) + (val % 100);
+        {
+          /* hhmm */
+          hour = val / 100;
+          min = val % 100;
+        }
+
+      if (hour > 99)
+        return FALSE;
+      if (min > 59)
+        return FALSE;
 
-      time_->tv_sec = mktime_utc (&tm) + (time_t) (60 * val * sign);
+      time_->tv_sec = mktime_utc (&tm) + (time_t) (60 * (gint64) (60 * hour + min) * sign);
     }
   else
     {
diff --git a/glib/gvariant-parser.c b/glib/gvariant-parser.c
index 3261bc1af..233a19f7c 100644
--- a/glib/gvariant-parser.c
+++ b/glib/gvariant-parser.c
@@ -260,6 +260,9 @@ token_stream_prepare (TokenStream *stream)
   stream->this = stream->stream;
   stream->stream = end;
 
+  /* We must have at least one byte in a token. */
+  g_assert (stream->stream - stream->this >= 1);
+
   return TRUE;
 }
 
@@ -276,7 +279,8 @@ token_stream_peek (TokenStream *stream,
   if (!token_stream_prepare (stream))
     return FALSE;
 
-  return stream->this[0] == first_char;
+  return stream->stream - stream->this >= 1 &&
+         stream->this[0] == first_char;
 }
 
 static gboolean
@@ -287,7 +291,8 @@ token_stream_peek2 (TokenStream *stream,
   if (!token_stream_prepare (stream))
     return FALSE;
 
-  return stream->this[0] == first_char &&
+  return stream->stream - stream->this >= 2 &&
+         stream->this[0] == first_char &&
          stream->this[1] == second_char;
 }
 
@@ -297,7 +302,8 @@ token_stream_is_keyword (TokenStream *stream)
   if (!token_stream_prepare (stream))
     return FALSE;
 
-  return g_ascii_isalpha (stream->this[0]) &&
+  return stream->stream - stream->this >= 2 &&
+         g_ascii_isalpha (stream->this[0]) &&
          g_ascii_isalpha (stream->this[1]);
 }
 
@@ -307,10 +313,11 @@ token_stream_is_numeric (TokenStream *stream)
   if (!token_stream_prepare (stream))
     return FALSE;
 
-  return (g_ascii_isdigit (stream->this[0]) ||
-          stream->this[0] == '-' ||
-          stream->this[0] == '+' ||
-          stream->this[0] == '.');
+  return (stream->stream - stream->this >= 1 &&
+          (g_ascii_isdigit (stream->this[0]) ||
+           stream->this[0] == '-' ||
+           stream->this[0] == '+' ||
+           stream->this[0] == '.'));
 }
 
 static gboolean
diff --git a/glib/tests/Makefile.am b/glib/tests/Makefile.am
index 2a53ae6fd..b29b68431 100644
--- a/glib/tests/Makefile.am
+++ b/glib/tests/Makefile.am
@@ -38,6 +38,7 @@ dist_test_extra_scripts = \
 
 test_extra_programs = \
 	test-spawn-echo			\
+	testing-helper			\
 	$(NULL)
 
 test_programs = \
@@ -164,6 +165,9 @@ dist_test_data += \
 	bookmarks/fail-36.xbel \
 	bookmarks/fail-37.xbel \
 	bookmarks/fail-38.xbel \
+	bookmarks/fail-39.xbel \
+	bookmarks/fail-40.xbel \
+	bookmarks/fail-41.xbel \
 	bookmarks/valid-01.xbel \
 	bookmarks/valid-02.xbel \
 	bookmarks/valid-03.xbel \
diff --git a/glib/tests/atomic.c b/glib/tests/atomic.c
index 2aafe869f..84c13fb21 100644
--- a/glib/tests/atomic.c
+++ b/glib/tests/atomic.c
@@ -92,7 +92,8 @@ test_types (void)
   g_assert (ip == 0);
 
   g_atomic_pointer_set (&gs, 0);
-  gs2 = (gsize) g_atomic_pointer_get (&gs);
+  vp2 = g_atomic_pointer_get (&gs);
+  gs2 = (gsize) vp2;
   g_assert (gs2 == 0);
   res = g_atomic_pointer_compare_and_exchange (&gs, 0, 0);
   g_assert (res);
diff --git a/glib/tests/bookmarks/fail-39.xbel b/glib/tests/bookmarks/fail-39.xbel
new file mode 100644
index 000000000..c57c83784
--- /dev/null
+++ b/glib/tests/bookmarks/fail-39.xbel
@@ -0,0 +1 @@
+<xbel version="1.0"><bookmark href=""><info><metadata owner="http://freedesktop.org"><mime-type/><mime-type/
\ No newline at end of file
diff --git a/glib/tests/bookmarks/fail-40.xbel b/glib/tests/bookmarks/fail-40.xbel
new file mode 100644
index 000000000..9ce48a828
--- /dev/null
+++ b/glib/tests/bookmarks/fail-40.xbel
@@ -0,0 +1 @@
+<xbel version="1.0"><bookmark href=""><info><metadata owner="http://freedesktop.org"><applications><application name=""exec=""/><application name=""exec=""/
\ No newline at end of file
diff --git a/glib/tests/bookmarks/fail-41.xbel b/glib/tests/bookmarks/fail-41.xbel
new file mode 100644
index 000000000..8ac0c5666
--- /dev/null
+++ b/glib/tests/bookmarks/fail-41.xbel
@@ -0,0 +1 @@
+<xbel version="1.0"><bookmark href=""added="2T0+819855292164632335">
diff --git a/glib/tests/date.c b/glib/tests/date.c
index d65aab7e8..b801ca704 100644
--- a/glib/tests/date.c
+++ b/glib/tests/date.c
@@ -265,7 +265,7 @@ test_month_names (void)
       TEST_DATE (1,  6, 2018,    "%Oh %Y",         "Jun 2018");
     }
   else
-    g_test_incomplete ("locale en_GB not available, skipping English month names test");
+    g_test_skip ("locale en_GB not available, skipping English month names test");
 
   setlocale (LC_ALL, "de_DE.utf-8");
 #ifdef G_OS_WIN32
@@ -281,7 +281,7 @@ test_month_names (void)
       TEST_DATE ( 1, 12, 2018,    "%Oh %Y",      "Dez 2018");
     }
   else
-    g_test_incomplete ("locale de_DE not available, skipping German month names test");
+    g_test_skip ("locale de_DE not available, skipping German month names test");
 
 
   setlocale (LC_ALL, "es_ES.utf-8");
@@ -298,7 +298,7 @@ test_month_names (void)
       TEST_DATE ( 1,  6, 2018,      "%Oh de %Y",         "jun de 2018");
     }
   else
-    g_test_incomplete ("locale es_ES not available, skipping Spanish month names test");
+    g_test_skip ("locale es_ES not available, skipping Spanish month names test");
 
   setlocale (LC_ALL, "fr_FR.utf-8");
 #ifdef G_OS_WIN32
@@ -314,7 +314,7 @@ test_month_names (void)
       TEST_DATE ( 1, 12, 2018,   "%Oh %Y",       "déc. 2018");
     }
   else
-    g_test_incomplete ("locale fr_FR not available, skipping French month names test");
+    g_test_skip ("locale fr_FR not available, skipping French month names test");
 
   /* Make sure that there are visible changes in some European languages.  */
   setlocale (LC_ALL, "el_GR.utf-8");
@@ -333,7 +333,7 @@ test_month_names (void)
       TEST_DATE ( 1,  8, 2018,   "%Ob %Y",            "Αύγ 2018");
     }
   else
-    g_test_incomplete ("locale el_GR not available, skipping Greek month names test");
+    g_test_skip ("locale el_GR not available, skipping Greek month names test");
 
   setlocale (LC_ALL, "hr_HR.utf-8");
 #ifdef G_OS_WIN32
@@ -351,7 +351,7 @@ test_month_names (void)
       TEST_DATE ( 1, 12, 2018,    "%Ob %Y",         "Pro 2018");
     }
   else
-    g_test_incomplete ("locale hr_HR not available, skipping Croatian month names test");
+    g_test_skip ("locale hr_HR not available, skipping Croatian month names test");
 
   setlocale (LC_ALL, "lt_LT.utf-8");
 #ifdef G_OS_WIN32
@@ -369,7 +369,7 @@ test_month_names (void)
       TEST_DATE ( 1,  8, 2018,      "%Y m. %Ob",           "2018 m. Rgp");
     }
   else
-    g_test_incomplete ("locale lt_LT not available, skipping Lithuanian month names test");
+    g_test_skip ("locale lt_LT not available, skipping Lithuanian month names test");
 
   setlocale (LC_ALL, "pl_PL.utf-8");
 #ifdef G_OS_WIN32
@@ -387,7 +387,7 @@ test_month_names (void)
       TEST_DATE ( 1, 12, 2018,   "%Ob %Y",         "gru 2018");
     }
   else
-    g_test_incomplete ("locale pl_PL not available, skipping Polish month names test");
+    g_test_skip ("locale pl_PL not available, skipping Polish month names test");
 
   setlocale (LC_ALL, "ru_RU.utf-8");
 #ifdef G_OS_WIN32
@@ -408,7 +408,7 @@ test_month_names (void)
       TEST_DATE (20,  5, 2018, "%Ob, %d-е, %Y", "май, 20-е, 2018");
     }
   else
-    g_test_incomplete ("locale ru_RU not available, skipping Russian month names test");
+    g_test_skip ("locale ru_RU not available, skipping Russian month names test");
 
   g_date_free (gdate);
 
diff --git a/glib/tests/gdatetime.c b/glib/tests/gdatetime.c
index c6837fcce..a028f6d20 100644
--- a/glib/tests/gdatetime.c
+++ b/glib/tests/gdatetime.c
@@ -2131,13 +2131,15 @@ test_posix_parse (void)
   GTimeZone *tz;
   GDateTime *gdt1, *gdt2;
 
-  tz = g_time_zone_new ("PST");
+  /* Check that an unknown zone name falls back to UTC. */
+  tz = g_time_zone_new ("nonexistent");
   g_assert_cmpstr (g_time_zone_get_identifier (tz), ==, "UTC");
   g_assert_cmpstr (g_time_zone_get_abbreviation (tz, 0), ==, "UTC");
   g_assert_cmpint (g_time_zone_get_offset (tz, 0), ==, 0);
   g_assert (!g_time_zone_is_dst (tz, 0));
   g_time_zone_unref (tz);
 
+  /* An existent zone name should not fall back to UTC. */
   tz = g_time_zone_new ("PST8");
   g_assert_cmpstr (g_time_zone_get_identifier (tz), ==, "PST8");
   g_assert_cmpstr (g_time_zone_get_abbreviation (tz, 0), ==, "PST");
diff --git a/glib/tests/gvariant.c b/glib/tests/gvariant.c
index fdaed1acc..5aac3de53 100644
--- a/glib/tests/gvariant.c
+++ b/glib/tests/gvariant.c
@@ -3889,27 +3889,48 @@ test_parse_failures (void)
     "boolean 4",                "8-9:",            "can not parse as",
     "int32 true",               "6-10:",           "can not parse as",
     "[double 5, int32 5]",      "1-9,11-18:",      "common type",
-    "string 4",                 "7-8:",            "can not parse as"
+    "string 4",                 "7-8:",            "can not parse as",
+    "\x0a",                     "1:",              "expected value",
+    "((",                       "2:",              "expected value",
   };
   gint i;
 
   for (i = 0; i < G_N_ELEMENTS (test); i += 3)
     {
-      GError *error = NULL;
+      GError *error1 = NULL, *error2 = NULL;
       GVariant *value;
 
-      value = g_variant_parse (NULL, test[i], NULL, NULL, &error);
-      g_assert (value == NULL);
+      /* Copy the test string and drop its nul terminator, then use the @limit
+       * parameter of g_variant_parse() to set the length. This allows valgrind
+       * to catch 1-byte heap buffer overflows. */
+      gsize test_len = MAX (strlen (test[i]), 1);
+      gchar *test_blob = g_malloc0 (test_len);  /* no nul terminator */
 
-      if (!strstr (error->message, test[i+2]))
+      memcpy (test_blob, test[i], test_len);
+      value = g_variant_parse (NULL, test_blob, test_blob + test_len, NULL, &error1);
+      g_assert_null (value);
+
+      g_free (test_blob);
+
+      if (!strstr (error1->message, test[i+2]))
         g_error ("test %d: Can't find '%s' in '%s'", i / 3,
-                 test[i+2], error->message);
+                 test[i+2], error1->message);
 
-      if (!g_str_has_prefix (error->message, test[i+1]))
+      if (!g_str_has_prefix (error1->message, test[i+1]))
         g_error ("test %d: Expected location '%s' in '%s'", i / 3,
-                 test[i+1], error->message);
+                 test[i+1], error1->message);
+
+      /* Test again with the nul terminator this time. The behaviour should be
+       * the same. */
+      value = g_variant_parse (NULL, test[i], NULL, NULL, &error2);
+      g_assert_null (value);
+
+      g_assert_cmpint (error1->domain, ==, error2->domain);
+      g_assert_cmpint (error1->code, ==, error2->code);
+      g_assert_cmpstr (error1->message, ==, error2->message);
 
-      g_error_free (error);
+      g_clear_error (&error1);
+      g_clear_error (&error2);
     }
 }
 
diff --git a/glib/tests/meson.build b/glib/tests/meson.build
index f5c0fbecb..0af71b072 100644
--- a/glib/tests/meson.build
+++ b/glib/tests/meson.build
@@ -183,6 +183,13 @@ executable('test-spawn-echo', 'test-spawn-echo.c',
   install: installed_tests_enabled,
 )
 
+executable('testing-helper', 'testing-helper.c',
+  c_args : test_cargs,
+  dependencies : test_deps,
+  install_dir: installed_tests_execdir,
+  install: installed_tests_enabled,
+)
+
 # some testing of gtester functionality
 if not meson.is_cross_build() and host_system != 'windows'
   xmllint = find_program('xmllint', required: false)
diff --git a/glib/tests/refstring.c b/glib/tests/refstring.c
index 41ab0c05c..4d58eecb9 100644
--- a/glib/tests/refstring.c
+++ b/glib/tests/refstring.c
@@ -98,11 +98,6 @@ test_refstring_intern (void)
 
   g_test_message ("releasing s[%p] ('%s')", s, s);
   g_ref_string_release (s);
-
-  p = g_ref_string_new_intern ("hello, world");
-  g_test_message ("p[%p] ('%s') != s[%p]", p, p, s);
-  g_assert_false (s == p);
-  g_ref_string_release (p);
 }
 
 int
diff --git a/glib/tests/testing-helper.c b/glib/tests/testing-helper.c
new file mode 100644
index 000000000..43127e8dd
--- /dev/null
+++ b/glib/tests/testing-helper.c
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2018 Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#include <glib.h>
+
+static void
+test_pass (void)
+{
+}
+
+static void
+test_skip (void)
+{
+  g_test_skip ("not enough tea");
+}
+
+static void
+test_fail (void)
+{
+  g_test_fail ();
+}
+
+static void
+test_incomplete (void)
+{
+  g_test_incomplete ("mind reading not implemented yet");
+}
+
+int
+main (int   argc,
+      char *argv[])
+{
+  char *argv1;
+
+  g_return_val_if_fail (argc > 1, 1);
+  argv1 = argv[1];
+
+  if (argc > 2)
+    memmove (&argv[1], &argv[2], (argc - 2) * sizeof (char *));
+
+  argc -= 1;
+  argv[argc] = NULL;
+
+  g_test_init (&argc, &argv, NULL);
+  g_test_set_nonfatal_assertions ();
+
+  if (g_strcmp0 (argv1, "pass") == 0)
+    {
+      g_test_add_func ("/pass", test_pass);
+    }
+  else if (g_strcmp0 (argv1, "skip") == 0)
+    {
+      g_test_add_func ("/skip", test_skip);
+    }
+  else if (g_strcmp0 (argv1, "incomplete") == 0)
+    {
+      g_test_add_func ("/incomplete", test_incomplete);
+    }
+  else if (g_strcmp0 (argv1, "fail") == 0)
+    {
+      g_test_add_func ("/fail", test_fail);
+    }
+  else if (g_strcmp0 (argv1, "all-non-failures") == 0)
+    {
+      g_test_add_func ("/pass", test_pass);
+      g_test_add_func ("/skip", test_skip);
+      g_test_add_func ("/incomplete", test_incomplete);
+    }
+  else if (g_strcmp0 (argv1, "all") == 0)
+    {
+      g_test_add_func ("/pass", test_pass);
+      g_test_add_func ("/skip", test_skip);
+      g_test_add_func ("/incomplete", test_incomplete);
+      g_test_add_func ("/fail", test_fail);
+    }
+  else
+    {
+      g_assert_not_reached ();
+    }
+
+  return g_test_run ();
+}
diff --git a/glib/tests/testing.c b/glib/tests/testing.c
index de95f2635..716516e2c 100644
--- a/glib/tests/testing.c
+++ b/glib/tests/testing.c
@@ -20,6 +20,8 @@
  * if advised of the possibility of such damage.
  */
 
+#include "config.h"
+
 /* We want to distinguish between messages originating from libglib
  * and messages originating from this program.
  */
@@ -78,6 +80,7 @@ test_assertions (void)
   g_assert_cmpfloat_with_epsilon (3.14, 3.15, 0.01);
   g_assert_cmpfloat_with_epsilon (3.14159, 3.1416, 0.0001);
   g_assert (TRUE);
+  g_assert_true (TRUE);
   g_assert_cmpstr ("foo", !=, "faa");
   fuu = g_strdup_printf ("f%s", "uu");
   g_test_queue_free (fuu);
@@ -170,7 +173,7 @@ test_fork_timeout (void)
         g_usleep (1000 * 1000);
     }
   g_test_trap_assert_failed();
-  g_assert (g_test_trap_reached_timeout());
+  g_assert_true (g_test_trap_reached_timeout());
 }
 
 G_GNUC_END_IGNORE_DEPRECATIONS
@@ -233,7 +236,7 @@ test_subprocess_timeout (void)
   /* allow child to run for only a fraction of a second */
   g_test_trap_subprocess (NULL, 0.11 * 1000000, 0);
   g_test_trap_assert_failed ();
-  g_assert (g_test_trap_reached_timeout ());
+  g_assert_true (g_test_trap_reached_timeout ());
 }
 
 /* run a test with fixture setup and teardown */
@@ -246,7 +249,7 @@ static void
 fixturetest_setup (Fixturetest  *fix,
                    gconstpointer test_data)
 {
-  g_assert (test_data == (void*) 0xc0cac01a);
+  g_assert_true (test_data == (void*) 0xc0cac01a);
   fix->seed = 18;
   fix->prime = 19;
   fix->msg = g_strdup_printf ("%d", fix->prime);
@@ -259,13 +262,13 @@ fixturetest_test (Fixturetest  *fix,
   g_assert_cmpint (prime, ==, fix->prime);
   prime = g_ascii_strtoull (fix->msg, NULL, 0);
   g_assert_cmpint (prime, ==, fix->prime);
-  g_assert (test_data == (void*) 0xc0cac01a);
+  g_assert_true (test_data == (void*) 0xc0cac01a);
 }
 static void
 fixturetest_teardown (Fixturetest  *fix,
                       gconstpointer test_data)
 {
-  g_assert (test_data == (void*) 0xc0cac01a);
+  g_assert_true (test_data == (void*) 0xc0cac01a);
   g_free (fix->msg);
 }
 
@@ -308,7 +311,7 @@ test_rand2 (void)
 static void
 test_data_test (gconstpointer test_data)
 {
-  g_assert (test_data == (void*) 0xc0c0baba);
+  g_assert_true (test_data == (void*) 0xc0c0baba);
 }
 
 static void
@@ -319,7 +322,7 @@ test_random_conversions (void)
   char *err, *str = g_strdup_printf ("%d", vint);
   gint64 vint64 = g_ascii_strtoll (str, &err, 10);
   g_assert_cmphex (vint, ==, vint64);
-  g_assert (!err || *err == 0);
+  g_assert_true (!err || *err == 0);
   g_free (str);
 }
 
@@ -622,6 +625,10 @@ static void
 test_skip (void)
 {
   g_test_skip ("Skipped should count as passed, not failed");
+  /* This function really means "the test concluded with a non-successful
+   * status" rather than "the test failed": it is documented to return
+   * true for skipped and incomplete tests, not just for failures. */
+  g_assert_true (g_test_failed ());
 }
 
 static void
@@ -629,29 +636,52 @@ test_pass (void)
 {
 }
 
+static void
+subprocess_fail (void)
+{
+  /* Exit 1 instead of raising SIGABRT so that we can make assertions about
+   * how this combines with skipped/incomplete tests */
+  g_test_set_nonfatal_assertions ();
+  g_test_fail ();
+  g_assert_true (g_test_failed ());
+}
+
 static void
 test_fail (void)
 {
   if (g_test_subprocess ())
     {
-      g_test_fail ();
-      g_assert (g_test_failed ());
+      subprocess_fail ();
       return;
     }
   g_test_trap_subprocess (NULL, 0, 0);
   g_test_trap_assert_failed ();
 }
 
+static void
+subprocess_incomplete (void)
+{
+  g_test_incomplete ("not done");
+  /* This function really means "the test concluded with a non-successful
+   * status" rather than "the test failed": it is documented to return
+   * true for skipped and incomplete tests, not just for failures. */
+  g_assert_true (g_test_failed ());
+}
+
 static void
 test_incomplete (void)
 {
   if (g_test_subprocess ())
     {
-      g_test_incomplete ("not done");
-      g_assert (g_test_failed ());
+      subprocess_incomplete ();
       return;
     }
   g_test_trap_subprocess (NULL, 0, 0);
+  /* An incomplete test represents functionality that is known not to be
+   * implemented yet (an expected failure), so it does not cause test
+   * failure; but it does count as the test having been skipped, which
+   * causes nonzero exit status 77, which is treated as failure by
+   * g_test_trap_subprocess(). */
   g_test_trap_assert_failed ();
 }
 
@@ -664,18 +694,19 @@ test_subprocess_timed_out (void)
       return;
     }
   g_test_trap_subprocess (NULL, 50000, 0);
-  g_assert (g_test_trap_reached_timeout ());
+  g_assert_true (g_test_trap_reached_timeout ());
 }
 
 static const char *argv0;
 
 static void
-test_skip_all (void)
+test_combining (void)
 {
   GPtrArray *argv;
   GError *error = NULL;
   int status;
 
+  g_test_message ("single test case skipped -> overall status 77");
   argv = g_ptr_array_new ();
   g_ptr_array_add (argv, (char *) argv0);
   g_ptr_array_add (argv, "--GTestSubprocess");
@@ -693,15 +724,16 @@ test_skip_all (void)
   g_assert_error (error, G_SPAWN_EXIT_ERROR, 77);
   g_clear_error (&error);
 
+  g_test_message ("each test case skipped -> overall status 77");
   g_ptr_array_set_size (argv, 0);
   g_ptr_array_add (argv, (char *) argv0);
   g_ptr_array_add (argv, "--GTestSubprocess");
   g_ptr_array_add (argv, "-p");
   g_ptr_array_add (argv, "/misc/skip");
   g_ptr_array_add (argv, "-p");
-  g_ptr_array_add (argv, "/misc/skip-all/subprocess/skip1");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/skip1");
   g_ptr_array_add (argv, "-p");
-  g_ptr_array_add (argv, "/misc/skip-all/subprocess/skip2");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/skip2");
   g_ptr_array_add (argv, NULL);
 
   g_spawn_sync (NULL, (char **) argv->pdata, NULL,
@@ -714,15 +746,260 @@ test_skip_all (void)
   g_assert_error (error, G_SPAWN_EXIT_ERROR, 77);
   g_clear_error (&error);
 
+  g_test_message ("single test case incomplete -> overall status 77");
+  g_ptr_array_set_size (argv, 0);
+  g_ptr_array_add (argv, (char *) argv0);
+  g_ptr_array_add (argv, "--GTestSubprocess");
+  g_ptr_array_add (argv, "-p");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/incomplete");
+  g_ptr_array_add (argv, NULL);
+
+  g_spawn_sync (NULL, (char **) argv->pdata, NULL,
+                G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL,
+                NULL, NULL, NULL, NULL, &status,
+                &error);
+  g_assert_no_error (error);
+
+  g_spawn_check_exit_status (status, &error);
+  g_assert_error (error, G_SPAWN_EXIT_ERROR, 77);
+  g_clear_error (&error);
+
+  g_test_message ("one pass and some skipped -> overall status 0");
   g_ptr_array_set_size (argv, 0);
   g_ptr_array_add (argv, (char *) argv0);
   g_ptr_array_add (argv, "--GTestSubprocess");
   g_ptr_array_add (argv, "-p");
   g_ptr_array_add (argv, "/misc/skip");
   g_ptr_array_add (argv, "-p");
-  g_ptr_array_add (argv, "/misc/skip-all/subprocess/pass");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/pass");
   g_ptr_array_add (argv, "-p");
-  g_ptr_array_add (argv, "/misc/skip-all/subprocess/skip1");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/skip1");
+  g_ptr_array_add (argv, NULL);
+
+  g_spawn_sync (NULL, (char **) argv->pdata, NULL,
+                G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL,
+                NULL, NULL, NULL, NULL, &status,
+                &error);
+  g_assert_no_error (error);
+
+  g_spawn_check_exit_status (status, &error);
+  g_assert_no_error (error);
+
+  g_test_message ("one pass and some incomplete -> overall status 0");
+  g_ptr_array_set_size (argv, 0);
+  g_ptr_array_add (argv, (char *) argv0);
+  g_ptr_array_add (argv, "--GTestSubprocess");
+  g_ptr_array_add (argv, "-p");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/pass");
+  g_ptr_array_add (argv, "-p");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/incomplete");
+  g_ptr_array_add (argv, NULL);
+
+  g_spawn_sync (NULL, (char **) argv->pdata, NULL,
+                G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL,
+                NULL, NULL, NULL, NULL, &status,
+                &error);
+  g_assert_no_error (error);
+
+  g_spawn_check_exit_status (status, &error);
+  g_assert_no_error (error);
+
+  g_test_message ("one pass and mix of skipped and incomplete -> overall status 0");
+  g_ptr_array_set_size (argv, 0);
+  g_ptr_array_add (argv, (char *) argv0);
+  g_ptr_array_add (argv, "--GTestSubprocess");
+  g_ptr_array_add (argv, "-p");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/pass");
+  g_ptr_array_add (argv, "-p");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/skip1");
+  g_ptr_array_add (argv, "-p");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/incomplete");
+  g_ptr_array_add (argv, NULL);
+
+  g_spawn_sync (NULL, (char **) argv->pdata, NULL,
+                G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL,
+                NULL, NULL, NULL, NULL, &status,
+                &error);
+  g_assert_no_error (error);
+
+  g_spawn_check_exit_status (status, &error);
+  g_assert_no_error (error);
+
+  g_test_message ("one fail and some skipped -> overall status fail");
+  g_ptr_array_set_size (argv, 0);
+  g_ptr_array_add (argv, (char *) argv0);
+  g_ptr_array_add (argv, "--GTestSubprocess");
+  g_ptr_array_add (argv, "-p");
+  g_ptr_array_add (argv, "/misc/skip");
+  g_ptr_array_add (argv, "-p");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/fail");
+  g_ptr_array_add (argv, "-p");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/skip1");
+  g_ptr_array_add (argv, NULL);
+
+  g_spawn_sync (NULL, (char **) argv->pdata, NULL,
+                G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL,
+                NULL, NULL, NULL, NULL, &status,
+                &error);
+  g_assert_no_error (error);
+
+  g_spawn_check_exit_status (status, &error);
+  g_assert_error (error, G_SPAWN_EXIT_ERROR, 1);
+  g_clear_error (&error);
+
+  g_test_message ("one fail and some incomplete -> overall status fail");
+  g_ptr_array_set_size (argv, 0);
+  g_ptr_array_add (argv, (char *) argv0);
+  g_ptr_array_add (argv, "--GTestSubprocess");
+  g_ptr_array_add (argv, "-p");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/fail");
+  g_ptr_array_add (argv, "-p");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/incomplete");
+  g_ptr_array_add (argv, NULL);
+
+  g_spawn_sync (NULL, (char **) argv->pdata, NULL,
+                G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL,
+                NULL, NULL, NULL, NULL, &status,
+                &error);
+  g_assert_no_error (error);
+
+  g_spawn_check_exit_status (status, &error);
+  g_assert_error (error, G_SPAWN_EXIT_ERROR, 1);
+  g_clear_error (&error);
+
+  g_test_message ("one fail and mix of skipped and incomplete -> overall status fail");
+  g_ptr_array_set_size (argv, 0);
+  g_ptr_array_add (argv, (char *) argv0);
+  g_ptr_array_add (argv, "--GTestSubprocess");
+  g_ptr_array_add (argv, "-p");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/fail");
+  g_ptr_array_add (argv, "-p");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/skip1");
+  g_ptr_array_add (argv, "-p");
+  g_ptr_array_add (argv, "/misc/combining/subprocess/incomplete");
+  g_ptr_array_add (argv, NULL);
+
+  g_spawn_sync (NULL, (char **) argv->pdata, NULL,
+                G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL,
+                NULL, NULL, NULL, NULL, &status,
+                &error);
+  g_assert_no_error (error);
+
+  g_spawn_check_exit_status (status, &error);
+  g_assert_error (error, G_SPAWN_EXIT_ERROR, 1);
+  g_clear_error (&error);
+
+  g_ptr_array_unref (argv);
+}
+
+/* Test the TAP output when a test suite is run with --tap. */
+static void
+test_tap (void)
+{
+  const char *testing_helper;
+  GPtrArray *argv;
+  GError *error = NULL;
+  int status;
+  gchar *output;
+
+  testing_helper = g_test_get_filename (G_TEST_BUILT, "testing-helper" EXEEXT, NULL);
+
+  g_test_message ("pass");
+  argv = g_ptr_array_new ();
+  g_ptr_array_add (argv, (char *) testing_helper);
+  g_ptr_array_add (argv, "pass");
+  g_ptr_array_add (argv, "--tap");
+  g_ptr_array_add (argv, NULL);
+
+  g_spawn_sync (NULL, (char **) argv->pdata, NULL,
+                G_SPAWN_STDERR_TO_DEV_NULL,
+                NULL, NULL, &output, NULL, &status,
+                &error);
+  g_assert_no_error (error);
+
+  g_spawn_check_exit_status (status, &error);
+  g_assert_no_error (error);
+  g_assert_nonnull (strstr (output, "\nok 1 /pass\n"));
+  g_free (output);
+  g_ptr_array_unref (argv);
+
+  g_test_message ("skip");
+  argv = g_ptr_array_new ();
+  g_ptr_array_add (argv, (char *) testing_helper);
+  g_ptr_array_add (argv, "skip");
+  g_ptr_array_add (argv, "--tap");
+  g_ptr_array_add (argv, NULL);
+
+  g_spawn_sync (NULL, (char **) argv->pdata, NULL,
+                G_SPAWN_STDERR_TO_DEV_NULL,
+                NULL, NULL, &output, NULL, &status,
+                &error);
+  g_assert_no_error (error);
+
+  g_spawn_check_exit_status (status, &error);
+  g_assert_no_error (error);
+  g_assert_nonnull (strstr (output, "\nok 1 /skip # SKIP not enough tea\n"));
+  g_free (output);
+  g_ptr_array_unref (argv);
+
+  g_test_message ("incomplete");
+  argv = g_ptr_array_new ();
+  g_ptr_array_add (argv, (char *) testing_helper);
+  g_ptr_array_add (argv, "incomplete");
+  g_ptr_array_add (argv, "--tap");
+  g_ptr_array_add (argv, NULL);
+
+  g_spawn_sync (NULL, (char **) argv->pdata, NULL,
+                G_SPAWN_STDERR_TO_DEV_NULL,
+                NULL, NULL, &output, NULL, &status,
+                &error);
+  g_assert_no_error (error);
+
+  g_spawn_check_exit_status (status, &error);
+  g_assert_no_error (error);
+  g_assert_nonnull (strstr (output, "\nnot ok 1 /incomplete # TODO mind reading not implemented yet\n"));
+  g_free (output);
+  g_ptr_array_unref (argv);
+
+  g_test_message ("fail");
+  argv = g_ptr_array_new ();
+  g_ptr_array_add (argv, (char *) testing_helper);
+  g_ptr_array_add (argv, "fail");
+  g_ptr_array_add (argv, "--tap");
+  g_ptr_array_add (argv, NULL);
+
+  g_spawn_sync (NULL, (char **) argv->pdata, NULL,
+                G_SPAWN_STDERR_TO_DEV_NULL,
+                NULL, NULL, &output, NULL, &status,
+                &error);
+  g_assert_no_error (error);
+
+  g_spawn_check_exit_status (status, &error);
+  g_assert_error (error, G_SPAWN_EXIT_ERROR, 1);
+  g_assert_nonnull (strstr (output, "\nnot ok 1 /fail\n"));
+  g_free (output);
+  g_ptr_array_unref (argv);
+
+  g_test_message ("all");
+  argv = g_ptr_array_new ();
+  g_ptr_array_add (argv, (char *) testing_helper);
+  g_ptr_array_add (argv, "all");
+  g_ptr_array_add (argv, "--tap");
+  g_ptr_array_add (argv, NULL);
+
+  g_spawn_sync (NULL, (char **) argv->pdata, NULL,
+                G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL,
+                NULL, NULL, NULL, NULL, &status,
+                &error);
+  g_assert_error (error, G_SPAWN_EXIT_ERROR, 1);
+  g_clear_error (&error);
+  g_ptr_array_unref (argv);
+
+  g_test_message ("all-non-failures");
+  argv = g_ptr_array_new ();
+  g_ptr_array_add (argv, (char *) testing_helper);
+  g_ptr_array_add (argv, "all-non-failures");
+  g_ptr_array_add (argv, "--tap");
   g_ptr_array_add (argv, NULL);
 
   g_spawn_sync (NULL, (char **) argv->pdata, NULL,
@@ -801,13 +1078,17 @@ main (int   argc,
   g_test_add_func ("/misc/nonfatal", test_nonfatal);
 
   g_test_add_func ("/misc/skip", test_skip);
-  g_test_add_func ("/misc/skip-all", test_skip_all);
-  g_test_add_func ("/misc/skip-all/subprocess/skip1", test_skip);
-  g_test_add_func ("/misc/skip-all/subprocess/skip2", test_skip);
-  g_test_add_func ("/misc/skip-all/subprocess/pass", test_pass);
+  g_test_add_func ("/misc/combining", test_combining);
+  g_test_add_func ("/misc/combining/subprocess/fail", subprocess_fail);
+  g_test_add_func ("/misc/combining/subprocess/skip1", test_skip);
+  g_test_add_func ("/misc/combining/subprocess/skip2", test_skip);
+  g_test_add_func ("/misc/combining/subprocess/incomplete", subprocess_incomplete);
+  g_test_add_func ("/misc/combining/subprocess/pass", test_pass);
   g_test_add_func ("/misc/fail", test_fail);
   g_test_add_func ("/misc/incomplete", test_incomplete);
   g_test_add_func ("/misc/timeout", test_subprocess_timed_out);
 
+  g_test_add_func ("/tap", test_tap);
+
   return g_test_run();
 }
diff --git a/glib/tests/timer.c b/glib/tests/timer.c
index cb9a2686c..c0b9ba802 100644
--- a/glib/tests/timer.c
+++ b/glib/tests/timer.c
@@ -115,6 +115,14 @@ test_timeval_add (void)
   g_time_val_add (&time, 1000);
   g_assert_cmpint (time.tv_sec, ==, 1); 
   g_assert_cmpint (time.tv_usec, ==, 510);
+
+  g_time_val_add (&time, 0);
+  g_assert_cmpint (time.tv_sec, ==, 1);
+  g_assert_cmpint (time.tv_usec, ==, 510);
+
+  g_time_val_add (&time, -210);
+  g_assert_cmpint (time.tv_sec, ==, 1);
+  g_assert_cmpint (time.tv_usec, ==, 300);
 }
 
 typedef struct {
@@ -144,7 +152,39 @@ test_timeval_from_iso8601 (void)
     { FALSE, "2001-10-08Tx", { 0, 0 } },
     { FALSE, "2001-10-08T10:11x", { 0, 0 } },
     { FALSE, "Wed Dec 19 17:20:20 GMT 2007", { 0, 0 } },
-    { FALSE, "1980-02-22T10:36:00Zulu", { 0, 0 } }
+    { FALSE, "1980-02-22T10:36:00Zulu", { 0, 0 } },
+    { FALSE, "2T0+819855292164632335", { 0, 0 } },
+    { TRUE, "2018-08-03T14:08:05.446178377+01:00", { 1533301685, 446178 } },
+    { FALSE, "2147483648-08-03T14:08:05.446178377+01:00", { 0, 0 } },
+    { FALSE, "2018-13-03T14:08:05.446178377+01:00", { 0, 0 } },
+    { FALSE, "2018-00-03T14:08:05.446178377+01:00", { 0, 0 } },
+    { FALSE, "2018-08-00T14:08:05.446178377+01:00", { 0, 0 } },
+    { FALSE, "2018-08-32T14:08:05.446178377+01:00", { 0, 0 } },
+    { FALSE, "2018-08-03T24:08:05.446178377+01:00", { 0, 0 } },
+    { FALSE, "2018-08-03T14:60:05.446178377+01:00", { 0, 0 } },
+    { FALSE, "2018-08-03T14:08:63.446178377+01:00", { 0, 0 } },
+    { FALSE, "2018-08-03T14:08:05.446178377+100:00", { 0, 0 } },
+    { FALSE, "2018-08-03T14:08:05.446178377+01:60", { 0, 0 } },
+    { TRUE, "20180803T140805.446178377+0100", { 1533301685, 446178 } },
+    { FALSE, "21474836480803T140805.446178377+0100", { 0, 0 } },
+    { FALSE, "20181303T140805.446178377+0100", { 0, 0 } },
+    { FALSE, "20180003T140805.446178377+0100", { 0, 0 } },
+    { FALSE, "20180800T140805.446178377+0100", { 0, 0 } },
+    { FALSE, "20180832T140805.446178377+0100", { 0, 0 } },
+    { FALSE, "20180803T240805.446178377+0100", { 0, 0 } },
+    { FALSE, "20180803T146005.446178377+0100", { 0, 0 } },
+    { FALSE, "20180803T140863.446178377+0100", { 0, 0 } },
+    { FALSE, "20180803T140805.446178377+10000", { 0, 0 } },
+    { FALSE, "20180803T140805.446178377+0160", { 0, 0 } },
+    { TRUE, "+1980-02-22T12:36:00+02:00", { 320063760, 0 } },
+    { FALSE, "-0005-01-01T00:00:00Z", { 0, 0 } },
+    { FALSE, "2018-08-06", { 0, 0 } },
+    { FALSE, "2018-08-06 13:51:00Z", { 0, 0 } },
+    { TRUE, "20180803T140805,446178377+0100", { 1533301685, 446178 } },
+    { TRUE, "2018-08-03T14:08:05.446178377-01:00", { 1533308885, 446178 } },
+    { FALSE, "2018-08-03T14:08:05.446178377 01:00", { 0, 0 } },
+    { TRUE, "1990-11-01T10:21:17", { 657454877, 0 } },
+    { TRUE, "1990-11-01T10:21:17     ", { 657454877, 0 } },
   };
   GTimeVal out;
   gboolean success;
@@ -198,6 +238,22 @@ test_timeval_to_iso8601 (void)
     }
 }
 
+/* Test error handling for g_time_val_to_iso8601() on dates which are too large. */
+static void
+test_timeval_to_iso8601_overflow (void)
+{
+  GTimeVal val;
+  gchar *out = NULL;
+
+  g_unsetenv ("TZ");
+
+  val.tv_sec = G_MAXLONG;
+  val.tv_usec = G_USEC_PER_SEC - 1;
+
+  out = g_time_val_to_iso8601 (&val);
+  g_assert_null (out);
+}
+
 int
 main (int argc, char *argv[])
 {
@@ -210,6 +266,7 @@ main (int argc, char *argv[])
   g_test_add_func ("/timeval/add", test_timeval_add);
   g_test_add_func ("/timeval/from-iso8601", test_timeval_from_iso8601);
   g_test_add_func ("/timeval/to-iso8601", test_timeval_to_iso8601);
+  g_test_add_func ("/timeval/to-iso8601/overflow", test_timeval_to_iso8601_overflow);
 
   return g_test_run ();
 }
diff --git a/po/lt.po b/po/lt.po
index 659b0251f..f9c42fe98 100644
--- a/po/lt.po
+++ b/po/lt.po
@@ -13,8 +13,8 @@ msgid ""
 msgstr ""
 "Project-Id-Version: lt\n"
 "Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/glib/issues\n"
-"POT-Creation-Date: 2018-07-20 07:02+0000\n"
-"PO-Revision-Date: 2018-07-28 17:26+0300\n"
+"POT-Creation-Date: 2018-07-30 18:46+0000\n"
+"PO-Revision-Date: 2018-08-05 23:25+0300\n"
 "Last-Translator: Aurimas Černius <aurisc4@gmail.com>\n"
 "Language-Team: Lietuvių <gnome-lt@lists.akl.lt>\n"
 "Language: lt\n"
@@ -641,8 +641,6 @@ msgstr "Nepalaikomi požymiai aptikti konstruojant kliento pusės ryšį"
 
 #: gio/gdbusconnection.c:4115 gio/gdbusconnection.c:4462
 #, c-format
-#| msgid ""
-#| "No such interface 'org.freedesktop.DBus.Properties' on object at path %s"
 msgid ""
 "No such interface “org.freedesktop.DBus.Properties” on object at path %s"
 msgstr ""
@@ -650,25 +648,21 @@ msgstr ""
 
 #: gio/gdbusconnection.c:4257
 #, c-format
-#| msgid "No such property '%s'"
 msgid "No such property “%s”"
 msgstr "Nėra savybės „%s“"
 
 #: gio/gdbusconnection.c:4269
 #, c-format
-#| msgid "Property '%s' is not readable"
 msgid "Property “%s” is not readable"
 msgstr "Savybė „%s“ yra neskaitoma"
 
 #: gio/gdbusconnection.c:4280
 #, c-format
-#| msgid "Property '%s' is not writable"
 msgid "Property “%s” is not writable"
 msgstr "Savybė „%s“ nėra rašoma"
 
 #: gio/gdbusconnection.c:4300
 #, c-format
-#| msgid "Error setting property '%s': Expected type '%s' but got '%s'"
 msgid "Error setting property “%s”: Expected type “%s” but got “%s”"
 msgstr "Klaida nustatant savybę „%s“: tikėtasi tipo „%s“, bet gauta „%s“"
 
@@ -680,19 +674,16 @@ msgstr "Nėra sąsajos „%s“"
 
 #: gio/gdbusconnection.c:4831 gio/gdbusconnection.c:7091
 #, c-format
-#| msgid "No such interface '%s' on object at path %s"
 msgid "No such interface “%s” on object at path %s"
 msgstr "Nėra sąsajos „%s“ objektui, kurio kelias %s"
 
 #: gio/gdbusconnection.c:4929
 #, c-format
-#| msgid "No such key “%s”\n"
 msgid "No such method “%s”"
 msgstr "Nėra metodo „%s“"
 
 #: gio/gdbusconnection.c:4960
 #, c-format
-#| msgid "Type of message, '%s', does not match expected type '%s'"
 msgid "Type of message, “%s”, does not match expected type “%s”"
 msgstr "Pranešimo tipas „%s“ neatitinka laukiamo tipo „%s“"
 
@@ -713,13 +704,11 @@ msgstr "Nepavyko nustatyti savybės: %s.%s"
 
 #: gio/gdbusconnection.c:5618
 #, c-format
-#| msgid "Method '%s' returned type '%s', but expected '%s'"
 msgid "Method “%s” returned type “%s”, but expected “%s”"
 msgstr "Metodas „%s“ grąžino tipą „%s“, bet laukta „%s“"
 
 #: gio/gdbusconnection.c:6693
 #, c-format
-#| msgid "Method '%s' on interface '%s' with signature '%s' does not exist"
 msgid "Method “%s” on interface “%s” with signature “%s” does not exist"
 msgstr "Metodas „%s“ sąsajoje „%s“ su signatūra „%s“ neegzistuoja"
 
@@ -2004,7 +1993,6 @@ msgid "Eject"
 msgstr "Išstumti"
 
 #: gio/gio-tool-mount.c:66
-#| msgid "Mount volume with device file"
 msgid "Stop drive with device file"
 msgstr "Sustabdyti laikmeną su įrenginio failu"
 
@@ -2042,8 +2030,6 @@ msgid "The numeric PIM when unlocking a VeraCrypt volume"
 msgstr "Skaitmeninis PIM atrakinant VeraCrypt tomą"
 
 #: gio/gio-tool-mount.c:74
-#| msgctxt "GDateTime"
-#| msgid "PM"
 msgid "PIM"
 msgstr "PIM"
 
@@ -2060,7 +2046,6 @@ msgid "Anonymous access denied"
 msgstr "Neleidžiama anoniminė prieiga"
 
 #: gio/gio-tool-mount.c:524
-#| msgid "No volume for device file"
 msgid "No drive for device file"
 msgstr "Nėra laikmenos ar įrenginio failo"
 
@@ -2297,14 +2282,10 @@ msgid "Show program version and exit"
 msgstr "Parodyti programos versiją ir išeiti"
 
 #: gio/glib-compile-resources.c:737
-#| msgid "name of the output file"
 msgid "Name of the output file"
 msgstr "Išvesties failo pavadinimas"
 
 #: gio/glib-compile-resources.c:738
-#| msgid ""
-#| "The directories where files are to be read from (default to current "
-#| "directory)"
 msgid ""
 "The directories to load files referenced in FILE from (default: current "
 "directory)"
@@ -2327,7 +2308,6 @@ msgid "Generate source header"
 msgstr "Generuoti šaltinio antraštę"
 
 #: gio/glib-compile-resources.c:741
-#| msgid "Generate sourcecode used to link in the resource file into your code"
 msgid "Generate source code used to link in the resource file into your code"
 msgstr "Generuoti kodą, naudojamą išteklių failo įrišimui į jūsų kodą"
 
@@ -2336,7 +2316,6 @@ msgid "Generate dependency list"
 msgstr "Generuoti priklausomybių sąrašą"
 
 #: gio/glib-compile-resources.c:743
-#| msgid "name of the dependency file to generate"
 msgid "Name of the dependency file to generate"
 msgstr "Generuojamo priklausomybių failo pavadinimas"
 
@@ -2724,7 +2703,6 @@ msgstr "Nepaisoma šio failo.\n"
 
 #: gio/glib-compile-schemas.c:1959
 #, c-format
-#| msgid "No such key '%s' in schema '%s' as specified in override file '%s'"
 msgid "No such key “%s” in schema “%s” as specified in override file “%s”"
 msgstr "Nėra rakto „%s“ schemoje „%s“ kaip nurodyta perrašančiame faile „%s“"
 
@@ -2751,9 +2729,6 @@ msgstr ""
 
 #: gio/glib-compile-schemas.c:2011
 #, c-format
-#| msgid ""
-#| "error parsing key '%s' in schema '%s' as specified in override file '%s': "
-#| "%s."
 msgid ""
 "error parsing key “%s” in schema “%s” as specified in override file “%s”: %s."
 msgstr ""
@@ -2767,9 +2742,6 @@ msgstr "Nepaisoma šio rakto perrašymo.\n"
 
 #: gio/glib-compile-schemas.c:2040
 #, c-format
-#| msgid ""
-#| "override for key '%s' in schema '%s' in override file '%s' is outside the "
-#| "range given in the schema"
 msgid ""
 "override for key “%s” in schema “%s” in override file “%s” is outside the "
 "range given in the schema"
@@ -2779,9 +2751,6 @@ msgstr ""
 
 #: gio/glib-compile-schemas.c:2069
 #, c-format
-#| msgid ""
-#| "override for key '%s' in schema '%s' in override file '%s' is not in the "
-#| "list of valid choices"
 msgid ""
 "override for key “%s” in schema “%s” in override file “%s” is not in the "
 "list of valid choices"
@@ -2899,7 +2868,6 @@ msgstr "Nepavyko rasti šakninio aplanko %s išmesti"
 
 #: gio/glocalfile.c:1979
 #, c-format
-#| msgid "Copy (reflink/clone) between mounts is not supported"
 msgid "Trashing on system internal mounts is not supported"
 msgstr "Išmetimas tarp sistemos vidinių prijungimo taškų nepalaikomas"
 
@@ -4924,32 +4892,26 @@ msgstr "Klaida eilutėje %d simbolyje %d: "
 
 #: glib/gmarkup.c:461 glib/gmarkup.c:544
 #, c-format
-#| msgid "Invalid UTF-8 encoded text in name - not valid '%s'"
 msgid "Invalid UTF-8 encoded text in name — not valid “%s”"
 msgstr "Klaidingai koduotas UTF-8 tekstas varde – netinkamas „%s“"
 
 #: glib/gmarkup.c:472
 #, c-format
-#| msgid "'%s' is not a valid name"
 msgid "“%s” is not a valid name"
 msgstr "„%s“ nėra tinkamas vardas"
 
 #: glib/gmarkup.c:488
 #, c-format
-#| msgid "'%s' is not a valid name: '%c'"
 msgid "“%s” is not a valid name: “%c”"
 msgstr "„%s“ nėra tinkamas vardas: „%c“"
 
-#: glib/gmarkup.c:598
+#: glib/gmarkup.c:610
 #, c-format
 msgid "Error on line %d: %s"
 msgstr "Klaida eilutėje %d: %s"
 
-#: glib/gmarkup.c:675
+#: glib/gmarkup.c:687
 #, c-format
-#| msgid ""
-#| "Failed to parse '%-.*s', which should have been a digit inside a "
-#| "character reference (&#234; for example) - perhaps the digit is too large"
 msgid ""
 "Failed to parse “%-.*s”, which should have been a digit inside a character "
 "reference (&#234; for example) — perhaps the digit is too large"
@@ -4957,11 +4919,7 @@ msgstr ""
 "Nepavyko perskaityti „%-.*s“, kuris galėjo turėti skaičius simbolio aprašyme "
 "(pvz., &#234;) – gal skaičius per didelis"
 
-#: glib/gmarkup.c:687
-#| msgid ""
-#| "Character reference did not end with a semicolon; most likely you used an "
-#| "ampersand character without intending to start an entity - escape "
-#| "ampersand as &amp;"
+#: glib/gmarkup.c:699
 msgid ""
 "Character reference did not end with a semicolon; most likely you used an "
 "ampersand character without intending to start an entity — escape ampersand "
@@ -4971,31 +4929,24 @@ msgstr ""
 "ampersendo simbolį nepradėdami elemento įvedimo – pakeiskite ampersendą "
 "įvesdami &amp;"
 
-#: glib/gmarkup.c:713
+#: glib/gmarkup.c:725
 #, c-format
-#| msgid "Character reference '%-.*s' does not encode a permitted character"
 msgid "Character reference “%-.*s” does not encode a permitted character"
 msgstr "Simbolio aprašymas „%-.*s“ neatitinka leistinų simbolių"
 
-#: glib/gmarkup.c:751
-#| msgid ""
-#| "Empty entity '&;' seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
+#: glib/gmarkup.c:763
 msgid ""
 "Empty entity “&;” seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
 msgstr ""
 "Aptiktas tuščias elementas '&;'; galimi elementai yra: &amp; &quot; &lt; "
 "&gt; &apos;"
 
-#: glib/gmarkup.c:759
+#: glib/gmarkup.c:771
 #, c-format
-#| msgid "Entity name '%-.*s' is not known"
 msgid "Entity name “%-.*s” is not known"
 msgstr "Elemento vardas „%-.*s“ nežinomas"
 
-#: glib/gmarkup.c:764
-#| msgid ""
-#| "Entity did not end with a semicolon; most likely you used an ampersand "
-#| "character without intending to start an entity - escape ampersand as &amp;"
+#: glib/gmarkup.c:776
 msgid ""
 "Entity did not end with a semicolon; most likely you used an ampersand "
 "character without intending to start an entity — escape ampersand as &amp;"
@@ -5003,26 +4954,20 @@ msgstr ""
 "Elementas nepasibaigė kabliataškiu; greičiausiai Jūs panaudojote ampersendo "
 "simbolį nepradėdami elemento įvedimo – pakeiskite ampersendą įvesdami &amp;"
 
-#: glib/gmarkup.c:1170
+#: glib/gmarkup.c:1182
 msgid "Document must begin with an element (e.g. <book>)"
 msgstr "Dokumentas turėtų prasidėti elementu (pvz., <book>)"
 
-#: glib/gmarkup.c:1210
+#: glib/gmarkup.c:1222
 #, c-format
-#| msgid ""
-#| "'%s' is not a valid character following a '<' character; it may not begin "
-#| "an element name"
 msgid ""
 "“%s” is not a valid character following a “<” character; it may not begin an "
 "element name"
 msgstr ""
 "„%s“ negali būti rašomas po „<“ simbolio; jis nepradeda jokio elemento vardo"
 
-#: glib/gmarkup.c:1252
+#: glib/gmarkup.c:1264
 #, c-format
-#| msgid ""
-#| "Odd character '%s', expected a '>' character to end the empty-element tag "
-#| "'%s'"
 msgid ""
 "Odd character “%s”, expected a “>” character to end the empty-element tag "
 "“%s”"
@@ -5030,23 +4975,16 @@ msgstr ""
 "Neįprastas simbolis „%s“, tikėtasi sulaukti „>“ simbolio, užbaigiančio "
 "tuščią žymą „%s“"
 
-#: glib/gmarkup.c:1333
+#: glib/gmarkup.c:1345
 #, c-format
-#| msgid ""
-#| "Odd character '%s', expected a '=' after attribute name '%s' of element "
-#| "'%s'"
 msgid ""
 "Odd character “%s”, expected a “=” after attribute name “%s” of element “%s”"
 msgstr ""
 "Neįprastas simbolis „%1$s“, tikėtasi sulaukti „=“ po elemento „%3$s“ "
 "atributo vardo „%2$s“"
 
-#: glib/gmarkup.c:1374
+#: glib/gmarkup.c:1386
 #, c-format
-#| msgid ""
-#| "Odd character '%s', expected a '>' or '/' character to end the start tag "
-#| "of element '%s', or optionally an attribute; perhaps you used an invalid "
-#| "character in an attribute name"
 msgid ""
 "Odd character “%s”, expected a “>” or “/” character to end the start tag of "
 "element “%s”, or optionally an attribute; perhaps you used an invalid "
@@ -5056,11 +4994,8 @@ msgstr ""
 "užbaigiančių elementą „%s“, arba papildomo požymio; gal Jūs panaudojote "
 "netinkama simbolį požymio varde"
 
-#: glib/gmarkup.c:1418
+#: glib/gmarkup.c:1430
 #, c-format
-#| msgid ""
-#| "Odd character '%s', expected an open quote mark after the equals sign "
-#| "when giving value for attribute '%s' of element '%s'"
 msgid ""
 "Odd character “%s”, expected an open quote mark after the equals sign when "
 "giving value for attribute “%s” of element “%s”"
@@ -5068,22 +5003,16 @@ msgstr ""
 "Neįprastas simbolis „%1$s“, po lygybės tikėtasi sulaukti atidarančio "
 "citavimo simbolio pradedant „%3$s“ elemento „%2$s“ atributo reikšmę."
 
-#: glib/gmarkup.c:1551
+#: glib/gmarkup.c:1563
 #, c-format
-#| msgid ""
-#| "'%s' is not a valid character following the characters '</'; '%s' may not "
-#| "begin an element name"
 msgid ""
 "“%s” is not a valid character following the characters “</”; “%s” may not "
 "begin an element name"
 msgstr ""
 "„%s“ negali būti rašomas po simbolių „</“; „%s“ negali pradėti elemento vardo"
 
-#: glib/gmarkup.c:1587
+#: glib/gmarkup.c:1599
 #, c-format
-#| msgid ""
-#| "'%s' is not a valid character following the close element name '%s'; the "
-#| "allowed character is '>'"
 msgid ""
 "“%s” is not a valid character following the close element name “%s”; the "
 "allowed character is “>”"
@@ -5091,36 +5020,30 @@ msgstr ""
 "„%s“ negali būti rašomas po uždarančio elemento vardo „%s“; leistinas "
 "simbolis yra „>“"
 
-#: glib/gmarkup.c:1598
+#: glib/gmarkup.c:1610
 #, c-format
-#| msgid "Element '%s' was closed, no element is currently open"
 msgid "Element “%s” was closed, no element is currently open"
 msgstr ""
 "Elemento „%s“ uždarymo simbolis sutiktas anksčiau už elemento atidarymo "
 "simbolį"
 
-#: glib/gmarkup.c:1607
+#: glib/gmarkup.c:1619
 #, c-format
-#| msgid "Element '%s' was closed, but the currently open element is '%s'"
 msgid "Element “%s” was closed, but the currently open element is “%s”"
 msgstr ""
 "Sutiktas elemento „%s“ uždarymo simbolis, tačiau šiuo metu atidarytas kitas "
 "elementas „%s“"
 
-#: glib/gmarkup.c:1760
+#: glib/gmarkup.c:1772
 msgid "Document was empty or contained only whitespace"
 msgstr "Dokumentas tuščias arba susideda tik iš tarpų"
 
-#: glib/gmarkup.c:1774
-#| msgid "Document ended unexpectedly just after an open angle bracket '<'"
+#: glib/gmarkup.c:1786
 msgid "Document ended unexpectedly just after an open angle bracket “<”"
 msgstr "Dokumentas netikėtai pasibaigė tuoj po atidarančių skliaustų „<“"
 
-#: glib/gmarkup.c:1782 glib/gmarkup.c:1827
+#: glib/gmarkup.c:1794 glib/gmarkup.c:1839
 #, c-format
-#| msgid ""
-#| "Document ended unexpectedly with elements still open - '%s' was the last "
-#| "element opened"
 msgid ""
 "Document ended unexpectedly with elements still open — “%s” was the last "
 "element opened"
@@ -5128,7 +5051,7 @@ msgstr ""
 "Dokumentas netikėtai pasibaigė neuždarius dalies elementų – „%s“ yra "
 "paskutinis atviras elementas"
 
-#: glib/gmarkup.c:1790
+#: glib/gmarkup.c:1802
 #, c-format
 msgid ""
 "Document ended unexpectedly, expected to see a close angle bracket ending "
@@ -5137,19 +5060,19 @@ msgstr ""
 "Dokumentas netikėtai pasibaigė, tikėtasi uždarančių skliaustų simbolio, "
 "užbaigiančio žymą <%s/>"
 
-#: glib/gmarkup.c:1796
+#: glib/gmarkup.c:1808
 msgid "Document ended unexpectedly inside an element name"
 msgstr "Dokumentas netikėtai pasibaigė elemento varde"
 
-#: glib/gmarkup.c:1802
+#: glib/gmarkup.c:1814
 msgid "Document ended unexpectedly inside an attribute name"
 msgstr "Dokumentas netikėtai pasibaigė požymio varde"
 
-#: glib/gmarkup.c:1807
+#: glib/gmarkup.c:1819
 msgid "Document ended unexpectedly inside an element-opening tag."
 msgstr "Dokumentas netikėtai pasibaigė elemento atvėrimo žyma."
 
-#: glib/gmarkup.c:1813
+#: glib/gmarkup.c:1825
 msgid ""
 "Document ended unexpectedly after the equals sign following an attribute "
 "name; no attribute value"
@@ -5157,17 +5080,22 @@ msgstr ""
 "Dokumentas netikėtai pasibaigė lygybės simboliu einančio po požymio vardo; "
 "nerasta požymio reikšmė"
 
-#: glib/gmarkup.c:1820
+#: glib/gmarkup.c:1832
 msgid "Document ended unexpectedly while inside an attribute value"
 msgstr "Dokumentas netikėtai pasibaigė požymio verte"
 
-#: glib/gmarkup.c:1836
+#: glib/gmarkup.c:1849
 #, c-format
-#| msgid "Document ended unexpectedly inside the close tag for element '%s'"
 msgid "Document ended unexpectedly inside the close tag for element “%s”"
 msgstr "Dokumentas netikėtai pasibaigė žymos „%s“ uždarančiame simbolyje"
 
-#: glib/gmarkup.c:1842
+#: glib/gmarkup.c:1853
+#| msgid "Document ended unexpectedly inside the close tag for element “%s”"
+msgid ""
+"Document ended unexpectedly inside the close tag for an unopened element"
+msgstr "Dokumentas netikėtai pasibaigė neatidaryto elemento uždarymo žymoje"
+
+#: glib/gmarkup.c:1859
 msgid "Document ended unexpectedly inside a comment or processing instruction"
 msgstr ""
 "Dokumentas netikėtai pasibaigė komentaruose arba apdorojimo instrukcijose"
@@ -5669,7 +5597,6 @@ msgstr "Nepavyko perskaityti duomenų iš antrinio konvejerio (%s)"
 
 #: glib/gspawn.c:1596
 #, c-format
-#| msgid "Failed to execute child process “%s” (%s)"
 msgid "Failed to spawn child process “%s” (%s)"
 msgstr "Nepavyko paleisti antrinio proceso „%s“ (%s)"
 
