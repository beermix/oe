Index: synaptics.c
===================================================================
RCS file: /data/cvs/gpm/src/synaptics.c,v
retrieving revision 1.3
diff -c -r1.3 synaptics.c
*** synaptics.c	2002/05/31 21:14:38	1.3
--- synaptics.c	2002/08/23 12:28:56
***************
*** 5,10 ****
--- 5,13 ----
   *                  Geert Van der Plas provided the code to support
   *                        older Synaptics PS/2 touchpads.
   *
+  *   Synpatics Passthrough Support Copyright (C) 2002 Linuxcare Inc.
+  *   dkennedy@linuxcare.com (David Kennedy)
+  * 
   *   This program is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU General Public License as published by
   *   the Free Software Foundation; either version 2 of the License, or
***************
*** 93,108 ****
  **
  **  Four buttons to work
  **        Some touchpads have 4 buttons. Only 3 was read and the last was set to 
! **        up or down "button". 
  **
  **  Multiple fingers
  **        I have added an option to detect such by looking at pressure levels,
! **        which is not that great. If the pad have the capability to detect
! **        it, this is used instead, but this far from optimal. It does detect
! **        two horizontal parted finger if in same vertical position, otherwise
! **        the detection is bad. This is/was a problem as my wrist lays on the
  **        laptop which gives a 45 deg to horizontal for my fingers. Now I try
! **        to add further detections, which works for me in 95% of the time.
  **
  **  Multi finger tap
  **        Using 1,2 or 3 fingers to make a tap translates into left, right or
--- 96,113 ----
  **
  **  Four buttons to work
  **        Some touchpads have 4 buttons. Only 3 was read and the last was set to 
! **        up or down "button". They can be configured just as the
! **        touchpads corners.
  **
  **  Multiple fingers
  **        I have added an option to detect such by looking at pressure levels,
! **        which is not that great. If the pad have the capability to detect it,
! **        this is used instead, but this far from optimal. It does detect two
! **        horizontal parted finger if in same vertical position, otherwise the
! **        detection is bad. This is/was a problem as my wrist lays on the
  **        laptop which gives a 45 deg to horizontal for my fingers. Now I try
! **        to add further detections, which works for me in 95% of the
! **        time. 
  **
  **  Multi finger tap
  **        Using 1,2 or 3 fingers to make a tap translates into left, right or
***************
*** 110,116 ****
  **        called a "HOP" where after a quick finger shift the distance of the
  **        hop decides which button is pressed. I dropped it partly because
  **        synaptics did in version 3.2 and because it was harder than I
! **        thought.
  **
  **  Multi finger less sensitive
  **        Adding or removing a finger or just accidently touch the pad with
--- 115,121 ----
  **        called a "HOP" where after a quick finger shift the distance of the
  **        hop decides which button is pressed. I dropped it partly because
  **        synaptics did in version 3.2 and because it was harder than I
! **        thought. Multifinger taps can be configured just as the touchpads corners.
  **
  **  Multi finger less sensitive
  **        Adding or removing a finger or just accidently touch the pad with
***************
*** 204,209 ****
--- 209,215 ----
  */
  
  
+ #include <math.h>                /* ceil */
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
***************
*** 229,235 ****
--- 235,246 ----
  #  define DEBUG_TOSS              1
  #  define DEBUG_PALM              1
  #  define DEBUG_STICK             1
+ #  define DEBUG_TAPS              1
  #  define DEBUG_MULTI_FINGER      1
+ #  define DEBUG_CMD               1
+ #  define DEBUG_GETBYTE           1    /* this is VERY verbose */
+ #  undef  DEBUG_PUTBYTE           1    /* this is VERY verbose */
+ #  define DEBUG_PUTBYTE_ACK       1    /* this is VERY verbose */
  #  define DEBUG_REPORTS           1    /* this is VERY verbose */
  #endif
  
***************
*** 268,275 ****
--- 279,289 ----
  * END BADE CODE */
  
  /* Prototype */
+ typedef unsigned char byte;
  
  static void syn_ps2_absolute_mode(int fd);
+ static char *syn_model_name (int sensor);
+ static void syn_ps2_send_cmd(int fd, int stick, byte cmd); 
  
  
  /* Defines */
***************
*** 288,297 ****
  #define RIGHT_EDGE          0x02
  #define TOP_EDGE            0x04
  #define BOTTOM_EDGE         0x08
- #define UP_BUTTON           0x01
- #define DOWN_BUTTON         0x02
- #define LEFT_BUTTON         0x04
- #define RIGHT_BUTTON        0x08
  #define UPPER_LEFT_CORNER   (LEFT_EDGE  | TOP_EDGE)
  #define LOWER_LEFT_CORNER   (LEFT_EDGE  | BOTTOM_EDGE)
  #define UPPER_RIGHT_CORNER  (RIGHT_EDGE | TOP_EDGE)
--- 302,307 ----
***************
*** 299,305 ****
--- 309,345 ----
  #define is_corner(edges)    (((edges) & (LEFT_EDGE | RIGHT_EDGE)) && \
  			     ((edges) & (TOP_EDGE  | BOTTOM_EDGE)))
  
+ /*
+ ** Define the action button bit values.
+ */
+ #define RIGHT_BUTTON        0x01
+ #define MIDDLE_BUTTON       0x02
+ #define LEFT_BUTTON         0x04
+ #define FOURTH_BUTTON       0x08
+ #define UP_BUTTON           0x10
+ #define DOWN_BUTTON         0x20
+ #define ONE_FINGER          0x01
+ #define TWO_FINGERS         0x02
+ #define THREE_FINGERS       0x04
+ #define FOUR_UP_BUTTON      0x01
+ #define FOUR_DOWN_BUTTON    0x02
+ #define FOUR_LEFT_BUTTON    0x04
+ #define FOUR_RIGHT_BUTTON   0x08
+ #define STICK_RIGHT_BUTTON  0x01
+ #define STICK_MIDDLE_BUTTON 0x02
+ #define STICK_LEFT_BUTTON   0x04
+ /*
+ ** Define additional gpm button bit values.
+ */
+ #define GPM_B_NOT_SET       (-1)
+ 
+ /*
+ ** Define the guest and touchpad devices.
+ */
+ #define DEVICE_TOUCHPAD     0
+ #define DEVICE_STICK        1
  
+ 
  /****************************************************************************
  **
  ** Configuration constants.
***************
*** 358,363 ****
--- 398,404 ----
  static int   multi_finger_tap_enabled= 1;     /* No of fingers decides which button is pressed C*/
  static int   multi_finger_stop_enabled = 1;   /* less sensitive mouse with multi finger C*/
  static int   multi_finger_stop_delay = 8;     /* how long to stop after a multifinger detection. C*/
+ static int   fake_finger_layer_enabled = 1;   /* add an extra software layer to detect multi fingers C*/
  
  
  /* mixed configurations */
***************
*** 366,372 ****
                                             * same device port. The stick will be ignored in
                                             * absolute mode, this option try to recognize
                                             * it's packets.                                         C*/
! static int   stick_pressure_enabled  = 0; /* A (hard) press on the stick is reported as left click C*/
  static int   four_way_button_enabled = 1; /* Round button giving 4 choices on some touchpads        C*/
  static int   four_way_button_is_mouse= 1; /* Is the button: 4 buttons or does it moves the mouse.  C*/
  static int   scrolling_enabled       = 1; /* Simulate wheel mouse in at the right edge             C*/
--- 407,413 ----
                                             * same device port. The stick will be ignored in
                                             * absolute mode, this option try to recognize
                                             * it's packets.                                         C*/
! static int   stick_pressure_enabled  = 1; /* A (hard) press on the stick is reported as left click C*/
  static int   four_way_button_enabled = 1; /* Round button giving 4 choices on some touchpads        C*/
  static int   four_way_button_is_mouse= 1; /* Is the button: 4 buttons or does it moves the mouse.  C*/
  static int   scrolling_enabled       = 1; /* Simulate wheel mouse in at the right edge             C*/
***************
*** 398,404 ****
    Reset_Touchpad_Action,
    Toggle_Four_Way_Button_Action,
    Toggle_Stick_Pressure_Action,
!   Toggle_Scrolling_Action
  } action_type;
  
  
--- 439,446 ----
    Reset_Touchpad_Action,
    Toggle_Four_Way_Button_Action,
    Toggle_Stick_Pressure_Action,
!   Toggle_Scrolling_Action,
!   Left_Double_Click_Action,
  } action_type;
  
  
***************
*** 414,429 ****
    { LOWER_RIGHT_CORNER, Right_Button_Action  },
    { 0,                  No_Action } /* stop flag value */
  };
- 
  
! static touchpad_action_type four_button_action [] = {
    { UP_BUTTON,          Up_Button_Action },
    { DOWN_BUTTON,        Down_Button_Action },
-   { LEFT_BUTTON,        Middle_Button_Action },
-   { RIGHT_BUTTON,       Fourth_Button_Action },
    { 0,                  No_Action } /* stop flag value */
  };
  
  /*
  ** These types are used to read the configuration data from the config file.
  */
--- 456,495 ----
    { LOWER_RIGHT_CORNER, Right_Button_Action  },
    { 0,                  No_Action } /* stop flag value */
  };
  
! static touchpad_action_type normal_button_actions [] = {
!   { LEFT_BUTTON,        Left_Button_Action },
!   { MIDDLE_BUTTON,      Middle_Button_Action },
!   { RIGHT_BUTTON,       Right_Button_Action },
!   { FOURTH_BUTTON,      Fourth_Button_Action },
    { UP_BUTTON,          Up_Button_Action },
    { DOWN_BUTTON,        Down_Button_Action },
    { 0,                  No_Action } /* stop flag value */
  };
  
+ static touchpad_action_type multi_finger_actions [] = {
+   { ONE_FINGER,         Left_Button_Action },
+   { TWO_FINGERS,        Right_Button_Action },
+   { THREE_FINGERS,      Middle_Button_Action },
+   { 0,                  No_Action } /* stop flag value */
+ };
+ 
+ static touchpad_action_type four_button_actions [] = {
+   { FOUR_LEFT_BUTTON,   Middle_Button_Action },
+   { FOUR_RIGHT_BUTTON,  Fourth_Button_Action },
+   { FOUR_UP_BUTTON,     Up_Button_Action },
+   { FOUR_DOWN_BUTTON,   Down_Button_Action },
+   { 0,                  No_Action } /* stop flag value */
+ };
+ 
+ static touchpad_action_type stick_actions [] = {
+   { LEFT_BUTTON,        Left_Button_Action },
+   { MIDDLE_BUTTON,      Middle_Button_Action },
+   { RIGHT_BUTTON,       Right_Button_Action },
+   { 0,                  No_Action } /* stop flag value */
+ };
+ 
+ 
  /*
  ** These types are used to read the configuration data from the config file.
  */
***************
*** 475,490 ****
    { "y_min_center",               Integer_Param, {&y_min_center               }},
    { "y_max_center",               Integer_Param, {&y_max_center               }},
    { "edge_speed",                 Integer_Param, {&edge_speed                 }},
-   /* corner tap actions */			 			     
-   { "upper_left_action",          Action_Param,  {&corner_actions [0]         }},
-   { "lower_left_action",          Action_Param,  {&corner_actions [1]         }},
-   { "upper_right_action",         Action_Param,  {&corner_actions [2]         }},
-   { "lower_right_action",         Action_Param,  {&corner_actions [3]         }},
-   /* 4 way button actions */
-   { "up_button_action",           Action_Param,  {&four_button_action [0]     }},
-   { "down_button_action",         Action_Param,  {&four_button_action [1]     }},
-   { "left_button_action",         Action_Param,  {&four_button_action [2]     }},
-   { "right_button_action",        Action_Param,  {&four_button_action [3]     }},
    /* use wmode */				 			     
    { "wmode_enabled",		  Flag_Param,	 {&wmode_enabled	      }},
    { "drag_lock_enabled",	  Flag_Param,	 {&drag_lock_enabled	      }},
--- 541,546 ----
***************
*** 495,506 ****
    { "tap_interval",		  Integer_Param, {&tap_interval		      }},
    { "multiple_tap_delay",	  Integer_Param, {&multiple_tap_delay	      }},
    { "pads_tap_interval",	  Integer_Param, {&pads_tap_interval	      }},
!   /* Additional wmode parameters */				 			     
    { "palm_detect_enabled",	  Flag_Param,	 {&palm_detect_enabled	      }},
    { "palm_detect_level",	  Integer_Param, {&palm_detect_level	      }},
    { "multi_finger_tap_enable",    Flag_Param,    {&multi_finger_tap_enabled   }},
    { "multi_finger_stop_enabled",  Flag_Param,    {&multi_finger_stop_enabled  }},
    { "multi_finger_stop_delay",    Integer_Param, {&multi_finger_stop_delay    }},
    /* Additional options*/
    { "touchpad_enabled", 	  Flag_Param,    {&touchpad_enabled	      }},
    { "stick_enabled",	          Flag_Param,    {&stick_enabled	      }},
--- 551,563 ----
    { "tap_interval",		  Integer_Param, {&tap_interval		      }},
    { "multiple_tap_delay",	  Integer_Param, {&multiple_tap_delay	      }},
    { "pads_tap_interval",	  Integer_Param, {&pads_tap_interval	      }},
!   /* Additional wmode parameters */ 
    { "palm_detect_enabled",	  Flag_Param,	 {&palm_detect_enabled	      }},
    { "palm_detect_level",	  Integer_Param, {&palm_detect_level	      }},
    { "multi_finger_tap_enable",    Flag_Param,    {&multi_finger_tap_enabled   }},
    { "multi_finger_stop_enabled",  Flag_Param,    {&multi_finger_stop_enabled  }},
    { "multi_finger_stop_delay",    Integer_Param, {&multi_finger_stop_delay    }},
+   { "fake_finger_layer_enabled",  Integer_Param, {&fake_finger_layer_enabled  }},
    /* Additional options*/
    { "touchpad_enabled", 	  Flag_Param,    {&touchpad_enabled	      }},
    { "stick_enabled",	          Flag_Param,    {&stick_enabled	      }},
***************
*** 513,518 ****
--- 570,600 ----
    { "scrolling_speed",	          Integer_Param, {&scrolling_speed	      }},
    { "scrolling_button_factor",    Float_Param,   {&scrolling_button_factor    }},
    { "auto_scrolling_factor",      Float_Param,   {&auto_scrolling_factor      }},
+   /* corner tap actions */			 			     
+   { "upper_left_action",          Action_Param,  {&corner_actions [0]         }},
+   { "lower_left_action",          Action_Param,  {&corner_actions [1]         }},
+   { "upper_right_action",         Action_Param,  {&corner_actions [2]         }},
+   { "lower_right_action",         Action_Param,  {&corner_actions [3]         }},
+   /* no. of fingers tap actions */
+   { "one_finger_tap_action",      Action_Param,  {&multi_finger_actions [0]   }},
+   { "two_fingers_tap_action",     Action_Param,  {&multi_finger_actions [1]   }},
+   { "three_fingers_tap_action",   Action_Param,  {&multi_finger_actions [2]   }},
+   /* normal button actions */
+   { "left_button_action",         Action_Param,  {&normal_button_actions [0]  }},
+   { "middle_button_action",       Action_Param,  {&normal_button_actions [1]  }},
+   { "right_button_action",        Action_Param,  {&normal_button_actions [2]  }},
+   { "fourth_button_action",       Action_Param,  {&normal_button_actions [3]  }},
+   { "up_button_action",           Action_Param,  {&normal_button_actions [4]  }},
+   { "down_button_action",         Action_Param,  {&normal_button_actions [5]  }},
+   /* 4 way button actions */
+   { "four_way_left_button_action", Action_Param,  {&four_button_actions [0]   }},
+   { "four_way_right_button_action",Action_Param,  {&four_button_actions [1]   }},
+   { "four_way_up_button_action",   Action_Param,  {&four_button_actions [2]   }},
+   { "four_way_down_button_action", Action_Param,  {&four_button_actions [3]   }},
+   /* Synaptic Stick (passthrugh,stick) actions */
+   { "stick_left_button_action",    Action_Param,  {&stick_actions [0]         }},
+   { "stick_middle_button_action",  Action_Param,  {&stick_actions [1]         }},
+   { "stick_right_button_action",   Action_Param,  {&stick_actions [2]         }},
    /* end of list */				 			     
    { NULL,                         Flag_Param,    {NULL                        }}
  };
***************
*** 528,534 ****
    int info_minor;
  } info_type;
  
! static info_type ident;
  
  /*
  ** The information returned in the model ID packet.
--- 610,616 ----
    int info_minor;
  } info_type;
  
! static info_type ident[2];
  
  /*
  ** The information returned in the model ID packet.
***************
*** 556,562 ****
    int info_geometry; 
  } model_id_type; 
  
! static model_id_type model;
  
  /*
  ** The sensor types as of STIG 2.5
--- 638,644 ----
    int info_geometry; 
  } model_id_type; 
  
! static model_id_type model[2];
  
  /*
  ** The sensor types as of STIG 2.5
***************
*** 603,615 ****
    "SubMini w/6 buttons",
    "Standard USB Module",
    "cPad Dropin Plain USB Module",
!   "cPad"                                    /* 40 */ 
  };
  
  
- 
- 
- 
  /*
  ** Define the information known about a sensor.
  ** STIG page 14.
--- 685,698 ----
    "SubMini w/6 buttons",
    "Standard USB Module",
    "cPad Dropin Plain USB Module",
!   "cPad",                                   /* 40 */ 
!   "",
!   "",
!   "",
!   "UltraNav",
  };
  
  
  /*
  ** Define the information known about a sensor.
  ** STIG page 14.
***************
*** 641,647 ****
    { "SubMini",   122, 167, 32.8, 18.2 },
  };
  
! static sensor_info_type *sensor;
  
  /*
  ** The information returned in the extended capability packet.
--- 724,732 ----
    { "SubMini",   122, 167, 32.8, 18.2 },
  };
  
! static sensor_info_type *sensor[2] = {
!   &sensor_info[0],&sensor_info[0]
! };
  
  /*
  ** The information returned in the extended capability packet.
***************
*** 650,655 ****
--- 735,741 ----
  
  #define EXT_CAP_EXTENDED     0x8000     /* Bit 15  */
  #define EXT_CAP_STICK        0x0080     /* Bit 8   */
+ #define EXT_CAP_PASS_THROUGH 0X0080     /* Bit 8!! */
  #define EXT_CAP_SLEEP        0x0010     /* Bit 4   */
  #define EXT_CAP_FOUR_BUTTON  0x0008     /* Bit 3   */
  #define EXT_CAP_MULTI_FINGER 0X0002     /* Bit 1   */
***************
*** 664,670 ****
    int cap_palm_detect; 
  } ext_cap_type;
  
! static ext_cap_type capabilities;
  
  /*
  ** The information in the mode byte.
--- 750,756 ----
    int cap_palm_detect; 
  } ext_cap_type;
  
! static ext_cap_type capabilities[2];
  
  /*
  ** The information in the mode byte.
***************
*** 704,713 ****
    int pressure;
    int gesture;
    int fingers;
    int w;
  } report_type;
  
! static report_type last_report,report;
  
  /*
  ** A location record.
--- 790,800 ----
    int pressure;
    int gesture;
    int fingers;
+   int fingerwidth;
    int w;
  } report_type;
  
! static report_type last_report,cur_report;
  
  /*
  ** A location record.
***************
*** 735,750 ****
  static int           packet_num = 0;
  static int           was_edges = 0;
  static int           was_non_edge = 0;
- static int           last_corner_action = GPM_B_NONE;
  static location_type last_locs [4];
  static Gpm_Event     last_state;
  static int           tap_lower_limit_packet;    
  static int           tap_upper_limit_packet;
  
  /* toss status information */
  static int           is_tossing = 0;
  static int           was_tossing = 0;
! static int           min_toss_dist__2;
  static int           max_toss_packets;
  static int           min_toss_packets;
  static int           prevent_toss_packets;
--- 822,844 ----
  static int           packet_num = 0;
  static int           was_edges = 0;
  static int           was_non_edge = 0;
  static location_type last_locs [4];
  static Gpm_Event     last_state;
  static int           tap_lower_limit_packet;    
  static int           tap_upper_limit_packet;
+ static int           last_corner_action = GPM_B_NOT_SET;
+ static int           last_finger_action = GPM_B_NOT_SET;
+ static int           last_normal_button_actions[6] = 
+   {GPM_B_NOT_SET,GPM_B_NOT_SET,GPM_B_NOT_SET,GPM_B_NOT_SET,GPM_B_NOT_SET,GPM_B_NOT_SET};
+ static int           last_stick_button_actions[3]  = 
+   {GPM_B_NOT_SET,GPM_B_NOT_SET,GPM_B_NOT_SET};
+ static int           last_4_way_button_actions[4] =
+   {GPM_B_NOT_SET,GPM_B_NOT_SET,GPM_B_NOT_SET,GPM_B_NOT_SET};
  
  /* toss status information */
  static int           is_tossing = 0;
  static int           was_tossing = 0;
! static int           min_toss_dist__2 = 32000;
  static int           max_toss_packets;
  static int           min_toss_packets;
  static int           prevent_toss_packets;
***************
*** 752,767 ****
  static location_type toss_speed;
  static location_type touch_loc;
  
  
  /* Multi finger information */
  static int           was_fingers = 0;
  static int           multi_finger_stop_timer = 0;
- static int           multi_finger_reset_timer;
  static int           multi_finger_pressure  = 0;
  static int           multi_finger_xy = 0;
  
  
- 
  /* Scrolling information */
  static int           is_scrolling = 0;            /* Scrolling using touchpad edge*/
  static int           is_always_scrolling = 0;     /* Only report scrolling, no mouse movement */
--- 846,864 ----
  static location_type toss_speed;
  static location_type touch_loc;
  
+ /* Multi tap information */
+ static int           gesture_delay = 0;
+ static int           fake_forget_tap_interval = 0;  /* if hardware sends tap-hold, we need to keep track */
+ static int           fake_time_to_forget_tap = 0;   /* not to lose user defined actions in the hold periode. 
+ 						     * (action like: Multifingers, non-repeating actions etc.*/
  
  /* Multi finger information */
  static int           was_fingers = 0;
  static int           multi_finger_stop_timer = 0;
  static int           multi_finger_pressure  = 0;
  static int           multi_finger_xy = 0;
  
  
  /* Scrolling information */
  static int           is_scrolling = 0;            /* Scrolling using touchpad edge*/
  static int           is_always_scrolling = 0;     /* Only report scrolling, no mouse movement */
***************
*** 839,849 ****
  }
  
  
  
  /* Get model name, STIG page 11 */
  static char *syn_model_name (int sensor) 
  {
!   if (sensor < 0 || 40 < sensor ) {
      return "Reserved";
    } else {
      return model_names [sensor];
--- 936,985 ----
  }
  
  
+ /* syn_dump_info
+ **
+ ** Print properties for the hardare.
+ **
+  */
+ static void syn_dump_info(int stick)
+ {
+ 
+   gpm_report (GPM_PR_INFO,"Synaptic %s Device:",(stick?"Stick":"Touchpad"));
+     
+   gpm_report (GPM_PR_INFO,"Synaptics Ident:  model_code=%d   Firmware version %d.%d",
+ 	      ident[stick].info_model_code, ident[stick].info_major, ident[stick].info_minor);
+   gpm_report (GPM_PR_INFO,"Synaptics model:");
+   gpm_report (GPM_PR_INFO,"   rot180:      %s", model[stick].info_rot180 ? "Yes" : "No");
+   gpm_report (GPM_PR_INFO,"   portrait:    %s", model[stick].info_portrait ? "Yes" : "No");
+   gpm_report (GPM_PR_INFO,"   sensor:      %d", model[stick].info_sensor);
+   gpm_report (GPM_PR_INFO,"                %s", syn_model_name (model[stick].info_sensor));
+   gpm_report (GPM_PR_INFO,"                %s", sensor[stick]->model);
+   gpm_report (GPM_PR_INFO,"                %dx%d res/mm",
+ 	      sensor[stick]->x_per_mm, sensor[stick]->y_per_mm);
+   gpm_report (GPM_PR_INFO,"                %4.1fx%4.1f mm",
+ 	      sensor[stick]->width_mm, sensor[stick]->height_mm);
+   gpm_report (GPM_PR_INFO,"                %dx%d res", res_x, res_y);
+   gpm_report (GPM_PR_INFO,"   hardware:    %d", model[stick].info_hardware);
+   gpm_report (GPM_PR_INFO,"   newABS:      %s", model[stick].info_new_abs ? "Yes" : "No");
+   gpm_report (GPM_PR_INFO,"   simpleCmd:   %s", model[stick].info_simple_cmd ? "Yes" : "No");
+   gpm_report (GPM_PR_INFO,"   geometry:    %d", model[stick].info_geometry);
+   gpm_report (GPM_PR_INFO,"   extended:    %s", capabilities[stick].cap_ext ? "Yes" : "No");
+   gpm_report (GPM_PR_INFO,"   stick:       %s", capabilities[stick].cap_stick ? "Yes" : "No");
+   gpm_report (GPM_PR_INFO,"   sleep:       %s", capabilities[stick].cap_sleep ? "Yes" : "No");
+   gpm_report (GPM_PR_INFO,"   4 buttons:   %s", capabilities[stick].cap_four_button ? "Yes" : "No");
+   gpm_report (GPM_PR_INFO,"   multifinger: %s", capabilities[stick].cap_multi_finger ? "Yes" : "No");
+   gpm_report (GPM_PR_INFO,"   palmdetect:  %s", capabilities[stick].cap_palm_detect ? "Yes" : "No");
+ 
+ #if DEBUG_TOSS
+   gpm_report (GPM_PR_INFO,"Min Toss Dist^2: %d\n", min_toss_dist__2);
+ #endif
+ }
+ 
  
  /* Get model name, STIG page 11 */
  static char *syn_model_name (int sensor) 
  {
!   if (sensor < 0 || 44 < sensor ) {
      return "Reserved";
    } else {
      return model_names [sensor];
***************
*** 886,892 ****
  {
  
  # ifdef DEBUG  
!   gpm_report(GPM_PR_INFO,"Synaptics Touchpad Capabilities: %02X",ext_cap_int);
  # endif 
  
    cap->cap_ext            = check_bits (ext_cap_int, EXT_CAP_EXTENDED);
--- 1022,1028 ----
  {
  
  # ifdef DEBUG  
!   gpm_report(GPM_PR_INFO,"Synaptics Device Capabilities: %02X",ext_cap_int);
  # endif 
  
    cap->cap_ext            = check_bits (ext_cap_int, EXT_CAP_EXTENDED);
***************
*** 903,913 ****
      cap->cap_four_button  = 0;
      cap->cap_multi_finger = 0;
      cap->cap_palm_detect  = 0;
!     wmode_enabled         = 0; /* neither is wmode support by the pad */
    }
- 
-   if(!cap->cap_palm_detect)
-     palm_detect_enabled   = 0;
  }
  
  
--- 1039,1047 ----
      cap->cap_four_button  = 0;
      cap->cap_multi_finger = 0;
      cap->cap_palm_detect  = 0;
!     /* Wmode is not supported, but this should be turned off after reading the
!        config file.*/
    }
  }
  
  
***************
*** 949,965 ****
    if ( scrolling_amount_left < -256*20 )
      scrolling_amount_left = -256*20;
  
    
    if (scrolling_amount_left > scrolling_speed){
      scrolling_amount_left -= scrolling_speed;
!     state->buttons |= GPM_B_DOWN;
    }else if (scrolling_amount_left < -scrolling_speed){
      scrolling_amount_left += scrolling_speed;
!     state->buttons |= GPM_B_UP;
!   }else {
!     state->buttons &= ~(GPM_B_DOWN | GPM_B_UP);
!   }
!     
  }
  
  
--- 1083,1097 ----
    if ( scrolling_amount_left < -256*20 )
      scrolling_amount_left = -256*20;
  
+   state->buttons &= ~(GPM_B_DOWN | GPM_B_UP);
    
    if (scrolling_amount_left > scrolling_speed){
      scrolling_amount_left -= scrolling_speed;
!     state->buttons |= GPM_B_UP;
    }else if (scrolling_amount_left < -scrolling_speed){
      scrolling_amount_left += scrolling_speed;
!     state->buttons |= GPM_B_DOWN;
!   } 
  }
  
  
***************
*** 967,1068 ****
  ** process_action
  **
  ** Do the action and return a button state for a given action list and mask.
! ** Actions that should not be repeated should report GPM_B_NONE (when holding
! ** down a button).
  */
  
  static int tp_process_action(touchpad_action_type *action_list, int mask)
  {
    int i = 0;
!   int status = GPM_B_NONE;
  
    if (mask == 0){
!     return GPM_B_NONE;
    }
! 
    while (action_list [i].action_mask) {
      if (check_bits (mask, action_list [i].action_mask)) {
        switch (action_list [i].action) {
! 	case Left_Button_Action:
! 	status |= GPM_B_LEFT;
! 	  break;
! 	case Middle_Button_Action:
! 	status |= GPM_B_MIDDLE;
! 	  break;
! 	case Right_Button_Action:
! 	status |= GPM_B_RIGHT;
! 	  break;
! 	case Fourth_Button_Action:
! 	status |= GPM_B_FOURTH;
! 	  break;
!         case Up_Button_Action:
! 	scrolling_amount_left += scrolling_button_factor * scrolling_speed;
  	status = GPM_B_UP;
!           break;
!         case Down_Button_Action:
! 	scrolling_amount_left -= scrolling_button_factor * scrolling_speed;
  	status = GPM_B_DOWN;
!           break;
! 	case Turn_On_Off_Action:
  	touchpad_enabled = !touchpad_enabled;
! 	status = GPM_B_NONE;
! 	  break;
! 	case Debug_On_Off_Action:
! #         ifdef DEBUG_SYNAPTIC
! 	    debug_syn_to_stderr = !debug_syn_to_stderr;
! #         endif
! 	status = GPM_B_NONE;
! 	  break;
! 	case Reset_Touchpad_Action:
! 	  syn_ps2_reset(which_mouse->fd);
! 	  syn_ps2_absolute_mode(which_mouse->fd);
! 	status = GPM_B_NONE;
! 	  break;
! 	case Toggle_Four_Way_Button_Action:
! 	  four_way_button_is_mouse = !four_way_button_is_mouse;
! 	status = GPM_B_NONE;
  	break;
        case Toggle_Stick_Pressure_Action:
  	stick_pressure_enabled = !stick_pressure_enabled;
! 	status = GPM_B_NONE;
! 	  break;
        case Toggle_Scrolling_Action:
  	is_always_scrolling = !is_always_scrolling;
! 	status = GPM_B_NONE;
! 	case No_Action:
! 	default:
! 	status = GPM_B_NONE;
! 	  break;
! 	}
        }
  
!       i++;
      }
! 
    return status;
  }
  
  
  /*
! ** process_corner_taps. 
  **
! ** last_corner_action holds the last action because then the second "tap" in
! ** Tap hold and two taps do not have to be at the corner, we just repeat the
! ** action. This function is only called the at the first gesture report; at
! ** consecutive gestures, the buttons are repeated other place. Action that
! ** should not be repeated should report GPM_B_NONE.
  */
! static void tp_process_corner_taps (Gpm_Event *state, report_type report) 
  {
!   if (corner_taps_enabled && report.gesture &&
!       (is_corner (was_edges) || last_corner_action != GPM_B_NONE)) {
  
!     gpm_report (GPM_PR_DEBUG,"\rTouchpad: Corner action"); 
!     last_corner_action = tp_process_action(corner_actions,was_edges);
  
!     state->buttons |= last_corner_action;
    } else {
!     last_corner_action = GPM_B_NONE;
    }
  }
  
--- 1099,1360 ----
  ** process_action
  **
  ** Do the action and return a button state for a given action list and mask.
! ** Actions that should not be repeated should report GPM_B_NOT_SET (when
! ** holding down a button).
  */
  
  static int tp_process_action(touchpad_action_type *action_list, int mask)
  {
    int i = 0;
!   int status = GPM_B_NOT_SET;
!   static int Left_Double_Click = 0;
  
    if (mask == 0){
!     gpm_report (GPM_PR_WARN,"Action Mask is 0");
!     return GPM_B_NOT_SET;
    }
!   
    while (action_list [i].action_mask) {
      if (check_bits (mask, action_list [i].action_mask)) {
        switch (action_list [i].action) {
!       case Left_Button_Action:
! 	status = GPM_B_LEFT;
! 	break;
!       case Middle_Button_Action:
! 	status = GPM_B_MIDDLE;
! 	break;
!       case Right_Button_Action:
! 	status = GPM_B_RIGHT;
! 	break;
!       case Fourth_Button_Action:
! 	status = GPM_B_FOURTH;
! 	break;
!       case Up_Button_Action:
! 	scrolling_amount_left += ceil(scrolling_button_factor * scrolling_speed);
  	status = GPM_B_UP;
! 	break;
!       case Down_Button_Action:
! 	scrolling_amount_left -= ceil(scrolling_button_factor * scrolling_speed);
  	status = GPM_B_DOWN;
! 	break;
!       case Left_Double_Click_Action:
! 	Left_Double_Click++;
! 	status = GPM_B_LEFT; 
! 	if(Left_Double_Click == 2)
! 	  status = GPM_B_NONE; 
! 	if(Left_Double_Click == 4) {
! 	  status = GPM_B_NOT_SET; 
! 	  Left_Double_Click = 0;
! 	}
! 	break;
!       case Turn_On_Off_Action:
  	touchpad_enabled = !touchpad_enabled;
! 	status = GPM_B_NOT_SET;
! 	break;
!       case Debug_On_Off_Action:
! #       ifdef DEBUG_SYNAPTIC
! 	  debug_syn_to_stderr = !debug_syn_to_stderr;
! #       endif
! 	status = GPM_B_NOT_SET;
! 	break;
!       case Reset_Touchpad_Action:
! 	syn_ps2_reset(which_mouse->fd);
! 	syn_ps2_absolute_mode(which_mouse->fd);
! 	status = GPM_B_NOT_SET;
  	break;
+       case Toggle_Four_Way_Button_Action:
+ 	four_way_button_is_mouse = !four_way_button_is_mouse;
+ 	status = GPM_B_NOT_SET;
+ 	break;
        case Toggle_Stick_Pressure_Action:
  	stick_pressure_enabled = !stick_pressure_enabled;
! 	status = GPM_B_NOT_SET;
! 	break;
        case Toggle_Scrolling_Action:
  	is_always_scrolling = !is_always_scrolling;
! 	status = GPM_B_NOT_SET;
! 	break;
!       case No_Action:
! 	status = GPM_B_NOT_SET;
! 	break;
!       default:
! 	gpm_report (GPM_PR_WARN,"Default Action: Action no. %X not defined",
! 		    action_list [i].action); 
! 	status = GPM_B_NOT_SET;
! 	break;
        }
  
!       return status;
      }
!     
!     i++;
!   }
!   
    return status;
  }
  
  
  /*
! ** tp_process_corner_taps. 
! **
! ** last_*_action is an easy way of remember which taps/buttons should call/repeat
! ** the action when the tap/button is held pressed. It could just as well  have
! ** been one variable where each bit held the repeater info for all the
! ** tap/buttons, but that will mean more code.
! **
! ** The reason for not actually reusing last_*_action, instead of
! ** calculating it again, is that some actions like scrolling have "side effects".
! ** This may be perceived as a design fault.
! **
! ** tp_process_corner_taps and tp_process_button_press are more complicated than
! ** to what is obvious. This is because 1) in a corner tap-and-hold the hold
! ** could take place at non edge. 2) A normal tap-and-hold can be moved to a
! ** corner.
! */
! static void tp_process_corner_taps (Gpm_Event *state, report_type *report) 
! {
!   static int edges_at_cornertap_time;
! 
!   if (report->gesture && 
!       ((is_corner (was_edges) && !last_report.gesture) || 
!        (last_corner_action != GPM_B_NOT_SET))) {
! 
!     if(!last_report.gesture && last_corner_action == GPM_B_NOT_SET)
!       edges_at_cornertap_time = was_edges;
! 
!     last_corner_action = tp_process_action(corner_actions,edges_at_cornertap_time);
! 
!     if (last_corner_action != GPM_B_NOT_SET)
!       state->buttons |= last_corner_action;
!   } 
! }
! 
! /* tp_process_button_press
! **
! ** Handles finger taps. Same way as tp_process_corner_taps.
  **
! ** Should only calculate a tap if 
! ** 1) There is a gesture (tap)
! ** 2) The tap did not start at a corner with a corneraction
! ** 3) If it is calculated before it should have returned a repeating action.
  */
! static void tp_process_finger_taps (Gpm_Event *state, report_type *report) 
  {
! 
! 
!   if (report->gesture && last_corner_action == GPM_B_NOT_SET &&
!       !(corner_taps_enabled && is_corner (was_edges) && !last_report.gesture) &&
!       !(last_report.gesture && last_finger_action == GPM_B_NOT_SET) ){
  
!     if( ( multi_finger_tap_enabled && (was_fingers == 0 || was_fingers == 1)) ||
!  	(!multi_finger_tap_enabled && was_fingers > 0))
!       last_finger_action = tp_process_action(multi_finger_actions, ONE_FINGER);
!     
!     if (multi_finger_tap_enabled && was_fingers == 2)
!       last_finger_action = tp_process_action(multi_finger_actions, TWO_FINGERS);
!     
!     if (multi_finger_tap_enabled && was_fingers == 3)
!       last_finger_action = tp_process_action(multi_finger_actions, THREE_FINGERS);
!     
!     if (last_finger_action != GPM_B_NOT_SET) 
!       state->buttons |= last_finger_action;
!   }
! }
! 
! /*
! ** tp_process_do_repeating_action
! **
! ** The function test whether a feature's action should be repeated/called.  The
! ** action should be called if the feature is there and if it was there last
! ** time, then it should be a repeating action.
! */
  
! static inline void 
! tp_process_repeating_action(Gpm_Event *state, int feature, int last_feature, int *last_action, 
! 			    touchpad_action_type *action_list,int feature_mask)
! {
!   if (feature) {
!     if (!(last_feature && *last_action == GPM_B_NOT_SET)) {
!       *last_action = tp_process_action(action_list, feature_mask);
!       if (*last_action != GPM_B_NOT_SET)
! 	state->buttons |= *last_action;
!     }
    } else {
!       *last_action = GPM_B_NOT_SET;
!   }
! }
! 
! /*
! ** tp_process_do_repeating_actions
! **
! ** Call tp_process_do_repeating_action foreach possible action (right now only buttons.)
! */
! 
! static inline void 
! tp_process_repeating_actions(Gpm_Event *state, int features, int last_features, int last_actions[], 
! 			     touchpad_action_type *action_list)
! {
!   int feature_no, feature_mask;
! 
!   for(feature_no = 0; feature_no < 8; feature_no++) {
!     feature_mask = (1<<feature_no);
!     tp_process_repeating_action(state, features & feature_mask, last_features & feature_mask,
! 				&last_actions[feature_no], action_list, feature_mask);
!   }
! }
! 
! /* tp_process_button_press
! **
! ** Handles normal button presse explicitly because of the report
! ** layout (instead of using tp_process_do_repeating_actions).
! */
! static void tp_process_button_press (Gpm_Event *state, report_type *report) 
! {
! 
!   tp_process_repeating_action(state, report->left, last_report.left,
! 			      &last_normal_button_actions[0], normal_button_actions, LEFT_BUTTON);
! 
!   tp_process_repeating_action(state, report->right, last_report.right,
! 			      &last_normal_button_actions[1], normal_button_actions, RIGHT_BUTTON);
! 
!   tp_process_repeating_action(state, report->middle, last_report.middle,
! 			      &last_normal_button_actions[2], normal_button_actions, MIDDLE_BUTTON);
! 
!   tp_process_repeating_action(state, report->fourth, last_report.fourth,
! 			      &last_normal_button_actions[3], normal_button_actions, FOURTH_BUTTON);
! 
!   tp_process_repeating_action(state, report->up, last_report.up,
! 			      &last_normal_button_actions[4], normal_button_actions, UP_BUTTON);
! 
!   tp_process_repeating_action(state, report->down, last_report.down,
! 			      &last_normal_button_actions[5], normal_button_actions, DOWN_BUTTON);
! }
! 
! 
! /*
! ** syn_process_wmode_report
! **
! ** Translate synaptics specific values.
! */
! 
! 
! static void syn_process_wmode_report( report_type *report )
! {
!   /* STIG page 9: Values of w, vary from pad to pad. It is not precise when pressure is small < 25.
!    * 4-7  finger of normal width
!    * 8-14 very wide finger or palm
!    * 15   maximum reportable width     
!    */
!   report->fingerwidth = max(0,report->w - 4);
! 
!   /* Check whether there is one finger on the pad */
!   report->fingers  = (report->pressure > finger_threshold);
!   
!   /* use w values. w = 0: 2 fingers, w = 1: 3 fingers, (if there is pressure) */
!   if (capabilities[0].cap_multi_finger){      
!     if (report->pressure != 0 && (report->w == 0 || report->w == 1)){
!       report->fingers = 2+report->w;
!     }
    }
  }
  
***************
*** 1084,1102 ****
  */
  
  static int syn_ps2_process_extended_packets( unsigned char *data, 
! 				   report_type *report,
  					     Gpm_Event *state)
  {
  
    /* Sanity check of data. */
!   if (report->pressure == 0 && (report->x != 0 || report->y != 0) ){
  
       /* Something is wrong, should we assume it is an extended packet?  It
       *  cannot be processed further than here as the pressure is 0, which would
       *  break things, if the user uses it simultaneously with the touchpad. 
       */
!     /* Allow some simultaneously uses: tap hold on touchpad, then extended movement. */
!     state->buttons |= last_state.buttons;
  
      /* Stick invariant bits (I hope). See absolute packets */
      /* Stick pressed: The stick do only generates one packet, so double tap is
--- 1376,1403 ----
  */
  
  static int syn_ps2_process_extended_packets( unsigned char *data, 
! 					     report_type *report,
  					     Gpm_Event *state)
  {
+   static int last_stick_buttons = GPM_B_NONE;
+   static int last_4_way_buttons = GPM_B_NONE;
+   int tmp_buttons = GPM_B_NONE;
  
    /* Sanity check of data. */
!   if ((report->pressure == 0 && (report->x != 0 || report->y != 0)) ||
!       report->w == 3 ) {
  
       /* Something is wrong, should we assume it is an extended packet?  It
       *  cannot be processed further than here as the pressure is 0, which would
       *  break things, if the user uses it simultaneously with the touchpad. 
       */
!     /* Allow some simultaneously usage: tap-hold on touchpad, with extended movement.
!      * Do not do buttons, as they are not always correctly defined yet. */
!     if (last_report.gesture) {
!       report->gesture = 1;
!       if(tap_gesture_enabled) tp_process_finger_taps (state, report);
!       if(corner_taps_enabled) tp_process_corner_taps (state, report);
!     }
  
      /* Stick invariant bits (I hope). See absolute packets */
      /* Stick pressed: The stick do only generates one packet, so double tap is
***************
*** 1105,1129 ****
       * thereby returning a non-clicked state between the packets. Maybe
       * press-lock mechanism is useful. Forget it, the styk supports it! */
      if((data[0] & 0xFC) == 0x84 && 
!        (data[1] & 0xCE) == 0x08 &&
         (data[3] & 0xFC) == 0xC4){
  
!       if (stick_enabled){
! 	
! 	state->buttons |=
! 	  ((data[0]& 0x01) ? GPM_B_LEFT  : 0 )+
! 	  ((data[0]& 0x02) ? GPM_B_RIGHT : 0 )+
! 	  (((data[0] ^ data[3]) & 0x01) ? GPM_B_MIDDLE : 0) +
! 	  (((data[0] ^ data[3]) & 0x02) ? GPM_B_FOURTH : 0);
! 	
  	state->dx=  ((data[1] & 0x10) ? data[4]-256 : data[4]);
  	state->dy= -((data[1] & 0x20) ? data[5]-256 : data[5]);
        }
  
!       if (stick_pressure_enabled && 
! 	  data[1] & 0x01){
! 	state->buttons |= GPM_B_LEFT;
!       }
              
  #     ifdef DEBUG_STICK      
        gpm_report (GPM_PR_DEBUG,"StickData? %02x %02x %02x %02x %02x %02x :dx:%d dy:%d b:%d",
--- 1406,1430 ----
       * thereby returning a non-clicked state between the packets. Maybe
       * press-lock mechanism is useful. Forget it, the styk supports it! */
      if((data[0] & 0xFC) == 0x84 && 
!        (data[1] & 0xC8) == 0x08 &&
         (data[3] & 0xFC) == 0xC4){
  
!       tp_process_button_press (state,report);
! 
!       if (stick_enabled) {
  	state->dx=  ((data[1] & 0x10) ? data[4]-256 : data[4]);
  	state->dy= -((data[1] & 0x20) ? data[5]-256 : data[5]);
        }
  
!       if (stick_pressure_enabled) {
!   	tmp_buttons  = ((data[1] & 0x01) ? STICK_LEFT_BUTTON   : 0);
!   	tmp_buttons |= ((data[1] & 0x04) ? STICK_MIDDLE_BUTTON : 0);
!   	tmp_buttons |= ((data[1] & 0x02) ? STICK_RIGHT_BUTTON  : 0);
! 	tp_process_repeating_actions(state,tmp_buttons,last_stick_buttons,
! 				     &last_stick_button_actions[0],stick_actions);
!       } 
! 
!       last_stick_buttons = tmp_buttons;
              
  #     ifdef DEBUG_STICK      
        gpm_report (GPM_PR_DEBUG,"StickData? %02x %02x %02x %02x %02x %02x :dx:%d dy:%d b:%d",
***************
*** 1141,1153 ****
  
        if(four_way_button_enabled){
  
! 	state->buttons|=
! 	  ((data[0]& 0x01) ? GPM_B_LEFT  : 0 )+
! 	  ((data[0]& 0x02) ? GPM_B_RIGHT : 0 )+
! 	  (((data[0] ^ data[3]) & 0x01) ? GPM_B_MIDDLE : 0) +
! 	  (((data[0] ^ data[3]) & 0x02) ? 0 : GPM_B_FOURTH); /* Note that this is reversed. */
  
- 
  	if (four_way_button_is_mouse){
  	  /* Report motion */
  	  if (report->x & 1) /* UP */
--- 1442,1450 ----
  
        if(four_way_button_enabled){
  
! 	report->fourth = !report->fourth;   /* Note that this is reversed. */
! 	tp_process_button_press (state,report);
  
  	if (four_way_button_is_mouse){
  	  /* Report motion */
  	  if (report->x & 1) /* UP */
***************
*** 1160,1176 ****
  	    state->dx = 1;
  	}else{ 
  	  /* Report buttons */
! 	  if (report->x & 1) /* UP */
! 	    state->buttons |= tp_process_action(four_button_action,UP_BUTTON);
! 	  if (report->y & 1) /* DOWN */
! 	    state->buttons |= tp_process_action(four_button_action,DOWN_BUTTON);
! 	  if (report->x & 2) /* LEFT */
! 	    state->buttons |= tp_process_action(four_button_action,LEFT_BUTTON);
! 	  if (report->y & 2) /* RIGHT */
! 	    state->buttons |= tp_process_action(four_button_action,RIGHT_BUTTON);
  	}
        }
  
        if ( scrolling_amount_left != 0 ){
  	tp_handle_scrolling(state);
        }
--- 1457,1473 ----
  	    state->dx = 1;
  	}else{ 
  	  /* Report buttons */
! 	  tmp_buttons  = ((report->x & 1) ? FOUR_UP_BUTTON   : 0); /* UP */
! 	  tmp_buttons |= ((report->y & 1) ? FOUR_DOWN_BUTTON : 0); /* DOWN */
! 	  tmp_buttons |= ((report->x & 2) ? FOUR_LEFT_BUTTON : 0); /* LEFT */
! 	  tmp_buttons |= ((report->y & 2) ? FOUR_RIGHT_BUTTON: 0); /* RIGHT */
! 	  tp_process_repeating_actions(state,tmp_buttons,last_4_way_buttons,
! 				       &last_4_way_button_actions[0],four_button_actions);	  
  	}
        }
  
+       last_4_way_buttons = tmp_buttons;
+ 
        if ( scrolling_amount_left != 0 ){
  	tp_handle_scrolling(state);
        }
***************
*** 1185,1190 ****
--- 1482,1490 ----
      return 1;
    }
  
+   /* Multiplexing with the stick (guest) device. */
+   state->buttons |= last_4_way_buttons | last_stick_buttons;
+ 
    return 0;
  }
  
***************
*** 1197,1219 ****
  **            
  */
  
! static int tp_preprocess_report ( report_type *report,
! 				  Gpm_Event *state)
  {
  
    static int fake_extra_finger;
    static int was_fake_pressure;
  
    /* Check whether there is a palm on the pad */
!   /* STIG page 9: Values of w, vary from pad to pad. It is not precise when pressure is small < 25.
!    * 4-7  finger of normal width
!    * 8-14 very wide finger or palm
!    * 15   maximum reportable width     
!    */
!   if (wmode_enabled && palm_detect_enabled &&  
!       report->pressure != 0 && ((report->w - 4) >= palm_detect_level)){
  #   ifdef DEBUG_PALM
!     gpm_report (GPM_PR_DEBUG,"\rSynps2: palm detected. w: %d",report->w); 
  #   endif
      /* BUG should not return 1, as this drops packets. Return a repeated report ? */
      /*       last_locs [mod4 (packet_num - 1)].x = report->x; */
--- 1497,1514 ----
  **            
  */
  
! static int tp_find_fingers ( report_type *report,
! 			     Gpm_Event *state)
  {
  
    static int fake_extra_finger;
    static int was_fake_pressure;
  
    /* Check whether there is a palm on the pad */
!   if (palm_detect_enabled &&  
!       report->fingers && (report->fingerwidth >= palm_detect_level)){
  #   ifdef DEBUG_PALM
!     gpm_report (GPM_PR_DEBUG,"\rTouchpad: palm detected. finger width: %d",report->fingerwidth); 
  #   endif
      /* BUG should not return 1, as this drops packets. Return a repeated report ? */
      /*       last_locs [mod4 (packet_num - 1)].x = report->x; */
***************
*** 1224,1251 ****
    }
  
  
      
!   /* Check whether there is one finger on the pad,
!   *  but only if pad does not report it, as it also report gestures then,
!   *  which it would signal independed on whether we detect fingers. */
!   if(wmode_enabled){
!     report->fingers  = (report->pressure > finger_threshold);
!   }
!   
!   if (multi_finger_tap_enabled || multi_finger_stop_enabled){
!     
!     if (wmode_enabled && capabilities.cap_multi_finger){
!       
!       /* use w values. w = 0: 2 fingers, w = 1: 3 fingers, (if there is pressure) */
!       if (report->pressure != 0 && (report->w == 0 || report->w == 1)){
! 	report->fingers = 2+report->w;
! 	fake_extra_finger = 0;
!       }
      }
! 
!     /* Extra check for vertical multi fingers which my pad is very bad to detect. 
!      * Only check for extra fingers if w has not changed.
!      * Faking fingers may go wrong so sanity check: */
      if(report->fingers == 0){
        fake_extra_finger = 0;
  #     ifdef DEBUG_REPORTS
--- 1519,1535 ----
    }
  
  
+   /* Extra check for vertical multi fingers which my pad is very bad to detect.
+   ** Only check for extra fingers if no of fingers has not changed.  Faking
+   ** fingers may go wrong so sanity check needed.  This is not an attempt to
+   ** know the number of fingers all the time, as this is not needed. 
+   */
+   if (fake_finger_layer_enabled){
      
!     if (report->fingers > 1){
!       fake_extra_finger = 0;
      }
!         
      if(report->fingers == 0){
        fake_extra_finger = 0;
  #     ifdef DEBUG_REPORTS
***************
*** 1253,1259 ****
          multi_finger_xy = 0;
  #     endif
      }else
!       if (report->fingers + fake_extra_finger == last_report.fingers){
  
  	multi_finger_pressure = sqr(report->pressure) - sqr(last_report.pressure);
  	multi_finger_xy = (sqr(last_locs [mod4 (packet_num - 1)].x - report->x) +
--- 1537,1543 ----
          multi_finger_xy = 0;
  #     endif
      }else
!       if (report->fingers + fake_extra_finger == last_report.fingers) {
  
  	multi_finger_pressure = sqr(report->pressure) - sqr(last_report.pressure);
  	multi_finger_xy = (sqr(last_locs [mod4 (packet_num - 1)].x - report->x) +
***************
*** 1331,1346 ****
    }
  
    /* If wmode is not used, we do not know all the informations to reset the
!    * was_fingers variable, so set a timer to reset the variable when we believe it is time.
!    * pads_tap_interval is optimal when set to the touchpads tap_interval.
     */
  
!   if(!wmode_enabled){
      if (report->fingers || report->gesture)
!       multi_finger_reset_timer = pads_tap_interval;
  
!     if(multi_finger_reset_timer > 0)
!       multi_finger_reset_timer --;
      else
        was_fingers = 0;
    }
--- 1615,1631 ----
    }
  
    /* If wmode is not used, we do not know all the informations to reset the
!    * was_fingers variable or stop waiting for a tap-hold, so set a timer to
!    * reset the variables when we believe it is time.  pads_tap_interval is
!    * optimal when set to the touchpads tap_interval.
     */
  
!   if(fake_forget_tap_interval){
      if (report->fingers || report->gesture)
!       fake_time_to_forget_tap = pads_tap_interval;
  
!     if(fake_time_to_forget_tap > 0)
!       fake_time_to_forget_tap --;
      else
        was_fingers = 0;
    }
***************
*** 1353,1359 ****
  
  
  /** 
! ** tp_process_wmode_report
  ** Process the report from a wmode enabled device.  No gesture calculation is
  ** done by the device in wmode, so the find tap and drag hold and tap hold gestures.
  **
--- 1638,1644 ----
  
  
  /** 
! ** tp_find_gestures
  ** Process the report from a wmode enabled device.  No gesture calculation is
  ** done by the device in wmode, so the find tap and drag hold and tap hold gestures.
  **
***************
*** 1424,1434 ****
  */
  
  
! static void tp_process_wmode_report (report_type *report) 
  {
    static int finger_on_pad_timer = 0;
    static int time_to_forget_tap = 0;
-   static int gesture_delay = 0;
    static int stroke_x;
    static int stroke_y;
    static int drag_locked = 0;
--- 1709,1718 ----
  */
  
  
! static void tp_find_gestures (report_type *report) 
  {
    static int finger_on_pad_timer = 0;
    static int time_to_forget_tap = 0;
    static int stroke_x;
    static int stroke_y;
    static int drag_locked = 0;
***************
*** 1458,1465 ****
       */
      if ((finger_on_pad_timer > (tap_lower_limit_packet)) &&  /* minimum finger down time */
  	(finger_on_pad_timer < (tap_upper_limit_packet)) &&  /* maximum finger down time */
! 	((distance((double)(stroke_x - report->x),  /* maximum range for finger to drift while down */
! 		  (double)(stroke_y - report->y))
  	 < sqr((double)tap_range)) ||
  	 (multi_finger_tap_enabled && was_fingers > 1))) {
        
--- 1742,1749 ----
       */
      if ((finger_on_pad_timer > (tap_lower_limit_packet)) &&  /* minimum finger down time */
  	(finger_on_pad_timer < (tap_upper_limit_packet)) &&  /* maximum finger down time */
! 	((distance((double)(stroke_x - last_report.x),  /* maximum range for finger to drift while down */
! 		   (double)(stroke_y - last_report.y))
  	 < sqr((double)tap_range)) ||
  	 (multi_finger_tap_enabled && was_fingers > 1))) {
        
***************
*** 1491,1496 ****
--- 1775,1787 ----
        
      }
      
+ #   ifdef DEBUG_TAPS
+     if (finger_on_pad_timer)
+       gpm_report (GPM_PR_DEBUG,"A tap? %d < %d < %d && (%d)^2 + (%d)^2 < %d",
+ 		  tap_lower_limit_packet,finger_on_pad_timer,tap_upper_limit_packet,
+ 		  stroke_x-last_report.x,stroke_y-last_report.y,tap_range*tap_range);
+ #   endif
+ 
      finger_on_pad_timer = 0;
      
    }
***************
*** 1524,1530 ****
  **
  */
  static void tp_process_report (Gpm_Event *state,
! 				report_type report) 
  {
    location_type loc;
    int           edges;
--- 1815,1821 ----
  **
  */
  static void tp_process_report (Gpm_Event *state,
! 			       report_type *report) 
  {
    location_type loc;
    int           edges;
***************
*** 1534,1545 ****
    float         dx, dy;
  
    /* extract location and edges */
!   loc.x = report.x;
!   loc.y = report.y;
    edges = tp_edges (loc);
  
  
!   if (report.fingers > 0) {
  
      if (tossing_enabled) {
        /* this is the cue to stop tossing, if we are tossing so
--- 1825,1836 ----
    float         dx, dy;
  
    /* extract location and edges */
!   loc.x = report->x;
!   loc.y = report->y;
    edges = tp_edges (loc);
  
  
!   if (report->fingers > 0) {
  
      if (tossing_enabled) {
        /* this is the cue to stop tossing, if we are tossing so
***************
*** 1591,1598 ****
        /* compute the speed factor based on pressure */
        pressure_speed_factor = standard_speed_factor;
  
!       if (report.pressure > speed_up_pressure) {
! 	pressure_speed_factor *= 1.0 + ((report.pressure - speed_up_pressure) *
  			       speed_pressure_factor);
        }
  
--- 1882,1889 ----
        /* compute the speed factor based on pressure */
        pressure_speed_factor = standard_speed_factor;
  
!       if (report->pressure > speed_up_pressure) {
! 	pressure_speed_factor *= 1.0 + ((report->pressure - speed_up_pressure) *
  			       speed_pressure_factor);
        }
  
***************
*** 1690,1699 ****
      }
  
  
!   /* if we are scrolling then stop moving and report wheel amount. */
    if ((scrolling_enabled && is_scrolling) ||
        is_always_scrolling){
!     scrolling_amount_left += state->dy;
      state->dx = 0;
      state->dy = 0;
    }
--- 1981,1993 ----
      }
  
  
!   /* if we are scrolling then stop moving and report wheel amount.  The reason
!   ** for having this above buttons actions is buttons can then move the
!   ** mouse while scrolling. 
!   */
    if ((scrolling_enabled && is_scrolling) ||
        is_always_scrolling){
!     scrolling_amount_left -= state->dy;
      state->dx = 0;
      state->dy = 0;
    }
***************
*** 1702,1745 ****
    /* check for (corner)buttons if we didn't just complete a toss or is scrolling */
    if (!is_tossing && !was_tossing && !is_scrolling) {
      /*
!     ** If there is no gesture then there are no buttons.
!     ** If there is a continuing gesture then report the same buttons.
!     ** Otherwise compute new buttons.
      */
!     if (!report.gesture && 
! 	!report.left && !report.right && !report.middle && !report.fourth &&
! 	!report.up && !report.down ) {
        state->buttons = GPM_B_NONE;
-     } else if (last_report.gesture) {
-       state->buttons = last_state.buttons;
      } else {
!       if (report.left)   state->buttons |= GPM_B_LEFT;
!       
!       if (report.right)  state->buttons |= GPM_B_RIGHT;
! 
!       if (report.middle) state->buttons |= GPM_B_MIDDLE;
! 
!       if (report.fourth) state->buttons |= GPM_B_FOURTH;
! 
!       if (report.up)  	 state->buttons |= GPM_B_UP;
! 
!       if (report.down)	 state->buttons |= GPM_B_DOWN;
! 
!       if ((tap_gesture_enabled && report.gesture && !is_corner (was_edges))){
! 
! 	if( ( multi_finger_tap_enabled && (was_fingers == 0 || was_fingers == 1)) ||
! 	    (!multi_finger_tap_enabled && was_fingers > 0))
! 	  state->buttons |= GPM_B_LEFT;
! 
! 	if(multi_finger_tap_enabled && was_fingers == 2)
! 	  state->buttons |= GPM_B_RIGHT;
! 
! 	if(multi_finger_tap_enabled && was_fingers == 3)
! 	  state->buttons |= GPM_B_MIDDLE;
! 
!       }
! 
!       tp_process_corner_taps (state, report);
      }
    }
  
--- 1996,2015 ----
    /* check for (corner)buttons if we didn't just complete a toss or is scrolling */
    if (!is_tossing && !was_tossing && !is_scrolling) {
      /*
!     ** If there is no gesture then there are no buttons, but dont clear if we
!     ** are about to make a double tap.  Otherwise compute new buttons.
      */
!     if (!report->gesture && 
! 	!report->left && !report->right && !report->middle && !report->fourth ) {
!       if (!gesture_delay && !fake_time_to_forget_tap) {
! 	last_corner_action = GPM_B_NOT_SET;
! 	last_finger_action = GPM_B_NOT_SET;
!       }
        state->buttons = GPM_B_NONE;
      } else {
!       tp_process_button_press (state, report);
!       if(tap_gesture_enabled) tp_process_finger_taps (state, report);
!       if(corner_taps_enabled) tp_process_corner_taps (state, report);
      }
    }
  
***************
*** 1755,1761 ****
  
  
    /* remember the last state of the finger for toss processing */
!   last_report   = report;
    last_state    = *state;
  
    /* Dont do anything if the pad is not enabled, but after corner actions are
--- 2025,2031 ----
  
  
    /* remember the last state of the finger for toss processing */
!   last_report   = *report;
    last_state    = *state;
  
    /* Dont do anything if the pad is not enabled, but after corner actions are
***************
*** 1767,1773 ****
    }
  
  #if DEBUG_REPORTS
!   tp_dump_report_data (report, edges, state);
  #endif
  
  }
--- 2037,2043 ----
    }
  
  #if DEBUG_REPORTS
!   tp_dump_report_data (*report, edges, state);
  #endif
  
  }
***************
*** 1784,1793 ****
    char line [80];
    char *token;
    char *end_ptr;
!   int param;
    FILE *config;
    char full_filename[100];
    int  status;
  
    status = snprintf(full_filename,100,SYSCONFDIR "/%s",config_filename);
    if (status < 0) {
--- 2054,2064 ----
    char line [80];
    char *token;
    char *end_ptr;
!   int  param, tmp_read_int_param;
    FILE *config;
    char full_filename[100];
    int  status;
+   float tmp_read_float_param;
  
    status = snprintf(full_filename,100,SYSCONFDIR "/%s",config_filename);
    if (status < 0) {
***************
*** 1801,1807 ****
    }else{
      while (fgets (line, 80, config)) {
        if (line [0] == '[') {
! 	if ( (token = strtok (line, "[] ")) ) {
  	  param = 0;
  
  	  /* which param is it */
--- 2072,2078 ----
    }else{
      while (fgets (line, 80, config)) {
        if (line [0] == '[') {
! 	if ( (token = strtok (line, "[] \t")) ) {
  	  param = 0;
  
  	  /* which param is it */
***************
*** 1814,1826 ****
  	  if (!param_data [param].name) {
  	    gpm_report (GPM_PR_WARN,"Unknown parameter %s", token);
  	  } else {
! 	    token = strtok (NULL, "[] ");
  
  	    switch (param_data [param].p_type) {
  	    case Integer_Param:
! 	      *(param_data [param].addr.int_p) = strtol (token, &end_ptr, 0);
! 	      if (end_ptr == token)
! 		gpm_report (GPM_PR_WARN,"Value (%s) for parameter %s is invalid",
  			    token, param_data [param].name);
  #             if DEBUG_PARAMS
  	      gpm_report (GPM_PR_INFO,"Param %s set to %d",
--- 2085,2099 ----
  	  if (!param_data [param].name) {
  	    gpm_report (GPM_PR_WARN,"Unknown parameter %s", token);
  	  } else {
! 	    token = strtok (NULL, "[] \t");
  
  	    switch (param_data [param].p_type) {
  	    case Integer_Param:
! 	      tmp_read_int_param = strtol (token, &end_ptr, 0);
! 	      if (end_ptr != token)
! 		*(param_data [param].addr.int_p) = tmp_read_int_param;
! 	      else
! 		gpm_report (GPM_PR_WARN,"Integer value (%s) for parameter %s is invalid",
  			    token, param_data [param].name);
  #             if DEBUG_PARAMS
  	      gpm_report (GPM_PR_INFO,"Param %s set to %d",
***************
*** 1830,1838 ****
  	      break;
  
  	    case Float_Param:
! 	      *(param_data [param].addr.float_p) = strtod (token, &end_ptr);
! 	      if (end_ptr == token)
! 		gpm_report (GPM_PR_WARN,"Value (%s) for parameter %s is invalid",
  			    token, param_data [param].name);
  #             if DEBUG_PARAMS
  	      gpm_report (GPM_PR_INFO,"Param %s set to %3.3f",
--- 2103,2113 ----
  	      break;
  
  	    case Float_Param:
! 	      tmp_read_float_param = strtod (token, &end_ptr);
! 	      if (end_ptr != token)
! 		*(param_data [param].addr.float_p) = tmp_read_float_param;
! 	      else
! 		gpm_report (GPM_PR_WARN,"Float value (%s) for parameter %s is invalid",
  			    token, param_data [param].name);
  #             if DEBUG_PARAMS
  	      gpm_report (GPM_PR_INFO,"Param %s set to %3.3f",
***************
*** 1847,1853 ****
  	      } else if (index ("NnFf0", token [0])) {
  		*(param_data [param].addr.flag_p) = 0;
  	      } else {
! 		gpm_report (GPM_PR_WARN,"Value (%s) for parameter %s is invalid",
  			    token, param_data [param].name);
  	      }
  #             if DEBUG_PARAMS
--- 2122,2128 ----
  	      } else if (index ("NnFf0", token [0])) {
  		*(param_data [param].addr.flag_p) = 0;
  	      } else {
! 		gpm_report (GPM_PR_WARN,"Flag value (%s) for parameter %s is invalid",
  			    token, param_data [param].name);
  	      }
  #             if DEBUG_PARAMS
***************
*** 1859,1868 ****
  	      break;
  
  	    case Action_Param:
! 	      param_data [param].addr.corner_p->action = strtol (token,
! 								 &end_ptr, 0);
! 	      if (end_ptr == token)
! 		gpm_report (GPM_PR_WARN,"Value (%s) for parameter %s is invalid",
  			    token, param_data [param].name);
  #             if DEBUG_PARAMS
  	      gpm_report (GPM_PR_INFO,"Param %s set to %d",
--- 2134,2144 ----
  	      break;
  
  	    case Action_Param:
! 	      tmp_read_int_param = strtol (token, &end_ptr, 0);
! 	      if (end_ptr != token)
! 		param_data [param].addr.corner_p->action = tmp_read_int_param;
! 	      else
! 		gpm_report (GPM_PR_WARN,"Action value (%s) for parameter %s is invalid",
  			    token, param_data [param].name);
  #             if DEBUG_PARAMS
  	      gpm_report (GPM_PR_INFO,"Param %s set to %d",
***************
*** 1891,1907 ****
  static void syn_process_config (info_type ident,
  				model_id_type model) 
  {
!   sensor = syn_get_sensor_info (model.info_sensor);
    gpm_report (GPM_PR_INFO, "     Firmware version %d.%d\n",
  	      ident.info_major, ident.info_minor);
  
    tp_read_config_file ("gpm-syn.conf");
  
    /* Save important information */
!   x_per_mm = sensor->x_per_mm;
!   y_per_mm = sensor->y_per_mm;
!   res_x = (int) (x_per_mm * sensor->width_mm);
!   res_y = (int) (y_per_mm * sensor->height_mm);
  
    /* convert the tap times to packets (80 pkts/sec and 1000 ms/sec) */
    tap_lower_limit_packet = tap_lower_limit * 80 / 1000;
--- 2167,2204 ----
  static void syn_process_config (info_type ident,
  				model_id_type model) 
  {
!   sensor[0] = syn_get_sensor_info (model.info_sensor);
    gpm_report (GPM_PR_INFO, "     Firmware version %d.%d\n",
  	      ident.info_major, ident.info_minor);
  
    tp_read_config_file ("gpm-syn.conf");
  
+   
+   /* Limit the options depending on the touchpad capabilities. This should be
+      done after reading the configure file so they may be turned off on purpose
+      and can'nt be turned on if not supported. */
+   if(!capabilities[0].cap_ext){
+     wmode_enabled         = 0;
+   }
+ 
+   if(!wmode_enabled || !capabilities[0].cap_palm_detect){
+     palm_detect_enabled   = 0;
+   }
+ 
+   if(!wmode_enabled || !capabilities[0].cap_stick){
+     stick_enabled          = 0;
+     stick_pressure_enabled = 0;
+   }
+   
+   /* fake_forget_tap_interval must be set if the hardware does the gesture. */
+   if(!wmode_enabled)
+     fake_forget_tap_interval = 1;
+ 
    /* Save important information */
!   x_per_mm = sensor[0]->x_per_mm;
!   y_per_mm = sensor[0]->y_per_mm;
!   res_x = (int) (x_per_mm * sensor[0]->width_mm);
!   res_y = (int) (y_per_mm * sensor[0]->height_mm);
  
    /* convert the tap times to packets (80 pkts/sec and 1000 ms/sec) */
    tap_lower_limit_packet = tap_lower_limit * 80 / 1000;
***************
*** 1915,1949 ****
    min_toss_packets     = min_toss_time * 80 / 1000;
    prevent_toss_packets = prevent_toss_time * 80 / 1000;
  
- #if DEBUG
-   gpm_report (GPM_PR_INFO,"Synaptics Ident:  model_code=%d   Firmware version %d.%d",
- 	      ident.info_model_code, ident.info_major, ident.info_minor);
-   gpm_report (GPM_PR_INFO,"Synaptics model:");
-   gpm_report (GPM_PR_INFO,"   rot180:      %s", model.info_rot180 ? "Yes" : "No");
-   gpm_report (GPM_PR_INFO,"   portrait:    %s", model.info_portrait ? "Yes" : "No");
-   gpm_report (GPM_PR_INFO,"   sensor:      %d", model.info_sensor);
-   gpm_report (GPM_PR_INFO,"                %s", syn_model_name (model.info_sensor));
-   gpm_report (GPM_PR_INFO,"                %s", sensor->model);
-   gpm_report (GPM_PR_INFO,"                %dx%d res/mm",
- 	      sensor->x_per_mm, sensor->y_per_mm);
-   gpm_report (GPM_PR_INFO,"                %4.1fx%4.1f mm",
- 	      sensor->width_mm, sensor->height_mm);
-   gpm_report (GPM_PR_INFO,"                %dx%d res", res_x, res_y);
-   gpm_report (GPM_PR_INFO,"   hardware:    %d", model.info_hardware);
-   gpm_report (GPM_PR_INFO,"   newABS:      %s", model.info_new_abs ? "Yes" : "No");
-   gpm_report (GPM_PR_INFO,"   simpleCmd:   %s", model.info_simple_cmd ? "Yes" : "No");
-   gpm_report (GPM_PR_INFO,"   geometry:    %d", model.info_geometry);
-   gpm_report (GPM_PR_INFO,"   extended:    %s", capabilities.cap_ext ? "Yes" : "No");
-   gpm_report (GPM_PR_INFO,"   stick:       %s", capabilities.cap_stick ? "Yes" : "No");
-   gpm_report (GPM_PR_INFO,"   sleep:       %s", capabilities.cap_sleep ? "Yes" : "No");
-   gpm_report (GPM_PR_INFO,"   4 buttons:   %s", capabilities.cap_four_button ? "Yes" : "No");
-   gpm_report (GPM_PR_INFO,"   multifinger: %s", capabilities.cap_multi_finger ? "Yes" : "No");
-   gpm_report (GPM_PR_INFO,"   palmdetect:  %s", capabilities.cap_palm_detect ? "Yes" : "No");
- 
- #endif
- #if DEBUG_TOSS
-   gpm_report (GPM_PR_INFO,"\nMin Toss Dist^2: %d\n", min_toss_dist__2);
- #endif
  }
  
  
--- 2212,2217 ----
***************
*** 1957,1963 ****
  
  
  static unsigned char tp_hextoint (unsigned char byte1,
! 			       unsigned char byte2) 
  {
    unsigned char bytes [3];
    int result;
--- 2225,2231 ----
  
  
  static unsigned char tp_hextoint (unsigned char byte1,
! 				  unsigned char byte2) 
  {
    unsigned char bytes [3];
    int result;
***************
*** 1998,2005 ****
  }
  
  static void tp_serial_read (int fd,
! 		      unsigned char *bytes,
! 		      int count) 
  {
    struct timeval tv;
    fd_set rfds;
--- 2266,2273 ----
  }
  
  static void tp_serial_read (int fd,
! 			    unsigned char *bytes,
! 			    size_t count) 
  {
    struct timeval tv;
    fd_set rfds;
***************
*** 2027,2033 ****
  
  /* Write a string of commands */
  static void tp_serial_send_cmd(int fd,
! 			 unsigned char *cmd) 
  {
    unsigned char junk [15];
  
--- 2295,2301 ----
  
  /* Write a string of commands */
  static void tp_serial_send_cmd(int fd,
! 			       unsigned char *cmd) 
  {
    unsigned char junk [15];
  
***************
*** 2098,2105 ****
     *
     * pebl: It is easier just to check version number less than 3.2, STIG page 60.
     */
!   if ( (ident.info_major >= 4) ||
!        (ident.info_major == 3 && ident.info_minor >= 2)){
      tp_serial_send_cmd (fd, "%D");
      tp_serial_read (fd, bytes, 6);
  
--- 2366,2373 ----
     *
     * pebl: It is easier just to check version number less than 3.2, STIG page 60.
     */
!   if ( (ident[0].info_major >= 4) ||
!        (ident[0].info_major == 3 && ident[0].info_minor >= 2)){
      tp_serial_send_cmd (fd, "%D");
      tp_serial_read (fd, bytes, 6);
  
***************
*** 2136,2142 ****
    gpm_report (GPM_PR_DEBUG,"Serial capabilites: %s", bytes);
  #endif
  
!   if (ident.info_major >= 4){
      if (bytes [0] == '3' && bytes [0] == 'B'){
        cap_int = ((tp_hextoint (bytes [4], bytes [5]) << 8) |
  		 (tp_hextoint (bytes [6], bytes [7])));
--- 2404,2410 ----
    gpm_report (GPM_PR_DEBUG,"Serial capabilites: %s", bytes);
  #endif
  
!   if (ident[0].info_major >= 4){
      if (bytes [0] == '3' && bytes [0] == 'B'){
        cap_int = ((tp_hextoint (bytes [4], bytes [5]) << 8) |
  		 (tp_hextoint (bytes [6], bytes [7])));
***************
*** 2199,2204 ****
--- 2467,2473 ----
  #define PS2_SYN_SET_MODE1 0x0A      /* Set the mode byte 1 instead of sample rate (used after a sample rate cmd) */
  #define PS2_SYN_SET_MODE2 0x14      /* Set the mode byte 2 instead of sample rate (used after a sample rate cmd).
  				     * All other sample rate gives undefined behavior (used to address 4 byte mode)*/
+ #define PS2_SYN_SET_STICK 0x28      /* Send byte to stick */
  #define PS2_SYN_STATUS_OK 0x47      /* Special synaptics Status report is recognized */
  
  
***************
*** 2214,2262 ****
  
  
  
- typedef unsigned char byte;
- 
  /* read a byte from the ps/2 port */
  static byte tp_ps2_getbyte(int fd) 
  {
    byte b;
  
    read(fd, &b, 1);
    return b;
  }
  
  
! /* write a byte to the ps/2 port, handling ACK and resend.*/
! static void tp_ps2_putbyte(int fd,
! 			byte b) 
  {
    byte ack;
  
!   do{
      write(fd, &b, 1);
      read(fd, &ack, 1);
!   } while(ack == PS2_RESEND);
!   
    if (ack != PS2_ACK)
!     gpm_report (GPM_PR_ERR,"Invalid ACK to synps2 send byte %02X, got %02X",b,ack);
  }
  
  /* use the Synaptics extended ps/2 syntax to write a special command byte 
  * STIG page 36: Send exactly four PS2_SYN_CMD (which is otherwise ignored)
  * and after each a byte with the 2 first bits being the command (LSB). End it with
  * either  PS2_SAMPLE_RATE or PS2_STATUS_REQ. It is hinted to send an inert command
  * first so not having five or more PS2_SYN_CMD by coincident.
  */
  static void syn_ps2_send_cmd(int fd,
! 			 byte cmd) 
  {
    int i;
  
    /* initialize with 'inert' command */
    tp_ps2_putbyte(fd, PS2_SYN_INERT);
    for (i=0; i<4; i++) {
!     tp_ps2_putbyte(fd, PS2_SYN_CMD);
!     tp_ps2_putbyte(fd, (cmd>>6)&0x3);
      cmd<<=2;
    }
  }
--- 2483,2621 ----
  
  
  
  /* read a byte from the ps/2 port */
  static byte tp_ps2_getbyte(int fd) 
  {
    byte b;
  
+ # ifdef DEBUG_GETBYTE
+   gpm_report(GPM_PR_DEBUG,"Getting byte");
+ # endif
+ 
    read(fd, &b, 1);
+ 
+ # ifdef DEBUG_GETBYTE
+   gpm_report(GPM_PR_DEBUG,"Got %X",b);
+ # endif
+ 
    return b;
  }
  
  
! /* write a byte to the ps/2 port, handling resend.*/
! static byte tp_ps2_putbyte(int fd,
! 			   byte b) 
  {
    byte ack;
  
! # ifdef DEBUG_PUTBYTE
!   gpm_report(GPM_PR_DEBUG,"Send real byte %X",b);
! # endif
! 
!   write(fd, &b, 1);
!   read(fd, &ack, 1);
! 
!   if (ack == PS2_RESEND) {
      write(fd, &b, 1);
      read(fd, &ack, 1);
!   }
! 
! # ifdef DEBUG_PUTBYTE_ACK
!   gpm_report(GPM_PR_DEBUG,"Responce %X to byte %X",ack,b);
! # endif
! 
!   return ack;
! }
! 
! 
! /* Read a byte from the touchpad or use the Synaptics extended ps/2 syntax to
!  * read a byte from the stick device. The variable stick is used to indicate
!  * whether it is the touchpad or stick device that is meant.
!  */
! static byte syn_ps2_getbyte(int fd, int stick) 
! {
!   byte response[6];
! 
!   if (!stick) {
!     response[1]=tp_ps2_getbyte(fd);
!   } else {
!     response[0]=tp_ps2_getbyte(fd);
!     response[1]=tp_ps2_getbyte(fd);
!     response[2]=tp_ps2_getbyte(fd);
!     response[3]=tp_ps2_getbyte(fd);
!     response[4]=tp_ps2_getbyte(fd);
!     response[5]=tp_ps2_getbyte(fd);
!     
!     /* Do some sanity checking */
!     if((response[0] & 0xFC) != 0x84) {
!       gpm_report (GPM_PR_ERR,"Byte 0 of stick device responce is not valid");
!       return -1;
!     }
!     if((response[3] & 0xCC) != 0xC4) {
!       gpm_report (GPM_PR_ERR,"Byte 3 of stick device responce is not valid");
!       return -1;
!     }
!   }
! 
!   return response[1];
! }
! 
! 
! /* write byte to the touchpad or use the Synaptics extended ps/2 syntax to write
!  * a byte to the stick device. The variable stick is used to indicate
!  * whether it is the touchpad or stick device that is meant.  */
! static void syn_ps2_putbyte(int fd,
! 			    int stick,
! 			    byte b) 
! {
!   byte ack;
! 
! # ifdef DEBUG_PUTBYTE
!   gpm_report(GPM_PR_DEBUG,"Send byte %X to %s",b,(stick?"Stick":"Touchpad"));
! # endif
! 
!   if (!stick) {
!     ack = tp_ps2_putbyte(fd,b);
!   } else {
!     syn_ps2_send_cmd(fd, DEVICE_TOUCHPAD, b);
!     ack = tp_ps2_putbyte(fd, PS2_SAMPLE_RATE);
!     if (ack != PS2_ACK)
!       gpm_report (GPM_PR_ERR,"Invalid ACK to stick putbytet sample rate");
!     ack = tp_ps2_putbyte(fd, PS2_SYN_SET_STICK);
!     if (ack != PS2_ACK)
!       gpm_report (GPM_PR_ERR,"Invalid ACK to stick putbytet set stick");
!     ack = syn_ps2_getbyte(fd,DEVICE_STICK);
!   }
! 
    if (ack != PS2_ACK)
!     gpm_report (GPM_PR_ERR,"Invalid ACK to synps2 %s putbyte %02X, got %02X",
! 		(stick?"Stick":"Touchpad"),b,ack);
  }
  
+ 
  /* use the Synaptics extended ps/2 syntax to write a special command byte 
  * STIG page 36: Send exactly four PS2_SYN_CMD (which is otherwise ignored)
  * and after each a byte with the 2 first bits being the command (LSB). End it with
  * either  PS2_SAMPLE_RATE or PS2_STATUS_REQ. It is hinted to send an inert command
  * first so not having five or more PS2_SYN_CMD by coincident.
+ *
+ * If data is for the stick device every byte has to be encode by the above method.
  */
  static void syn_ps2_send_cmd(int fd,
! 			     int stick, 
! 			     byte cmd)
  {
    int i;
  
+ # ifdef DEBUG_CMD
+   gpm_report(GPM_PR_DEBUG,"Send Command %X to %s",cmd,(stick?"Stick":"Touchpad"));
+ # endif
+ 
    /* initialize with 'inert' command */
    tp_ps2_putbyte(fd, PS2_SYN_INERT);
    for (i=0; i<4; i++) {
!     syn_ps2_putbyte(fd, stick, PS2_SYN_CMD);
!     syn_ps2_putbyte(fd, stick, (cmd>>6)&0x3);
      cmd<<=2;
    }
  }
***************
*** 2271,2281 ****
   * used, and is probably leftover from mixing with Van der Plas code.
   */
  static void syn_ps2_set_mode1(int fd,
! 			  byte cmd) 
  {
!   syn_ps2_send_cmd(fd, cmd);
!   tp_ps2_putbyte(fd, PS2_SAMPLE_RATE);
!   tp_ps2_putbyte(fd, PS2_SYN_SET_MODE1);
  }
  
  #endif
--- 2630,2641 ----
   * used, and is probably leftover from mixing with Van der Plas code.
   */
  static void syn_ps2_set_mode1(int fd,
! 			      int stick, 
! 			      byte cmd)
  {
!   syn_ps2_send_cmd(fd, stick, cmd);
!   tp_ps2_putbyte(fd, stick, PS2_SAMPLE_RATE);
!   tp_ps2_putbyte(fd, stick, PS2_SYN_SET_MODE1);
  }
  
  #endif
***************
*** 2286,2326 ****
   * four PS2_SYN_CMD commands
   */
  static void syn_ps2_set_mode2(int fd,
! 			  byte cmd) 
  {
!   syn_ps2_send_cmd(fd, cmd);
!   tp_ps2_putbyte(fd, PS2_SAMPLE_RATE);
!   tp_ps2_putbyte(fd, PS2_SYN_SET_MODE2);
  }
  
  
- 
  /* read three byte status ('a','b','c') corresponding to register 'cmd' 
  *  Special status request for synaptics is given after a cmd.
  *  Byte b is PS2_SYN_STATUS_OK to recognize a synaptics
  */
  static void syn_ps2_status_rqst(int fd,
! 			    byte cmd,
! 			    byte *bytes) 
! {
!   syn_ps2_send_cmd(fd, cmd);
!   tp_ps2_putbyte(fd, PS2_STATUS_REQ);
!   bytes [0]=tp_ps2_getbyte(fd);
!   bytes [1]=tp_ps2_getbyte(fd);
!   bytes [2]=tp_ps2_getbyte(fd);
  }
  
  
  #if 0
  
  /* read the modes from the touchpad (in ps/2 format) */
! static void syn_ps2_read_modes (int fd) 
  {
    unsigned char bytes [3];
  
!   syn_ps2_status_rqst (fd, PS2_SYN_CMD_MODES, bytes);
  # ifdef DEBUG
!   gpm_report (GPM_PR_INFO,"Synaptic PS/2 touchpad modes: %02X", bytes [2]);
  # endif
  }
  
--- 2646,2691 ----
   * four PS2_SYN_CMD commands
   */
  static void syn_ps2_set_mode2(int fd,
! 			      int stick,
! 			      byte cmd)
  {
!   syn_ps2_send_cmd(fd, stick, cmd);
!   syn_ps2_putbyte (fd, stick, PS2_SAMPLE_RATE);
!   syn_ps2_putbyte (fd, stick, PS2_SYN_SET_MODE2);
  }
  
  
  /* read three byte status ('a','b','c') corresponding to register 'cmd' 
  *  Special status request for synaptics is given after a cmd.
  *  Byte b is PS2_SYN_STATUS_OK to recognize a synaptics
  */
  static void syn_ps2_status_rqst(int fd,
! 				int stick,
! 				byte cmd,
! 				byte *bytes)
! {
!   gpm_report (GPM_PR_INFO,"Status request for %s, %X", (stick?"stick":"touchpad"),cmd);
! 
!   syn_ps2_send_cmd(fd, stick, cmd);
!   syn_ps2_putbyte (fd, stick, PS2_STATUS_REQ);
!   bytes [0]=syn_ps2_getbyte(fd,stick);
!   bytes [1]=syn_ps2_getbyte(fd,stick);
!   bytes [2]=syn_ps2_getbyte(fd,stick);
! 
!   gpm_report (GPM_PR_INFO,"Status request %X %X %X", bytes[0], bytes[1], bytes[2]);
  }
  
  
  #if 0
  
  /* read the modes from the touchpad (in ps/2 format) */
! static void syn_ps2_read_modes (int fd, int stick) 
  {
    unsigned char bytes [3];
  
!   syn_ps2_status_rqst (fd, stick, PS2_SYN_CMD_MODES, bytes);
  # ifdef DEBUG
!   gpm_report (GPM_PR_INFO,"Synaptic PS/2 %s modes: %02X", (stick?"stick":"touchpad"),bytes [2]);
  # endif
  }
  
***************
*** 2329,2341 ****
  
  /* read the identification from the ps2 touchpad */
  static void syn_ps2_read_ident (int fd,
! 				info_type *info) 
  {
    byte bytes [3];
  
!   syn_ps2_status_rqst (fd, PS2_SYN_CMD_IDENTIFY, bytes);
    if (bytes [1] != PS2_SYN_STATUS_OK) {
!     gpm_report (GPM_PR_ERR,"PS/2 device doesn't appear to be a synaptics touchpad\n");
      info->info_minor      = 0;
      info->info_model_code = 0;
      info->info_major      = 0;
--- 2694,2708 ----
  
  /* read the identification from the ps2 touchpad */
  static void syn_ps2_read_ident (int fd,
! 				int stick, 
! 				info_type *info)
  {
    byte bytes [3];
  
!   syn_ps2_status_rqst (fd, stick, PS2_SYN_CMD_IDENTIFY, bytes);
    if (bytes [1] != PS2_SYN_STATUS_OK) {
!     gpm_report (GPM_PR_ERR,"PS/2 device doesn't appear to have synaptics %s identification\n",
! 		(stick?"sticks":"touchpads"));
      info->info_minor      = 0;
      info->info_model_code = 0;
      info->info_major      = 0;
***************
*** 2348,2361 ****
  }
  
  
! /* read the model_id from the ps2 touchpad */
  static void syn_ps2_read_model_id (int fd,
! 				   model_id_type *model) 
  {
    unsigned char bytes [3];
    int model_int;
  
!   syn_ps2_status_rqst (fd, PS2_SYN_CMD_MODEL_ID, bytes);
    model_int = ((bytes [0] << 16) |
  	       (bytes [1] << 8)  |
  	       (bytes [2]));
--- 2715,2729 ----
  }
  
  
! /* read the model_id from the ps2 touchpad/stick */
  static void syn_ps2_read_model_id (int fd,
! 				   int stick, 
! 				   model_id_type *model)
  {
    unsigned char bytes [3];
    int model_int;
  
!   syn_ps2_status_rqst (fd, stick, PS2_SYN_CMD_MODEL_ID, bytes);
    model_int = ((bytes [0] << 16) |
  	       (bytes [1] << 8)  |
  	       (bytes [2]));
***************
*** 2363,2381 ****
  }
  
  
- 
- 
  /* read the extended capability from the ps2 touchpad, STIG page 15 */
  static void syn_ps2_read_cap (int fd,
                                ext_cap_type *cap)
  {
    unsigned char bytes [3];
    int ext_cap_int;
  
!   syn_ps2_status_rqst (fd, PS2_SYN_CMD_CAPABILITIES, bytes);
  
    if (bytes [1] != PS2_SYN_STATUS_OK) {
!     gpm_report (GPM_PR_ERR,"PS/2 device doesn't appear to be a synaptics touchpad\n");
      ext_cap_int = 0;
    }else{
      ext_cap_int = bytes[0] << 8 | bytes[2];
--- 2731,2749 ----
  }
  
  
  /* read the extended capability from the ps2 touchpad, STIG page 15 */
  static void syn_ps2_read_cap (int fd,
+ 			      int stick,
                                ext_cap_type *cap)
  {
    unsigned char bytes [3];
    int ext_cap_int;
  
!   syn_ps2_status_rqst (fd, stick, PS2_SYN_CMD_CAPABILITIES, bytes);
  
    if (bytes [1] != PS2_SYN_STATUS_OK) {
!     gpm_report (GPM_PR_ERR,"PS/2 device doesn't appear to have synaptics %s capabilities\n",
! 		(stick?"stick":"touchpad"));
      ext_cap_int = 0;
    }else{
      ext_cap_int = bytes[0] << 8 | bytes[2];
***************
*** 2413,2424 ****
  
    write(fd,&cmd,1);
  
!   usleep (3000);
    
    while (select (fd+1, &rfds, NULL, NULL, &tv) == 1) {
      read (fd, &status, 1);
  #if DEBUG_RESET
!     gpm_report (GPM_PR_INFO,"PS/2 touchpad disable data flush: %02X", status);
  #endif
      FD_ZERO(&rfds);
      FD_SET (fd, &rfds);
--- 2781,2792 ----
  
    write(fd,&cmd,1);
  
!   usleep (50000);
    
    while (select (fd+1, &rfds, NULL, NULL, &tv) == 1) {
      read (fd, &status, 1);
  #if DEBUG_RESET
!     gpm_report (GPM_PR_INFO,"PS/2 device disable data flush: %02X", status);
  #endif
      FD_ZERO(&rfds);
      FD_SET (fd, &rfds);
***************
*** 2432,2493 ****
  
  
  /* 
!  * ps2_enable_data
   *
   * Enable data after a disable data command. Should have called the disable data
   * before calling this function.
   */
  
! static void tp_ps2_enable_data(int fd)
  {  
!   tp_ps2_putbyte(fd,PS2_ENABLE_DATA);
! 
  }
  
  
  /* 
!  * ps2_send_reset
   *
   * Send reset command and absorb additional READY, IDCODE from the
   * touchpad. Should have called the disable data before calling this function.
   * Synaptics garanties always to return PS2_READY. STIG page 31 and 48.
   */
  
! static void tp_ps2_send_reset(int fd)
  {
    byte status,id_code = PS2_MOUSE_IDCODE;
    byte reset_cmd = PS2_RESET;
!   
!   /* Send reset command. */
!   write(fd,&reset_cmd,1);
!   status = tp_ps2_getbyte(fd);
  
    /* Sometimes the touchpad sends additional ready,idcode before ack the reset command.
     * I dont know why! */
    while (status == PS2_READY){
!     gpm_report(GPM_PR_INFO,"PS/2 Touchpad sending additional READY, ID CODE.\n");
!     id_code = tp_ps2_getbyte(fd);
!     status  = tp_ps2_getbyte(fd);
    }
  
    if (status != PS2_ACK || id_code != PS2_MOUSE_IDCODE){
!     gpm_report(GPM_PR_ERR,"Sending reset command to PS/2 TouchPad failed: No ACK, got %02X.\n",status);
    }
!     
    /* Wait 750 ms to recalibrate. */
!   usleep(7500);
  
!   if ( (status  = tp_ps2_getbyte(fd)) != PS2_READY ){
!     gpm_report(GPM_PR_ERR,"Reseting PS/2 TouchPad failed: No READY, got %02X.\n",status);
    }
!   if ( (id_code = tp_ps2_getbyte(fd)) != PS2_MOUSE_IDCODE){
!     gpm_report(GPM_PR_ERR,"Reseting PS/2 TouchPad failed: Wrong ID, got %02X.\n",id_code);
    }
  
  }
  
  
- 
  /*
  ** syn_ps2_absolute_mode
  **
--- 2800,2869 ----
  
  
  /* 
!  * syn_ps2_enable_data
   *
   * Enable data after a disable data command. Should have called the disable data
   * before calling this function.
   */
  
! static void syn_ps2_enable_data(int fd)
  {  
!   if (stick_enabled)
!     syn_ps2_putbyte(fd,DEVICE_STICK,PS2_ENABLE_DATA);
!   syn_ps2_putbyte(fd,DEVICE_TOUCHPAD,PS2_ENABLE_DATA);
  }
  
  
  /* 
!  * syn_ps2_send_reset
   *
   * Send reset command and absorb additional READY, IDCODE from the
   * touchpad. Should have called the disable data before calling this function.
   * Synaptics garanties always to return PS2_READY. STIG page 31 and 48.
   */
  
! static void syn_ps2_send_reset(int fd, int stick)
  {
    byte status,id_code = PS2_MOUSE_IDCODE;
    byte reset_cmd = PS2_RESET;
! 
!   gpm_report(GPM_PR_DEBUG,"Reseting Synaptic PS/2 %s\n",(stick?"Stick":"Touchpad"));
! 
!   /* Send reset command without eating the ack. */
!   if(!stick) {
!     write(fd,&reset_cmd,1);
!     status = tp_ps2_getbyte(fd);
!   } else {
!     syn_ps2_putbyte(fd, stick, reset_cmd);
!     status = PS2_ACK;
!   }
  
    /* Sometimes the touchpad sends additional ready,idcode before ack the reset command.
     * I dont know why! */
    while (status == PS2_READY){
!     gpm_report(GPM_PR_INFO,"PS/2 device sending additional READY, ID CODE.\n");
!     id_code = syn_ps2_getbyte(fd,stick);
!     status  = syn_ps2_getbyte(fd,stick);
    }
  
    if (status != PS2_ACK || id_code != PS2_MOUSE_IDCODE){
!     gpm_report(GPM_PR_ERR,"Sending reset command to PS/2 Device failed: No ACK, got %02X.\n",status);
    }
! 
    /* Wait 750 ms to recalibrate. */
!   usleep(750000);
  
!   if ( (status  = syn_ps2_getbyte(fd,stick)) != PS2_READY ){
!     gpm_report(GPM_PR_ERR,"Reseting PS/2 Device failed: No READY, got %02X.\n"
! 	                  "Check pc_keyb.c for reconnect smartness.\n",status);
    }
!   if ( (id_code = syn_ps2_getbyte(fd,stick)) != PS2_MOUSE_IDCODE){
!     gpm_report(GPM_PR_ERR,"Reseting PS/2 Device failed: Wrong ID, got %02X.\n",id_code);
    }
  
  }
  
  
  /*
  ** syn_ps2_absolute_mode
  **
***************
*** 2496,2508 ****
  
  static void syn_ps2_absolute_mode(int fd)
  {
    /* select 6 byte packet, high packet rate, no-sleep */
!   syn_ps2_set_mode2 (fd, (ABSOLUTE_MODE    |
  		      HIGH_REPORT_RATE |
  		      PS2_NO_SLEEP     |
! 		      (stick_enabled ? STICK_ENABLED : STICK_DISABLE) |
  		      (wmode_enabled ? REPORT_W_ON : REPORT_W_OFF)));
!   
  }
  
  
--- 2872,2887 ----
  
  static void syn_ps2_absolute_mode(int fd)
  {
+ 
    /* select 6 byte packet, high packet rate, no-sleep */
!   syn_ps2_set_mode2 (fd, DEVICE_TOUCHPAD, 
! 		     (ABSOLUTE_MODE    |
  		      HIGH_REPORT_RATE |
  		      PS2_NO_SLEEP     |
! 		      (wmode_enabled ? NO_TAPDRAG_GESTURE : TAPDRAG_GESTURE) |
! 		      (stick_enabled ? STICK_ENABLED : STICK_DISABLE)        |
  		      (wmode_enabled ? REPORT_W_ON : REPORT_W_OFF)));
! 
  }
  
  
***************
*** 2530,2549 ****
  static void syn_serial_translate_data (unsigned char *data,
  					 report_type *report) 
  {
!   report->gesture  = check_bits (data [0], 0x10);
!   report->fingers  = check_bits (data [0], 0x08);
!   report->left     = check_bits (data [0], 0x04);
!   report->middle   = check_bits (data [0], 0x02);
!   report->right    = check_bits (data [0], 0x01);
!   report->x        = (data [1] << 7) | (data [2] << 1);
!   report->y        = (data [3] << 7) | (data [4] << 1);
!   report->pressure = data [5] << 2;
!   report->fourth   = 0;
!   report->up       = 0;
!   report->down     = 0;
!   report->w        = 0;
  
!   if (model.info_new_abs){
      report->up        = check_bits (data [6], 0x20);
      report->down      = check_bits (data [6], 0x40);
      report->y        |= (data [6] & 0x08) >> 3;
--- 2909,2929 ----
  static void syn_serial_translate_data (unsigned char *data,
  					 report_type *report) 
  {
!   report->gesture     = check_bits (data [0], 0x10);
!   report->fingers     = check_bits (data [0], 0x08);
!   report->left        = check_bits (data [0], 0x04);
!   report->middle      = check_bits (data [0], 0x02);
!   report->right       = check_bits (data [0], 0x01);
!   report->x           = (data [1] << 7) | (data [2] << 1);
!   report->y           = (data [3] << 7) | (data [4] << 1);
!   report->pressure    = data [5] << 2;
!   report->fourth      = 0;
!   report->up          = 0;
!   report->down        = 0;
!   report->w           = 0;
!   report->fingerwidth = 0;
  
!   if (model[0].info_new_abs){
      report->up        = check_bits (data [6], 0x20);
      report->down      = check_bits (data [6], 0x40);
      report->y        |= (data [6] & 0x08) >> 3;
***************
*** 2567,2573 ****
  				    report_type *report)
  {
    gpm_report(GPM_PR_WARN,"Unrecognized Synaptic PS/2 Touchpad packet: %02X %02X %02X %02X %02X %02X",
! 	      data [0],data [1],data [2],data [3],data [4],data [5]);
  
    if (reset_on_error_enabled) {
      /* Hack to get the fd: which_mouse is the current mouse,
--- 2947,2953 ----
  				    report_type *report)
  {
    gpm_report(GPM_PR_WARN,"Unrecognized Synaptic PS/2 Touchpad packet: %02X %02X %02X %02X %02X %02X",
! 	     data [0],data [1],data [2],data [3],data [4],data [5]);
  
    if (reset_on_error_enabled) {
      /* Hack to get the fd: which_mouse is the current mouse,
***************
*** 2576,2593 ****
      syn_ps2_absolute_mode(which_mouse->fd);
    }
    
!   report->left     = 0;
!   report->middle   = 0;
!   report->right    = 0;
!   report->fourth   = 0;
!   report->up       = 0;
!   report->down     = 0;
!   report->x        = 0;
!   report->y        = 0;
!   report->pressure = 0;
!   report->gesture  = 0;
!   report->fingers  = 0;
!   report->w        = 0;
    
  }
  
--- 2956,2974 ----
      syn_ps2_absolute_mode(which_mouse->fd);
    }
    
!   report->left        = 0;
!   report->middle      = 0;
!   report->right       = 0;
!   report->fourth      = 0;
!   report->up          = 0;
!   report->down        = 0;
!   report->x           = 0;
!   report->y           = 0;
!   report->pressure    = 0;
!   report->gesture     = 0;
!   report->fingers     = 0;
!   report->fingerwidth = 0;
!   report->w           = 0;
    
  }
  
***************
*** 2613,2620 ****
   * byte 3 |     1   |    0   |               z-pressure 0-5                            |
   * byte 4 |Reserved |    0   |    0     |              y - pos 8-12                    |
   * byte 5 |                                 y - pos 0-7                                |
!  *
!  
   */
  
  /* Translate the reported data into a record for processing */
--- 2994,3000 ----
   * byte 3 |     1   |    0   |               z-pressure 0-5                            |
   * byte 4 |Reserved |    0   |    0     |              y - pos 8-12                    |
   * byte 5 |                                 y - pos 0-7                                |
!  * 
   */
  
  /* Translate the reported data into a record for processing */
***************
*** 2626,2668 ****
    if (((data [0] & 0xc8) == 0x80) &&              /* Check static in byte 0 */
        ((data [3] & 0xc8) == 0xc0) &&              /* Check static in byte 3 */
        ((data [0] & 0x0F) == (data [3] & 0x0F))) { /* check repeated data */
!     report->left     = check_bits (data [0], 0x01);
!     report->middle   = 0;
!     report->right    = check_bits (data [0], 0x02);
!     report->fourth   = 0;
!     report->up       = 0;
!     report->down     = 0;
!     report->x        = (((data [1] & 0x0F) << 8) |
! 			((data [3] & 0x10) << 8) |
! 			((data [4])));
!     report->y        = (((data [1] & 0xF0) << 4) |
! 			((data [3] & 0x20) << 7) |
! 			((data [5])));
!     report->pressure = data [2];
!     report->gesture  = check_bits (data [0], 0x04);
!     report->fingers  = check_bits (data [0], 0x20);
!     report->w        = 0;
      
!   } /* Old style packet maybe */
    else if (((data [0] & 0xC0) == 0xC0) && /* Static in byte 0*/
  	   ((data [1] & 0x60) == 0x00) && /* Static in byte 1*/
  	   ((data [3] & 0xC0) == 0x80) && /* Static in byte 3*/
  	   ((data [4] & 0x60) == 0x00)) { /* Static in byte 4*/
!     report->left     = check_bits (data [0], 0x01);
!     report->middle   = 0;
!     report->right    = check_bits (data [0], 0x02);
!     report->fourth   = 0;
!     report->up       = 0;
!     report->down     = 0;
!     report->x        = (((data [1] & 0x1F) << 8) |
! 			((data [2])));
!     report->y        = (((data [4] & 0x1f) << 8) |
! 			((data [5])));
!     report->pressure = (((data [0] & 0x30) << 2 ) |
! 			((data [3] & 0x3f)));
!     report->gesture  = check_bits (data [0], 0x04);
!     report->fingers  = check_bits (data [1], 0x80);
!     report->w        = 0;
      
    } else { 
      syn_ps2_translate_error(data,report);
--- 3006,3050 ----
    if (((data [0] & 0xc8) == 0x80) &&              /* Check static in byte 0 */
        ((data [3] & 0xc8) == 0xc0) &&              /* Check static in byte 3 */
        ((data [0] & 0x0F) == (data [3] & 0x0F))) { /* check repeated data */
!     report->left        = check_bits (data [0], 0x01);
!     report->middle      = 0;
!     report->right       = check_bits (data [0], 0x02);
!     report->fourth      = 0;
!     report->up          = 0;
!     report->down        = 0;
!     report->x           = (((data [1] & 0x0F) << 8) |
! 			   ((data [3] & 0x10) << 8) |
! 			   ((data [4])));
!     report->y           = (((data [1] & 0xF0) << 4) |
! 			   ((data [3] & 0x20) << 7) |
! 			   ((data [5])));
!     report->pressure    = data [2];
!     report->gesture     = check_bits (data [0], 0x04);
!     report->fingers     = check_bits (data [0], 0x20);
!     report->fingerwidth = 0;
!     report->w           = 0;
      
!   } /*th Old style packet maybe */
    else if (((data [0] & 0xC0) == 0xC0) && /* Static in byte 0*/
  	   ((data [1] & 0x60) == 0x00) && /* Static in byte 1*/
  	   ((data [3] & 0xC0) == 0x80) && /* Static in byte 3*/
  	   ((data [4] & 0x60) == 0x00)) { /* Static in byte 4*/
!     report->left        = check_bits (data [0], 0x01);
!     report->middle      = 0;
!     report->right       = check_bits (data [0], 0x02);
!     report->fourth      = 0;
!     report->up          = 0;
!     report->down        = 0;
!     report->x           = (((data [1] & 0x1F) << 8) |
! 			   ((data [2])));
!     report->y           = (((data [4] & 0x1f) << 8) |
! 			   ((data [5])));
!     report->pressure    = (((data [0] & 0x30) << 2 ) |
! 			   ((data [3] & 0x3f)));
!     report->gesture     = check_bits (data [0], 0x04);
!     report->fingers     = check_bits (data [1], 0x80);
!     report->fingerwidth = 0;
!     report->w           = 0;
      
    } else { 
      syn_ps2_translate_error(data,report);
***************
*** 2688,2708 ****
    /* Check that it is an absolute packet */
    if (((data[0] & 0xc8) == 0x80) && ((data[3] & 0xc8) == 0xc0)) {
  
!     report->left     = check_bits (data[0], 0x01);
!     report->middle   = check_bits (data[0] ^ data[3], 0x01);
!     report->right    = check_bits (data[0], 0x02);
!     report->fourth   = check_bits (data[0] ^ data[3], 0x02);
!     report->up       = 0;
!     report->down     = 0;
!     report->x        = (((data[1] & 0x0F) << 8) |
! 			((data[3] & 0x10) << 8) |
! 			((data[4])));
!     report->y        = (((data[1] & 0xF0) << 4) |
! 			((data[3] & 0x20) << 7) |
! 			((data[5])));
!     report->pressure = data[2];
!     report->fingers  = 0;
!     report->gesture  = 0;
      report->w = (((data[3] & 0x04) >> 2) |
  		 ((data[0] & 0x04) >> 1) |
  		 ((data[0] & 0x30) >> 2));
--- 3070,3091 ----
    /* Check that it is an absolute packet */
    if (((data[0] & 0xc8) == 0x80) && ((data[3] & 0xc8) == 0xc0)) {
  
!     report->left        = check_bits (data[0], 0x01);
!     report->middle      = check_bits (data[0] ^ data[3], 0x01);
!     report->right       = check_bits (data[0], 0x02);
!     report->fourth      = check_bits (data[0] ^ data[3], 0x02);
!     report->up          = 0;
!     report->down        = 0;
!     report->x           = (((data[1] & 0x0F) << 8) |
! 			   ((data[3] & 0x10) << 8) |
! 			   ((data[4])));
!     report->y           = (((data[1] & 0xF0) << 4) |
! 			   ((data[3] & 0x20) << 7) |
! 			   ((data[5])));
!     report->pressure    = data[2];
!     report->fingers     = 0;
!     report->fingerwidth = 0;
!     report->gesture     = 0;
      report->w = (((data[3] & 0x04) >> 2) |
  		 ((data[0] & 0x04) >> 1) |
  		 ((data[0] & 0x30) >> 2));
***************
*** 2733,2745 ****
    state->dx      = 0;
    state->dy      = 0;
  
!   syn_serial_translate_data (data, &report);
!   if (tp_preprocess_report(&report,state)) return;
    if (wmode_enabled){
!     tp_process_wmode_report(&report);    
    }    
  
!   tp_process_report (state, report);
  }
  
  
--- 3116,3131 ----
    state->dx      = 0;
    state->dy      = 0;
  
!   syn_serial_translate_data (data, &cur_report);
    if (wmode_enabled){
!     syn_process_wmode_report(&cur_report);
    }    
+   if (tp_find_fingers(&cur_report,state)) return;
+   if (wmode_enabled){
+     tp_find_gestures(&cur_report);    
+   }    
  
!   tp_process_report (state, &cur_report);
  }
  
  
***************
*** 2774,2788 ****
    int return_packetlength;
  
    gpm_report(GPM_PR_DEBUG,"Initializing Synaptics Serial TouchPad");
  
!   syn_serial_read_ident (fd, &ident);
!   syn_serial_read_model_id (fd, &model);
!   syn_serial_read_cap(fd, &capabilities);
  
!   syn_process_config (ident, model);
  
    /* Change the protocol to use either 6,7 or 8 bytes, STIG 63 */
!   if (model.info_new_abs){
      if (wmode_enabled){
        return_packetlength = 8;
      }else{
--- 3160,3176 ----
    int return_packetlength;
  
    gpm_report(GPM_PR_DEBUG,"Initializing Synaptics Serial TouchPad");
+ 
+   syn_serial_read_ident (fd, &ident[0]);
+   syn_serial_read_model_id (fd, &model[0]);
+   syn_serial_read_cap(fd, &capabilities[0]);
  
!   syn_process_config (ident[0], model[0]);
  
!   syn_dump_info(0);
  
    /* Change the protocol to use either 6,7 or 8 bytes, STIG 63 */
!   if (model[0].info_new_abs){
      if (wmode_enabled){
        return_packetlength = 8;
      }else{
***************
*** 2796,2802 ****
    syn_serial_set_mode (fd, (ABSOLUTE_MODE    |
  			    HIGH_REPORT_RATE |
  			    USE_9600_BAUD    |
! 			    (model.info_new_abs ? EXTENDED_REPORT : NORMAL_REPORT) |
  			    (wmode_enabled ? REPORT_W_ON : REPORT_W_OFF)));
  
    return return_packetlength;
--- 3184,3190 ----
    syn_serial_set_mode (fd, (ABSOLUTE_MODE    |
  			    HIGH_REPORT_RATE |
  			    USE_9600_BAUD    |
! 			    (model[0].info_new_abs ? EXTENDED_REPORT : NORMAL_REPORT) |
  			    (wmode_enabled ? REPORT_W_ON : REPORT_W_OFF)));
  
    return return_packetlength;
***************
*** 2820,2842 ****
  
  
    if (wmode_enabled) {
!     syn_ps2_translate_wmode_data (data, &report);
!     if (syn_ps2_process_extended_packets(data,&report,state)) return;      
!     if (tp_preprocess_report(&report,state)) return;
!     tp_process_wmode_report(&report);
    }else {
!     syn_ps2_translate_data (data, &report);
!     if (tp_preprocess_report(&report,state)) return;
    }
  
!   tp_process_report (state, report);
  }
  
  
- 
- 
  /*
! ** syn_serial_reset
  **
  ** Reset the touchpad and set to relative mode (ps/2).
  */
--- 3208,3229 ----
  
  
    if (wmode_enabled) {
!     syn_ps2_translate_wmode_data (data, &cur_report);
!     if (syn_ps2_process_extended_packets(data,&cur_report,state)) return;      
!     syn_process_wmode_report(&cur_report);
!     if (tp_find_fingers(&cur_report,state)) return;
!     tp_find_gestures(&cur_report);
    }else {
!     syn_ps2_translate_data (data, &cur_report);
!     if (tp_find_fingers(&cur_report,state)) return;
    }
  
!   tp_process_report (state, &cur_report);
  }
  
  
  /*
! ** syn_ps2_reset
  **
  ** Reset the touchpad and set to relative mode (ps/2).
  */
***************
*** 2847,2858 ****
  
    /* Stop incoming motion data (of whatever kind absolute/relative). */
    tp_ps2_disable_data(fd);
-   tp_ps2_send_reset(fd);
-   tp_ps2_enable_data(fd);
  
  }
  
  
  /*
  ** syn_ps2_init
  ** 
--- 3234,3276 ----
  
    /* Stop incoming motion data (of whatever kind absolute/relative). */
    tp_ps2_disable_data(fd);
  
+   if(stick_enabled)
+     syn_ps2_send_reset(fd,DEVICE_STICK);
+   syn_ps2_send_reset(fd,DEVICE_TOUCHPAD);
+ 
+   syn_ps2_enable_data(fd);
+ }
+ 
+ 
+ /*
+  * syn_ps2_init_stick
+  *
+  * Initialize the attached device on the synaptics touchpad (usually a stick).
+  */
+ 
+ static void syn_ps2_init_stick(int fd)
+ {
+   
+   if (!stick_enabled) return;
+ 
+   gpm_report(GPM_PR_DEBUG,"Initializing Synaptics PS/2 Stick Device");
+ 
+   /* Reset it, set defaults, streaming */
+   syn_ps2_send_reset(fd,DEVICE_STICK);
+   syn_ps2_putbyte(fd,DEVICE_STICK,PS2_SET_DEFAULT);
+   syn_ps2_putbyte(fd,DEVICE_STICK,PS2_STREAM_MODE);
+ 
+   /* Unused */
+   /*   syn_ps2_read_ident    (fd, DEVICE_STICK, &ident[1]); */
+   /*   syn_ps2_read_model_id (fd, DEVICE_STICK, &model[1]); */
+   /*   syn_ps2_read_cap      (fd, DEVICE_STICK, &capabilities[1]); */
+ 
+   /*   syn_dump_info(DEVICE_STICK); */
  }
  
  
+ 
  /*
  ** syn_ps2_init
  ** 
***************
*** 2867,2880 ****
  
    tp_ps2_disable_data(fd);
  
!   tp_ps2_send_reset(fd);
  
!   syn_ps2_read_ident    (fd, &ident);
!   syn_ps2_read_model_id (fd, &model);
!   syn_ps2_read_cap      (fd, &capabilities);
  
!   syn_process_config (ident, model);
    syn_ps2_absolute_mode(fd);
  
!   tp_ps2_enable_data(fd);
  }
--- 3285,3305 ----
  
    tp_ps2_disable_data(fd);
  
!   /* Init touchpad */
!   syn_ps2_send_reset(fd,DEVICE_TOUCHPAD);
  
!   syn_ps2_read_ident    (fd, DEVICE_TOUCHPAD, &ident[0]);
!   syn_ps2_read_model_id (fd, DEVICE_TOUCHPAD, &model[0]);
!   syn_ps2_read_cap      (fd, DEVICE_TOUCHPAD, &capabilities[0]);
  
!   syn_process_config (ident[0], model[0]);
!   syn_dump_info(DEVICE_TOUCHPAD);
! 
    syn_ps2_absolute_mode(fd);
+ 
+   /* Absolut mode must be set before Init Stick device*/
+   syn_ps2_init_stick(fd);
  
!   /* Enable absolut mode and streaming */
!   syn_ps2_enable_data(fd);
  }
