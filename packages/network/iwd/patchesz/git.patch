diff --git a/AUTHORS b/AUTHORS
index 69150421..cb31dfe6 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -14,3 +14,4 @@ John Zimmermann <johnz@posteo.net>
 Antonio Quartulli <a@unstable.cc>
 Andreas Henriksson <andreas@fatal.se>
 Jordan Glover <Golden_Miller83@protonmail.ch>
+Eduardo Abinader <eduardoabinader@gmail.com>
diff --git a/Makefile.am b/Makefile.am
index b4373f99..41ac0745 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -195,10 +195,10 @@ src_iwd_SOURCES = src/main.c linux/nl80211.h src/iwd.h src/missing.h \
 					src/knownnetworks.c \
 					src/rfkill.h src/rfkill.c \
 					src/ft.h src/ft.c \
-					src/ap.h src/ap.c \
-					src/adhoc.h src/adhoc.c \
+					src/ap.c src/adhoc.c \
 					src/sae.h src/sae.c \
 					src/nl80211util.h src/nl80211util.c \
+					src/nl80211cmd.h src/nl80211cmd.c \
 					src/owe.h src/owe.c \
 					src/blacklist.h src/blacklist.c \
 					src/manager.c \
@@ -206,8 +206,15 @@ src_iwd_SOURCES = src/main.c linux/nl80211.h src/iwd.h src/missing.h \
 					src/fils.h src/fils.c \
 					src/rtnlutil.h src/rtnlutil.c \
 					src/auth-proto.h \
+					src/anqp.h src/anqp.c \
+					src/anqputil.h src/anqputil.c \
+					src/netconfig.h src/netconfig.c\
+					src/resolve.h src/resolve.c\
+					src/hotspot.h src/hotspot.c \
 					$(eap_sources) \
 					$(builtin_sources)
+					src/p2putil.h src/p2putil.c
+
 src_iwd_LDADD = $(ell_ldadd) -ldl
 src_iwd_DEPENDENCIES = $(ell_dependencies)
 
@@ -267,7 +274,10 @@ monitor_iwmon_SOURCES = monitor/main.c linux/nl80211.h \
 					src/crypto.h src/crypto.c \
 					src/watchlist.h src/watchlist.c \
 					src/eapolutil.h src/eapolutil.c \
-					src/handshake.h src/handshake.c
+					src/handshake.h src/handshake.c \
+					src/nl80211cmd.h src/nl80211cmd.c \
+					src/p2putil.c src/p2putil.h \
+					src/anqputil.h src/anqputil.c
 monitor_iwmon_LDADD = $(ell_ldadd)
 endif
 
@@ -319,7 +329,7 @@ unit_tests = unit/test-cmac-aes \
 		unit/test-crypto unit/test-eapol unit/test-mpdu \
 		unit/test-ie unit/test-util unit/test-ssid-security \
 		unit/test-arc4 unit/test-wsc unit/test-eap-mschapv2 \
-		unit/test-eap-sim unit/test-sae
+		unit/test-eap-sim unit/test-sae unit/test-p2p
 
 if CLIENT
 unit_tests += unit/test-client
@@ -453,6 +463,13 @@ unit_test_sae_SOURCES = unit/test-sae.c \
 				src/mpdu.h src/mpdu.c
 unit_test_sae_LDADD = $(ell_ldadd)
 
+unit_test_p2p_SOURCES = unit/test-p2p.c src/wscutil.h src/wscutil.c \
+				src/crypto.h src/crypto.c \
+				src/ie.h src/ie.c \
+				src/util.h src/util.c \
+				src/p2putil.h src/p2putil.c
+unit_test_p2p_LDADD = $(ell_ldadd)
+
 TESTS = $(unit_tests)
 
 manual_pages = doc/iwmon.1
diff --git a/TODO b/TODO
index 9463d0ee..235fdf88 100644
--- a/TODO
+++ b/TODO
@@ -279,16 +279,6 @@ Wireless daemon
   Priority: Low
   Complexity: C2
 
-- Implement 4-Address mode when acting as a client
-
-  NL80211 allows one to use 4-address mode in STA role.  In this case the
-  EAPoL packets flow over the bridge interface while the rest of the commands
-  are addressed to the actual interface index.  This can be useful to share
-  the WiFi interface over various VM instances.
-
-  Priority: Low
-  Complexity: C2
-
 - Use NL80211_CMD_CRIT_PROTOCOL_START / CRIT_PROTOCOL_STOP
 
   Research whether iwd should be making use of these commands in order to
@@ -331,3 +321,106 @@ Wireless daemon
 
   Priority: Medium
   Complexity: C8
+
+- Support receiving OCE FILS Discovery Frames
+
+  When operating in station mode, we should support receiving of FILS
+  Discovery frames.
+
+  Priority: Medium
+  Complexity: C2
+
+- Support OCE Reduced Neighbor Reports
+
+  OCE specifies that the AP can send Reduced Neighbor Reports if the STA sets
+  the FILS Capability bit to true.  Reduced Neighbor Reports can be used to
+  replace the need to scan, particularly if the AP reports RNR Completeness
+  attribute.  RNRs can be sent in Probe Responses, Beacons and FILS Discovery
+  frames.
+
+  Priority: Medium
+  Complexity: C2
+
+- Support OCE Scanning
+
+  OCE Specifies various scanning optimizations.  When OCE scanning is enabled,
+  (e.g. when OCE APs are detected, or via some other means), enable the
+  relevant optimizations if driver support is present:
+    NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME
+    NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP
+    NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE
+    NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION
+
+  Priority: Medium
+  Complexity: C2
+
+- Support OCE mutually non-overlapping channels optimization.
+
+  OCE Section 3.10 mandates that the STA should scan channels 1, 6 and 11 in
+  the 2.4Ghz band first, unless it expects to find an AP on a different
+  channel.
+
+  Priority: Low
+  Complexity: C1
+
+- Support OCE RSSI-based Association Rejection attribute
+
+  OCE APs can reject a Re(Association) request with Status Code 34 and
+  optionally include RSSI-based Association Rejection attribute.  This
+  attribute can either contain a time delay information or an RSSI delta
+  value.  If the time delay info is included, make sure that this particular
+  BSS is blacklisted only for the duration of the delay.  If RSSI delta
+  is included, make sure to handle that as well.
+
+  Priority: Low
+  Complexity: C1
+
+- Support additional metrics sent by OCE APs
+
+  OCE APs can send BSS Load and Extended BSS Load IEs.  iwd already takes the
+  BSS Load IE into account for ranking purposes.  If Extended BSS Load IE is
+  present, it should be taken into account as well.
+
+  Additionally, Estimated Service Parameter (ESP) and Reduced WAN Metrics
+  should be taken into account if available.
+
+  Priority: Low
+  Complexity: C4
+
+- Support OCE FILS Indication element
+
+  OCE APs that support FILS authentication can notify which domains they
+  support.  This information is made available using the FILS Indication
+  element as part of the Probe Response and Beacon frames.
+
+  Priority: Low
+  Complexity: C4
+
+- Support OCE Higher Layer Protocol Encapsulation
+
+  This can be used to obtain DHCPv4 address faster.
+
+  Priority: Medium
+  Complexity: C4
+
+- Support Diagnostics interface
+
+  The diagnostic interface for a particular Device would contain information
+  (and possibly operations) that would be meant for diagnostics applications
+  or other applications that require access to very low level details.  Such
+  applications would be expected how to interpret this information
+  appropriately.
+
+  This interface would also be heavily utilized by the Auto-Test framework
+  in order to more easily ascertain the internal state of the hardware & the
+  daemon itself.
+
+  The list of possible information exposed via this interface includes:
+    - MAC address of the currently connected AP (in a Station)
+    - MAC addresses of currently connected clients (Adhoc, AP, etc)
+    - packet error rates or signal strength
+    - Throughput statistics
+    - FTM / direction finding operations
+
+  Priority: Medium
+  Complexity: C4
diff --git a/client/command.c b/client/command.c
index 2c5f4907..f07a6ad9 100644
--- a/client/command.c
+++ b/client/command.c
@@ -555,6 +555,21 @@ int command_get_exit_status(void)
 	return exit_status;
 }
 
+void command_reset_default_entities(void)
+{
+	const struct l_queue_entry *entry;
+
+	for (entry = l_queue_get_entries(command_families); entry;
+							entry = entry->next) {
+		struct command_family *family = entry->data;
+
+		if (!family->reset_default_entity)
+			continue;
+
+		family->reset_default_entity();
+	}
+}
+
 void command_family_register(const struct command_family *family)
 {
 	l_queue_push_tail(command_families, (void *) family);
diff --git a/client/command.h b/client/command.h
index 20ae39e3..2252ff25 100644
--- a/client/command.h
+++ b/client/command.h
@@ -49,6 +49,7 @@ struct command_family {
 	command_completion_func_t family_arg_completion;
 	command_completion_func_t entity_arg_completion;
 	void (*set_default_entity)(const char *entity);
+	void (*reset_default_entity)(void);
 };
 
 bool command_line_find_token(const char *token, uint8_t num_to_inspect);
@@ -62,6 +63,7 @@ void command_noninteractive_trigger(void);
 bool command_is_interactive_mode(void);
 int command_get_exit_status(void);
 void command_set_exit_status(int status);
+void command_reset_default_entities(void);
 
 void command_family_register(const struct command_family *family);
 void command_family_unregister(const struct command_family *family);
diff --git a/client/dbus-proxy.c b/client/dbus-proxy.c
index 671bce02..443e66ca 100644
--- a/client/dbus-proxy.c
+++ b/client/dbus-proxy.c
@@ -734,6 +734,8 @@ static void service_disappeared_callback(struct l_dbus *dbus,
 
 	l_queue_clear(proxy_interfaces, proxy_interface_destroy);
 
+	command_reset_default_entities();
+
 	display_disable_cmd_prompt();
 }
 
diff --git a/client/device.c b/client/device.c
index ebf35335..418ad159 100644
--- a/client/device.c
+++ b/client/device.c
@@ -306,6 +306,11 @@ static void device_set_default(const char *device_name)
 	l_queue_destroy(match, NULL);
 }
 
+static void device_reset_default(void)
+{
+	default_device = NULL;
+}
+
 const struct proxy_interface *device_get_default(void)
 {
 	struct l_queue *match;
@@ -483,6 +488,7 @@ static struct command_family device_command_family = {
 	.family_arg_completion = family_arg_completion,
 	.entity_arg_completion = entity_arg_completion,
 	.set_default_entity = device_set_default,
+	.reset_default_entity = device_reset_default,
 };
 
 static int device_command_family_init(void)
diff --git a/doc/hotspot.txt b/doc/hotspot.txt
new file mode 100644
index 00000000..4920095a
--- /dev/null
+++ b/doc/hotspot.txt
@@ -0,0 +1,46 @@
+Hotspot 2.0 networks are common in airports/airplanes (e.g. Boingo) and are also
+found in various other locations implemented by cable/cellular providers. These
+networks allow you to use a secure 8021x access point using the account
+credentials for your e.g. cable/cellular provider, or via a dedicated account
+like Boingo. Lots of these services also allow you to roam between networks.
+
+The underlying authentication is standard WPA2-Enterprise but Hotspot 2.0 adds a
+'discovery' stage to identifiying networks. This discovery is done using ANQP,
+which queries the network for additional information to determine if the client
+has the credentials to connect.
+
+Because of this network identification capability the hotspot network must be
+provisioned before hand as you would with 8021x, though the provisioning file
+requires at least one additional value in addition to the regular 8021x EAP
+information. Under the Hotspot group NAIRealmNames and HESSID have
+been added. NAIRealmNames is a required field. HESSID is optional but, if
+provided, may allow IWD to skip the ANQP step and directly connect (assuming
+the network advertised HESSID matches).
+
+NAIRealmNames is a comma separated list of realms e.g.
+
+[Hotspot]
+NAIRealmNames=realm.example.com,another.realm.com
+
+HESSID is simply a MAC address e.g.
+
+[Hotspot]
+HESSID=ab:cd:ef:01:23:67
+
+A side note:
+
+Since hotspot's use of ANQP is done before we are connected, it is done via
+public action frames. This requires the WiFi hardware go offchannel, similar
+to scans. Because of this scans and ANQP are done on a first come first serve
+basis in the kernel, which can result in delays. To mitigate this IWD will
+suspend any scanning until ANQP finishes. There is also a new feature in the
+5.3 kernel which notifies userspace when a 'remain-on-channel' action has
+completed. This feature is only available on mac80211 based driver and is
+required for IWD to do ANQP reliably.
+
+Since not all kernels will have this option right away an option was added to
+IWD which allows the user to disable ANQP. As a result, this will also disable
+any hotspot 2.0 network connections unless the HESSID is provided in the
+configuration file. By default ANQP will be disabled. It can be enabled with:
+
+disable_anqp=0
diff --git a/doc/main.conf b/doc/main.conf
index 16b857c2..60a3f8f8 100644
--- a/doc/main.conf
+++ b/doc/main.conf
@@ -31,6 +31,48 @@ roam_rssi_threshold=-70
 # driver it should be safe to omit/disable this setting.
 # use_default_interface=true
 
+#
+# Explicitly enforce/disable management frame protection
+#
+# 0 - Disable management frame protection
+# 1 - Set management frame protection capable
+# 2 - Management frame protection required
+#
+# ManagementFrameProtection=1
+
+#
+# Enable/disable ANQP queries. The way IWD does ANQP queries is dependent on
+# a recent kernel patch. If your kernel does not have this functionality this
+# should be disabled (default). Some drivers also do a terrible job of sending
+# public action frames (freezing or crashes) which is another reason why this
+# has been turned off by default. All aside, if you want to connect to Hotspot
+# 2.0 networks ANQP is most likely going to be required (you may be able to
+# pre-provision to avoid ANQP).
+#
+# disable_anqp=true
+
+#
+# Control the behavior of MAC address randomization by setting the
+# mac_randomize option.  iwd supports the following options:
+#   "default" - Lets the kernel assign a mac address from the permanent mac
+#   address store when the interface is created by iwd.  Alternatively,
+#   if the 'use_default_interface' is set to true, then the mac address is
+#   not touched.
+#   "once" - MAC address is randomized once when iwd starts.  If
+#   'use_default_interface' is set to true, only the interface(s) managed
+#   by iwd will be randomized.
+#
+# One can control which part of the address is randomized using
+# mac_randomize_bytes option.  iwd supports the following options:
+#   "nic" - Randomize only the NIC specific octets (last 3 octets).  Note that
+#   the randomization range is limited to 00:00:01 to 00:00:FE.  The permanent
+#   mac address of the card is used for the initial 3 octets.
+#   "full" - Randomize the full 6 octets.  The locally-administered bit will
+#   be set.
+#
+# mac_randomize=default
+# mac_randomize_bytes=full
+
 [Scan]
 #
 # Disable periodic scan. Setting this option to 'true' will prevent iwd from
diff --git a/monitor/nlmon.c b/monitor/nlmon.c
index fc5664d0..0e53b984 100644
--- a/monitor/nlmon.c
+++ b/monitor/nlmon.c
@@ -52,10 +52,12 @@
 #include "src/mpdu.h"
 #include "src/eapol.h"
 #include "src/util.h"
-#include "src/wscutil.h"
+#include "src/p2putil.h"
+#include "src/nl80211cmd.h"
 #include "monitor/pcap.h"
 #include "monitor/display.h"
 #include "monitor/nlmon.h"
+#include "src/anqputil.h"
 
 #define COLOR_TIMESTAMP		COLOR_YELLOW
 
@@ -578,6 +580,7 @@ static const struct cipher_suites rsn_akm_selectors[] = {
 	{ 0x000fac10, "FILS FT SHA256"                                                            },
 	{ 0x000fac11, "FILS FT SHA3854"                                                           },
 	{ 0x000fac12, "OWE"                                                                       },
+	{ 0x506f9a01, "WFA OSEN"                                                                  },
 	{ }
 };
 
@@ -700,6 +703,60 @@ static void print_ie_bitfield(unsigned int level, const char *label,
 	}
 }
 
+static size_t print_ie_rsn_suites(unsigned int level, const char *label,
+				const void *data, uint16_t size)
+{
+	uint16_t count;
+	uint16_t orig_size = size;
+
+	print_ie_cipher_suites(level + 1, "Group Data Cipher Suite", data, 4,
+				rsn_cipher_selectors);
+
+	data += 4;
+	size -= 4;
+
+	if (size < 2)
+		goto end;
+
+	count = l_get_le16(data) * 4;
+	data += 2;
+	size -= 2;
+
+	if (size < count)
+		goto end;
+
+	print_ie_cipher_suites(level + 1, "Pairwise Cipher Suite", data,
+					count, rsn_cipher_selectors);
+	data += count;
+	size -= count;
+
+	if (size < 2)
+		goto end;
+
+	count = l_get_le16(data) * 4;
+	data += 2;
+	size -= 2;
+
+	if (size < count)
+		goto end;
+
+	print_ie_cipher_suites(level + 1, "AKM Suite", data, count,
+				rsn_akm_selectors);
+	data += count;
+	size -= count;
+
+	if (size < 2)
+		goto end;
+
+	return orig_size - size;
+
+end:
+	if (size)
+		print_ie_error(level, label, size, -EINVAL);
+
+	return orig_size - size;
+}
+
 static void print_ie_rsn(unsigned int level, const char *label,
 			const void *data, uint16_t size)
 {
@@ -733,39 +790,7 @@ static void print_ie_rsn(unsigned int level, const char *label,
 	if (end - data < 4)
 		goto end;
 
-	print_ie_cipher_suites(level + 1, "Group Data Cipher Suite", data, 4,
-				rsn_cipher_selectors);
-
-	data += 4;
-
-	if (end - data < 2)
-		goto end;
-
-	count = l_get_le16(data) * 4;
-	data += 2;
-
-	if (end - data < count)
-		goto end;
-
-	print_ie_cipher_suites(level + 1, "Pairwise Cipher Suite", data,
-					count, rsn_cipher_selectors);
-	data += count;
-
-	if (end - data < 2)
-		goto end;
-
-	count = l_get_le16(data) * 4;
-	data += 2;
-
-	if (end - data < count)
-		goto end;
-
-	print_ie_cipher_suites(level + 1, "AKM Suite", data, count,
-				rsn_akm_selectors);
-	data += count;
-
-	if (end - data < 2)
-		goto end;
+	data += print_ie_rsn_suites(level, label, data, size);
 
 	bytemask[0] = 0x03;
 	bytemask[1] = 0x00;
@@ -881,19 +906,63 @@ end:
 	print_ie_error(level, label, size, -EINVAL);
 }
 
-static void print_ie_vendor(unsigned int level, const char *label,
-				const void *data, uint16_t size)
+static void print_ie_wfa_hs20(unsigned int level, const char *label,
+						const void *data, uint16_t size)
 {
-	static const unsigned char wfa_oui[3] = { 0x00, 0x50, 0xf2 };
-	const uint8_t *oui = data;
-	const char *str = NULL;
-	unsigned int i;
-
-	print_attr(level, "%s: len %u", label, size);
+	const uint8_t *ptr = data;
+	bool pps_mo_id_present;
+	bool anpq_domain_id_present;
 
-	if (size < 4)
+	if (size < 1)
 		return;
 
+	pps_mo_id_present = util_is_bit_set(ptr[0], 1);
+	anpq_domain_id_present = util_is_bit_set(ptr[0], 2);
+
+	print_attr(level + 1, "HS2.0 Indication Element:");
+	print_attr(level + 2, "DGAF Disabled: %u", util_is_bit_set(ptr[0], 0));
+	print_attr(level + 2, "PPS MO ID Present: %u", pps_mo_id_present);
+	print_attr(level + 2, "ANQP Domain ID Present: %u",
+				anpq_domain_id_present);
+
+	switch (util_bit_field(ptr[0], 4, 7)) {
+	case 0:
+		print_attr(level + 2, "Version Number: 1.x");
+		break;
+	case 1:
+		print_attr(level + 2, "Version Number: 2.x");
+		break;
+	case 2:
+		print_attr(level + 2, "Version Number: 3.x");
+		break;
+	}
+
+	ptr += 1;
+	size -= 1;
+
+	if (pps_mo_id_present) {
+		if (size < 2)
+			return;
+
+		print_attr(level + 2, "PPS MO ID: %02x %02x", ptr[0], ptr[1]);
+		ptr += 2;
+		size -= 2;
+	}
+
+	if (anpq_domain_id_present) {
+		if (size < 2)
+			return;
+
+		print_attr(level + 2, "ANQP Domain ID: %02x %02x",
+				ptr[0], ptr[1]);
+	}
+}
+
+static bool print_oui(unsigned int level, const uint8_t *oui)
+{
+	const char *str = NULL;
+	unsigned int i;
+
 	for (i = 0; oui_table[i].str; i++) {
 		if (!memcmp(oui_table[i].oui, oui, 3)) {
 			str = oui_table[i].str;
@@ -905,24 +974,114 @@ static void print_ie_vendor(unsigned int level, const char *label,
 		print_attr(level + 1, "OUI: %02x:%02x:%02x type:%02x",
 							oui[0], oui[1], oui[2],
 							oui[3]);
-		return;
+		return false;
 	}
 
 	print_attr(level + 1, "%s (%02x:%02x:%02x) type: %02x", str,
 							oui[0], oui[1], oui[2],
 							oui[3]);
+	return true;
+}
+
+static void print_ipv4(unsigned int level, const char *label,
+				const uint8_t *addr)
+{
+	print_attr(level, "%s: %u.%u.%u.%u", label,
+			addr[0], addr[1], addr[2], addr[3]);
+}
+
+static void print_ie_vendor(unsigned int level, const char *label,
+				const void *data, uint16_t size)
+{
+	const uint8_t *oui = data;
+
+	print_attr(level, "%s: len %u", label, size);
+
+	if (size < 4)
+		return;
+
+	if (!print_oui(level, oui))
+		return;
 
 	data += 4;
 	size -= 4;
 
-	if (!memcmp(oui, wfa_oui, 3)) {
+	if (!memcmp(oui, microsoft_oui, 3)) {
 		switch (oui[3]) {
-		case 1:		/* WFA WPA IE */
+		case 1:		/* MSoft WPA IE */
 			print_ie_wpa(level + 2, label, data, size);
 			return;
 		default:
 			return;
 		}
+	} else if (!memcmp(oui, wifi_alliance_oui, 3)) {
+		switch (oui[3]) {
+		case 0x04:
+			print_attr(level + 1, "IP Address Request KDE");
+			return;
+		case 0x05:
+			print_attr(level + 1, "IP Address Allocation KDE");
+
+			if (size < 12)
+				return;
+
+			print_ipv4(level + 2, "Client IP Address", data + 0);
+			print_ipv4(level + 2, "Subnet Mask", data + 4);
+			print_ipv4(level + 2, "GO IP Address", data + 8);
+			return;
+		case 0x10:
+			print_ie_wfa_hs20(level + 1, label, data, size);
+			return;
+		case 0x12:
+			print_ie_rsn_suites(level + 1, label, data, size);
+			return;
+		default:
+			return;
+		}
+	} else if (!memcmp(oui, ieee_oui, 3)) {
+		const char *kde;
+
+		/* EAPoL-Key KDEs */
+		switch (oui[3]) {
+		case 1:
+			kde = "GTK";
+			break;
+		case 3:
+			kde = "MAC address";
+			break;
+		case 4:
+			kde = "PMKID";
+			break;
+		case 5:
+			kde = "SMK";
+			break;
+		case 6:
+			kde = "Nonce";
+			break;
+		case 7:
+			kde = "Lifetime";
+			break;
+		case 8:
+			kde = "Error";
+			break;
+		case 9:
+			kde = "IGTK";
+			break;
+		case 10:
+			kde = "Key ID";
+			break;
+		case 11:
+			kde = "Multi-band GTK";
+			break;
+		case 12:
+			kde = "Multi-band Key ID";
+			break;
+		default:
+			return;
+		}
+
+		print_attr(level + 1, "%s KDE", kde);
+		return;
 	}
 }
 
@@ -1410,6 +1569,177 @@ static void print_ie_rm_enabled_caps(unsigned int level,
 				bytemask2, sizeof(bytemask2), capabilities);
 }
 
+static void print_ie_interworking(unsigned int level,
+					const char *label,
+					const void *data, uint16_t size)
+{
+	const uint8_t *ptr = data;
+	const char *msg;
+	uint8_t type;
+	bool venue = false;
+	bool hessid = false;
+
+	print_attr(level, "%s: len %u", label, size);
+
+	type = util_bit_field(ptr[0], 0, 3);
+
+	switch (type) {
+	case 0:
+		msg = "Private network";
+		break;
+	case 1:
+		msg = "Private network w/ guest access";
+		break;
+	case 2:
+		msg = "Chargeable public network";
+		break;
+	case 3:
+		msg = "Free public network";
+		break;
+	case 4:
+		msg = "Personal device network";
+		break;
+	case 5:
+		msg = "Emergency services only network";
+		break;
+	case 14:
+		msg = "Test/Experimental";
+		break;
+	case 15:
+		msg = "Wildcard";
+		break;
+	default:
+		return;
+	}
+
+	print_attr(level + 1, "Network Type: %s", msg);
+	print_attr(level + 1, "Internet: %u", util_is_bit_set(ptr[0], 4));
+	print_attr(level + 1, "ASRA: %u", util_is_bit_set(ptr[0], 5));
+	print_attr(level + 1, "ESR: %u", util_is_bit_set(ptr[0], 6));
+	print_attr(level + 1, "UESA: %u", util_is_bit_set(ptr[0], 7));
+
+	size--;
+	ptr++;
+
+	if (!size)
+		return;
+
+	/*
+	 * There is venue/hessid info optionally, and no way of determining if
+	 * they exist except looking at the length.
+	 */
+	if (size == 2)
+		venue = true;
+	else if (size == 6)
+		hessid = true;
+	else if (size == 8) {
+		venue = true;
+		hessid = true;
+	}
+
+	if (venue) {
+		switch (ptr[0]) {
+		case 0:
+			msg = "Unspecified";
+			break;
+		case 1:
+			msg = "Assembly";
+			break;
+		case 2:
+			msg = "Business";
+			break;
+		case 3:
+			msg = "Educational";
+			break;
+		case 5:
+			msg = "Factory and Industrial";
+			break;
+		case 6:
+			msg = "Institutional";
+			break;
+		case 7:
+			msg = "Mercantile";
+			break;
+		case 8:
+			msg = "Residential";
+			break;
+		case 9:
+			msg = "Utility and Miscellaneous";
+			break;
+		case 10:
+			msg = "Vehicular";
+			break;
+		case 11:
+			msg = "Outdoor";
+			break;
+		default:
+			return;
+		}
+
+		/*
+		 * Each of the above groups have many group types, but if
+		 * anyone really cares they can cross reference the integer
+		 * type with IEEE 802.11-2016 Table 9-62
+		 */
+		print_attr(level + 1, "Venue: %s, type: %u", msg, ptr[1]);
+
+		ptr += 2;
+		size -= 2;
+	}
+
+	if (hessid)
+		print_attr(level + 1, "HESSID: "MAC, MAC_STR(ptr));
+}
+
+static void print_ie_advertisement(unsigned int level,
+					const char *label,
+					const void *data, uint16_t size)
+{
+	const uint8_t *ptr = data;
+	const char *msg = NULL;
+
+	print_attr(level, "%s: len %u", label, size);
+
+	while (size) {
+		uint8_t qr_len = util_bit_field(ptr[0], 0, 7);
+		uint8_t id = ptr[1];
+
+		switch (id) {
+		case IE_ADVERTISEMENT_ANQP:
+			msg = "ANQP";
+			break;
+		case IE_ADVERTISEMENT_MIH_SERVICE:
+			msg = "MIH Information Service";
+			break;
+		case IE_ADVERTISEMENT_MIH_DISCOVERY:
+			msg = "MIH Command and Event Services";
+			break;
+		case IE_ADVERTISEMENT_EAS:
+			msg = "EAS";
+			break;
+		case IE_ADVERTISEMENT_RLQP:
+			msg = "RLQP";
+			break;
+		case IE_ADVERTISEMENT_VENDOR_SPECIFIC:
+			msg = "Vendor Specific";
+			break;
+		default:
+			return;
+		}
+
+		if (id == IE_ADVERTISEMENT_VENDOR_SPECIFIC) {
+			size -= ptr[3];
+			ptr += ptr[3];
+		} else {
+			size -= 2;
+			ptr += 2;
+		}
+
+		print_attr(level + 1, "Protocol: %s, Query Resp Limit: %u",
+				msg, qr_len);
+	}
+}
+
 static void print_ie_owe(unsigned int level,
 					const char *label,
 					const void *data, uint16_t size)
@@ -1500,6 +1830,10 @@ static struct attr_entry ie_entry[] = {
 		ATTR_CUSTOM,	{ .function = print_ie_ht_capabilities } },
 	{ IE_TYPE_RM_ENABLED_CAPABILITIES,	"RM Enabled Capabilities",
 		ATTR_CUSTOM,	{ .function = print_ie_rm_enabled_caps } },
+	{ IE_TYPE_INTERWORKING,			"Interworking",
+		ATTR_CUSTOM,	{ .function = print_ie_interworking } },
+	{ IE_TYPE_ADVERTISEMENT_PROTOCOL,	"Advertisement Protocol",
+		ATTR_CUSTOM,	{ .function = print_ie_advertisement } },
 	{ IE_TYPE_OWE_DH_PARAM,			"OWE Diffie-Hellman Parameter",
 		ATTR_CUSTOM,	{ .function = print_ie_owe } },
 	{ IE_TYPE_FILS_INDICATION,		"FILS Indication",
@@ -2384,32 +2718,711 @@ static void print_wsc_attributes(unsigned int level, const char *label,
 	}
 }
 
-static void print_management_ies(unsigned int level, const char *label,
-					const void *data, uint16_t size)
+static void print_p2p_status(unsigned int level, const char *label,
+				const void *data, uint16_t size)
 {
-	void *wsc_data;
-	ssize_t wsc_len;
-
-	print_ie(level, label, data, size);
+	const uint8_t *bytes = data;
+	static const struct p2p_status_desc {
+		uint8_t code;
+		const char *desc;
+	} descs[] = {
+		{ P2P_STATUS_SUCCESS, "Success" },
+		{ P2P_STATUS_FAIL_INFO_NOT_AVAIL, "Fail; information is "
+			"currently unavailable" },
+		{ P2P_STATUS_FAIL_INCOMPATIBLE_PARAMS, "Fail; incompatible "
+			"parameters" },
+		{ P2P_STATUS_FAIL_LIMIT_REACHED, "Fail; limit reached" },
+		{ P2P_STATUS_FAIL_INVALID_PARAMS, "Fail; invalid parameters" },
+		{ P2P_STATUS_FAIL_UNABLE_TO_ACCOMMODATE_REQUEST, "Fail; unable "
+			"to accomodate request" },
+		{ P2P_STATUS_FAIL_PREV_PROTOCOL_ERROR, "Fail; previous protocol"
+			" error, or distruptive behavior" },
+		{ P2P_STATUS_FAIL_NO_COMMON_CHANNELS, "Fail; no common "
+			"channels" },
+		{ P2P_STATUS_FAIL_UNKNOWN_P2P_GROUP, "Fail; unknown P2P "
+			"Group" },
+		{ P2P_STATUS_FAIL_INTENT_15_IN_GO_NEGOTIATION, "Fail; both P2P "
+			"Devices indicated an Intent of 15 in Group Owner "
+			"Negotiation" },
+		{ P2P_STATUS_FAIL_INCOMPATIBLE_PROVISIONING, "Fail; "
+			"incompatible provisioning method" },
+		{ P2P_STATUS_FAIL_REJECTED_BY_USER, "Fail; rejected by user" },
+		{ P2P_STATUS_SUCCESS_ACCEPTED_BY_USER, "Success; accepted by "
+			"user" },
+		{}
+	};
+	int i;
 
-	wsc_data = ie_tlv_extract_wsc_payload(data, size, &wsc_len);
-	if (!wsc_data)
+	if (size != 1) {
+		printf("malformed P2P %s\n", label);
 		return;
+	}
+
+	for (i = 0; descs[i].desc; i++)
+		if (descs[i].code == bytes[0])
+			break;
 
-	print_wsc_attributes(level + 1, "WSC Payload", wsc_data, wsc_len);
-	l_free(wsc_data);
+	if (descs[i].desc)
+		print_attr(level, "%s: %s", label, descs[i].desc);
+	else
+		print_attr(level, "%s: 0x%02x", label, bytes[0]);
 }
 
-static void print_address(unsigned int level, const char *label,
-					const unsigned char address[6])
+#define CHECK_CAPS_BIT(v, str)	\
+	if (caps & (v)) {	\
+		print_attr(level + 1, "%s", (str));	\
+		caps &= ~(v);	\
+	}
+static void print_p2p_device_capability(unsigned int level, const char *label,
+					const void *data, uint16_t size)
 {
-	char addr[18];
+	uint8_t caps;
 
-	snprintf(addr, sizeof(addr), "%02X:%02X:%02X:%02X:%02X:%02X",
-					address[0], address[1], address[2],
-					address[3], address[4], address[5]);
+	if (size != 1) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
 
-	print_attr(level, "%s %s", label, addr);
+	caps = *(const uint8_t *) data;
+
+	print_attr(level, "%s:%s", label, !caps ? " None" : "");
+
+	CHECK_CAPS_BIT(P2P_DEVICE_CAP_SVC_DISCOVERY,
+			"Service Discovery");
+	CHECK_CAPS_BIT(P2P_DEVICE_CAP_CLIENT_DISCOVERABILITY,
+			"P2P Client Discoverability");
+	CHECK_CAPS_BIT(P2P_DEVICE_CAP_CONCURRENT_OP,
+			"Concurrent Operation");
+	CHECK_CAPS_BIT(P2P_DEVICE_CAP_INFRASTRUCTURE_MANAGED,
+			"P2P Infrastructure Managed");
+	CHECK_CAPS_BIT(P2P_DEVICE_CAP_DEVICE_LIMIT,
+			"P2P Device Limit");
+	CHECK_CAPS_BIT(P2P_DEVICE_CAP_INVITATION_PROCEDURE,
+			"P2P Invitation Procedure");
+
+	if (caps)
+		print_attr(level + 1, "Reserved: 0x%02x", caps);
+}
+
+static void print_p2p_capability(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	uint8_t caps;
+
+	if (size != 2) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	print_p2p_device_capability(level, "P2P Device Capability", data++, 1);
+
+	caps = *(const uint8_t *) data++;
+
+	print_attr(level, "P2P Group Capability:%s", !caps ? " None" : "");
+
+	CHECK_CAPS_BIT(P2P_GROUP_CAP_GO,
+			"P2P Group Owner");
+	CHECK_CAPS_BIT(P2P_GROUP_CAP_PERSISTENT_GROUP,
+			"Persistent P2P Group");
+	CHECK_CAPS_BIT(P2P_GROUP_CAP_GROUP_LIMIT,
+			"P2P Group Limit");
+	CHECK_CAPS_BIT(P2P_GROUP_CAP_INTRA_BSS_DISTRIBUTION,
+			"Intra-BSS Distribution");
+	CHECK_CAPS_BIT(P2P_GROUP_CAP_CROSS_CONNECT,
+			"Cross Connection");
+	CHECK_CAPS_BIT(P2P_GROUP_CAP_PERSISTENT_RECONNECT,
+			"Persistent Reconnect");
+	CHECK_CAPS_BIT(P2P_GROUP_CAP_GROUP_FORMATION,
+			"Group Formation");
+	CHECK_CAPS_BIT(P2P_GROUP_CAP_IP_ALLOCATION,
+			"IP Address Allocation");
+}
+#undef CHECK_CAPS_BIT
+
+static void print_p2p_go_intent(unsigned int level, const char *label,
+				const void *data, uint16_t size)
+{
+	const uint8_t *bytes = data;
+
+	if (size != 1) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	print_attr(level, "%s: Intent %u out of 15, tie breaker %u", label,
+			bytes[0] >> 1, bytes[0] & 1);
+}
+
+static void print_p2p_config_timeout(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	const uint8_t *bytes = data;
+
+	if (size != 2) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	print_attr(level, "%s: GO Timeout %ums, Client Timeout %ums", label,
+			bytes[0] * 10, bytes[1] * 10);
+}
+
+static void print_p2p_oper_channel(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	const uint8_t *bytes = data;
+
+	if (size != 5) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	print_attr(level, "%s:", label);
+	print_attr(level + 1, "Country %c%c table %u", bytes[0], bytes[1],
+			bytes[2]);
+	print_attr(level + 1, "Operating Class %u", bytes[3]);
+	print_attr(level + 1, "Channel Number %u", bytes[4]);
+}
+
+static void print_p2p_extended_timing(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	if (size != 4) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	print_attr(level, "%s: Availability period: %ums, interval: %ums", label,
+			l_get_le16(data + 0), l_get_le16(data + 2));
+}
+
+static void print_p2p_manageability(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	uint8_t val;
+
+	if (size != 1) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+#define CHECK_BIT(v, str)	\
+	if (val & (v)) {	\
+		print_attr(level + 1, "%s", (str));	\
+		val &= ~(v);	\
+	}
+
+	val = *(const uint8_t *) data;
+
+	print_attr(level, "%s:%s", label, !val ? " None" : "");
+
+	CHECK_BIT(P2P_MANAGEABILITY_DEVICE_MGMT, "P2P Device Management");
+	CHECK_BIT(P2P_MANAGEABILITY_CROSS_CONNECT,
+			"Cross Connection Permitted");
+	CHECK_BIT(P2P_MANAGEABILITY_COEXIST_OPTIONAL, "Coexistence Optional");
+
+	if (val)
+		print_attr(level + 1, "Reserved: 0x%02x", val);
+#undef CHECK_BIT
+}
+
+static void print_p2p_channel_list(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	const uint8_t *bytes = data;
+
+	if (size < 3) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	print_attr(level, "%s:", label);
+	print_attr(level + 1, "Country %c%c table %u", bytes[0], bytes[1],
+			bytes[2]);
+	bytes += 3;
+	size -= 3;
+
+	while (size) {
+		uint8_t channels;
+		char str[128];
+		int pos = 0;
+
+		if (size < 2 || size < 2 + bytes[1]) {
+			printf("malformed P2P %s\n", label);
+			return;
+		}
+
+		print_attr(level + 1, "Operating Class %u channels:", *bytes++);
+		channels = *bytes++;
+		size -= 2 + channels;
+
+		while (channels--)
+			snprintf(str + pos, sizeof(str) - pos, "%s%u",
+					pos ? ", " : "", (int) *bytes++);
+
+		print_attr(level + 2, "%s", str);
+	}
+}
+
+static void print_p2p_notice_of_absence(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	const uint8_t *bytes = data;
+
+	if (size < 2) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	print_attr(level, "%s %u:", label, bytes[0]);
+	print_attr(level + 1, "GO uses Opportunistic Power Save: %s",
+			(bytes[1] & 0x80) ? "true" : "false");
+	print_attr(level + 1, "Client Traffic window len: %u TUs",
+			bytes[1] & 0x7f);
+	bytes += 2;
+	size -= 2;
+
+	while (size) {
+		if (size < 13) {
+			printf("malformed P2P Channel List\n");
+			return;
+		}
+
+		print_attr(level + 1, "Notice:");
+		print_attr(level + 2, "Count/Type: %u", bytes[0]);
+		print_attr(level + 2, "Duration: %uus", l_get_le32(bytes + 1));
+		print_attr(level + 2, "Interval: %uus", l_get_le32(bytes + 5));
+		print_attr(level + 2, "Start Time: %u", l_get_le32(bytes + 8));
+		bytes += 13;
+		size -= 13;
+	}
+}
+
+static void print_p2p_device_info(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	const uint8_t *bytes = data;
+	int secondary_types;
+
+	if (size < 17 || size < 17 + bytes[16] * 8 + 4) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	print_attr(level, "%s:", label);
+	print_wsc_mac_address(level + 1, "P2P Device address", bytes, 6);
+	print_wsc_config_methods(level + 1, "Config Methods", bytes + 6, 2);
+	print_wsc_primary_device_type(level + 1, "Primary Device Type",
+					bytes + 8, 8);
+	secondary_types = bytes[16];
+	bytes += 17;
+	size -= 17;
+
+	while (secondary_types--) {
+		print_wsc_primary_device_type(level + 1,
+						"Secondary Device Type",
+						bytes, 8);
+		bytes += 8;
+		size -= 8;
+	}
+
+	if (l_get_be16(bytes) != WSC_ATTR_DEVICE_NAME ||
+			4 + l_get_be16(bytes + 2) > size) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	print_wsc_device_name(level + 1, "Device Name", bytes + 4,
+				l_get_be16(bytes + 2));
+}
+
+static void print_p2p_group_info(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	const uint8_t *bytes = data;
+
+	print_attr(level, "%s:", label);
+
+	while (size) {
+		size_t desc_size = bytes[0];
+		int secondary_types;
+
+		if (1 + desc_size > size || desc_size < 24 ||
+				desc_size < (size_t) 24 + bytes[24] * 8 + 4) {
+			printf("malformed P2P Client Info Descriptor\n");
+			return;
+		}
+
+		size -= 1 + desc_size;
+
+		print_attr(level + 1, "P2P Client Info Descriptor:");
+		print_wsc_mac_address(level + 2, "P2P Device address",
+					bytes + 1, 6);
+		print_wsc_mac_address(level + 2, "P2P Interface address",
+					bytes + 7, 6);
+		print_p2p_device_capability(level + 2, "P2P Device Capability",
+						bytes + 13, 1);
+		print_wsc_config_methods(level + 2, "Config Methods",
+						bytes + 14, 2);
+		print_wsc_primary_device_type(level + 2, "Primary Device Type",
+						bytes + 16, 8);
+		secondary_types = bytes[24];
+		bytes += 25;
+		desc_size -= 24;
+
+		while (secondary_types--) {
+			print_wsc_primary_device_type(level + 2,
+							"Secondary Device Type",
+							bytes, 8);
+			bytes += 8;
+			desc_size -= 8;
+		}
+
+		if (l_get_be16(bytes) != WSC_ATTR_DEVICE_NAME ||
+				(size_t) 4 + l_get_be16(bytes + 2) >
+				desc_size) {
+			printf("malformed P2P Client Info Descriptor\n");
+			return;
+		}
+
+		print_wsc_device_name(level + 1, "Device Name", bytes + 4,
+					l_get_be16(bytes + 2));
+		bytes += 4 + l_get_be16(bytes + 2);
+	}
+}
+
+static void print_p2p_group_id(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	const uint8_t *bytes = data;
+
+	if (size < 6 || size > 38) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	print_attr(level, "%s:", label);
+
+	print_wsc_mac_address(level + 1, "P2P Device address",
+				bytes, 6);
+	print_ie_ssid(level + 1, "SSID", bytes + 6, size - 6);
+}
+
+static void print_p2p_interface(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	const uint8_t *bytes = data;
+	int addr_count;
+
+	if (size < 7 || size < 7 + bytes[6] * 6) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	print_attr(level, "%s:", label);
+
+	print_wsc_mac_address(level + 1, "P2P Device Address",
+				bytes, 6);
+	addr_count = bytes[6];
+	print_attr(level + 1, "P2P Interface Address Count: %u", addr_count);
+	bytes += 7;
+	size -= 7;
+
+	while (addr_count--) {
+		print_wsc_mac_address(level + 2, "Interface Address", bytes, 6);
+		bytes += 6;
+	}
+}
+
+static void print_p2p_invite_flags(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	uint8_t flags;
+
+	if (size != 1) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	flags = *(const uint8_t *) data;
+	print_attr(level, "Invitation Type: %s",
+			(flags & 1) ? "re-invoke a Persistent Group" :
+			"join active group");
+	flags &= ~1;
+
+	if (flags)
+		print_attr(level, "Invitation Flags: reserved 0x%02x", flags);
+}
+
+static void print_p2p_oob_neg_channel(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	const uint8_t *bytes = data;
+	const char *role;
+
+	if (size != 6) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	print_p2p_oper_channel(level, label, bytes + 0, 5);
+
+	switch (bytes[5]) {
+	case 0x00:
+		role = "not in a group";
+		break;
+	case 0x01:
+		role = "client";
+		break;
+	case 0x02:
+		role = "Group Owner";
+		break;
+	default:
+		role = "reserved";
+		break;
+	}
+
+	print_attr(level + 1, "Current group role indication: %s", role);
+}
+
+static void print_p2p_service_hash(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	if (size % 6 != 0) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	while (size) {
+		print_wsc_bytes(level, "Service Hash", data, 6);
+		data += 6;
+		size -= 6;
+	}
+}
+
+static void print_p2p_connection_caps(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	uint8_t caps;
+	const char *first;
+
+	if (size != 1) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	caps = *(const uint8_t *) data;
+
+	if (caps & 1)
+		first = "New";
+	else if (caps & 2)
+		first = "Cli";
+	else if (caps & ~4)
+		first = "Unknown";
+	else
+		first = "GO";
+
+	print_attr(level, "%s: %s%s", label, first,
+			(caps & ~4) && (caps & 4) ? ", GO" : "");
+}
+
+static void print_p2p_advertisement_id(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	if (size != 10) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	print_attr(level, "%s: 0x%08x", label, l_get_le32(data + 0));
+	print_wsc_mac_address(level + 1, "Service MAC Address", data + 4, 6);
+}
+
+static void print_p2p_advertised_svc_info(unsigned int level, const char *label,
+						const void *data, uint16_t size)
+{
+	const uint8_t *bytes = data;
+
+	while (size) {
+		if (size < 7 || size < 7 + bytes[6]) {
+			printf("malformed P2P %s\n", label);
+			return;
+		}
+
+		print_attr(level, "%s:", label);
+
+		print_attr(level, "Servce advertisement: ID 0x%08x",
+				l_get_le32(bytes + 0));
+		print_wsc_utf8_string(level + 1, "Service Name",
+					bytes + 6, bytes[6], 255);
+		print_wsc_config_methods(level + 1, "Service Config Methods",
+						bytes + 4, 2);
+		size -= 7 + bytes[6];
+		bytes += 7 + bytes[6];
+	}
+}
+
+static void print_p2p_session_id(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	if (size != 10) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	print_attr(level, "%s: 0x%08x", label, l_get_le32(data + 0));
+	print_wsc_mac_address(level + 1, "Session MAC Address", data + 4, 6);
+}
+
+static void print_p2p_feature_caps(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	const uint8_t *bytes = data;
+
+	if (size != 2) {
+		printf("malformed P2P %s\n", label);
+		return;
+	}
+
+	print_attr(level, "%s:", label);
+
+	if (bytes[0] == 0x01)
+		print_attr(level + 1, "Coordination Protocol Transport: UDP");
+	else
+		print_attr(level + 1, "Coordination Protocol Transport: "
+				"reserved 0x%02x", bytes[1]);
+}
+
+static struct attr_entry p2p_attr_entry[] = {
+	{ P2P_ATTR_STATUS,			"Status",
+		ATTR_CUSTOM,	{ .function = print_p2p_status } },
+	{ P2P_ATTR_MINOR_REASON_CODE,		"Minor Reason Code",
+		ATTR_CUSTOM,	{ .function = print_wsc_byte } },
+	{ P2P_ATTR_P2P_CAPABILITY,		"P2P Capability",
+		ATTR_CUSTOM,	{ .function = print_p2p_capability } },
+	{ P2P_ATTR_P2P_DEVICE_ID,		"P2P Device ID",
+		ATTR_CUSTOM,	{ .function = print_wsc_mac_address } },
+	{ P2P_ATTR_GO_INTENT,			"Group Owner Intent",
+		ATTR_CUSTOM,	{ .function = print_p2p_go_intent } },
+	{ P2P_ATTR_CONFIGURATION_TIMEOUT,	"Configuration Timeout",
+		ATTR_CUSTOM,	{ .function = print_p2p_config_timeout } },
+	{ P2P_ATTR_LISTEN_CHANNEL,		"Listen Channel",
+		ATTR_CUSTOM,	{ .function = print_p2p_oper_channel } },
+	{ P2P_ATTR_P2P_GROUP_BSSID,		"P2P Group BSSID",
+		ATTR_CUSTOM,	{ .function = print_wsc_mac_address } },
+	{ P2P_ATTR_EXTENDED_LISTEN_TIMING,	"Extended Listen Timing",
+		ATTR_CUSTOM,	{ .function = print_p2p_extended_timing } },
+	{ P2P_ATTR_INTENDED_P2P_INTERFACE_ADDR,	"Intended P2P Interface "
+		"Address",
+		ATTR_CUSTOM,	{ .function = print_wsc_mac_address } },
+	{ P2P_ATTR_P2P_MANAGEABILITY,		"P2P Manageability",
+		ATTR_CUSTOM,	{ .function = print_p2p_manageability } },
+	{ P2P_ATTR_CHANNEL_LIST,		"Channel List",
+		ATTR_CUSTOM,	{ .function = print_p2p_channel_list } },
+	{ P2P_ATTR_NOTICE_OF_ABSENCE,		"Notice of Absence",
+		ATTR_CUSTOM,	{ .function = print_p2p_notice_of_absence } },
+	{ P2P_ATTR_P2P_DEVICE_INFO,		"P2P Device Info",
+		ATTR_CUSTOM,	{ .function = print_p2p_device_info } },
+	{ P2P_ATTR_P2P_GROUP_INFO,		"P2P Group Info",
+		ATTR_CUSTOM,	{ .function = print_p2p_group_info } },
+	{ P2P_ATTR_P2P_GROUP_ID,		"P2P Group ID",
+		ATTR_CUSTOM,	{ .function = print_p2p_group_id } },
+	{ P2P_ATTR_P2P_INTERFACE,		"P2P Interface",
+		ATTR_CUSTOM,	{ .function = print_p2p_interface } },
+	{ P2P_ATTR_OPERATING_CHANNEL,		"Operating Channel",
+		ATTR_CUSTOM,	{ .function = print_p2p_oper_channel } },
+	{ P2P_ATTR_INVITATION_FLAGS,		"Invitation Flags",
+		ATTR_CUSTOM,	{ .function = print_p2p_invite_flags } },
+	{ P2P_ATTR_OOB_GO_NEGOTIATION_CHANNEL,	"Out-of-Band Group Owner "
+		"Negotiation Channel",
+		ATTR_CUSTOM,	{ .function = print_p2p_oob_neg_channel } },
+	{ P2P_ATTR_SVC_HASH,			"Service Hash",
+		ATTR_CUSTOM,	{ .function = print_p2p_service_hash } },
+	{ P2P_ATTR_SESSION_INFO_DATA_INFO,	"Session Information Data Info",
+		ATTR_CUSTOM,	{ .function = print_wsc_bytes } },
+	{ P2P_ATTR_CONNECTION_CAPABILITY_INFO,	"Connection Capability Info",
+		ATTR_CUSTOM,	{ .function = print_p2p_connection_caps } },
+	{ P2P_ATTR_ADVERTISEMENT_ID_INFO,	"Advertisement_ID Info",
+		ATTR_CUSTOM,	{ .function = print_p2p_advertisement_id } },
+	{ P2P_ATTR_ADVERTISED_SVC_INFO,		"Advertised Service Info",
+		ATTR_CUSTOM,	{ .function = print_p2p_advertised_svc_info } },
+	{ P2P_ATTR_SESSION_ID_INFO,		"Session ID Info",
+		ATTR_CUSTOM,	{ .function = print_p2p_session_id } },
+	{ P2P_ATTR_FEATURE_CAPABILITY,		"Feature Capability",
+		ATTR_CUSTOM,	{ .function = print_p2p_feature_caps } },
+	{ P2P_ATTR_PERSISTENT_GROUP_INFO,	"Persistent Group Info",
+		ATTR_CUSTOM,	{ .function = print_p2p_group_id } },
+	{ P2P_ATTR_VENDOR_SPECIFIC_ATTR,	"Vendor specific attribute",
+		ATTR_CUSTOM,	{ .function = print_wsc_bytes } },
+	{ },
+};
+
+static void print_p2p_attributes(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	struct p2p_attr_iter iter;
+	int i;
+
+	print_attr(level, "%s: len %u", label, size);
+
+	p2p_attr_iter_init(&iter, data, size);
+
+	while (p2p_attr_iter_next(&iter)) {
+		uint16_t type = p2p_attr_iter_get_type(&iter);
+		uint16_t len = p2p_attr_iter_get_length(&iter);
+		const void *attr = p2p_attr_iter_get_data(&iter);
+		struct attr_entry *entry = NULL;
+
+		for (i = 0; p2p_attr_entry[i].str; i++) {
+			if (p2p_attr_entry[i].attr == type) {
+				entry = &p2p_attr_entry[i];
+				break;
+			}
+		}
+
+		if (entry && entry->function)
+			entry->function(level + 1, entry->str, attr, len);
+		else {
+			print_attr(level + 1, "Type: 0x%02x: len %u",
+								type, len);
+			print_hexdump(level + 2, attr, len);
+		}
+	}
+}
+
+static void print_management_ies(unsigned int level, const char *label,
+					const void *data, uint16_t size)
+{
+	void *wsc_data, *p2p_data;
+	ssize_t wsc_len, p2p_len;
+
+	print_ie(level, label, data, size);
+
+	wsc_data = ie_tlv_extract_wsc_payload(data, size, &wsc_len);
+	if (wsc_data) {
+		print_wsc_attributes(level + 1, "WSC Payload",
+					wsc_data, wsc_len);
+		l_free(wsc_data);
+	}
+
+	p2p_data = ie_tlv_extract_p2p_payload(data, size, &p2p_len);
+	if (p2p_data) {
+		print_p2p_attributes(level + 1, "P2P Attributes",
+					p2p_data, p2p_len);
+		l_free(p2p_data);
+	}
+}
+
+static void print_address(unsigned int level, const char *label,
+					const unsigned char address[6])
+{
+	char addr[18];
+
+	snprintf(addr, sizeof(addr), "%02X:%02X:%02X:%02X:%02X:%02X",
+					address[0], address[1], address[2],
+					address[3], address[4], address[5]);
+
+	print_attr(level, "%s %s", label, addr);
 }
 
 static void print_reason_code(unsigned int level, const char *label,
@@ -2636,6 +3649,335 @@ static void print_deauthentication_mgmt_frame(unsigned int level,
 				L_LE16_TO_CPU(body->reason_code));
 }
 
+static void print_p2p_public_action_frame(unsigned int level,
+						const uint8_t *body,
+						size_t body_len)
+{
+	const char *subtype;
+
+	/* P2P v1.7 Table 60 */
+	static const char *p2p_public_table[] = {
+		[0] = "GO Negotiation Request",
+		[1] = "GO Negotiation Response",
+		[2] = "GO Negotiation Confirmation",
+		[3] = "P2P Invitation Request",
+		[4] = "P2P Invitation Response",
+		[5] = "Device Discoverability Request",
+		[6] = "Device Discoverability Response",
+		[7] = "Provision Discovery Request",
+		[8] = "Provision Discovery Response",
+	};
+
+	if (body_len < 2)
+		return;
+
+	if (body[1] < L_ARRAY_SIZE(p2p_public_table) &&
+			p2p_public_table[body[0]])
+		subtype = p2p_public_table[body[0]];
+	else
+		subtype = "Unknown";
+
+	print_attr(level, "OUI Type: P2P public action frame");
+	print_attr(level, "OUI Subtype: %s (%u)", subtype, body[0]);
+	print_attr(level + 1, "Dialog Token: %u", body[1]);
+
+	print_management_ies(level, "IEs", body + 2, body_len - 2);
+}
+
+static void print_p2p_action_frame(unsigned int level, const uint8_t *body,
+					size_t body_len)
+{
+	const char *subtype;
+
+	/* P2P v1.7 Table 74 */
+	static const char *p2p_action_table[] = {
+		[0] = "Notice of Absence",
+		[1] = "P2P Presence Request",
+		[2] = "P2P Presence Response",
+		[3] = "GO Discoverability Request",
+	};
+
+	if (body_len < 2)
+		return;
+
+	if (body[1] < L_ARRAY_SIZE(p2p_action_table) &&
+			p2p_action_table[body[0]])
+		subtype = p2p_action_table[body[0]];
+	else
+		subtype = "Unknown";
+
+	print_attr(level, "OUI Type: P2P action frame");
+	print_attr(level, "OUI Subtype: %s (%u)", subtype, body[0]);
+	print_attr(level + 1, "Dialog Token: %u", body[1]);
+
+	print_management_ies(level, "IEs", body + 2, body_len - 2);
+}
+
+static void print_anqp_frame(unsigned int level, const uint8_t *anqp,
+				size_t anqp_len)
+{
+	struct anqp_iter iter;
+	uint16_t id, len;
+	const void *data;
+
+	static const char *anqp_elements[] = {
+		[ANQP_QUERY_LIST] = "Query List",
+		[ANQP_CAPABILITY_LIST] = "Capability List",
+		[ANQP_VENUE_NAME] = "Venue Name",
+		[ANQP_EMERGENCY_CALL_NUMBER] = "Emergency Call Number",
+		[ANQP_NETWORK_AUTH_TYPE] = "Network Authentication Type",
+		[ANQP_ROAMING_CONSORTIUM] = "Roaming Consortium",
+		[ANQP_IP_ADDRESS_TYPE_AVAILABILITY] = "IP Address type avail",
+		[ANQP_NAI_REALM] = "NAI Realm",
+		[ANQP_3GPP_CELLULAR_NETWORK] = "3GPP Cellular Network",
+		[ANQP_AP_GEOSPATIAL_LOCATION] = "AP Geospatial location",
+		[ANQP_AP_CIVIC_LOCATION] = "AP Civic Location",
+		[ANQP_AP_LOCATION_PUBLIC_ID] = "AP Location Public ID",
+		[ANQP_DOMAIN_NAME] = "Domain Name",
+		[ANQP_EMERGENCY_ALERT_ID_URI] = "Emergency Alery ID URI",
+		[ANQP_TDLS_CAPABILITY] = "TDLS Capability",
+		[ANQP_EMERGENCY_NAI] = "Emergency NAI",
+		[ANQP_NEIGHBOR_REPORT] = "Neighbor Report",
+		[ANQP_VENUE_URI] = "Venue URI",
+		[ANQP_ADVICE_OF_CHARGE] = "Advice of Charge",
+		[ANQP_LOCAL_CONTENT] = "Local Content",
+		[ANQP_NETWORK_AUTH_TYPE_WITH_TIMESTAMP] =
+					"Network Auth Type with Timestamp",
+		[ANQP_VENDOR_SPECIFIC] = "Vendor Specific"
+	};
+
+	anqp_iter_init(&iter, anqp, anqp_len);
+
+	while (anqp_iter_next(&iter, &id, &len, &data)) {
+		const char *str;
+		char **nai_realms;
+		int i;
+
+		if (id >= L_ARRAY_SIZE(anqp_elements) || id < ANQP_QUERY_LIST)
+			str = "Unknown";
+		else
+			str = anqp_elements[id];
+
+		print_attr(level, "ANQP ID: %s, Len: %u", str, len);
+
+		switch (id) {
+		case ANQP_NAI_REALM:
+			nai_realms = anqp_parse_nai_realms(data, len);
+			if (!nai_realms) {
+				print_attr(level + 1, "bad NAI Realm data");
+				break;
+			}
+
+			for (i = 0; nai_realms[i]; i++)
+				print_attr(level + 2, "Realm[%u] %s", i,
+						nai_realms[i]);
+
+			l_strv_free(nai_realms);
+
+			break;
+		default:
+			print_hexdump(level + 1, anqp + 4, len);
+		}
+	}
+}
+
+static void print_public_action_frame(unsigned int level, const uint8_t *body,
+					size_t body_len)
+{
+	const char *category;
+	const uint8_t *oui = body + 1;
+
+	/* 802.11-2016, Table 9-307 */
+	static const char *public_action_table[] = {
+		[0] = "20/40 BSS Coexistence Management",
+		[1] = "DSE enablement",
+		[2] = "DSE deenablement",
+		[3] = "DSE Registered Location Announcement",
+		[4] = "Extended Channel Switch Announcement",
+		[5] = "DSE measurement request",
+		[6] = "DSE measurement report",
+		[7] = "Measurement Pilot",
+		[8] = "DSE power constraint",
+		[9] = "Vendor-specific",
+		[10] = "GAS Initial Request",
+		[11] = "GAS Initial Response",
+		[12] = "GAS Comeback Request",
+		[13] = "GAS Comeback Response",
+		[14] = "TDLS Discovery Response",
+		[15] = "Location Track Notification",
+		[16] = "QAB Request frame",
+		[17] = "QAB Response frame",
+		[18] = "QMF Policy",
+		[19] = "QMF Policy Change",
+		[20] = "QLoad Request",
+		[21] = "QLoad Report",
+		[22] = "HCCA TXOP Advertisement",
+		[23] = "HCCA TXOP Response",
+		[24] = "Public Key",
+		[25] = "Channel Availabilty Query",
+		[26] = "Channel Schedule Management",
+		[27] = "Contact Verification Signal",
+		[28] = "GDD Enablement Request",
+		[29] = "GDD Enablement Response",
+		[30] = "Network Channel Control",
+		[31] = "White Space Map Announcement",
+		[32] = "Fine Timing Measurement Request",
+		[33] = "Fine Timing Measurement",
+	};
+
+	if (body_len < 1)
+		return;
+
+	if (body[0] < L_ARRAY_SIZE(public_action_table) &&
+			public_action_table[body[0]])
+		category = public_action_table[body[0]];
+	else
+		category = "Unknown";
+
+	print_attr(level, "Public Action: %s (%u)", category, body[0]);
+
+	if (body_len < 5)
+		return;
+
+	if (!memcmp(oui, wsc_wfa_oui, 3) && oui[3] == 0x09) {
+		if (body[0] != 9)
+			return;
+
+		if (!print_oui(level, oui))
+			return;
+
+		print_p2p_public_action_frame(level + 1, body + 5,
+						body_len - 5);
+	} else if (body[0] == 0x0a) {
+		if (body_len < 9)
+			return;
+
+		if (body[2] != IE_TYPE_ADVERTISEMENT_PROTOCOL)
+			return;
+
+		if (body[5] != IE_ADVERTISEMENT_ANQP)
+			return;
+
+		if (body_len < l_get_le16(body + 6) + 8u)
+			return;
+
+		print_anqp_frame(level + 1, body + 8, l_get_le16(body + 6));
+	} else if (body[0] == 0x0b) {
+		if (body_len < 10)
+			return;
+
+		print_attr(level + 1, "Dialog Token: %u", body[1]);
+		print_attr(level + 1, "Status: %u", l_get_le16(body + 2));
+		print_attr(level + 1, "Delay: %u", l_get_le16(body + 4));
+
+		if (body[6] != IE_TYPE_ADVERTISEMENT_PROTOCOL)
+			return;
+
+		if (body_len < body[7] + 7u)
+			return;
+
+		if (body_len < l_get_le16(body + 8 + body[7]) + 10u)
+			return;
+
+		print_anqp_frame(level + 1, body + 10 + body[7],
+					l_get_le16(body + 8 + body[7]));
+	}
+}
+
+static void print_rm_action_frame(unsigned int level, const uint8_t *body,
+					size_t body_len)
+{
+	const char *category;
+
+	/* 802.11-2016, Table 9-306 */
+	static const char *rm_action_table[] = {
+		[0] = "Radio Measurement Request",
+		[1] = "Radio Measurement Report",
+		[2] = "Link Measurement Request",
+		[3] = "Link Measurement Report",
+		[4] = "Neighbor Report Request",
+		[5] = "Neighbor Report Response",
+	};
+
+	if (body_len < 1)
+		return;
+
+	if (body[0] < L_ARRAY_SIZE(rm_action_table) && rm_action_table[body[0]])
+		category = rm_action_table[body[0]];
+	else
+		category = "Unknown";
+
+	print_attr(level, "Radio Measurement Action: %s (%u)", category, body[0]);
+}
+
+static void print_action_mgmt_frame(unsigned int level,
+					const struct mmpdu_header *mmpdu,
+					size_t total_len, bool no_ack)
+{
+	const uint8_t *body;
+	size_t body_len;
+	const char *category;
+
+	/* 802.11-2016, Table 9-47 */
+	static const char *category_table[] = {
+		[0] = "Sepctrum Management",
+		[1] = "QoS",
+		[2] = "DLS",
+		[3] = "Block Ack",
+		[4] = "Public",
+		[5] = "Radio Measurement",
+		[6] = "Fast BSS Transition",
+		[7] = "HT",
+		[8] = "SA Query",
+		[9] = "Protected Dual of Public Action",
+		[10] = "WNM",
+		[11] = "Unprotected WNM",
+		[12] = "TDLS",
+		[13] = "Mesh",
+		[14] = "Multihop",
+		[15] = "Self-protected",
+		[16] = "DMG",
+		[18] = "Fast Session Transfer",
+		[19] = "Robust AV Streaming",
+		[20] = "Unprotected DMG",
+		[21] = "VHT",
+		[126] = "Vendor-specific Protected",
+		[127] = "Vendor-specific",
+		[128 ... 255] = "Error",
+	};
+
+	body = mmpdu_body(mmpdu);
+	body_len = total_len - (body - (uint8_t *) mmpdu);
+
+	if (category_table[body[0]])
+		category = category_table[body[0]];
+	else
+		category = "Unknown";
+
+	print_attr(level, "Subtype: Action%s", no_ack ? " No Ack" : "");
+	print_attr(level, "Action Category: %s (%u)", category, body[0]);
+
+	if (body[0] == 4) {
+		print_public_action_frame(level, body + 1, body_len - 1);
+		return;
+	} else if (body[0] == 5) {
+		print_rm_action_frame(level, body + 1, body_len - 1);
+		return;
+	} else if ((body[0] == 126 || body[0] == 127) && body_len >= 5) {
+		const uint8_t *oui = body + 1;
+
+		if (!print_oui(level, oui))
+			return;
+
+		if (!memcmp(oui, wsc_wfa_oui, 3) && oui[3] == 0x09)
+			print_p2p_action_frame(level + 1, body + 5,
+						body_len - 5);
+	}
+
+	print_mpdu_frame_control(level + 1, &mmpdu->fc);
+	print_mmpdu_header(level + 1, mmpdu);
+}
+
 static void print_frame_type(unsigned int level, const char *label,
 					const void *data, uint16_t size)
 {
@@ -2705,10 +4047,14 @@ static void print_frame_type(unsigned int level, const char *label,
 			str = "Deauthentication";
 		break;
 	case 0x0d:
-		str = "Action";
-		break;
 	case 0x0e:
-		str = "Action No Ack";
+		if (mpdu)
+			print_action_mgmt_frame(level + 1, mpdu, size,
+						subtype == 0x0e);
+		else if (subtype == 0x0d)
+			str = "Action";
+		else
+			str = "Action No Ack";
 		break;
 	default:
 		str = "Reserved";
@@ -3030,127 +4376,6 @@ static const struct attr_entry rekey_table[] = {
 #define NLA_DATA(nla)		((void*)(((char*)(nla)) + NLA_LENGTH(0)))
 #define NLA_PAYLOAD(nla)	((int)((nla)->nla_len - NLA_LENGTH(0)))
 
-static const struct {
-	uint8_t cmd;
-	const char *str;
-} cmd_table[] = {
-	{ NL80211_CMD_GET_WIPHY,		"Get Wiphy"		},
-	{ NL80211_CMD_SET_WIPHY,		"Set Wiphy"		},
-	{ NL80211_CMD_NEW_WIPHY,		"New Wiphy"		},
-	{ NL80211_CMD_DEL_WIPHY,		"Del Wiphy"		},
-	{ NL80211_CMD_GET_INTERFACE,		"Get Interface"		},
-	{ NL80211_CMD_SET_INTERFACE,		"Set Interface"		},
-	{ NL80211_CMD_NEW_INTERFACE,		"New Interface"		},
-	{ NL80211_CMD_DEL_INTERFACE,		"Del Interface"		},
-	{ NL80211_CMD_GET_KEY,			"Get Key"		},
-	{ NL80211_CMD_SET_KEY,			"Set Key"		},
-	{ NL80211_CMD_NEW_KEY,			"New Key"		},
-	{ NL80211_CMD_DEL_KEY,			"Del Key"		},
-	{ NL80211_CMD_GET_BEACON,		"Get Beacon"		},
-	{ NL80211_CMD_SET_BEACON,		"Set Beacon"		},
-	{ NL80211_CMD_START_AP,			"Start AP"		},
-	{ NL80211_CMD_STOP_AP,			"Stop AP"		},
-	{ NL80211_CMD_GET_STATION,		"Get Station"		},
-	{ NL80211_CMD_SET_STATION,		"Set Station"		},
-	{ NL80211_CMD_NEW_STATION,		"New Station"		},
-	{ NL80211_CMD_DEL_STATION,		"Del Station"		},
-	{ NL80211_CMD_GET_MPATH,		"Get Mesh Path"		},
-	{ NL80211_CMD_SET_MPATH,		"Set Mesh Path"		},
-	{ NL80211_CMD_NEW_MPATH,		"New Mesh Path"		},
-	{ NL80211_CMD_DEL_MPATH,		"Del Mesh Path"		},
-	{ NL80211_CMD_SET_BSS,			"Set BSS"		},
-	{ NL80211_CMD_SET_REG,			"Set Reg"		},
-	{ NL80211_CMD_REQ_SET_REG,		"Req Set Reg"		},
-	{ NL80211_CMD_GET_MESH_CONFIG,		"Get Mesh Config"	},
-	{ NL80211_CMD_SET_MESH_CONFIG,		"Set Mesh Config"	},
-	{ NL80211_CMD_SET_MGMT_EXTRA_IE,	"Mgmt Extra IE"		},
-	{ NL80211_CMD_GET_REG,			"Get Reg"		},
-	{ NL80211_CMD_GET_SCAN,			"Get Scan"		},
-	{ NL80211_CMD_TRIGGER_SCAN,		"Trigger Scan"		},
-	{ NL80211_CMD_NEW_SCAN_RESULTS,		"New Scan Results"	},
-	{ NL80211_CMD_SCAN_ABORTED,		"Scan Aborted"		},
-	{ NL80211_CMD_REG_CHANGE,		"Reg Change"		},
-	{ NL80211_CMD_AUTHENTICATE,		"Authenticate"		},
-	{ NL80211_CMD_ASSOCIATE,		"Associate"		},
-	{ NL80211_CMD_DEAUTHENTICATE,		"Deauthenticate"	},
-	{ NL80211_CMD_DISASSOCIATE,		"Disassociate"		},
-	{ NL80211_CMD_MICHAEL_MIC_FAILURE,	"Michael MIC Failure"	},
-	{ NL80211_CMD_REG_BEACON_HINT,		"Reg Beacon Hint"	},
-	{ NL80211_CMD_JOIN_IBSS,		"Join IBSS"		},
-	{ NL80211_CMD_LEAVE_IBSS,		"Leave IBSS"		},
-	{ NL80211_CMD_TESTMODE,			"Test Mode"		},
-	{ NL80211_CMD_CONNECT,			"Connect"		},
-	{ NL80211_CMD_ROAM,			"Roam"			},
-	{ NL80211_CMD_DISCONNECT,		"Disconnect"		},
-	{ NL80211_CMD_SET_WIPHY_NETNS,		"Set Wiphy Netns"	},
-	{ NL80211_CMD_GET_SURVEY,		"Get Survey"		},
-	{ NL80211_CMD_NEW_SURVEY_RESULTS,	"New Survey Results"	},
-	{ NL80211_CMD_SET_PMKSA,		"Set PMKSA"		},
-	{ NL80211_CMD_DEL_PMKSA,		"Del PMKSA"		},
-	{ NL80211_CMD_FLUSH_PMKSA,		"Flush PMKSA"		},
-	{ NL80211_CMD_REMAIN_ON_CHANNEL,	"Remain on Channel"	},
-	{ NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,	"Cancel Remain on Channel"},
-	{ NL80211_CMD_SET_TX_BITRATE_MASK,	"Set TX Bitrate Mask"	},
-	{ NL80211_CMD_REGISTER_FRAME,		"Register Frame"	},
-	{ NL80211_CMD_FRAME,			"Frame"			},
-	{ NL80211_CMD_FRAME_TX_STATUS,		"Frame TX Status"	},
-	{ NL80211_CMD_SET_POWER_SAVE,		"Set Power Save"	},
-	{ NL80211_CMD_GET_POWER_SAVE,		"Get Power Save"	},
-	{ NL80211_CMD_SET_CQM,			"Set CQM"		},
-	{ NL80211_CMD_NOTIFY_CQM,		"Notify CQM"		},
-	{ NL80211_CMD_SET_CHANNEL,		"Set Channel"		},
-	{ NL80211_CMD_SET_WDS_PEER,		"Set WDS Peer"		},
-	{ NL80211_CMD_FRAME_WAIT_CANCEL,	"Frame Wait Cancel"	},
-	{ NL80211_CMD_JOIN_MESH,		"Join Mesh"		},
-	{ NL80211_CMD_LEAVE_MESH,		"Leave Mesh"		},
-	{ NL80211_CMD_UNPROT_DEAUTHENTICATE,	"Unprot Deauthenticate"	},
-	{ NL80211_CMD_UNPROT_DISASSOCIATE,	"Unprot Disassociate"	},
-	{ NL80211_CMD_NEW_PEER_CANDIDATE,	"New Peer Candidate"	},
-	{ NL80211_CMD_GET_WOWLAN,		"Get WoWLAN"		},
-	{ NL80211_CMD_SET_WOWLAN,		"Set WoWLAN"		},
-	{ NL80211_CMD_START_SCHED_SCAN,		"Start Sched Scan"	},
-	{ NL80211_CMD_STOP_SCHED_SCAN,		"Stop Sched Scan"	},
-	{ NL80211_CMD_SCHED_SCAN_RESULTS,	"Sched Scan Results"	},
-	{ NL80211_CMD_SCHED_SCAN_STOPPED,	"Sched Scan Stopped"	},
-	{ NL80211_CMD_SET_REKEY_OFFLOAD,	"Set Rekey Offload"	},
-	{ NL80211_CMD_PMKSA_CANDIDATE,		"PMKSA Candidate"	},
-	{ NL80211_CMD_TDLS_OPER,		"TDLS Oper"		},
-	{ NL80211_CMD_TDLS_MGMT,		"TDLS Mgmt"		},
-	{ NL80211_CMD_UNEXPECTED_FRAME,		"Unexpected Frame"	},
-	{ NL80211_CMD_PROBE_CLIENT,		"Probe Client"		},
-	{ NL80211_CMD_REGISTER_BEACONS,		"Register Beacons"	},
-	{ NL80211_CMD_UNEXPECTED_4ADDR_FRAME,	"Unexpected 4addr Frame"},
-	{ NL80211_CMD_SET_NOACK_MAP,		"Set NoAck Map"		},
-	{ NL80211_CMD_CH_SWITCH_NOTIFY,		"Channel Switch Notify"	},
-	{ NL80211_CMD_START_P2P_DEVICE,		"Start P2P Device"	},
-	{ NL80211_CMD_STOP_P2P_DEVICE,		"Stop P2P Device"	},
-	{ NL80211_CMD_CONN_FAILED,		"Conn Failed"		},
-	{ NL80211_CMD_SET_MCAST_RATE,		"Set Mcast Rate"	},
-	{ NL80211_CMD_SET_MAC_ACL,		"Set MAC ACL"		},
-	{ NL80211_CMD_RADAR_DETECT,		"Radar Detect"		},
-	{ NL80211_CMD_GET_PROTOCOL_FEATURES,	"Get Protocol Features"	},
-	{ NL80211_CMD_UPDATE_FT_IES,		"Update FT IEs"		},
-	{ NL80211_CMD_FT_EVENT,			"FT Event"		},
-	{ NL80211_CMD_CRIT_PROTOCOL_START,	"Crit Protocol Start"	},
-	{ NL80211_CMD_CRIT_PROTOCOL_STOP,	"Crit Protocol Stop"	},
-	{ NL80211_CMD_GET_COALESCE,		"Get Coalesce"		},
-	{ NL80211_CMD_SET_COALESCE,		"Set Coalesce"		},
-	{ NL80211_CMD_CHANNEL_SWITCH,		"Channel Switch"	},
-	{ NL80211_CMD_VENDOR,			"Vendor"		},
-	{ NL80211_CMD_SET_QOS_MAP,		"Set QoS Map"		},
-	{ NL80211_CMD_ADD_TX_TS,		"Add Traffic Stream"	},
-	{ NL80211_CMD_DEL_TX_TS,		"Delete Traffic Stream" },
-	{ NL80211_CMD_GET_MPP,			"Get Mesh Proxy Path"	},
-	{ NL80211_CMD_JOIN_OCB,			"Join OCB Network"	},
-	{ NL80211_CMD_LEAVE_OCB,		"Leave OCB Network"	},
-	{ NL80211_CMD_CH_SWITCH_STARTED_NOTIFY, "Channel Switch Notify"	},
-	{ NL80211_CMD_TDLS_CHANNEL_SWITCH,	"TDLS Channel Switch"	},
-	{ NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH,
-						"Cancel TLDS Channel Switch" },
-	{ NL80211_CMD_WIPHY_REG_CHANGE,		"Wiphy Reg Change"	},
-	{ }
-};
-
 static void print_supported_commands(unsigned int level, const char *label,
 					const void *data, uint16_t size)
 {
@@ -3159,18 +4384,10 @@ static void print_supported_commands(unsigned int level, const char *label,
 	print_attr(level, "%s:", label);
 
 	for (nla = data; NLA_OK(nla, size); nla = NLA_NEXT(nla, size)) {
-		const char *cmd_str = "Reserved";
 		uint32_t cmd = *((uint32_t *) NLA_DATA(nla));
-		unsigned int i;
 
-		for (i = 0; cmd_table[i].str; i++) {
-			if (cmd_table[i].cmd == cmd) {
-				cmd_str = cmd_table[i].str;
-				break;
-			}
-		}
-
-		print_attr(level + 1, "%s [%d]", cmd_str, cmd);
+		print_attr(level + 1, "%s [%d]",
+					nl80211cmd_to_string(cmd), cmd);
 	}
 }
 
@@ -3598,7 +4815,8 @@ static const struct attr_entry attr_table[] = {
 	{ NL80211_ATTR_ACL_POLICY,
 			"ACL Policy", ATTR_U32 },
 	{ NL80211_ATTR_MAC_ADDRS,
-			"MAC Addresses" },
+			"MAC Addresses", ATTR_ARRAY,
+					{ .array_type = ATTR_ADDRESS } },
 	{ NL80211_ATTR_MAC_ACL_MAX,
 			"MAC ACL Max" },
 	{ NL80211_ATTR_RADAR_EVENT,
@@ -3680,10 +4898,72 @@ static const struct attr_entry attr_table[] = {
 			"CSA C Offsets TX" },
 	{ NL80211_ATTR_MAX_CSA_COUNTERS,
 			"Max CSA Counters" },
+	{ NL80211_ATTR_TDLS_INITIATOR,
+			"TDLS Initiator" },
+	{ NL80211_ATTR_USE_RRM,
+			"Use RRM", ATTR_FLAG },
+	{ NL80211_ATTR_EXT_FEATURES,
+			"Extended Features" },
 	{ NL80211_ATTR_FILS_KEK,
 			"FILS KEK" },
 	{ NL80211_ATTR_FILS_NONCES,
 			"FILS Nonces" },
+	{ NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED,
+			"Multicast to Unicast Enabled", ATTR_FLAG },
+	{ NL80211_ATTR_BSSID,
+			"BSSID", ATTR_ADDRESS },
+	{ NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI,
+			"Scheduled Scan Relative RSSI" },
+	{ NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST,
+			"Scheduled Scan RSSI Adjust" },
+	{ NL80211_ATTR_TIMEOUT_REASON,
+			"Timeout Reason" },
+	{ NL80211_ATTR_FILS_ERP_USERNAME,
+			"FILS ERP Username" },
+	{ NL80211_ATTR_FILS_ERP_REALM,
+			"FILS ERP Realm" },
+	{ NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM,
+			"FILS ERP Next Sequence Number" },
+	{ NL80211_ATTR_FILS_ERP_RRK,
+			"FILS ERP RRK" },
+	{ NL80211_ATTR_FILS_CACHE_ID,
+			"FILS Cache ID" },
+	{ NL80211_ATTR_PMK,
+			"PMK" },
+	{ NL80211_ATTR_SCHED_SCAN_MULTI,
+			"Scheduled Scan Multi" },
+	{ NL80211_ATTR_SCHED_SCAN_MAX_REQS,
+			"Scheduled Scan Maximum Requests" },
+	{ NL80211_ATTR_WANT_1X_4WAY_HS,
+			"Want 1X 4Way Handshake" },
+	{ NL80211_ATTR_PMKR0_NAME,
+			"PMKR0 Name" },
+	{ NL80211_ATTR_PORT_AUTHORIZED,
+			"Port Authorized" },
+	{ NL80211_ATTR_EXTERNAL_AUTH_ACTION,
+			"External Auth Action" },
+	{ NL80211_ATTR_EXTERNAL_AUTH_SUPPORT,
+			"External Auth Support" },
+	{ NL80211_ATTR_NSS,
+			"NSS" },
+	{ NL80211_ATTR_ACK_SIGNAL,
+			"Ack Signal" },
+	{ NL80211_ATTR_CONTROL_PORT_OVER_NL80211,
+			"Control Port over NL80211", ATTR_FLAG },
+	{ NL80211_ATTR_TXQ_STATS,
+			"TXQ Stats" },
+	{ NL80211_ATTR_TXQ_LIMIT,
+			"TXQ Limit" },
+	{ NL80211_ATTR_TXQ_MEMORY_LIMIT,
+			"TXQ Memory Limit" },
+	{ NL80211_ATTR_TXQ_QUANTUM,
+			"TXQ Quantum" },
+	{ NL80211_ATTR_HE_CAPABILITY,
+			"HE Capability" },
+	{ NL80211_ATTR_FTM_RESPONDER,
+			"FTM Responder" },
+	{ NL80211_ATTR_FTM_RESPONDER_STATS,
+			"FTM Responder Stats" },
 	{ }
 };
 
@@ -3706,6 +4986,9 @@ static void print_value(int indent, const char *label, enum attr_type type,
 		if (len != 4)
 			printf("malformed packet\n");
 		break;
+	case ATTR_ADDRESS:
+		print_address(indent, label, buf);
+		break;
 	case ATTR_UNSPEC:
 	case ATTR_FLAG:
 	case ATTR_U8:
@@ -3714,7 +4997,6 @@ static void print_value(int indent, const char *label, enum attr_type type,
 	case ATTR_S32:
 	case ATTR_S64:
 	case ATTR_STRING:
-	case ATTR_ADDRESS:
 	case ATTR_BINARY:
 	case ATTR_NESTED:
 	case ATTR_ARRAY:
@@ -4078,7 +5360,6 @@ static void print_message(struct nlmon *nlmon, const struct timeval *tv,
 	const char *color = COLOR_OFF;
 	const char *cmd_str;
 	bool out = false;
-	int i;
 
 	if (nlmon->nowiphy && (cmd == NL80211_CMD_NEW_WIPHY))
 		return;
@@ -4111,14 +5392,7 @@ static void print_message(struct nlmon *nlmon, const struct timeval *tv,
 		break;
 	}
 
-	cmd_str = "Reserved";
-
-	for (i = 0; cmd_table[i].str; i++) {
-		if (cmd_table[i].cmd == cmd) {
-			cmd_str = cmd_table[i].str;
-			break;
-		}
-	}
+	cmd_str = nl80211cmd_to_string(cmd);
 
 	netlink_str(extra_str, sizeof(extra_str), cmd, flags, len);
 
diff --git a/src/adhoc.c b/src/adhoc.c
index ec89bc34..01d02c52 100644
--- a/src/adhoc.c
+++ b/src/adhoc.c
@@ -38,12 +38,12 @@
 #include "src/eapol.h"
 #include "src/handshake.h"
 #include "src/mpdu.h"
-#include "src/adhoc.h"
 #include "src/dbus.h"
 #include "src/nl80211util.h"
 
 struct adhoc_state {
 	struct netdev *netdev;
+	struct l_genl_family *nl80211;
 	char *ssid;
 	uint8_t pmk[32];
 	struct l_queue *sta_states;
@@ -72,7 +72,6 @@ struct sta_state {
 	bool authenticated : 1;
 };
 
-static struct l_genl_family *nl80211 = NULL;
 static uint32_t netdev_watch;
 
 static void adhoc_sta_free(void *data)
@@ -83,7 +82,8 @@ static void adhoc_sta_free(void *data)
 		goto end;
 
 	if (sta->gtk_query_cmd_id)
-		l_genl_family_cancel(nl80211, sta->gtk_query_cmd_id);
+		l_genl_family_cancel(sta->adhoc->nl80211,
+						sta->gtk_query_cmd_id);
 
 	if (sta->sm)
 		eapol_sm_free(sta->sm);
@@ -109,7 +109,8 @@ static void adhoc_remove_sta(struct sta_state *sta)
 	}
 
 	if (sta->gtk_query_cmd_id) {
-		l_genl_family_cancel(nl80211, sta->gtk_query_cmd_id);
+		l_genl_family_cancel(sta->adhoc->nl80211,
+						sta->gtk_query_cmd_id);
 		sta->gtk_query_cmd_id = 0;
 	}
 
@@ -227,8 +228,8 @@ static struct eapol_sm *adhoc_new_sm(struct sta_state *sta, bool authenticator,
 	handshake_state_set_event_func(hs, adhoc_handshake_event, sta);
 	handshake_state_set_ssid(hs, (void *)adhoc->ssid, strlen(adhoc->ssid));
 	/* we dont have the connecting peer rsn info, so just set ap == own */
-	handshake_state_set_authenticator_rsn(hs, bss_rsne);
-	handshake_state_set_supplicant_rsn(hs, bss_rsne);
+	handshake_state_set_authenticator_ie(hs, bss_rsne);
+	handshake_state_set_supplicant_ie(hs, bss_rsne);
 	handshake_state_set_pmk(hs, adhoc->pmk, 32);
 
 	if (authenticator) {
@@ -251,7 +252,6 @@ static struct eapol_sm *adhoc_new_sm(struct sta_state *sta, bool authenticator,
 	}
 
 	eapol_sm_set_listen_interval(sm, 100);
-	eapol_sm_set_protocol_version(sm, EAPOL_PROTOCOL_VERSION_2004);
 
 	if (authenticator)
 		sta->hs_auth = hs;
@@ -264,6 +264,7 @@ static struct eapol_sm *adhoc_new_sm(struct sta_state *sta, bool authenticator,
 static void adhoc_free(struct adhoc_state *adhoc)
 {
 	adhoc_reset(adhoc);
+	l_genl_family_free(adhoc->nl80211);
 	l_free(adhoc);
 }
 
@@ -358,8 +359,8 @@ static void adhoc_new_station(struct adhoc_state *adhoc, const uint8_t *mac)
 					adhoc->gtk, gtk_len, NULL,
 					0, NULL);
 
-		if (!l_genl_family_send(nl80211, msg, adhoc_gtk_op_cb, NULL,
-					NULL)) {
+		if (!l_genl_family_send(adhoc->nl80211, msg, adhoc_gtk_op_cb,
+					NULL, NULL)) {
 			l_genl_msg_unref(msg);
 			l_error("Issuing NEW_KEY failed");
 			return;
@@ -367,8 +368,8 @@ static void adhoc_new_station(struct adhoc_state *adhoc, const uint8_t *mac)
 
 		msg = nl80211_build_set_key(netdev_get_ifindex(adhoc->netdev),
 						adhoc->gtk_index);
-		if (!l_genl_family_send(nl80211, msg, adhoc_gtk_op_cb, NULL,
-					NULL)) {
+		if (!l_genl_family_send(adhoc->nl80211, msg, adhoc_gtk_op_cb,
+					NULL, NULL)) {
 			l_genl_msg_unref(msg);
 			l_error("Issuing SET_KEY failed");
 			return;
@@ -406,7 +407,7 @@ static void adhoc_new_station(struct adhoc_state *adhoc, const uint8_t *mac)
 	else {
 		msg = nl80211_build_get_key(netdev_get_ifindex(adhoc->netdev),
 					adhoc->gtk_index);
-		sta->gtk_query_cmd_id = l_genl_family_send(nl80211, msg,
+		sta->gtk_query_cmd_id = l_genl_family_send(adhoc->nl80211, msg,
 							adhoc_gtk_query_cb,
 							sta, NULL);
 		if (!sta->gtk_query_cmd_id) {
@@ -651,6 +652,7 @@ static void adhoc_add_interface(struct netdev *netdev)
 	/* just allocate/set device, Start method will complete setup */
 	adhoc = l_new(struct adhoc_state, 1);
 	adhoc->netdev = netdev;
+	adhoc->nl80211 = l_genl_family_new(iwd_get_genl(), NL80211_GENL_NAME);
 
 	/* setup adhoc dbus interface */
 	l_dbus_object_add_interface(dbus_get_bus(),
@@ -682,19 +684,19 @@ static void adhoc_netdev_watch(struct netdev *netdev,
 	}
 }
 
-bool adhoc_init(struct l_genl_family *nl)
+static int adhoc_init(void)
 {
 	netdev_watch = netdev_watch_add(adhoc_netdev_watch, NULL, NULL);
 	l_dbus_register_interface(dbus_get_bus(), IWD_ADHOC_INTERFACE,
 			adhoc_setup_interface, adhoc_destroy_interface, false);
 
-	nl80211 = nl;
-
-	return true;
+	return 0;
 }
 
-void adhoc_exit(void)
+static void adhoc_exit(void)
 {
 	netdev_watch_remove(netdev_watch);
 	l_dbus_unregister_interface(dbus_get_bus(), IWD_ADHOC_INTERFACE);
 }
+
+IWD_MODULE(adhoc, adhoc_init, adhoc_exit)
diff --git a/src/anqp.c b/src/anqp.c
new file mode 100644
index 00000000..b3584b3e
--- /dev/null
+++ b/src/anqp.c
@@ -0,0 +1,539 @@
+/*
+ *
+ *  Wireless daemon for Linux
+ *
+ *  Copyright (C) 2019  Intel Corporation. All rights reserved.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdint.h>
+
+#include <ell/ell.h>
+
+#include "src/anqp.h"
+#include "src/util.h"
+#include "src/eap-private.h"
+#include "src/ie.h"
+#include "src/nl80211util.h"
+#include "src/nl80211cmd.h"
+#include "src/scan.h"
+#include "src/netdev.h"
+#include "src/iwd.h"
+#include "src/mpdu.h"
+#include "src/wiphy.h"
+
+#include "linux/nl80211.h"
+
+struct anqp_request {
+	uint32_t ifindex;
+	anqp_response_func_t anqp_cb;
+	anqp_destroy_func_t anqp_destroy;
+	void *anqp_data;
+	uint64_t anqp_cookie;
+	uint8_t anqp_token;
+};
+
+static struct l_genl_family *nl80211 = NULL;
+
+static struct l_queue *anqp_requests;
+static uint8_t anqp_token = 0;
+
+static uint32_t netdev_watch;
+static uint32_t unicast_watch;
+
+static void anqp_destroy(void *user_data)
+{
+	struct anqp_request *request = user_data;
+
+	if (request->anqp_destroy)
+		request->anqp_destroy(request->anqp_data);
+}
+
+static void netdev_gas_request_cb(struct l_genl_msg *msg, void *user_data)
+{
+	struct anqp_request *request = user_data;
+	struct l_genl_attr attr;
+	uint16_t type, len;
+	const void *data;
+
+	if (l_genl_msg_get_error(msg) != 0)
+		goto error;
+
+	if (!l_genl_attr_init(&attr, msg))
+		return;
+
+	while (l_genl_attr_next(&attr, &type, &len, &data)) {
+		switch (type) {
+		case NL80211_ATTR_COOKIE:
+			if (len != 8)
+				goto error;
+
+			request->anqp_cookie = l_get_u64(data);
+			break;
+		}
+	}
+
+	return;
+
+error:
+	l_debug("Error sending CMD_FRAME (%d)", l_genl_msg_get_error(msg));
+
+	if (request->anqp_cb)
+		request->anqp_cb(ANQP_FAILED, NULL, 0, request->anqp_data);
+
+	if (request->anqp_destroy)
+		request->anqp_destroy(request->anqp_data);
+
+	l_free(request);
+}
+
+static bool match_token(const void *a, const void *b)
+{
+	const struct anqp_request *request = a;
+	const struct token_match {
+		uint32_t ifindex;
+		uint8_t token;
+
+	} *match = b;
+
+	if (request->ifindex != match->ifindex)
+		return false;
+
+	if (request->anqp_token != match->token)
+		return false;
+
+	return true;
+}
+
+static void anqp_response_frame_event(uint32_t ifindex,
+					const struct mmpdu_header *hdr,
+					const void *body, size_t body_len)
+{
+	struct anqp_request *request;
+	const uint8_t *ptr = body;
+	uint16_t status_code;
+	uint16_t delay;
+	uint16_t qrlen;
+	uint8_t adv_proto_len;
+	uint8_t token;
+	struct token_match {
+		uint32_t ifindex;
+		uint8_t token;
+
+	} match;
+
+	if (body_len < 9)
+		return;
+
+	/* Skip past category/action since this frame was prefixed matched */
+	ptr += 2;
+	body_len -= 2;
+
+	/* dialog token */
+	token = *ptr++;
+
+	match.ifindex = ifindex;
+	match.token = token;
+
+	request = l_queue_find(anqp_requests, match_token, &match);
+	if (!request)
+		return;
+
+	status_code = l_get_le16(ptr);
+	ptr += 2;
+	body_len -= 2;
+
+	if (status_code != 0) {
+		l_error("Bad status code on GAS response %u", status_code);
+		return;
+	}
+
+	delay = l_get_le16(ptr);
+	ptr += 2;
+	body_len -= 2;
+
+	/*
+	 * IEEE 80211-2016 Section 9.6.8.13
+	 *
+	 * The value 0 will be returned by the STA when a Query Response is
+	 * provided in this frame
+	 */
+	if (delay != 0) {
+		l_error("GAS comeback delay was not zero");
+		return;
+	}
+
+	if (*ptr != IE_TYPE_ADVERTISEMENT_PROTOCOL) {
+		l_error("GAS request not advertisement protocol");
+		return;
+	}
+
+	ptr++;
+	body_len--;
+
+	adv_proto_len = *ptr++;
+	body_len--;
+
+	if (body_len < adv_proto_len)
+		return;
+
+	ptr += adv_proto_len;
+	body_len -= adv_proto_len;
+
+	if (body_len < 2)
+		return;
+
+	qrlen = l_get_le16(ptr);
+	ptr += 2;
+
+	if (body_len < qrlen)
+		return;
+
+	l_queue_remove(anqp_requests, request);
+
+	l_debug("ANQP response received from "MAC, MAC_STR(hdr->address_2));
+
+	if (request->anqp_cb)
+		request->anqp_cb(ANQP_SUCCESS, ptr, qrlen,
+					request->anqp_data);
+
+	if (request->anqp_destroy)
+		request->anqp_destroy(request->anqp_data);
+
+	l_free(request);
+
+	return;
+}
+
+static void netdev_gas_timeout_cb(void *user_data)
+{
+	struct anqp_request *request = user_data;
+
+	l_debug("GAS request timed out");
+
+	if (request->anqp_cb)
+		request->anqp_cb(ANQP_TIMEOUT, NULL, 0,
+					request->anqp_data);
+
+	/* allows anqp_request to be re-entrant */
+	if (request->anqp_destroy)
+		request->anqp_destroy(request->anqp_data);
+
+	l_queue_remove(anqp_requests, request);
+	l_free(request);
+}
+
+static bool match_cookie(const void *a, const void *b)
+{
+	const struct anqp_request *request = a;
+	const struct cookie_match {
+		uint64_t cookie;
+		uint32_t ifindex;
+	} *match = b;
+
+	if (match->ifindex != request->ifindex)
+		return false;
+
+	if (match->cookie != request->anqp_cookie)
+		return false;
+
+	return true;
+}
+
+static void anqp_frame_wait_cancel_event(struct l_genl_msg *msg,
+						uint32_t ifindex)
+{
+	struct l_genl_attr attr;
+	uint16_t type, len;
+	const void *data;
+	uint64_t cookie = 0;
+	struct anqp_request *request;
+	struct cookie_match {
+		uint64_t cookie;
+		uint32_t ifindex;
+	} match;
+
+	l_debug("");
+
+	if (!l_genl_attr_init(&attr, msg))
+		return;
+
+	while (l_genl_attr_next(&attr, &type, &len, &data)) {
+		switch (type) {
+		case NL80211_ATTR_COOKIE:
+			if (len != 8)
+				return;
+
+			cookie = l_get_u64(data);
+
+			break;
+		}
+	}
+
+	if (!cookie)
+		return;
+
+	match.cookie = cookie;
+	match.ifindex = ifindex;
+
+	request = l_queue_find(anqp_requests, match_cookie, &match);
+	if (!request)
+		return;
+
+	if (cookie != request->anqp_cookie)
+		return;
+
+	netdev_gas_timeout_cb(request);
+}
+
+uint32_t anqp_request(uint32_t ifindex, const uint8_t *addr,
+				struct scan_bss *bss, const uint8_t *anqp,
+				size_t len, anqp_response_func_t cb,
+				void *user_data, anqp_destroy_func_t destroy)
+{
+	struct anqp_request *request;
+	uint8_t frame[512];
+	struct l_genl_msg *msg;
+	struct iovec iov[2];
+	uint32_t id;
+	uint32_t duration = 300;
+	struct netdev *netdev = netdev_find(ifindex);
+
+	/*
+	 * TODO: Netdev dependencies will eventually be removed so we need
+	 * another way to figure out wiphy capabilities.
+	 */
+	if (!wiphy_can_offchannel_tx(netdev_get_wiphy(netdev))) {
+		l_error("ANQP failed, driver does not support offchannel TX");
+		return 0;
+	}
+
+	frame[0] = 0x04;		/* Category: Public */
+	frame[1] = 0x0a;		/* Action: GAS initial Request */
+	frame[2] = anqp_token;		/* Dialog Token */
+	frame[3] = IE_TYPE_ADVERTISEMENT_PROTOCOL;
+	frame[4] = 2;
+	frame[5] = 0x7f;
+	frame[6] = IE_ADVERTISEMENT_ANQP;
+	l_put_le16(len, frame + 7);
+
+	iov[0].iov_base = frame;
+	iov[0].iov_len = 9;
+	iov[1].iov_base = (void *)anqp;
+	iov[1].iov_len = len;
+
+	request = l_new(struct anqp_request, 1);
+
+	request->ifindex = ifindex;
+	request->anqp_cb = cb;
+	request->anqp_destroy = destroy;
+	request->anqp_token = anqp_token++;
+	request->anqp_data = user_data;
+
+	msg = nl80211_build_cmd_frame(ifindex, addr, bss->addr,
+					bss->frequency, iov, 2);
+
+	l_genl_msg_append_attr(msg, NL80211_ATTR_OFFCHANNEL_TX_OK, 0, "");
+	l_genl_msg_append_attr(msg, NL80211_ATTR_DURATION, 4, &duration);
+
+	id = l_genl_family_send(nl80211, msg, netdev_gas_request_cb,
+					request, NULL);
+
+	if (!id) {
+		l_debug("Failed to send ANQP request");
+		l_genl_msg_unref(msg);
+		l_free(request);
+		return 0;
+	}
+
+	l_debug("ANQP request sent to "MAC, MAC_STR(bss->addr));
+
+	l_queue_push_head(anqp_requests, request);
+
+	return id;
+}
+
+static void netdev_frame_cb(struct l_genl_msg *msg, void *user_data)
+{
+	if (l_genl_msg_get_error(msg) < 0)
+		l_error("Could not register frame watch type %04x: %i",
+			L_PTR_TO_UINT(user_data), l_genl_msg_get_error(msg));
+}
+
+static void anqp_register_frame(uint32_t ifindex)
+{
+	struct l_genl_msg *msg;
+	uint16_t frame_type = 0x00d0;
+	uint8_t prefix[] = { 0x04, 0x0b };
+
+	msg = l_genl_msg_new_sized(NL80211_CMD_REGISTER_FRAME, 34);
+
+	l_genl_msg_append_attr(msg, NL80211_ATTR_IFINDEX, 4, &ifindex);
+	l_genl_msg_append_attr(msg, NL80211_ATTR_FRAME_TYPE, 2, &frame_type);
+	l_genl_msg_append_attr(msg, NL80211_ATTR_FRAME_MATCH,
+					sizeof(prefix), prefix);
+
+	l_genl_family_send(nl80211, msg, netdev_frame_cb,
+			L_UINT_TO_PTR(frame_type), NULL);
+}
+
+static void anqp_netdev_watch(struct netdev *netdev,
+				enum netdev_watch_event event, void *user_data)
+{
+	switch (event) {
+	case NETDEV_WATCH_EVENT_NEW:
+		anqp_register_frame(netdev_get_ifindex(netdev));
+		return;
+	default:
+		break;
+	}
+}
+
+static void anqp_unicast_notify(struct l_genl_msg *msg, void *user_data)
+{
+	const struct mmpdu_header *mpdu = NULL;
+	const uint8_t *body;
+	struct l_genl_attr attr;
+	uint16_t type, len;
+	uint16_t frame_len = 0;
+	const void *data;
+	uint8_t cmd;
+	uint32_t ifindex = 0;
+
+	if (l_queue_isempty(anqp_requests))
+		return;
+
+	cmd = l_genl_msg_get_command(msg);
+	if (!cmd)
+		return;
+
+	if (!l_genl_attr_init(&attr, msg))
+		return;
+
+	while (l_genl_attr_next(&attr, &type, &len, &data)) {
+		switch (type) {
+		case NL80211_ATTR_IFINDEX:
+			if (len != sizeof(uint32_t)) {
+				l_warn("Invalid interface index attribute");
+				return;
+			}
+
+			ifindex = *((uint32_t *) data);
+
+			break;
+		case NL80211_ATTR_FRAME:
+			if (mpdu)
+				return;
+
+			mpdu = mpdu_validate(data, len);
+			if (!mpdu)
+				l_error("Frame didn't validate as MMPDU");
+
+			frame_len = len;
+			break;
+		}
+	}
+
+	if (!ifindex || !mpdu)
+		return;
+
+	body = mmpdu_body(mpdu);
+
+	anqp_response_frame_event(ifindex, mpdu, body,
+				(const uint8_t *) mpdu + frame_len - body);
+}
+
+static void anqp_mlme_notify(struct l_genl_msg *msg, void *user_data)
+{
+	struct l_genl_attr attr;
+	uint16_t type, len;
+	const void *data;
+	uint8_t cmd;
+	uint32_t ifindex = 0;
+
+	if (l_queue_isempty(anqp_requests))
+		return;
+
+	cmd = l_genl_msg_get_command(msg);
+
+	l_debug("MLME notification %s(%u)", nl80211cmd_to_string(cmd), cmd);
+
+	if (!l_genl_attr_init(&attr, msg))
+		return;
+
+	while (l_genl_attr_next(&attr, &type, &len, &data)) {
+		switch (type) {
+		case NL80211_ATTR_IFINDEX:
+			if (len != sizeof(uint32_t)) {
+				l_warn("Invalid interface index attribute");
+				return;
+			}
+
+			ifindex = *((uint32_t *) data);
+			break;
+		}
+	}
+
+	if (!ifindex) {
+		l_warn("MLME notification is missing ifindex attribute");
+		return;
+	}
+
+	switch (cmd) {
+	case NL80211_CMD_FRAME_WAIT_CANCEL:
+		anqp_frame_wait_cancel_event(msg, ifindex);
+		break;
+	}
+}
+
+bool anqp_init(struct l_genl_family *in)
+{
+	struct l_genl *genl = iwd_get_genl();
+
+	nl80211 = in;
+
+	anqp_requests = l_queue_new();
+
+	netdev_watch =  netdev_watch_add(anqp_netdev_watch, NULL, NULL);
+
+	unicast_watch = l_genl_add_unicast_watch(genl, NL80211_GENL_NAME,
+						anqp_unicast_notify,
+						NULL, NULL);
+
+	if (!l_genl_family_register(nl80211, "mlme", anqp_mlme_notify,
+								NULL, NULL))
+		l_error("Registering for MLME notification failed");
+
+	return true;
+}
+
+void anqp_exit(void)
+{
+	struct l_genl *genl = iwd_get_genl();
+
+	nl80211 = NULL;
+
+	l_queue_destroy(anqp_requests, anqp_destroy);
+
+	netdev_watch_remove(netdev_watch);
+
+	l_genl_remove_unicast_watch(genl, unicast_watch);
+}
diff --git a/src/anqp.h b/src/anqp.h
new file mode 100644
index 00000000..62d097d1
--- /dev/null
+++ b/src/anqp.h
@@ -0,0 +1,43 @@
+/*
+ *
+ *  Wireless daemon for Linux
+ *
+ *  Copyright (C) 2019  Intel Corporation. All rights reserved.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+struct scan_bss;
+
+enum anqp_result {
+	ANQP_SUCCESS,
+	ANQP_TIMEOUT,
+	ANQP_FAILED,
+};
+
+typedef void (*anqp_destroy_func_t)(void *user_data);
+
+typedef void (*anqp_response_func_t)(enum anqp_result result,
+					const void *anqp, size_t len,
+					void *user_data);
+
+uint32_t anqp_request(uint32_t ifindex, const uint8_t *addr,
+			struct scan_bss *bss, const uint8_t *anqp, size_t len,
+			anqp_response_func_t cb, void *user_data,
+			anqp_destroy_func_t destroy);
+
+bool anqp_init(struct l_genl_family *in);
+void anqp_exit(void);
diff --git a/src/anqputil.c b/src/anqputil.c
new file mode 100644
index 00000000..f04ac05d
--- /dev/null
+++ b/src/anqputil.c
@@ -0,0 +1,202 @@
+/*
+ *
+ *  Wireless daemon for Linux
+ *
+ *  Copyright (C) 2019  Intel Corporation. All rights reserved.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <ell/ell.h>
+
+#include "anqputil.h"
+#include "ie.h"
+#include "util.h"
+
+void anqp_iter_init(struct anqp_iter *iter, const unsigned char *anqp,
+			unsigned int len)
+{
+	iter->anqp = anqp;
+	iter->max = len;
+	iter->pos = 0;
+}
+
+bool anqp_iter_next(struct anqp_iter *iter, uint16_t *id, uint16_t *len,
+			const void **data)
+{
+	const unsigned char *anqp = iter->anqp + iter->pos;
+	const unsigned char *end = iter->anqp + iter->max;
+
+	if (iter->pos + 4 >= iter->max)
+		return false;
+
+	if (anqp + l_get_le16(anqp + 2) > end)
+		return false;
+
+	*id = l_get_le16(anqp);
+	anqp += 2;
+
+	*len = l_get_le16(anqp);
+	anqp += 2;
+
+	*data = anqp;
+
+	iter->id = *id;
+	iter->len = *len;
+	iter->data = *data;
+
+	iter->pos = anqp + *len - iter->anqp;
+
+	return true;
+}
+
+bool anqp_hs20_parse_osu_provider_nai(const unsigned char *anqp,
+					unsigned int len, const char **nai_out)
+{
+	uint8_t nai_len;
+	static char nai[256] = { 0 };
+
+	if (len < 1)
+		return false;
+
+	nai_len = *anqp++;
+	len--;
+
+	if (len < nai_len)
+		return false;
+
+	memcpy(nai, anqp, nai_len);
+
+	*nai_out = nai;
+
+	return true;
+}
+
+bool anqp_iter_is_hs20(const struct anqp_iter *iter, uint8_t *stype,
+			unsigned int *len, const unsigned char **data)
+{
+	const unsigned char *anqp = iter->data;
+	unsigned int anqp_len = iter->len;
+	uint8_t type;
+
+	if (iter->len < 6)
+		return false;
+
+	if (memcmp(anqp, wifi_alliance_oui, 3))
+		return false;
+
+	anqp += 3;
+	anqp_len -= 3;
+
+	type = *anqp++;
+	anqp_len--;
+
+	if (type != 0x11)
+		return false;
+
+	*stype = *anqp++;
+	anqp_len--;
+
+	/* reserved byte */
+	anqp++;
+	anqp_len--;
+
+	*data = anqp;
+	*len = anqp_len;
+
+	return true;
+}
+
+char **anqp_parse_nai_realms(const unsigned char *anqp, unsigned int len)
+{
+	char **realms = NULL;
+	uint16_t count;
+
+	if (len < 2)
+		return false;
+
+	count = l_get_le16(anqp);
+
+	anqp += 2;
+	len -= 2;
+
+	l_debug("");
+
+	while (count--) {
+		uint16_t realm_len;
+		uint8_t encoding;
+		uint8_t nai_len;
+		char nai_realm[256] = { 0 };
+
+		/*
+		 * The method list is a variable field, so the only way to
+		 * reliably increment anqp is by realm_len at the very end since
+		 * we dont know how many bytes parse_eap advanced (it does
+		 * internal length checking so it should not overflow). We
+		 * cant incrementally advance anqp/len, hence the hardcoded
+		 * length and pointer adjustments.
+		 */
+
+		if (len < 4)
+			goto failed;
+
+		realm_len = l_get_le16(anqp);
+		anqp += 2;
+		len -= 2;
+
+		encoding = anqp[0];
+
+		nai_len = anqp[1];
+
+		if (len - 2 < nai_len)
+			goto failed;
+
+		memcpy(nai_realm, anqp + 2, nai_len);
+
+		/*
+		 * TODO: Verify NAI encoding in accordance with RFC 4282 ?
+		 *
+		 * The encoding in RFC 4282 seems to only limit which characters
+		 * can be used in an NAI. Since these come in from public
+		 * action frames it could have been spoofed, but ultimately if
+		 * its bogus the AP won't allow us to connect.
+		 */
+		if (!util_is_bit_set(encoding, 0))
+			l_warn("Not verifying NAI encoding");
+		else if (!l_utf8_validate(nai_realm, nai_len, NULL)) {
+			l_warn("NAI is not UTF-8");
+			goto failed;
+		}
+
+		realms = l_strv_append(realms, nai_realm);
+
+		if (len < realm_len)
+			goto failed;
+
+		anqp += realm_len;
+		len -= realm_len;
+	}
+
+	return realms;
+
+failed:
+	l_strv_free(realms);
+	return NULL;
+}
diff --git a/src/anqputil.h b/src/anqputil.h
new file mode 100644
index 00000000..dba687e3
--- /dev/null
+++ b/src/anqputil.h
@@ -0,0 +1,103 @@
+/*
+ *
+ *  Wireless daemon for Linux
+ *
+ *  Copyright (C) 2019  Intel Corporation. All rights reserved.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <stdbool.h>
+#include <stdint.h>
+
+/* IEEE 802.11-2016 Section 9.4.5 ANQP elements */
+enum anqp_element {
+	/* 0-255 reserved */
+	ANQP_QUERY_LIST = 256,
+	ANQP_CAPABILITY_LIST = 257,
+	ANQP_VENUE_NAME = 258,
+	ANQP_EMERGENCY_CALL_NUMBER = 259,
+	ANQP_NETWORK_AUTH_TYPE = 260,
+	ANQP_ROAMING_CONSORTIUM = 261,
+	ANQP_IP_ADDRESS_TYPE_AVAILABILITY = 262,
+	ANQP_NAI_REALM = 263,
+	ANQP_3GPP_CELLULAR_NETWORK = 264,
+	ANQP_AP_GEOSPATIAL_LOCATION = 265,
+	ANQP_AP_CIVIC_LOCATION = 266,
+	ANQP_AP_LOCATION_PUBLIC_ID = 267,
+	ANQP_DOMAIN_NAME = 268,
+	ANQP_EMERGENCY_ALERT_ID_URI = 269,
+	ANQP_TDLS_CAPABILITY = 270,
+	ANQP_EMERGENCY_NAI = 271,
+	ANQP_NEIGHBOR_REPORT = 272,
+	/* 273-276 reserved */
+	ANQP_VENUE_URI = 277,
+	ANQP_ADVICE_OF_CHARGE = 278,
+	ANQP_LOCAL_CONTENT = 279,
+	ANQP_NETWORK_AUTH_TYPE_WITH_TIMESTAMP = 280,
+	/* 281-56796 reserved */
+	ANQP_VENDOR_SPECIFIC = 56797,
+	/* 56798-65535 reserved */
+};
+
+/* WiFi Alliance Hotspot 2.0 Spec - Section 4 Hotspot 2.0 ANQP-elements */
+enum anqp_hs20_element {
+	ANQP_HS20_QUERY_LIST = 1,
+	ANQP_HS20_CAPABILITY_LIST = 2,
+	ANQP_HS20_OPERATOR_FRIENDLY_NAME = 3,
+	ANQP_HS20_WLAN_METRICS = 4,
+	ANQP_HS20_CONNECTION_CAPABILITY = 5,
+	ANQP_HS20_NAI_HOME_REALM_QUERY = 6,
+	ANQP_HS20_OPERATING_CLASS_INDICATION = 7,
+	ANQP_HS20_OSU_PROVIDERS_LIST = 8,
+	/* 9 reserved */
+	ANQP_HS20_ICON_REQUST = 10,
+	ANQP_HS20_ICON_BINARY_FILE = 11,
+	ANQP_HS20_OPERATOR_ICON_METADATA = 12,
+	ANQP_HS20_OSU_PROVIDERS_NAI_LIST = 13,
+	/* 14 - 255 reserved */
+};
+
+/* IEEE 802.11-2016 Table 9-275 Authentication Parameter types */
+enum anqp_auth_parameter_type {
+	ANQP_AP_EXPANDED_EAP_METHOD = 1,
+	ANQP_AP_NON_INNER_AUTH_EAP = 2,
+	ANQP_AP_INNER_AUTH_EAP = 3,
+	ANQP_AP_EXPANDED_INNER_EAP_METHOD = 4,
+	ANQP_AP_CREDENTIAL = 5,
+	ANQP_AP_TUNNELED_EAP_CREDENTIAL = 6,
+	ANQP_AP_VENDOR_SPECIFIC = 221,
+};
+
+struct anqp_iter {
+	unsigned int max;
+	unsigned int pos;
+	const unsigned char *anqp;
+
+	unsigned int id;
+	unsigned int len;
+	const unsigned char *data;
+};
+
+void anqp_iter_init(struct anqp_iter *iter, const unsigned char *anqp,
+			unsigned int len);
+bool anqp_iter_next(struct anqp_iter *iter, uint16_t *id, uint16_t *len,
+			const void **data);
+bool anqp_iter_is_hs20(const struct anqp_iter *iter, uint8_t *stype,
+			unsigned int *len, const unsigned char **data);
+bool anqp_hs20_parse_osu_provider_nai(const unsigned char *anqp,
+					unsigned int len, const char **nai_out);
+char **anqp_parse_nai_realms(const unsigned char *anqp, unsigned int len);
diff --git a/src/ap.c b/src/ap.c
index fbebe97e..d7b93d88 100644
--- a/src/ap.c
+++ b/src/ap.c
@@ -42,12 +42,12 @@
 #include "src/util.h"
 #include "src/eapol.h"
 #include "src/handshake.h"
-#include "src/ap.h"
 #include "src/dbus.h"
 #include "src/nl80211util.h"
 
 struct ap_state {
 	struct netdev *netdev;
+	struct l_genl_family *nl80211;
 	char *ssid;
 	uint8_t channel;
 	unsigned int ciphers;
@@ -84,21 +84,21 @@ struct sta_state {
 	uint32_t gtk_query_cmd_id;
 };
 
-static struct l_genl_family *nl80211 = NULL;
 static uint32_t netdev_watch;
 
 static void ap_sta_free(void *data)
 {
 	struct sta_state *sta = data;
+	struct ap_state *ap = sta->ap;
 
 	l_uintset_free(sta->rates);
 	l_free(sta->assoc_rsne);
 
 	if (sta->assoc_resp_cmd_id)
-		l_genl_family_cancel(nl80211, sta->assoc_resp_cmd_id);
+		l_genl_family_cancel(ap->nl80211, sta->assoc_resp_cmd_id);
 
 	if (sta->gtk_query_cmd_id)
-		l_genl_family_cancel(nl80211, sta->gtk_query_cmd_id);
+		l_genl_family_cancel(ap->nl80211, sta->gtk_query_cmd_id);
 
 	if (sta->sm)
 		eapol_sm_free(sta->sm);
@@ -136,7 +136,7 @@ static void ap_reset(struct ap_state *ap)
 	l_queue_destroy(ap->frame_watch_ids, NULL);
 
 	if (ap->start_stop_cmd_id)
-		l_genl_family_cancel(nl80211, ap->start_stop_cmd_id);
+		l_genl_family_cancel(ap->nl80211, ap->start_stop_cmd_id);
 
 	l_queue_destroy(ap->sta_states, ap_sta_free);
 
@@ -154,19 +154,21 @@ static void ap_free(void *data)
 	struct ap_state *ap = data;
 
 	ap_reset(ap);
-
+	l_genl_family_free(ap->nl80211);
 	l_free(ap);
 }
 
 static void ap_del_station(struct sta_state *sta, uint16_t reason,
 				bool disassociate)
 {
-	netdev_del_station(sta->ap->netdev, sta->addr, reason, disassociate);
+	struct ap_state *ap = sta->ap;
+
+	netdev_del_station(ap->netdev, sta->addr, reason, disassociate);
 	sta->associated = false;
 	sta->rsna = false;
 
 	if (sta->gtk_query_cmd_id) {
-		l_genl_family_cancel(nl80211, sta->gtk_query_cmd_id);
+		l_genl_family_cancel(ap->nl80211, sta->gtk_query_cmd_id);
 		sta->gtk_query_cmd_id = 0;
 	}
 
@@ -222,6 +224,7 @@ static void ap_new_rsna(struct sta_state *sta)
 
 static void ap_drop_rsna(struct sta_state *sta)
 {
+	struct ap_state *ap = sta->ap;
 	struct l_genl_msg *msg;
 	uint32_t ifindex = netdev_get_ifindex(sta->ap->netdev);
 	uint8_t key_id = 0;
@@ -232,7 +235,7 @@ static void ap_drop_rsna(struct sta_state *sta)
 
 	l_genl_msg_append_attr(msg, NL80211_ATTR_STA_AID, 2, &sta->aid);
 
-	if (!l_genl_family_send(nl80211, msg, ap_set_sta_cb, NULL, NULL)) {
+	if (!l_genl_family_send(ap->nl80211, msg, ap_set_sta_cb, NULL, NULL)) {
 		l_genl_msg_unref(msg);
 		l_error("Issuing SET_STATION failed");
 	}
@@ -242,7 +245,7 @@ static void ap_drop_rsna(struct sta_state *sta)
 	l_genl_msg_append_attr(msg, NL80211_ATTR_KEY_IDX, 1, &key_id);
 	l_genl_msg_append_attr(msg, NL80211_ATTR_MAC, 6, sta->addr);
 
-	if (!l_genl_family_send(nl80211, msg, ap_del_key_cb, NULL, NULL)) {
+	if (!l_genl_family_send(ap->nl80211, msg, ap_del_key_cb, NULL, NULL)) {
 		l_genl_msg_unref(msg);
 		l_error("Issuing DEL_KEY failed");
 	}
@@ -370,7 +373,7 @@ static uint32_t ap_send_mgmt_frame(struct ap_state *ap,
 		l_genl_msg_append_attr(msg, NL80211_ATTR_DONT_WAIT_FOR_ACK,
 					0, NULL);
 
-	id = l_genl_family_send(nl80211, msg, callback, user_data, NULL);
+	id = l_genl_family_send(ap->nl80211, msg, callback, user_data, NULL);
 
 	if (!id)
 		l_genl_msg_unref(msg);
@@ -422,8 +425,8 @@ static void ap_start_rsna(struct sta_state *sta, const uint8_t *gtk_rsc)
 	handshake_state_set_event_func(sta->hs, ap_handshake_event, sta);
 	handshake_state_set_ssid(sta->hs, (void *)ap->ssid, strlen(ap->ssid));
 	handshake_state_set_authenticator(sta->hs, true);
-	handshake_state_set_authenticator_rsn(sta->hs, bss_rsne);
-	handshake_state_set_supplicant_rsn(sta->hs, sta->assoc_rsne);
+	handshake_state_set_authenticator_ie(sta->hs, bss_rsne);
+	handshake_state_set_supplicant_ie(sta->hs, sta->assoc_rsne);
 	handshake_state_set_pmk(sta->hs, ap->pmk, 32);
 	handshake_state_set_authenticator_address(sta->hs, own_addr);
 	handshake_state_set_supplicant_address(sta->hs, sta->addr);
@@ -441,7 +444,6 @@ static void ap_start_rsna(struct sta_state *sta, const uint8_t *gtk_rsc)
 	}
 
 	eapol_sm_set_listen_interval(sta->sm, sta->listen_interval);
-	eapol_sm_set_protocol_version(sta->sm, EAPOL_PROTOCOL_VERSION_2004);
 
 	eapol_register(sta->sm);
 
@@ -571,7 +573,7 @@ static void ap_associate_sta_cb(struct l_genl_msg *msg, void *user_data)
 						ap->gtk, gtk_len, NULL,
 						0, NULL);
 
-		if (!l_genl_family_send(nl80211, msg, ap_gtk_op_cb, NULL,
+		if (!l_genl_family_send(ap->nl80211, msg, ap_gtk_op_cb, NULL,
 					NULL)) {
 			l_genl_msg_unref(msg);
 			l_error("Issuing NEW_KEY failed");
@@ -580,7 +582,7 @@ static void ap_associate_sta_cb(struct l_genl_msg *msg, void *user_data)
 
 		msg = nl80211_build_set_key(netdev_get_ifindex(ap->netdev),
 						ap->gtk_index);
-		if (!l_genl_family_send(nl80211, msg, ap_gtk_op_cb, NULL,
+		if (!l_genl_family_send(ap->nl80211, msg, ap_gtk_op_cb, NULL,
 					NULL)) {
 			l_genl_msg_unref(msg);
 			l_error("Issuing SET_KEY failed");
@@ -599,7 +601,7 @@ static void ap_associate_sta_cb(struct l_genl_msg *msg, void *user_data)
 	else {
 		msg = nl80211_build_get_key(netdev_get_ifindex(ap->netdev),
 					ap->gtk_index);
-		sta->gtk_query_cmd_id = l_genl_family_send(nl80211, msg,
+		sta->gtk_query_cmd_id = l_genl_family_send(ap->nl80211, msg,
 								ap_gtk_query_cb,
 								sta, NULL);
 		if (!sta->gtk_query_cmd_id) {
@@ -647,7 +649,8 @@ static void ap_associate_sta(struct ap_state *ap, struct sta_state *sta)
 	l_genl_msg_append_attr(msg, NL80211_ATTR_STA_CAPABILITY, 2,
 				&capability);
 
-	if (!l_genl_family_send(nl80211, msg, ap_associate_sta_cb, sta, NULL)) {
+	if (!l_genl_family_send(ap->nl80211, msg, ap_associate_sta_cb,
+								sta, NULL)) {
 		l_genl_msg_unref(msg);
 		if (l_genl_msg_get_command(msg) == NL80211_CMD_NEW_STATION)
 			l_error("Issuing NEW_STATION failed");
@@ -1162,7 +1165,7 @@ static void ap_disassoc_cb(struct netdev *netdev,
 	sta = l_queue_find(ap->sta_states, ap_sta_match_addr, hdr->address_2);
 
 	if (sta && sta->assoc_resp_cmd_id) {
-		l_genl_family_cancel(nl80211, sta->assoc_resp_cmd_id);
+		l_genl_family_cancel(ap->nl80211, sta->assoc_resp_cmd_id);
 		sta->assoc_resp_cmd_id = 0;
 	}
 
@@ -1470,8 +1473,8 @@ static int ap_start(struct ap_state *ap, const char *ssid, const char *psk,
 	if (!cmd)
 		goto error;
 
-	ap->start_stop_cmd_id = l_genl_family_send(nl80211, cmd, ap_start_cb,
-							ap, NULL);
+	ap->start_stop_cmd_id = l_genl_family_send(ap->nl80211, cmd,
+							ap_start_cb, ap, NULL);
 	if (!ap->start_stop_cmd_id) {
 		l_genl_msg_unref(cmd);
 		goto error;
@@ -1530,9 +1533,9 @@ static int ap_stop(struct ap_state *ap, struct l_dbus_message *message)
 		return -ENOMEM;
 
 	if (ap->start_stop_cmd_id)
-		l_genl_family_cancel(nl80211, ap->start_stop_cmd_id);
+		l_genl_family_cancel(ap->nl80211, ap->start_stop_cmd_id);
 
-	ap->start_stop_cmd_id = l_genl_family_send(nl80211, cmd, ap_stop_cb,
+	ap->start_stop_cmd_id = l_genl_family_send(ap->nl80211, cmd, ap_stop_cb,
 							ap, NULL);
 	if (!ap->start_stop_cmd_id) {
 		l_genl_msg_unref(cmd);
@@ -1545,7 +1548,7 @@ static int ap_stop(struct ap_state *ap, struct l_dbus_message *message)
 		ap->gtk_set = false;
 
 		msg = ap_build_cmd_del_key(ap);
-		if (!l_genl_family_send(nl80211, msg, ap_gtk_op_cb, NULL,
+		if (!l_genl_family_send(ap->nl80211, msg, ap_gtk_op_cb, NULL,
 					NULL)) {
 			l_genl_msg_unref(msg);
 			l_error("Issuing DEL_KEY failed");
@@ -1630,9 +1633,14 @@ static void ap_add_interface(struct netdev *netdev)
 {
 	struct ap_state *ap;
 
+	/*
+	 * TODO: Check wiphy supported channels and NL80211_ATTR_TX_FRAME_TYPES
+	 */
+
 	/* just allocate/set device, Start method will complete setup */
 	ap = l_new(struct ap_state, 1);
 	ap->netdev = netdev;
+	ap->nl80211 = l_genl_family_new(iwd_get_genl(), NL80211_GENL_NAME);
 
 	/* setup ap dbus interface */
 	l_dbus_object_add_interface(dbus_get_bus(),
@@ -1664,21 +1672,20 @@ static void ap_netdev_watch(struct netdev *netdev,
 	}
 }
 
-bool ap_init(struct l_genl_family *in)
+static int ap_init(void)
 {
 	netdev_watch = netdev_watch_add(ap_netdev_watch, NULL, NULL);
-	nl80211 = in;
 
-	return l_dbus_register_interface(dbus_get_bus(), IWD_AP_INTERFACE,
+	l_dbus_register_interface(dbus_get_bus(), IWD_AP_INTERFACE,
 			ap_setup_interface, ap_destroy_interface, false);
-	/*
-	 * TODO: Check wiphy supports AP mode, supported channels,
-	 * check wiphy's NL80211_ATTR_TX_FRAME_TYPES.
-	 */
+
+	return 0;
 }
 
-void ap_exit(void)
+static void ap_exit(void)
 {
 	netdev_watch_remove(netdev_watch);
 	l_dbus_unregister_interface(dbus_get_bus(), IWD_AP_INTERFACE);
 }
+
+IWD_MODULE(ap, ap_init, ap_exit)
diff --git a/src/blacklist.c b/src/blacklist.c
index 2da276f7..b17154d9 100644
--- a/src/blacklist.c
+++ b/src/blacklist.c
@@ -152,7 +152,7 @@ void blacklist_remove_bss(const uint8_t *addr)
 	l_free(entry);
 }
 
-void blacklist_init(void)
+static int blacklist_init(void)
 {
 	const struct l_settings *config = iwd_get_config();
 
@@ -168,16 +168,21 @@ void blacklist_init(void)
 					&blacklist_multiplier))
 		blacklist_multiplier = BLACKLIST_DEFAULT_MULTIPLIER;
 
-	if (!l_settings_get_uint64(config, "Blacklist", "bss_blacklist_max_time",
+	if (!l_settings_get_uint64(config, "Blacklist",
+					"bss_blacklist_max_time",
 					&blacklist_max_timeout))
 		blacklist_max_timeout = BLACKLIST_DEFAULT_MAX_TIMEOUT;
 
 	blacklist_max_timeout *= 1000000;
 
 	blacklist = l_queue_new();
+
+	return 0;
 }
 
-void blacklist_exit(void)
+static void blacklist_exit(void)
 {
 	l_queue_destroy(blacklist, l_free);
 }
+
+IWD_MODULE(blacklist, blacklist_init, blacklist_exit)
diff --git a/src/blacklist.h b/src/blacklist.h
index 8161f4ed..56260e20 100644
--- a/src/blacklist.h
+++ b/src/blacklist.h
@@ -23,6 +23,3 @@
 void blacklist_add_bss(const uint8_t *addr);
 bool blacklist_contains_bss(const uint8_t *addr);
 void blacklist_remove_bss(const uint8_t *addr);
-
-void blacklist_init(void);
-void blacklist_exit(void);
diff --git a/src/common.c b/src/common.c
index 8f5093d3..04d2cfe8 100644
--- a/src/common.c
+++ b/src/common.c
@@ -82,7 +82,8 @@ bool security_from_str(const char *str, enum security *security)
 		IE_RSN_AKM_SUITE_FILS_SHA256 |				\
 		IE_RSN_AKM_SUITE_FILS_SHA384 |				\
 		IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256 |			\
-		IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384)			\
+		IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384 |			\
+		IE_RSN_AKM_SUITE_OSEN)					\
 )
 
 enum security security_determine(uint16_t bss_capability,
diff --git a/src/crypto.c b/src/crypto.c
index 1c2d2db2..63608c8d 100644
--- a/src/crypto.c
+++ b/src/crypto.c
@@ -836,21 +836,22 @@ bool crypto_derive_pairwise_ptk(const uint8_t *pmk, size_t pmk_len,
 }
 
 /* Defined in 802.11-2012, Section 11.6.1.7.3 PMK-R0 */
-bool crypto_derive_pmk_r0(const uint8_t *xxkey,
+bool crypto_derive_pmk_r0(const uint8_t *xxkey, size_t xxkey_len,
 				const uint8_t *ssid, size_t ssid_len,
 				uint16_t mdid,
 				const uint8_t *r0khid, size_t r0kh_len,
-				const uint8_t *s0khid, uint8_t *out_pmk_r0,
-				uint8_t *out_pmk_r0_name)
+				const uint8_t *s0khid, bool sha384,
+				uint8_t *out_pmk_r0, uint8_t *out_pmk_r0_name)
 {
 	uint8_t context[512];
 	size_t pos = 0;
-	uint8_t output[48];
-	struct l_checksum *sha256;
+	uint8_t output[64];
+	size_t offset = sha384 ? 48 : 32;
+	struct l_checksum *sha;
 	bool r = false;
 	struct iovec iov[2] = {
 		[0] = { .iov_base = "FT-R0N", .iov_len = 6 },
-		[1] = { .iov_base = output + 32, .iov_len = 16 },
+		[1] = { .iov_base = output + offset, .iov_len = 16 },
 	};
 
 	context[pos++] = ssid_len;
@@ -869,25 +870,32 @@ bool crypto_derive_pmk_r0(const uint8_t *xxkey,
 	memcpy(context + pos, s0khid, ETH_ALEN);
 	pos += ETH_ALEN;
 
-	if (!kdf_sha256(xxkey, 32, "FT-R0", 5, context, pos, output, 48))
-		goto exit;
+	if (sha384) {
+		if (!kdf_sha384(xxkey, xxkey_len, "FT-R0", 5, context, pos,
+					output, 64))
+			goto exit;
+	} else {
+		if (!kdf_sha256(xxkey, xxkey_len, "FT-R0", 5, context, pos,
+					output, 48))
+			goto exit;
+	}
 
-	sha256 = l_checksum_new(L_CHECKSUM_SHA256);
-	if (!sha256)
+	sha = l_checksum_new((sha384) ? L_CHECKSUM_SHA384 : L_CHECKSUM_SHA256);
+	if (!sha)
 		goto exit;
 
-	l_checksum_updatev(sha256, iov, 2);
-	l_checksum_get_digest(sha256, out_pmk_r0_name, 16);
+	l_checksum_updatev(sha, iov, 2);
+	l_checksum_get_digest(sha, out_pmk_r0_name, 16);
 
-	l_checksum_free(sha256);
+	l_checksum_free(sha);
 
-	memcpy(out_pmk_r0, output, 32);
+	memcpy(out_pmk_r0, output, offset);
 
 	r = true;
 
 exit:
 	explicit_bzero(context, pos);
-	explicit_bzero(output, 48);
+	explicit_bzero(output, 64);
 
 	return r;
 }
@@ -895,12 +903,12 @@ exit:
 /* Defined in 802.11-2012, Section 11.6.1.7.4 PMK-R1 */
 bool crypto_derive_pmk_r1(const uint8_t *pmk_r0,
 				const uint8_t *r1khid, const uint8_t *s1khid,
-				const uint8_t *pmk_r0_name,
+				const uint8_t *pmk_r0_name, bool sha384,
 				uint8_t *out_pmk_r1,
 				uint8_t *out_pmk_r1_name)
 {
 	uint8_t context[2 * ETH_ALEN];
-	struct l_checksum *sha256;
+	struct l_checksum *sha;
 	bool r = false;
 	struct iovec iov[3] = {
 		[0] = { .iov_base = "FT-R1N", .iov_len = 6 },
@@ -912,20 +920,26 @@ bool crypto_derive_pmk_r1(const uint8_t *pmk_r0,
 
 	memcpy(context + ETH_ALEN, s1khid, ETH_ALEN);
 
-	if (!kdf_sha256(pmk_r0, 32, "FT-R1", 5, context, sizeof(context),
-				out_pmk_r1, 32))
-		goto exit;
+	if (sha384) {
+		if (!kdf_sha384(pmk_r0, 48, "FT-R1", 5, context,
+					sizeof(context), out_pmk_r1, 48))
+			goto exit;
+	} else {
+		if (!kdf_sha256(pmk_r0, 32, "FT-R1", 5, context,
+					sizeof(context), out_pmk_r1, 32))
+			goto exit;
+	}
 
-	sha256 = l_checksum_new(L_CHECKSUM_SHA256);
-	if (!sha256) {
-		explicit_bzero(out_pmk_r1, 32);
+	sha = l_checksum_new((sha384) ? L_CHECKSUM_SHA384 : L_CHECKSUM_SHA256);
+	if (!sha) {
+		explicit_bzero(out_pmk_r1, 48);
 		goto exit;
 	}
 
-	l_checksum_updatev(sha256, iov, 3);
-	l_checksum_get_digest(sha256, out_pmk_r1_name, 16);
+	l_checksum_updatev(sha, iov, 3);
+	l_checksum_get_digest(sha, out_pmk_r1_name, 16);
 
-	l_checksum_free(sha256);
+	l_checksum_free(sha);
 
 	r = true;
 
@@ -939,11 +953,11 @@ exit:
 bool crypto_derive_ft_ptk(const uint8_t *pmk_r1, const uint8_t *pmk_r1_name,
 				const uint8_t *addr1, const uint8_t *addr2,
 				const uint8_t *nonce1, const uint8_t *nonce2,
-				uint8_t *out_ptk, size_t ptk_len,
+				bool sha384, uint8_t *out_ptk, size_t ptk_len,
 				uint8_t *out_ptk_name)
 {
 	uint8_t context[ETH_ALEN * 2 + 64];
-	struct l_checksum *sha256;
+	struct l_checksum *sha;
 	bool r = false;
 	struct iovec iov[3] = {
 		[0] = { .iov_base = (uint8_t *) pmk_r1_name, .iov_len = 16 },
@@ -959,20 +973,26 @@ bool crypto_derive_ft_ptk(const uint8_t *pmk_r1, const uint8_t *pmk_r1_name,
 
 	memcpy(context + 64 + ETH_ALEN, addr2, ETH_ALEN);
 
-	if (!kdf_sha256(pmk_r1, 32, "FT-PTK", 6, context, sizeof(context),
-				out_ptk, ptk_len))
-		goto exit;
+	if (sha384) {
+		if (!kdf_sha384(pmk_r1, 48, "FT-PTK", 6, context,
+					sizeof(context), out_ptk, ptk_len))
+			goto exit;
+	} else {
+		if (!kdf_sha256(pmk_r1, 32, "FT-PTK", 6, context,
+					sizeof(context), out_ptk, ptk_len))
+			goto exit;
+	}
 
-	sha256 = l_checksum_new(L_CHECKSUM_SHA256);
-	if (!sha256) {
+	sha = l_checksum_new((sha384) ? L_CHECKSUM_SHA384 : L_CHECKSUM_SHA256);
+	if (!sha) {
 		explicit_bzero(out_ptk, ptk_len);
 		goto exit;
 	}
 
-	l_checksum_updatev(sha256, iov, 3);
-	l_checksum_get_digest(sha256, out_ptk_name, 16);
+	l_checksum_updatev(sha, iov, 3);
+	l_checksum_get_digest(sha, out_ptk_name, 16);
 
-	l_checksum_free(sha256);
+	l_checksum_free(sha);
 
 	r = true;
 
diff --git a/src/crypto.h b/src/crypto.h
index 0b7f0275..9a02a1fe 100644
--- a/src/crypto.h
+++ b/src/crypto.h
@@ -50,6 +50,7 @@ enum crypto_akm {
 	CRYPTO_AKM_FT_OVER_FILS_SHA256 = 0x000fac10,
 	CRYPTO_AKM_FT_OVER_FILS_SHA384 = 0x000fac11,
 	CRYPTO_AKM_OWE = 0x000fac12,
+	CRYPTO_AKM_OSEN = 0x506f9a01,
 };
 
 /* Min & Max reported by crypto_cipher_key_len when ignoring WEP */
@@ -116,21 +117,21 @@ bool crypto_derive_pairwise_ptk(const uint8_t *pmk, size_t pmk_len,
 				uint8_t *out_ptk, size_t ptk_len,
 				enum l_checksum_type type);
 
-bool crypto_derive_pmk_r0(const uint8_t *xxkey,
+bool crypto_derive_pmk_r0(const uint8_t *xxkey, size_t xxkey_len,
 				const uint8_t *ssid, size_t ssid_len,
 				uint16_t mdid,
 				const uint8_t *r0khid, size_t r0kh_len,
-				const uint8_t *s0khid, uint8_t *out_pmk_r0,
-				uint8_t *out_pmk_r0_name);
+				const uint8_t *s0khid, bool sha384,
+				uint8_t *out_pmk_r0, uint8_t *out_pmk_r0_name);
 bool crypto_derive_pmk_r1(const uint8_t *pmk_r0,
 				const uint8_t *r1khid, const uint8_t *s1khid,
-				const uint8_t *pmk_r0_name,
+				const uint8_t *pmk_r0_name, bool sha384,
 				uint8_t *out_pmk_r1,
 				uint8_t *out_pmk_r1_name);
 bool crypto_derive_ft_ptk(const uint8_t *pmk_r1, const uint8_t *pmk_r1_name,
 				const uint8_t *addr1, const uint8_t *addr2,
 				const uint8_t *nonce1, const uint8_t *nonce2,
-				uint8_t *out_ptk, size_t ptk_len,
+				bool sha384, uint8_t *out_ptk, size_t ptk_len,
 				uint8_t *out_ptk_name);
 
 bool crypto_derive_pmkid(const uint8_t *pmk,
diff --git a/src/device.c b/src/device.c
index 7bdd86c0..4f9d3933 100644
--- a/src/device.c
+++ b/src/device.c
@@ -422,7 +422,7 @@ struct device *device_create(struct wiphy *wiphy, struct netdev *netdev)
 		l_info("Unable to register %s interface",
 				L_DBUS_INTERFACE_PROPERTIES);
 
-	scan_ifindex_add(device->index);
+	scan_wdev_add(netdev_get_wdev_id(device->netdev));
 
 	/*
 	 * register for AP roam transition watch
@@ -449,7 +449,7 @@ void device_remove(struct device *device)
 
 	l_dbus_unregister_object(dbus, netdev_get_path(device->netdev));
 
-	scan_ifindex_remove(device->index);
+	scan_wdev_remove(netdev_get_wdev_id(device->netdev));
 
 	netdev_frame_watch_remove(device->netdev, device->ap_roam_watch);
 	wiphy_state_watch_remove(device->wiphy, device->wiphy_rfkill_watch);
@@ -457,7 +457,7 @@ void device_remove(struct device *device)
 	l_free(device);
 }
 
-bool device_init(void)
+static int device_init(void)
 {
 	if (!l_dbus_register_interface(dbus_get_bus(),
 					IWD_DEVICE_INTERFACE,
@@ -467,12 +467,14 @@ bool device_init(void)
 
 	netdev_watch = netdev_watch_add(device_netdev_notify, NULL, NULL);
 
-	return true;
+	return 0;
 }
 
-void device_exit(void)
+static void device_exit(void)
 {
 	netdev_watch_remove(netdev_watch);
 
 	l_dbus_unregister_interface(dbus_get_bus(), IWD_DEVICE_INTERFACE);
 }
+
+IWD_MODULE(device, device_init, device_exit)
diff --git a/src/eap-tls-common.c b/src/eap-tls-common.c
index be18b5d0..7e566c44 100644
--- a/src/eap-tls-common.c
+++ b/src/eap-tls-common.c
@@ -289,19 +289,26 @@ static void eap_tls_send_fragment(struct eap_state *eap)
 	uint8_t buf[mtu];
 	size_t len = eap_tls->tx_pdu_buf->len - eap_tls->tx_frag_offset;
 	size_t header_len = EAP_TLS_HEADER_LEN;
+	uint8_t position = 0;
 
-	buf[EAP_TLS_HEADER_OCTET_FLAGS] = eap_tls->version_negotiated;
+	if (eap_get_method_type(eap) == EAP_TYPE_EXPANDED) {
+		header_len += 7;
+		position += 7;
+	}
+
+	buf[EAP_TLS_HEADER_OCTET_FLAGS + position] =
+						eap_tls->version_negotiated;
 
-	if (len > mtu - EAP_TLS_HEADER_LEN) {
-		len = mtu - EAP_TLS_HEADER_LEN;
-		buf[EAP_TLS_HEADER_OCTET_FLAGS] |= EAP_TLS_FLAG_M;
+	if (len > mtu - EAP_TLS_HEADER_LEN - position) {
+		len = mtu - EAP_TLS_HEADER_LEN - position;
+		buf[EAP_TLS_HEADER_OCTET_FLAGS + position] |= EAP_TLS_FLAG_M;
 		eap_tls->expecting_frag_ack = true;
 	}
 
 	if (!eap_tls->tx_frag_offset) {
-		buf[EAP_TLS_HEADER_OCTET_FLAGS] |= EAP_TLS_FLAG_L;
+		buf[EAP_TLS_HEADER_OCTET_FLAGS + position] |= EAP_TLS_FLAG_L;
 		l_put_be32(eap_tls->tx_pdu_buf->len,
-					&buf[EAP_TLS_HEADER_OCTET_FRAG_LEN]);
+				&buf[EAP_TLS_HEADER_OCTET_FRAG_LEN + position]);
 		len -= 4;
 		header_len += 4;
 	}
@@ -320,10 +327,20 @@ static void eap_tls_send_response(struct eap_state *eap,
 	size_t msg_len = EAP_TLS_HEADER_LEN + pdu_len;
 
 	if (msg_len <= eap_get_mtu(eap)) {
-		uint8_t *buf = l_malloc(msg_len);
+		uint8_t *buf;
+		uint8_t extra = 0;
+
+		if (eap_get_method_type(eap) == EAP_TYPE_EXPANDED) {
+			extra += 7;
+			msg_len += 7;
+		}
 
-		buf[EAP_TLS_HEADER_OCTET_FLAGS] = eap_tls->version_negotiated;
-		memcpy(buf + EAP_TLS_HEADER_LEN, pdu, pdu_len);
+		buf = l_malloc(msg_len);
+
+		buf[EAP_TLS_HEADER_OCTET_FLAGS + extra] =
+						eap_tls->version_negotiated;
+
+		memcpy(buf + EAP_TLS_HEADER_LEN + extra, pdu, pdu_len);
 
 		eap_send_response(eap, eap_get_method_type(eap), buf, msg_len);
 		l_free(buf);
@@ -337,12 +354,16 @@ static void eap_tls_send_response(struct eap_state *eap,
 void eap_tls_common_send_empty_response(struct eap_state *eap)
 {
 	struct eap_tls_state *eap_tls = eap_get_data(eap);
-	uint8_t buf[EAP_TLS_HEADER_LEN];
+	uint8_t buf[EAP_TLS_HEADER_LEN + 7];
+	uint8_t position = 0;
+
+	if (eap_get_method_type(eap) == EAP_TYPE_EXPANDED)
+		position += 7;
 
-	buf[EAP_TLS_HEADER_OCTET_FLAGS] = eap_tls->version_negotiated;
+	buf[EAP_TLS_HEADER_OCTET_FLAGS + position] = eap_tls->version_negotiated;
 
 	eap_send_response(eap, eap_get_method_type(eap), buf,
-							EAP_TLS_HEADER_LEN);
+				EAP_TLS_HEADER_LEN + position);
 }
 
 static int eap_tls_init_request_assembly(struct eap_state *eap,
diff --git a/src/eap-tls.c b/src/eap-tls.c
index 025702cd..531b0eac 100644
--- a/src/eap-tls.c
+++ b/src/eap-tls.c
@@ -107,16 +107,37 @@ static struct eap_method eap_tls = {
 	.load_settings = eap_tls_settings_load,
 };
 
+static struct eap_method eap_wfa_tls = {
+	.request_type = EAP_TYPE_EXPANDED,
+	.exports_msk = true,
+	.name = "WFA-TLS",
+
+	.handle_request = eap_tls_common_handle_request,
+	.handle_retransmit = eap_tls_common_handle_retransmit,
+	.reset_state = eap_tls_common_state_reset,
+	.free = eap_tls_common_state_free,
+
+	.check_settings = eap_tls_settings_check,
+	.load_settings = eap_tls_settings_load,
+	.vendor_id = { 0x00, 0x9f, 0x68 },
+	.vendor_type = 0x0000000d,
+};
+
 static int eap_tls_init(void)
 {
 	l_debug("");
-	return eap_register_method(&eap_tls);
+
+	if (eap_register_method(&eap_tls) < 0)
+		return -EPERM;
+
+	return eap_register_method(&eap_wfa_tls);
 }
 
 static void eap_tls_exit(void)
 {
 	l_debug("");
 	eap_unregister_method(&eap_tls);
+	eap_unregister_method(&eap_wfa_tls);
 }
 
 EAP_METHOD_BUILTIN(eap_tls, eap_tls_init, eap_tls_exit)
diff --git a/src/eapol.c b/src/eapol.c
index 4d6c03a1..b2d0c6a9 100644
--- a/src/eapol.c
+++ b/src/eapol.c
@@ -104,6 +104,7 @@ bool eapol_calculate_mic(enum ie_rsn_akm_suite akm, const uint8_t *kck,
 		switch (akm) {
 		case IE_RSN_AKM_SUITE_SAE_SHA256:
 		case IE_RSN_AKM_SUITE_FT_OVER_SAE_SHA256:
+		case IE_RSN_AKM_SUITE_OSEN:
 			return cmac_aes(kck, 16, frame, frame_len,
 						mic, mic_len);
 		case IE_RSN_AKM_SUITE_OWE:
@@ -157,6 +158,7 @@ bool eapol_verify_mic(enum ie_rsn_akm_suite akm, const uint8_t *kck,
 		switch (akm) {
 		case IE_RSN_AKM_SUITE_SAE_SHA256:
 		case IE_RSN_AKM_SUITE_FT_OVER_SAE_SHA256:
+		case IE_RSN_AKM_SUITE_OSEN:
 			checksum = l_checksum_new_cmac_aes(kck, 16);
 			break;
 		case IE_RSN_AKM_SUITE_OWE:
@@ -257,6 +259,7 @@ uint8_t *eapol_decrypt_key_data(enum ie_rsn_akm_suite akm, const uint8_t *kek,
 		case IE_RSN_AKM_SUITE_SAE_SHA256:
 		case IE_RSN_AKM_SUITE_FT_OVER_SAE_SHA256:
 		case IE_RSN_AKM_SUITE_OWE:
+		case IE_RSN_AKM_SUITE_OSEN:
 			if (key_data_len < 24 || key_data_len % 8)
 				return NULL;
 
@@ -887,12 +890,6 @@ void eapol_sm_free(struct eapol_sm *sm)
 	eapol_sm_destroy(sm);
 }
 
-void eapol_sm_set_protocol_version(struct eapol_sm *sm,
-				enum eapol_protocol_version protocol_version)
-{
-	sm->protocol_version = protocol_version;
-}
-
 void eapol_sm_set_listen_interval(struct eapol_sm *sm, uint16_t interval)
 {
 	sm->listen_interval = interval;
@@ -978,10 +975,7 @@ static void send_eapol_start(struct l_timeout *timeout, void *user_data)
 	l_timeout_remove(sm->eapol_start_timeout);
 	sm->eapol_start_timeout = NULL;
 
-	if (!sm->protocol_version)
-		sm->protocol_version = EAPOL_PROTOCOL_VERSION_2001;
-
-	frame->header.protocol_version = sm->protocol_version;
+	frame->header.protocol_version = EAPOL_PROTOCOL_VERSION_2001;
 	frame->header.packet_type = 1;
 	l_put_be16(0, &frame->header.packet_len);
 
@@ -1388,6 +1382,25 @@ static const uint8_t *eapol_find_rsne(const uint8_t *data, size_t data_len,
 	return first;
 }
 
+static const uint8_t *eapol_find_osen(const uint8_t *data, size_t data_len)
+{
+	struct ie_tlv_iter iter;
+
+	ie_tlv_iter_init(&iter, data, data_len);
+
+	while (ie_tlv_iter_next(&iter)) {
+		if (ie_tlv_iter_get_tag(&iter) == IE_TYPE_VENDOR_SPECIFIC) {
+			if (!is_ie_wfa_ie(iter.data, iter.len, IE_WFA_OI_OSEN))
+				continue;
+		} else
+			continue;
+
+		return ie_tlv_iter_get_data(&iter) - 2;
+	}
+
+	return NULL;
+}
+
 /* 802.11-2016 Section 12.7.6.3 */
 static void eapol_handle_ptk_2_of_4(struct eapol_sm *sm,
 					const struct eapol_key *ek)
@@ -1504,13 +1517,16 @@ static void eapol_handle_ptk_3_of_4(struct eapol_sm *sm,
 	 * not identical to that the STA received in the Beacon or Probe
 	 * Response frame, the STA shall disassociate.
 	 */
-	if (!sm->handshake->wpa_ie)
+	if (sm->handshake->wpa_ie)
+		rsne = eapol_find_wpa_ie(decrypted_key_data,
+					decrypted_key_data_size);
+	else if (sm->handshake->osen_ie)
+		rsne = eapol_find_osen(decrypted_key_data,
+					decrypted_key_data_size);
+	else
 		rsne = eapol_find_rsne(decrypted_key_data,
 					decrypted_key_data_size,
 					&optional_rsne);
-	else
-		rsne = eapol_find_wpa_ie(decrypted_key_data,
-					decrypted_key_data_size);
 
 	if (!rsne)
 		goto error_ie_different;
@@ -2314,15 +2330,22 @@ void eapol_register(struct eapol_sm *sm)
 		sm->watch_id = eapol_frame_watch_add(sm->handshake->ifindex,
 						eapol_rx_auth_packet, sm);
 
+		if (!sm->handshake->proto_version)
+			sm->protocol_version = EAPOL_PROTOCOL_VERSION_2004;
+		else
+			sm->protocol_version = sm->handshake->proto_version;
+
 		sm->started = true;
 		/* Since AP/AdHoc only support AKM PSK we can hard code this */
 		sm->mic_len = 16;
 
 		/* kick off handshake */
 		eapol_ptk_1_of_4_retry(NULL, sm);
-	} else
+	} else {
 		sm->watch_id = eapol_frame_watch_add(sm->handshake->ifindex,
 						eapol_rx_packet, sm);
+		sm->protocol_version = sm->handshake->proto_version;
+	}
 }
 
 bool eapol_start(struct eapol_sm *sm)
@@ -2352,7 +2375,9 @@ bool eapol_start(struct eapol_sm *sm)
 	 * then we wait for a rekey.
 	 */
 	if (sm->handshake->akm_suite & (IE_RSN_AKM_SUITE_FILS_SHA256 |
-			IE_RSN_AKM_SUITE_FILS_SHA384))
+			IE_RSN_AKM_SUITE_FILS_SHA384 |
+			IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384 |
+			IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256))
 		return true;
 
 	if (sm->require_handshake)
diff --git a/src/eapolutil.h b/src/eapolutil.h
index 26ae50fd..020758c2 100644
--- a/src/eapolutil.h
+++ b/src/eapolutil.h
@@ -28,6 +28,7 @@
 enum eapol_protocol_version {
 	EAPOL_PROTOCOL_VERSION_2001	= 1,
 	EAPOL_PROTOCOL_VERSION_2004	= 2,
+	EAPOL_PROTOCOL_VERSION_2010	= 3,
 };
 
 /*
diff --git a/src/erp.c b/src/erp.c
index 030198a5..22938c32 100644
--- a/src/erp.c
+++ b/src/erp.c
@@ -31,6 +31,7 @@
 #include <ell/ell.h>
 
 #include "src/missing.h"
+#include "src/iwd.h"
 #include "src/eap-private.h"
 #include "src/erp.h"
 #include "src/crypto.h"
@@ -525,12 +526,16 @@ const void *erp_get_rmsk(struct erp_state *erp, size_t *rmsk_len)
 	return erp->rmsk;
 }
 
-void erp_init(void)
+static int erp_init(void)
 {
 	key_cache = l_queue_new();
+
+	return 0;
 }
 
-void erp_exit(void)
+static void erp_exit(void)
 {
 	l_queue_destroy(key_cache, erp_cache_entry_destroy);
 }
+
+IWD_MODULE(erp, erp_init, erp_exit)
diff --git a/src/erp.h b/src/erp.h
index 657b1b7b..d2c9da96 100644
--- a/src/erp.h
+++ b/src/erp.h
@@ -51,6 +51,3 @@ struct erp_cache_entry *erp_cache_get(const char *ssid);
 void erp_cache_put(struct erp_cache_entry *cache);
 
 const char *erp_cache_entry_get_identity(struct erp_cache_entry *cache);
-
-void erp_init(void);
-void erp_exit(void);
diff --git a/src/fils.c b/src/fils.c
index aa063357..4291e792 100644
--- a/src/fils.c
+++ b/src/fils.c
@@ -59,6 +59,9 @@ struct fils_sm {
 	uint8_t pmk[48];
 	size_t pmk_len;
 	uint8_t pmkid[16];
+
+	uint8_t fils_ft[48];
+	size_t fils_ft_len;
 };
 
 static void fils_derive_pmkid(struct fils_sm *fils, const uint8_t *erp_data,
@@ -67,8 +70,11 @@ static void fils_derive_pmkid(struct fils_sm *fils, const uint8_t *erp_data,
 	struct l_checksum *sha;
 	enum l_checksum_type type;
 
-	type = (fils->hs->akm_suite == IE_RSN_AKM_SUITE_FILS_SHA256) ?
-				L_CHECKSUM_SHA256 : L_CHECKSUM_SHA384;
+	if (fils->hs->akm_suite & (IE_RSN_AKM_SUITE_FILS_SHA256 |
+			IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256))
+		type = L_CHECKSUM_SHA256;
+	else
+		type = L_CHECKSUM_SHA384;
 
 	sha = l_checksum_new(type);
 	l_checksum_update(sha, erp_data, len);
@@ -108,6 +114,12 @@ static void fils_erp_tx_func(const uint8_t *eap_data, size_t len,
 	ie_tlv_builder_next(&builder, IE_TYPE_FILS_WRAPPED_DATA);
 	ie_tlv_builder_set_data(&builder, eap_data, len);
 
+	if (fils->hs->mde) {
+		ie_tlv_builder_next(&builder, IE_TYPE_MOBILITY_DOMAIN);
+		ie_tlv_builder_set_data(&builder, fils->hs->mde + 2,
+						fils->hs->mde[1]);
+	}
+
 	ie_tlv_builder_finalize(&builder, &tlv_len);
 
 	fils->auth(data, ptr - data + tlv_len, fils->user_data);
@@ -119,21 +131,29 @@ static int fils_derive_key_data(struct fils_sm *fils)
 	size_t rmsk_len;
 	struct ie_tlv_builder builder;
 	uint8_t key[FILS_NONCE_LEN * 2];
-	uint8_t key_data[64 + 48 + 16]; /* largest ICK, KEK, TK */
+	uint8_t key_data[64 + 48 + 16 + 48]; /* largest ICK, KEK, TK, FILS-FT */
 	uint8_t key_auth[48];
 	uint8_t data[44];
 	uint8_t *ptr = data;
 	size_t hash_len;
-	struct iovec iov[2];
+	struct iovec iov[4];
+	size_t iov_elems = 0;
+	size_t fils_ft_len = 0;
 	bool sha384;
 	unsigned int ie_len;
+	uint8_t *rsne = NULL;
 
 	rmsk = erp_get_rmsk(fils->erp, &rmsk_len);
 
+	if (fils->hs->akm_suite == IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256)
+		fils_ft_len = 32;
+	else if (fils->hs->akm_suite == IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384)
+		fils_ft_len = 48;
 	/*
 	 * IEEE 802.11ai - Section 12.12.2.5.3
 	 */
-	if (fils->hs->akm_suite == IE_RSN_AKM_SUITE_FILS_SHA256) {
+	if (fils->hs->akm_suite & (IE_RSN_AKM_SUITE_FILS_SHA256 |
+				IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256)) {
 		sha384 = false;
 		hash_len = 32;
 	} else {
@@ -176,12 +196,12 @@ static int fils_derive_key_data(struct fils_sm *fils)
 		kdf_sha384(fils->pmk, hash_len, "FILS PTK Derivation",
 				strlen("FILS PTK Derivation"), data,
 				sizeof(data), key_data,
-				hash_len + fils->kek_len + 16);
+				hash_len + fils->kek_len + 16 + fils_ft_len);
 	else
 		kdf_sha256(fils->pmk, hash_len, "FILS PTK Derivation",
 				strlen("FILS PTK Derivation"), data,
 				sizeof(data), key_data,
-				hash_len + fils->kek_len + 16);
+				hash_len + fils->kek_len + 16 + fils_ft_len);
 
 	ptr = data;
 
@@ -203,6 +223,14 @@ static int fils_derive_key_data(struct fils_sm *fils)
 	memcpy(fils->ick, key_data, hash_len);
 	fils->ick_len = hash_len;
 
+	if (fils_ft_len) {
+		memcpy(fils->fils_ft, key_data + hash_len + fils->kek_len + 16,
+				fils_ft_len);
+		fils->fils_ft_len = fils_ft_len;
+	}
+
+	handshake_state_set_fils_ft(fils->hs, fils->fils_ft, fils->fils_ft_len);
+
 	if (sha384)
 		hmac_sha384(fils->ick, hash_len, data, ptr - data,
 				key_auth, hash_len);
@@ -218,17 +246,56 @@ static int fils_derive_key_data(struct fils_sm *fils)
 	ie_tlv_builder_next(&builder, IE_TYPE_FILS_SESSION);
 	ie_tlv_builder_set_data(&builder, fils->session, sizeof(fils->session));
 
-	iov[0].iov_base = ie_tlv_builder_finalize(&builder, &ie_len);
-	iov[0].iov_len = ie_len;
-	iov[1].iov_base = fils->hs->supplicant_ie;
-	iov[1].iov_len = fils->hs->supplicant_ie[1] + 2;
+	iov[iov_elems].iov_base = ie_tlv_builder_finalize(&builder, &ie_len);
+	iov[iov_elems].iov_len = ie_len;
+	iov_elems++;
+	iov[iov_elems].iov_base = fils->hs->supplicant_ie;
+	iov[iov_elems].iov_len = fils->hs->supplicant_ie[1] + 2;
+	iov_elems++;
+
+	if (fils->hs->mde) {
+		struct ie_rsn_info rsn_info;
+
+		/*
+		 * IEEE 8021.11ai Section 13.2.4:
+		 *
+		 * If a key hierarchy already exists for this STA belonging to
+		 * the same mobility domain (i.e., having the same MDID), the
+		 * R0KH shall delete the existing PMK-R0 security association
+		 * and PMK-R1 security associations.
+		 *
+		 * All this means is we need to re-derive the new FT keys. This
+		 * will rederive the PTK too, but it will be overwritten with
+		 * the FILS PTK after associate
+		 */
+		handshake_state_derive_ptk(fils->hs);
+
+		iov[iov_elems].iov_base = fils->hs->mde;
+		iov[iov_elems].iov_len = fils->hs->mde[1] + 2;
+		iov_elems++;
+
+		if (ie_parse_rsne_from_data(fils->hs->supplicant_ie,
+						fils->hs->supplicant_ie[1] + 2,
+						&rsn_info) < 0)
+			return -EBADMSG;
+
+		rsn_info.num_pmkids = 1;
+		rsn_info.pmkids = fils->hs->pmk_r1_name;
+
+		rsne = alloca(256);
+		ie_build_rsne(&rsn_info, rsne);
+
+		iov[iov_elems].iov_base = rsne;
+		iov[iov_elems].iov_len = rsne[1] + 2;
+		iov_elems += 1;
+	}
 
 	memcpy(data, fils->nonce, sizeof(fils->nonce));
 	memcpy(data + sizeof(fils->nonce), fils->anonce, sizeof(fils->anonce));
 
 	memcpy(fils->kek_and_tk, key_data + hash_len, fils->kek_len + 16);
 
-	fils->assoc(iov, 2, fils->kek_and_tk, fils->kek_len, data,
+	fils->assoc(iov, iov_elems, fils->kek_and_tk, fils->kek_len, data,
 			FILS_NONCE_LEN * 2, fils->user_data);
 
 	return 0;
@@ -261,11 +328,15 @@ static int fils_rx_authenticate(struct auth_proto *driver, const uint8_t *frame,
 	struct fils_sm *fils = l_container_of(driver, struct fils_sm, ap);
 	const struct mmpdu_header *hdr = mpdu_validate(frame, len);
 	const struct mmpdu_authentication *auth;
+	uint16_t alg;
 	struct ie_tlv_iter iter;
 	const uint8_t *anonce = NULL;
 	const uint8_t *session = NULL;
 	const uint8_t *wrapped = NULL;
 	size_t wrapped_len = 0;
+	const uint8_t *rsne = NULL;
+	const uint8_t *mde = NULL;
+	const uint8_t *fte = NULL;
 
 	if (!hdr) {
 		l_debug("Auth frame header did not validate");
@@ -281,11 +352,12 @@ static int fils_rx_authenticate(struct auth_proto *driver, const uint8_t *frame,
 
 	if (auth->status != 0) {
 		l_debug("invalid status %u", auth->status);
-		return (int)auth->status;
+		return L_LE16_TO_CPU(auth->status);
 	}
 
-	if (auth->algorithm != MMPDU_AUTH_ALGO_FILS_SK &&
-			auth->algorithm != MMPDU_AUTH_ALGO_FILS_SK_PFS) {
+	alg = L_LE16_TO_CPU(auth->algorithm);
+	if (alg != MMPDU_AUTH_ALGO_FILS_SK &&
+			alg != MMPDU_AUTH_ALGO_FILS_SK_PFS) {
 		l_debug("invalid auth algorithm %u", auth->algorithm);
 		return MMPDU_STATUS_CODE_UNSUP_AUTH_ALG;
 	}
@@ -310,6 +382,27 @@ static int fils_rx_authenticate(struct auth_proto *driver, const uint8_t *frame,
 			wrapped = iter.data;
 			wrapped_len = iter.len;
 			break;
+		case IE_TYPE_RSN:
+			if (rsne)
+				goto invalid_ies;
+
+			rsne = ie_tlv_iter_get_data(&iter) - 2;
+			break;
+
+		case IE_TYPE_MOBILITY_DOMAIN:
+			if (mde)
+				goto invalid_ies;
+
+			mde = ie_tlv_iter_get_data(&iter) - 2;
+			break;
+
+		case IE_TYPE_FAST_BSS_TRANSITION:
+			if (fte)
+				goto invalid_ies;
+
+			fte = ie_tlv_iter_get_data(&iter) - 2;
+			break;
+
 		default:
 			continue;
 		}
@@ -320,6 +413,24 @@ static int fils_rx_authenticate(struct auth_proto *driver, const uint8_t *frame,
 		goto invalid_ies;
 	}
 
+	if (mde)
+		handshake_state_set_mde(fils->hs, mde);
+
+	if (fte) {
+		struct handshake_state *hs = fils->hs;
+		uint32_t kck_len = handshake_state_get_kck_len(hs);
+		struct ie_ft_info ft_info;
+
+		if (ie_parse_fast_bss_transition_from_data(fte, fte[1] + 2,
+					kck_len, &ft_info) < 0)
+			goto invalid_ies;
+
+		handshake_state_set_fte(fils->hs, fte);
+		handshake_state_set_kh_ids(fils->hs, ft_info.r0khid,
+							ft_info.r0khid_len,
+							ft_info.r1khid);
+	}
+
 	memcpy(fils->anonce, anonce, FILS_NONCE_LEN);
 
 	if (erp_rx_packet(fils->erp, wrapped, wrapped_len) < 0)
@@ -347,7 +458,8 @@ static int fils_rx_associate(struct auth_proto *driver, const uint8_t *frame,
 	uint8_t igtk_key_index;
 	const uint8_t *ap_key_auth = NULL;
 	uint8_t expected_key_auth[48];
-	bool sha384 = (fils->hs->akm_suite == IE_RSN_AKM_SUITE_FILS_SHA384);
+	bool sha384 = (fils->hs->akm_suite & (IE_RSN_AKM_SUITE_FILS_SHA384 |
+			IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384));
 	uint8_t data[44];
 	uint8_t *ptr = data;
 
@@ -364,7 +476,7 @@ static int fils_rx_associate(struct auth_proto *driver, const uint8_t *frame,
 	}
 
 	if (assoc->status_code != 0)
-		return (int)assoc->status_code;
+		return L_CPU_TO_LE16(assoc->status_code);
 
 	ie_tlv_iter_init(&iter, assoc->ies, (const uint8_t *) hdr + len -
 				assoc->ies);
@@ -409,6 +521,7 @@ static int fils_rx_associate(struct auth_proto *driver, const uint8_t *frame,
 				goto invalid_ies;
 
 			ap_key_auth = iter.data;
+			break;
 		}
 	}
 
diff --git a/src/ft.c b/src/ft.c
index 8457163a..5bd816db 100644
--- a/src/ft.c
+++ b/src/ft.c
@@ -55,7 +55,8 @@ static bool ft_calculate_fte_mic(struct handshake_state *hs, uint8_t seq_num,
 	int iov_elems = 0;
 	struct l_checksum *checksum;
 	const uint8_t *kck = handshake_state_get_kck(hs);
-	uint8_t zero_mic[16] = {};
+	size_t kck_len = handshake_state_get_kck_len(hs);
+	uint8_t zero_mic[24] = {};
 
 	iov[iov_elems].iov_base = hs->spa;
 	iov[iov_elems++].iov_len = 6;
@@ -79,10 +80,10 @@ static bool ft_calculate_fte_mic(struct handshake_state *hs, uint8_t seq_num,
 		iov[iov_elems++].iov_len = 4;
 
 		iov[iov_elems].iov_base = zero_mic;
-		iov[iov_elems++].iov_len = 16;
+		iov[iov_elems++].iov_len = kck_len;
 
-		iov[iov_elems].iov_base = (void *) (fte + 20);
-		iov[iov_elems++].iov_len = fte[1] + 2 - 20;
+		iov[iov_elems].iov_base = (void *) (fte + 4 + kck_len);
+		iov[iov_elems++].iov_len = fte[1] + 2 - 4 - kck_len;
 	}
 
 	if (ric) {
@@ -90,12 +91,16 @@ static bool ft_calculate_fte_mic(struct handshake_state *hs, uint8_t seq_num,
 		iov[iov_elems++].iov_len = ric[1] + 2;
 	}
 
-	checksum = l_checksum_new_cmac_aes(kck, 16);
+	if (kck_len == 16)
+		checksum = l_checksum_new_cmac_aes(kck, kck_len);
+	else
+		checksum = l_checksum_new_hmac(L_CHECKSUM_SHA384, kck, kck_len);
+
 	if (!checksum)
 		return false;
 
 	l_checksum_updatev(checksum, iov, iov_elems);
-	l_checksum_get_digest(checksum, out_mic, 16);
+	l_checksum_get_digest(checksum, out_mic, kck_len);
 	l_checksum_free(checksum);
 
 	return true;
@@ -227,7 +232,7 @@ static bool ft_parse_associate_resp_frame(const uint8_t *frame, size_t frame_len
 		}
 	}
 
-	*out_status = body->status_code;
+	*out_status = L_LE16_TO_CPU(body->status_code);
 
 	return true;
 }
@@ -237,6 +242,7 @@ static int ft_tx_reassociate(struct ft_sm *ft)
 	struct iovec iov[3];
 	int iov_elems = 0;
 	struct handshake_state *hs = ft->hs;
+	uint32_t kck_len = handshake_state_get_kck_len(hs);
 	bool is_rsn = hs->supplicant_ie != NULL;
 	uint8_t *rsne = NULL;
 
@@ -302,13 +308,13 @@ static int ft_tx_reassociate(struct ft_sm *ft)
 		memcpy(ft_info.snonce, hs->snonce, 32);
 
 		fte = alloca(256);
-		ie_build_fast_bss_transition(&ft_info, fte);
+		ie_build_fast_bss_transition(&ft_info, kck_len, fte);
 
 		if (!ft_calculate_fte_mic(hs, 5, rsne, fte, NULL, ft_info.mic))
 			goto error;
 
 		/* Rebuild the FT IE now with the MIC included */
-		ie_build_fast_bss_transition(&ft_info, fte);
+		ie_build_fast_bss_transition(&ft_info, kck_len, fte);
 
 		iov[iov_elems].iov_base = fte;
 		iov[iov_elems].iov_len = fte[1] + 2;
@@ -330,6 +336,7 @@ static int ft_process_ies(struct ft_sm *ft, const uint8_t *ies, size_t ies_len)
 	const uint8_t *mde = NULL;
 	const uint8_t *fte = NULL;
 	struct handshake_state *hs = ft->hs;
+	uint32_t kck_len = handshake_state_get_kck_len(hs);
 	bool is_rsn;
 
 	/* Check 802.11r IEs */
@@ -428,17 +435,17 @@ static int ft_process_ies(struct ft_sm *ft, const uint8_t *ies, size_t ies_len)
 	 */
 	if (is_rsn) {
 		struct ie_ft_info ft_info;
-		uint8_t zeros[16] = {};
+		uint8_t zeros[24] = {};
 
 		if (!fte)
 			goto ft_error;
 
 		if (ie_parse_fast_bss_transition_from_data(fte, fte[1] + 2,
-								&ft_info) < 0)
+						kck_len, &ft_info) < 0)
 			goto ft_error;
 
 		if (ft_info.mic_element_count != 0 ||
-				memcmp(ft_info.mic, zeros, 16))
+				memcmp(ft_info.mic, zeros, kck_len))
 			goto ft_error;
 
 		if (hs->r0khid_len != ft_info.r0khid_len ||
@@ -524,6 +531,7 @@ static int ft_rx_associate(struct auth_proto *ap, const uint8_t *frame,
 {
 	struct ft_sm *ft = l_container_of(ap, struct ft_sm, ap);
 	struct handshake_state *hs = ft->hs;
+	uint32_t kck_len = handshake_state_get_kck_len(hs);
 	const uint8_t *rsne = NULL;
 	const uint8_t *mde = NULL;
 	const uint8_t *fte = NULL;
@@ -586,10 +594,10 @@ static int ft_rx_associate(struct auth_proto *ap, const uint8_t *frame,
 
 	if (fte) {
 		struct ie_ft_info ft_info;
-		uint8_t mic[16];
+		uint8_t mic[24];
 
 		if (ie_parse_fast_bss_transition_from_data(fte, fte[1] + 2,
-								&ft_info) < 0)
+						kck_len, &ft_info) < 0)
 			return -EBADMSG;
 
 		/*
@@ -603,7 +611,7 @@ static int ft_rx_associate(struct auth_proto *ap, const uint8_t *frame,
 			return -EBADMSG;
 
 		if (ft_info.mic_element_count != 3 ||
-				memcmp(ft_info.mic, mic, 16))
+				memcmp(ft_info.mic, mic, kck_len))
 			return -EBADMSG;
 
 		if (hs->r0khid_len != ft_info.r0khid_len ||
@@ -665,6 +673,7 @@ static bool ft_start(struct auth_proto *ap)
 {
 	struct ft_sm *ft = l_container_of(ap, struct ft_sm, ap);
 	struct handshake_state *hs = ft->hs;
+	uint32_t kck_len = handshake_state_get_kck_len(hs);
 	bool is_rsn = hs->supplicant_ie != NULL;
 	uint8_t mde[5];
 	struct iovec iov[3];
@@ -732,7 +741,7 @@ static bool ft_start(struct auth_proto *ap)
 		memcpy(ft_info.snonce, hs->snonce, 32);
 
 		fte = alloca(256);
-		ie_build_fast_bss_transition(&ft_info, fte);
+		ie_build_fast_bss_transition(&ft_info, kck_len, fte);
 
 		iov[iov_elems].iov_base = fte;
 		iov[iov_elems].iov_len = fte[1] + 2;
diff --git a/src/handshake.c b/src/handshake.c
index 19adbfd9..514f47db 100644
--- a/src/handshake.c
+++ b/src/handshake.c
@@ -143,26 +143,36 @@ static bool handshake_state_setup_own_ciphers(struct handshake_state *s,
 	s->pairwise_cipher = info->pairwise_ciphers;
 	s->group_cipher = info->group_cipher;
 	s->group_management_cipher = info->group_management_cipher;
-	s->mfp = info->mfpc;
+
+	/*
+	 * Dont set MFP for OSEN otherwise EAPoL will attempt to negotiate a
+	 * iGTK which is not allowe for OSEN.
+	 */
+	if (!s->osen_ie)
+		s->mfp = info->mfpc;
 
 	return true;
 }
 
-static bool handshake_state_set_authenticator_ie(struct handshake_state *s,
-						const uint8_t *ie, bool is_wpa)
+bool handshake_state_set_authenticator_ie(struct handshake_state *s,
+						const uint8_t *ie)
 {
 	struct ie_rsn_info info;
 
 	l_free(s->authenticator_ie);
 	s->authenticator_ie = l_memdup(ie, ie[1] + 2u);
-	s->wpa_ie = is_wpa;
+	s->wpa_ie = is_ie_wpa_ie(ie + 2, ie[1]);
+	s->osen_ie = is_ie_wfa_ie(ie + 2, ie[1], IE_WFA_OI_OSEN);
 
 	if (!s->authenticator)
 		return true;
 
-	if (is_wpa) {
+	if (s->wpa_ie) {
 		if (ie_parse_wpa_from_data(ie, ie[1] + 2, &info) < 0)
 			return false;
+	} else if (s->osen_ie) {
+		if (ie_parse_osen_from_data(ie, ie[1] + 2, &info) < 0)
+			return false;
 	} else {
 		if (ie_parse_rsne_from_data(ie, ie[1] + 2, &info) < 0)
 			return false;
@@ -171,21 +181,25 @@ static bool handshake_state_set_authenticator_ie(struct handshake_state *s,
 	return handshake_state_setup_own_ciphers(s, &info);
 }
 
-static bool handshake_state_set_supplicant_ie(struct handshake_state *s,
-						const uint8_t *ie, bool is_wpa)
+bool handshake_state_set_supplicant_ie(struct handshake_state *s,
+						const uint8_t *ie)
 {
 	struct ie_rsn_info info;
 
 	l_free(s->supplicant_ie);
 	s->supplicant_ie = l_memdup(ie, ie[1] + 2u);
-	s->wpa_ie = is_wpa;
+	s->wpa_ie = is_ie_wpa_ie(ie + 2, ie[1]);
+	s->osen_ie = is_ie_wfa_ie(ie + 2, ie[1], IE_WFA_OI_OSEN);
 
 	if (s->authenticator)
 		return true;
 
-	if (is_wpa) {
+	if (s->wpa_ie) {
 		if (ie_parse_wpa_from_data(ie, ie[1] + 2, &info) < 0)
 			return false;
+	} else if (s->osen_ie) {
+		if (ie_parse_osen_from_data(ie, ie[1] + 2, &info) < 0)
+			return false;
 	} else {
 		if (ie_parse_rsne_from_data(ie, ie[1] + 2, &info) < 0)
 			return false;
@@ -194,30 +208,6 @@ static bool handshake_state_set_supplicant_ie(struct handshake_state *s,
 	return handshake_state_setup_own_ciphers(s, &info);
 }
 
-bool handshake_state_set_authenticator_rsn(struct handshake_state *s,
-						const uint8_t *rsn_ie)
-{
-	return handshake_state_set_authenticator_ie(s, rsn_ie, false);
-}
-
-bool handshake_state_set_supplicant_rsn(struct handshake_state *s,
-					const uint8_t *rsn_ie)
-{
-	return handshake_state_set_supplicant_ie(s, rsn_ie, false);
-}
-
-bool handshake_state_set_authenticator_wpa(struct handshake_state *s,
-				const uint8_t *wpa_ie)
-{
-	return handshake_state_set_authenticator_ie(s, wpa_ie, true);
-}
-
-bool handshake_state_set_supplicant_wpa(struct handshake_state *s,
-					const uint8_t *wpa_ie)
-{
-	return handshake_state_set_supplicant_ie(s, wpa_ie, true);
-}
-
 void handshake_state_set_ssid(struct handshake_state *s, const uint8_t *ssid,
 				size_t ssid_len)
 {
@@ -270,6 +260,29 @@ void handshake_state_set_no_rekey(struct handshake_state *s, bool no_rekey)
 	s->no_rekey = no_rekey;
 }
 
+void handshake_state_set_fils_ft(struct handshake_state *s,
+					const uint8_t *fils_ft,
+					size_t fils_ft_len)
+{
+	memcpy(s->fils_ft, fils_ft, fils_ft_len);
+	s->fils_ft_len = fils_ft_len;
+}
+
+/*
+ * Override the protocol version used for EAPoL packets.  The selection is as
+ * follows:
+ *  0 -> Automatic, use same proto as the request for the response and
+ *       2004 when in authenticator mode
+ *  1 -> Chooses 2001 Protocol Version
+ *  2 -> Chooses 2004 Protocol Version
+ *  3 -> Chooses 2010 Protocol Version
+ */
+void handshake_state_set_protocol_version(struct handshake_state *s,
+						uint8_t proto_version)
+{
+	s->proto_version = proto_version;
+}
+
 void handshake_state_new_snonce(struct handshake_state *s)
 {
 	get_nonce(s->snonce);
@@ -360,8 +373,13 @@ static bool handshake_get_key_sizes(struct handshake_state *s, size_t *ptk_size,
 		break;
 	}
 
-	if (ptk_size)
+	if (ptk_size) {
 		*ptk_size = kck + kek + tk;
+		if (s->akm_suite == IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256)
+			*ptk_size += 32;
+		else if (s->akm_suite == IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384)
+			*ptk_size += 56;
+	}
 
 	if (kck_size)
 		*kck_size = kck;
@@ -377,25 +395,32 @@ bool handshake_state_derive_ptk(struct handshake_state *s)
 	size_t ptk_size;
 	enum l_checksum_type type;
 
-	if (!s->have_snonce || !s->have_pmk)
-		return false;
+	if (!(s->akm_suite & (IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256 |
+			IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384)))
+		if (!s->have_snonce || !s->have_pmk)
+			return false;
 
 	if ((s->akm_suite & (IE_RSN_AKM_SUITE_FT_OVER_8021X |
 				IE_RSN_AKM_SUITE_FT_USING_PSK |
-				IE_RSN_AKM_SUITE_FT_OVER_SAE_SHA256)) &&
+				IE_RSN_AKM_SUITE_FT_OVER_SAE_SHA256 |
+				IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256 |
+				IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384)) &&
 			(!s->mde || !s->fte))
 		return false;
 
 	s->ptk_complete = false;
 
-	if (s->akm_suite & IE_RSN_AKM_SUITE_FILS_SHA384)
+	if (s->akm_suite & (IE_RSN_AKM_SUITE_FILS_SHA384 |
+			IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384))
 		type = L_CHECKSUM_SHA384;
 	else if (s->akm_suite & (IE_RSN_AKM_SUITE_8021X_SHA256 |
 			IE_RSN_AKM_SUITE_PSK_SHA256 |
 			IE_RSN_AKM_SUITE_SAE_SHA256 |
 			IE_RSN_AKM_SUITE_FT_OVER_SAE_SHA256 |
 			IE_RSN_AKM_SUITE_OWE |
-			IE_RSN_AKM_SUITE_FILS_SHA256))
+			IE_RSN_AKM_SUITE_FILS_SHA256 |
+			IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256 |
+			IE_RSN_AKM_SUITE_OSEN))
 		type = L_CHECKSUM_SHA256;
 	else
 		type = L_CHECKSUM_SHA1;
@@ -404,10 +429,15 @@ bool handshake_state_derive_ptk(struct handshake_state *s)
 
 	if (s->akm_suite & (IE_RSN_AKM_SUITE_FT_OVER_8021X |
 				IE_RSN_AKM_SUITE_FT_USING_PSK |
-				IE_RSN_AKM_SUITE_FT_OVER_SAE_SHA256)) {
+				IE_RSN_AKM_SUITE_FT_OVER_SAE_SHA256 |
+				IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256 |
+				IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384)) {
 		uint16_t mdid;
 		uint8_t ptk_name[16];
 		const uint8_t *xxkey = s->pmk;
+		size_t xxkey_len = 32;
+		bool sha384 = (s->akm_suite &
+					IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384);
 
 		/*
 		 * In a Fast Transition initial mobility domain association
@@ -420,24 +450,31 @@ bool handshake_state_derive_ptk(struct handshake_state *s)
 		 */
 		if (s->akm_suite == IE_RSN_AKM_SUITE_FT_OVER_8021X)
 			xxkey = s->pmk + 32;
+		else if (s->akm_suite & (IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256 |
+				IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384)) {
+			xxkey = s->fils_ft;
+			xxkey_len = s->fils_ft_len;
+		}
 
 		ie_parse_mobility_domain_from_data(s->mde, s->mde[1] + 2,
 							&mdid, NULL, NULL);
 
-		if (!crypto_derive_pmk_r0(xxkey, s->ssid, s->ssid_len, mdid,
+		if (!crypto_derive_pmk_r0(xxkey, xxkey_len, s->ssid,
+						s->ssid_len, mdid,
 						s->r0khid, s->r0khid_len,
-						s->spa,
+						s->spa, sha384,
 						s->pmk_r0, s->pmk_r0_name))
 			return false;
 
 		if (!crypto_derive_pmk_r1(s->pmk_r0, s->r1khid, s->spa,
-						s->pmk_r0_name,
+						s->pmk_r0_name, sha384,
 						s->pmk_r1, s->pmk_r1_name))
 			return false;
 
 		if (!crypto_derive_ft_ptk(s->pmk_r1, s->pmk_r1_name, s->aa,
 						s->spa, s->snonce, s->anonce,
-						s->ptk, ptk_size, ptk_name))
+						sha384, s->ptk, ptk_size,
+						ptk_name))
 			return false;
 	} else
 		if (!crypto_derive_pairwise_ptk(s->pmk, s->pmk_len, s->spa,
@@ -460,9 +497,29 @@ size_t handshake_state_get_ptk_size(struct handshake_state *s)
 
 const uint8_t *handshake_state_get_kck(struct handshake_state *s)
 {
+	/*
+	 * FILS itself does not derive a KCK, but FILS-FT derives additional
+	 * key bytes at the end of the PTK, which contains a special KCK used
+	 * for fast transition. Since the normal FILS protocol will never call
+	 * this, we can assume that its only being called for FILS-FT and is
+	 * requesting this special KCK.
+	 */
+	if (s->akm_suite & IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256)
+		return s->ptk + 48;
+	else if (s->akm_suite & IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384)
+		return s->ptk + 80;
+
 	return s->ptk;
 }
 
+size_t handshake_state_get_kck_len(struct handshake_state *s)
+{
+	if (s->akm_suite & IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384)
+		return 24;
+
+	return 16;
+}
+
 size_t handshake_state_get_kek_len(struct handshake_state *s)
 {
 	size_t kek_size;
@@ -799,6 +856,24 @@ void handshake_util_build_gtk_kde(enum crypto_cipher cipher, const uint8_t *key,
 	memcpy(to, key, key_len);
 }
 
+static const uint8_t *handshake_state_get_ft_fils_kek(struct handshake_state *s,
+						size_t *len)
+{
+	if (s->akm_suite & IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256) {
+		if (len)
+			*len = 16;
+
+		return s->ptk + 64;
+	} else if (s->akm_suite & IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384) {
+		if (len)
+			*len = 32;
+
+		return s->ptk + 104;
+	}
+
+	return NULL;
+}
+
 /*
  * Unwrap a GTK / IGTK included in an FTE following 802.11-2012, Section 12.8.5:
  *
@@ -815,10 +890,17 @@ void handshake_util_build_gtk_kde(enum crypto_cipher cipher, const uint8_t *key,
 bool handshake_decode_fte_key(struct handshake_state *s, const uint8_t *wrapped,
 				size_t key_len, uint8_t *key_out)
 {
-	const uint8_t *kek = handshake_state_get_kek(s);
+	const uint8_t *kek;
+	size_t kek_len = 16;
 	size_t padded_len = key_len < 16 ? 16 : align_len(key_len, 8);
 
-	if (!aes_unwrap(kek, 16, wrapped, padded_len + 8, key_out))
+	if (s->akm_suite & (IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256 |
+				IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384))
+		kek = handshake_state_get_ft_fils_kek(s, &kek_len);
+	else
+		kek = handshake_state_get_kek(s);
+
+	if (!aes_unwrap(kek, kek_len, wrapped, padded_len + 8, key_out))
 		return false;
 
 	if (key_len < padded_len && key_out[key_len++] != 0xdd)
diff --git a/src/handshake.h b/src/handshake.h
index f1e6dccb..4b9d438b 100644
--- a/src/handshake.h
+++ b/src/handshake.h
@@ -91,16 +91,19 @@ struct handshake_state {
 	size_t pmk_len;
 	uint8_t snonce[32];
 	uint8_t anonce[32];
-	uint8_t ptk[80];
-	uint8_t pmk_r0[32];
+	uint8_t ptk[136];
+	uint8_t pmk_r0[48];
 	uint8_t pmk_r0_name[16];
-	uint8_t pmk_r1[32];
+	uint8_t pmk_r1[48];
 	uint8_t pmk_r1_name[16];
 	uint8_t pmkid[16];
+	uint8_t fils_ft[48];
+	uint8_t fils_ft_len;
 	struct l_settings *settings_8021x;
 	bool have_snonce : 1;
 	bool ptk_complete : 1;
 	bool wpa_ie : 1;
+	bool osen_ie : 1;
 	bool have_pmk : 1;
 	bool mfp : 1;
 	bool have_anonce : 1;
@@ -117,6 +120,7 @@ struct handshake_state {
 	uint8_t r1khid[6];
 	uint8_t gtk[32];
 	uint8_t gtk_rsc[6];
+	uint8_t proto_version : 2;
 	unsigned int gtk_index;
 	struct erp_cache_entry *erp_cache;
 	void *user_data;
@@ -139,14 +143,10 @@ void handshake_state_set_ptk(struct handshake_state *s, const uint8_t *ptk,
 				size_t ptk_len);
 void handshake_state_set_8021x_config(struct handshake_state *s,
 					struct l_settings *settings);
-bool handshake_state_set_supplicant_rsn(struct handshake_state *s,
-					const uint8_t *rsn_ie);
-bool handshake_state_set_authenticator_rsn(struct handshake_state *s,
-					const uint8_t *rsn_ie);
-bool handshake_state_set_supplicant_wpa(struct handshake_state *s,
-					const uint8_t *wpa_ie);
-bool handshake_state_set_authenticator_wpa(struct handshake_state *s,
-					const uint8_t *wpa_ie);
+bool handshake_state_set_authenticator_ie(struct handshake_state *s,
+						const uint8_t *ie);
+bool handshake_state_set_supplicant_ie(struct handshake_state *s,
+						const uint8_t *ie);
 void handshake_state_set_ssid(struct handshake_state *s,
 					const uint8_t *ssid, size_t ssid_len);
 void handshake_state_set_mde(struct handshake_state *s,
@@ -164,6 +164,13 @@ void handshake_state_set_passphrase(struct handshake_state *s,
 					const char *passphrase);
 void handshake_state_set_no_rekey(struct handshake_state *s, bool no_rekey);
 
+void handshake_state_set_fils_ft(struct handshake_state *s,
+					const uint8_t *fils_ft,
+					size_t fils_ft_len);
+
+void handshake_state_set_protocol_version(struct handshake_state *s,
+						uint8_t proto_version);
+
 void handshake_state_new_snonce(struct handshake_state *s);
 void handshake_state_new_anonce(struct handshake_state *s);
 void handshake_state_set_anonce(struct handshake_state *s,
@@ -171,6 +178,7 @@ void handshake_state_set_anonce(struct handshake_state *s,
 void handshake_state_set_pmkid(struct handshake_state *s, const uint8_t *pmkid);
 bool handshake_state_derive_ptk(struct handshake_state *s);
 size_t handshake_state_get_ptk_size(struct handshake_state *s);
+size_t handshake_state_get_kck_len(struct handshake_state *s);
 const uint8_t *handshake_state_get_kck(struct handshake_state *s);
 size_t handshake_state_get_kek_len(struct handshake_state *s);
 const uint8_t *handshake_state_get_kek(struct handshake_state *s);
diff --git a/src/hotspot.c b/src/hotspot.c
new file mode 100644
index 00000000..4642bbec
--- /dev/null
+++ b/src/hotspot.c
@@ -0,0 +1,362 @@
+/*
+ *
+ *  Wireless daemon for Linux
+ *
+ *  Copyright (C) 2019  Intel Corporation. All rights reserved.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <dirent.h>
+#include <errno.h>
+
+#include <ell/ell.h>
+
+#include "src/iwd.h"
+#include "src/common.h"
+#include "src/network.h"
+#include "src/util.h"
+#include "src/hotspot.h"
+#include "src/ie.h"
+
+static struct l_dir_watch *hs20_dir_watch;
+static const char *hs20_dir = DAEMON_STORAGEDIR "/hotspot";
+static struct l_queue *hs20_settings;
+
+struct hs20_config {
+	char *filename;
+	uint8_t hessid[6];
+	char **nai_realms;
+	uint8_t *rc; /* roaming consortium */
+	size_t rc_len;
+};
+
+static bool match_filename(const void *a, const void *b)
+{
+	const struct hs20_config *config = a;
+	const char *filename = b;
+
+	if (!strcmp(config->filename, filename))
+		return true;
+
+	return false;
+}
+
+static void hs20_config_free(void *user_data)
+{
+	struct hs20_config *config = user_data;
+
+	l_strv_free(config->nai_realms);
+	l_free(config->filename);
+	l_free(config);
+}
+
+static struct hs20_config *hs20_config_new(struct l_settings *settings,
+						char *filename)
+{
+	struct hs20_config *config;
+	char *str;
+	char **nai_realms = NULL;
+	const char *rc_str;
+
+	config = l_new(struct hs20_config, 1);
+
+	/* One of HESSID, NAI realms, or Roaming Consortium must be included */
+	str = l_settings_get_string(settings, "Hotspot", "HESSID");
+	if (str) {
+		util_string_to_address(str, config->hessid);
+		l_free(str);
+	}
+
+	nai_realms = l_settings_get_string_list(settings, "Hotspot",
+						"NAIRealmNames", ',');
+	if (nai_realms)
+		config->nai_realms = nai_realms;
+
+	rc_str = l_settings_get_value(settings, "Hotspot", "RoamingConsortium");
+	if (rc_str) {
+		config->rc = l_util_from_hexstring(rc_str, &config->rc_len);
+		/*
+		 * WiFi Alliance Hotspot 2.0 Spec - Section 3.1.4
+		 *
+		 * "The Consortium OI field is 3 or 5-octet field set to a value
+		 * of a roaming consortium OI"
+		 */
+		if (config->rc && config->rc_len != 3 && config->rc_len != 5) {
+			l_warn("invalid RoamingConsortium length %zu",
+					config->rc_len);
+			l_free(config->rc);
+			config->rc = NULL;
+		}
+	}
+
+	if (util_mem_is_zero(config->hessid, 6) && !nai_realms && !config->rc) {
+		l_free(config);
+		return NULL;
+	}
+
+	config->filename = l_strdup(filename);
+
+	return config;
+}
+
+static void hs20_dir_watch_cb(const char *filename,
+				enum l_dir_watch_event event,
+				void *user_data)
+{
+	struct l_settings *new;
+	struct hs20_config *config;
+
+	L_AUTO_FREE_VAR(char *, full_path) = NULL;
+
+	/*
+	 * Ignore notifications for the actual directory, we can't do
+	 * anything about some of them anyway.  Only react to
+	 * notifications for files in the storage directory.
+	 */
+	if (!filename)
+		return;
+
+	full_path = l_strdup_printf("%s/%s", hs20_dir, filename);
+
+	switch (event) {
+	case L_DIR_WATCH_EVENT_CREATED:
+		new = l_settings_new();
+
+		if (!l_settings_load_from_file(new, full_path)) {
+			l_settings_free(new);
+			return;
+		}
+
+		config = hs20_config_new(new, full_path);
+		if (!config)
+			break;
+
+		l_queue_push_head(hs20_settings, config);
+
+		break;
+	case L_DIR_WATCH_EVENT_REMOVED:
+		config = l_queue_remove_if(hs20_settings, match_filename,
+						full_path);
+		if (!config)
+			return;
+
+		hs20_config_free(config);
+		config = NULL;
+
+		/*
+		 * TODO: Disconnect any networks using this provisioning file
+		 */
+
+		break;
+	case L_DIR_WATCH_EVENT_MODIFIED:
+		config = l_queue_remove_if(hs20_settings, match_filename,
+						full_path);
+		if (!config)
+			return;
+
+		hs20_config_free(config);
+
+		new = l_settings_new();
+
+		if (!l_settings_load_from_file(new, full_path)) {
+			l_settings_free(new);
+			return;
+		}
+
+		config = hs20_config_new(new, full_path);
+		if (!config)
+			break;
+
+		l_queue_push_head(hs20_settings, config);
+
+		break;
+	case L_DIR_WATCH_EVENT_ACCESSED:
+		break;
+	}
+}
+
+static void hs20_dir_watch_destroy(void *user_data)
+{
+	hs20_dir_watch = NULL;
+}
+
+static bool match_hessid(const void *a, const void *b)
+{
+	const struct hs20_config *config = a;
+	const uint8_t *hessid = b;
+
+	if (!memcmp(config->hessid, hessid, 6))
+		return true;
+
+	return false;
+}
+
+static bool match_nai_realm(const void *a, const void *b)
+{
+	const struct hs20_config *config = a;
+	char **realms = (char **)b;
+
+	while (*realms) {
+		if (l_strv_contains(config->nai_realms, *realms))
+			return true;
+
+		realms++;
+	}
+
+	return false;
+}
+
+static bool match_rc(const void *a, const void *b)
+{
+	const struct hs20_config *config = a;
+	const uint8_t *rc_ie = b;
+	const uint8_t *rc1, *rc2, *rc3;
+	size_t rc1_len, rc2_len, rc3_len;
+
+	if (ie_parse_roaming_consortium_from_data(rc_ie, rc_ie[1] + 2, NULL,
+						&rc1, &rc1_len, &rc2, &rc2_len,
+						&rc3, &rc3_len) < 0)
+		return false;
+
+	/* rc1 is guarenteed to be set if the above returns success */
+	if (rc1_len == config->rc_len && !memcmp(rc1, config->rc, rc1_len))
+		return true;
+
+	if (rc2 && rc2_len == config->rc_len &&
+				!memcmp(rc2, config->rc, rc2_len))
+		return true;
+
+	if (rc3 && rc1_len == config->rc_len &&
+				!memcmp(rc3, config->rc, rc3_len))
+		return true;
+
+	return false;
+}
+
+const char *hs20_find_settings_file(struct network *network)
+{
+	struct hs20_config *config;
+	uint8_t *hessid = network_get_hessid(network);
+	char **nai_realms = network_get_nai_realms(network);
+	const uint8_t *rc_ie = network_get_roaming_consortium(network);
+
+	if (!hessid || util_mem_is_zero(hessid, 6)) {
+		l_debug("Network has no HESSID, trying NAI realms");
+		goto try_nai_realms;
+	}
+
+	config = l_queue_find(hs20_settings, match_hessid, hessid);
+	if (config)
+		return config->filename;
+
+try_nai_realms:
+	if (!nai_realms) {
+		l_debug("Network has no NAI Realms, trying roaming consortium");
+		goto try_roaming_consortium;
+	}
+
+	config = l_queue_find(hs20_settings, match_nai_realm, nai_realms);
+	if (config)
+		return config->filename;
+
+try_roaming_consortium:
+	if (!rc_ie) {
+		l_debug("Network has no roaming consortium IE");
+		return NULL;
+	}
+
+	config = l_queue_find(hs20_settings, match_rc, rc_ie);
+	if (config)
+		return config->filename;
+
+	return NULL;
+}
+
+const uint8_t *hs20_get_roaming_consortium(struct network *network,
+						size_t *len)
+{
+	struct hs20_config *config;
+	const uint8_t *rc_ie = network_get_roaming_consortium(network);
+
+	if (!rc_ie)
+		return NULL;
+
+	config = l_queue_find(hs20_settings, match_rc, rc_ie);
+	if (config) {
+		*len = config->rc_len;
+		return config->rc;
+	}
+
+	return NULL;
+}
+
+static int hotspot_init(void)
+{
+	DIR *dir;
+	struct dirent *dirent;
+
+	dir = opendir(hs20_dir);
+	if (!dir)
+		return -ENOENT;
+
+	hs20_settings = l_queue_new();
+
+	while ((dirent = readdir(dir))) {
+		struct hs20_config *config;
+		struct l_settings *s;
+		char *filename;
+
+		if (dirent->d_type != DT_REG && dirent->d_type != DT_LNK)
+			continue;
+
+		filename = l_strdup_printf("%s/%s", hs20_dir, dirent->d_name);
+		s = l_settings_new();
+
+		if (!l_settings_load_from_file(s, filename))
+			goto next;
+
+		config = hs20_config_new(s, filename);
+
+		if (config)
+			l_queue_push_head(hs20_settings, config);
+
+next:
+		l_free(filename);
+		l_settings_free(s);
+	}
+
+	closedir(dir);
+
+	hs20_dir_watch = l_dir_watch_new(hs20_dir, hs20_dir_watch_cb, NULL,
+						hs20_dir_watch_destroy);
+
+	return 0;
+}
+
+static void hotspot_exit(void)
+{
+	l_dir_watch_destroy(hs20_dir_watch);
+
+	l_queue_destroy(hs20_settings, hs20_config_free);
+	hs20_settings = NULL;
+}
+
+IWD_MODULE(hotspot, hotspot_init, hotspot_exit)
diff --git a/src/hotspot.h b/src/hotspot.h
new file mode 100644
index 00000000..7ce95156
--- /dev/null
+++ b/src/hotspot.h
@@ -0,0 +1,28 @@
+/*
+ *
+ *  Wireless daemon for Linux
+ *
+ *  Copyright (C) 2019  Intel Corporation. All rights reserved.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+struct network;
+
+const char *hs20_find_settings_file(struct network *network);
+
+const uint8_t *hs20_get_roaming_consortium(struct network *network,
+						size_t *len);
diff --git a/src/ie.c b/src/ie.c
index 239cb2c8..5e607df4 100644
--- a/src/ie.c
+++ b/src/ie.c
@@ -32,8 +32,9 @@
 #include "src/crypto.h"
 #include "src/ie.h"
 
-static const uint8_t ieee_oui[3] = { 0x00, 0x0f, 0xac };
-static const uint8_t microsoft_oui[3] = { 0x00, 0x50, 0xf2 };
+const unsigned char ieee_oui[3] = { 0x00, 0x0f, 0xac };
+const unsigned char microsoft_oui[3] = { 0x00, 0x50, 0xf2 };
+const unsigned char wifi_alliance_oui[3] = { 0x50, 0x6f, 0x9a };
 
 void ie_tlv_iter_init(struct ie_tlv_iter *iter, const unsigned char *tlv,
 			unsigned int len)
@@ -96,6 +97,7 @@ static void *ie_tlv_vendor_ie_concat(const unsigned char oui[],
 					unsigned char type,
 					const unsigned char *ies,
 					unsigned int len,
+					bool empty_ok,
 					ssize_t *out_len)
 {
 	struct ie_tlv_iter iter;
@@ -103,6 +105,7 @@ static void *ie_tlv_vendor_ie_concat(const unsigned char oui[],
 	unsigned int ie_len;
 	unsigned int concat_len = 0;
 	unsigned char *ret;
+	bool ie_found = false;
 
 	ie_tlv_iter_init(&iter, ies, len);
 
@@ -123,11 +126,12 @@ static void *ie_tlv_vendor_ie_concat(const unsigned char oui[],
 			continue;
 
 		concat_len += ie_len - 4;
+		ie_found = true;
 	}
 
 	if (concat_len == 0) {
 		if (out_len)
-			*out_len = -ENOENT;
+			*out_len = (ie_found && empty_ok) ? 0 : -ENOENT;
 
 		return NULL;
 	}
@@ -175,7 +179,25 @@ static void *ie_tlv_vendor_ie_concat(const unsigned char oui[],
 void *ie_tlv_extract_wsc_payload(const unsigned char *ies, size_t len,
 							ssize_t *out_len)
 {
-	return ie_tlv_vendor_ie_concat(microsoft_oui, 0x04, ies, len, out_len);
+	return ie_tlv_vendor_ie_concat(microsoft_oui, 0x04,
+					ies, len, false, out_len);
+}
+
+/*
+ * Wi-Fi P2P Technical Specification v1.7, Section 8.2:
+ * "More than one P2P IE may be included in a single frame.  If multiple P2P
+ * IEs are present, the complete P2P attribute data consists of the
+ * concatenation of the P2P Attribute fields of the P2P IEs.  The P2P
+ * Attributes field of each P2P IE may be any length up to the maximum
+ * (251 octets).  The order of the concatenated P2P attribute data shall be
+ * preserved in the ordering of the P2P IEs in the frame.  All of the P2P IEs
+ * shall fit within a single frame and shall be adjacent in the frame."
+ */
+void *ie_tlv_extract_p2p_payload(const unsigned char *ies, size_t len,
+							ssize_t *out_len)
+{
+	return ie_tlv_vendor_ie_concat(wifi_alliance_oui, 0x09,
+					ies, len, true, out_len);
 }
 
 /*
@@ -187,6 +209,7 @@ void *ie_tlv_extract_wsc_payload(const unsigned char *ies, size_t len,
 static void *ie_tlv_vendor_ie_encapsulate(const unsigned char oui[],
 					uint8_t type,
 					const void *data, size_t len,
+					bool build_empty,
 					size_t *out_len)
 {
 	size_t overhead;
@@ -200,6 +223,9 @@ static void *ie_tlv_vendor_ie_encapsulate(const unsigned char oui[],
 	 */
 	overhead = (len + 250) / 251 * 6;
 
+	if (len == 0 && build_empty)
+		overhead = 6;
+
 	ret = l_malloc(len + overhead);
 
 	if (out_len)
@@ -207,7 +233,7 @@ static void *ie_tlv_vendor_ie_encapsulate(const unsigned char oui[],
 
 	offset = 0;
 
-	while (len) {
+	while (overhead) {
 		ie_len = len <= 251 ? len : 251;
 		ret[offset++] = IE_TYPE_VENDOR_SPECIFIC;
 		ret[offset++] = ie_len + 4;
@@ -218,6 +244,7 @@ static void *ie_tlv_vendor_ie_encapsulate(const unsigned char oui[],
 
 		data += ie_len;
 		len -= ie_len;
+		overhead -= 6;
 	}
 
 	return ret;
@@ -227,7 +254,14 @@ void *ie_tlv_encapsulate_wsc_payload(const uint8_t *data, size_t len,
 								size_t *out_len)
 {
 	return ie_tlv_vendor_ie_encapsulate(microsoft_oui, 0x04,
-							data, len, out_len);
+						data, len, false, out_len);
+}
+
+void *ie_tlv_encapsulate_p2p_payload(const uint8_t *data, size_t len,
+								size_t *out_len)
+{
+	return ie_tlv_vendor_ie_encapsulate(wifi_alliance_oui, 0x09,
+						data, len, true, out_len);
 }
 
 #define TLV_HEADER_LEN 2
@@ -423,7 +457,7 @@ static bool ie_parse_cipher_suite(const uint8_t *data,
 }
 
 /* 802.11, Section 8.4.2.27.2 */
-static int ie_parse_akm_suite(const uint8_t *data,
+static int ie_parse_rsn_akm_suite(const uint8_t *data,
 					enum ie_rsn_akm_suite *out)
 {
 	/*
@@ -497,6 +531,20 @@ static int ie_parse_akm_suite(const uint8_t *data,
 	return -ENOENT;
 }
 
+static int ie_parse_osen_akm_suite(const uint8_t *data,
+					enum ie_rsn_akm_suite *out)
+{
+	if (memcmp(data, wifi_alliance_oui, 3))
+		return -ENOENT;
+
+	if (data[3] != 1)
+		return -ENOENT;
+
+	*out = IE_RSN_AKM_SUITE_OSEN;
+
+	return 0;
+}
+
 static bool ie_parse_group_cipher(const uint8_t *data,
 					enum ie_rsn_cipher_suite *out)
 {
@@ -559,6 +607,7 @@ static bool ie_parse_group_management_cipher(const uint8_t *data,
 
 	switch (tmp) {
 	case IE_RSN_CIPHER_SUITE_BIP:
+	case IE_RSN_CIPHER_SUITE_NO_GROUP_TRAFFIC:
 		break;
 	default:
 		return false;
@@ -575,35 +624,19 @@ static bool ie_parse_group_management_cipher(const uint8_t *data,
 	if (len == 0)			\
 		goto done		\
 
-int ie_parse_rsne(struct ie_tlv_iter *iter, struct ie_rsn_info *out_info)
+static int parse_ciphers(const uint8_t *data, size_t len,
+			int (*akm_parse)(const uint8_t *data,
+						enum ie_rsn_akm_suite *out),
+			struct ie_rsn_info *out_info)
 {
-	const uint8_t *data = iter->data;
-	size_t len = iter->len;
-	uint16_t version;
-	struct ie_rsn_info info;
 	uint16_t count;
 	uint16_t i;
 
-	memset(&info, 0, sizeof(info));
-	info.group_cipher = IE_RSN_CIPHER_SUITE_CCMP;
-	info.pairwise_ciphers = IE_RSN_CIPHER_SUITE_CCMP;
-	info.akm_suites = IE_RSN_AKM_SUITE_8021X;
-
-	/* Parse Version field */
-	if (len < 2)
-		return -EMSGSIZE;
-
-	version = l_get_le16(data);
-	if (version != 0x01)
-		return -EBADMSG;
-
-	RSNE_ADVANCE(data, len, 2);
-
 	/* Parse Group Cipher Suite field */
 	if (len < 4)
 		return -EBADMSG;
 
-	if (!ie_parse_group_cipher(data, &info.group_cipher))
+	if (!ie_parse_group_cipher(data, &out_info->group_cipher))
 		return -ERANGE;
 
 	RSNE_ADVANCE(data, len, 4);
@@ -628,13 +661,13 @@ int ie_parse_rsne(struct ie_tlv_iter *iter, struct ie_rsn_info *out_info)
 		return -EBADMSG;
 
 	/* Parse Pairwise Cipher Suite List field */
-	for (i = 0, info.pairwise_ciphers = 0; i < count; i++) {
+	for (i = 0, out_info->pairwise_ciphers = 0; i < count; i++) {
 		enum ie_rsn_cipher_suite suite;
 
 		if (!ie_parse_pairwise_cipher(data + i * 4, &suite))
 			return -ERANGE;
 
-		info.pairwise_ciphers |= suite;
+		out_info->pairwise_ciphers |= suite;
 	}
 
 	RSNE_ADVANCE(data, len, count * 4);
@@ -654,14 +687,14 @@ int ie_parse_rsne(struct ie_tlv_iter *iter, struct ie_rsn_info *out_info)
 		return -EBADMSG;
 
 	/* Parse AKM Suite List field */
-	for (i = 0, info.akm_suites = 0; i < count; i++) {
+	for (i = 0, out_info->akm_suites = 0; i < count; i++) {
 		enum ie_rsn_akm_suite suite;
 		int ret;
 
-		ret = ie_parse_akm_suite(data + i * 4, &suite);
+		ret = akm_parse(data + i * 4, &suite);
 		switch (ret) {
 		case 0:
-			info.akm_suites |= suite;
+			out_info->akm_suites |= suite;
 			break;
 		case -ENOENT:
 			/* Skip unknown or vendor specific AKMs */
@@ -676,24 +709,24 @@ int ie_parse_rsne(struct ie_tlv_iter *iter, struct ie_rsn_info *out_info)
 	if (len < 2)
 		return -EBADMSG;
 
-	info.preauthentication = util_is_bit_set(data[0], 0);
-	info.no_pairwise = util_is_bit_set(data[0], 1);
-	info.ptksa_replay_counter = util_bit_field(data[0], 2, 2);
-	info.gtksa_replay_counter = util_bit_field(data[0], 4, 2);
-	info.mfpr = util_is_bit_set(data[0], 6);
-	info.mfpc = util_is_bit_set(data[0], 7);
-	info.peerkey_enabled = util_is_bit_set(data[1], 1);
-	info.spp_a_msdu_capable = util_is_bit_set(data[1], 2);
-	info.spp_a_msdu_required = util_is_bit_set(data[1], 3);
-	info.pbac = util_is_bit_set(data[1], 4);
-	info.extended_key_id = util_is_bit_set(data[1], 5);
+	out_info->preauthentication = util_is_bit_set(data[0], 0);
+	out_info->no_pairwise = util_is_bit_set(data[0], 1);
+	out_info->ptksa_replay_counter = util_bit_field(data[0], 2, 2);
+	out_info->gtksa_replay_counter = util_bit_field(data[0], 4, 2);
+	out_info->mfpr = util_is_bit_set(data[0], 6);
+	out_info->mfpc = util_is_bit_set(data[0], 7);
+	out_info->peerkey_enabled = util_is_bit_set(data[1], 1);
+	out_info->spp_a_msdu_capable = util_is_bit_set(data[1], 2);
+	out_info->spp_a_msdu_required = util_is_bit_set(data[1], 3);
+	out_info->pbac = util_is_bit_set(data[1], 4);
+	out_info->extended_key_id = util_is_bit_set(data[1], 5);
 
 	/*
 	 * BIPdefault group management cipher suite in an RSNA with
 	 * management frame protection enabled
 	 */
-	if (info.mfpc)
-		info.group_management_cipher = IE_RSN_CIPHER_SUITE_BIP;
+	if (out_info->mfpc)
+		out_info->group_management_cipher = IE_RSN_CIPHER_SUITE_BIP;
 
 	RSNE_ADVANCE(data, len, 2);
 
@@ -701,11 +734,11 @@ int ie_parse_rsne(struct ie_tlv_iter *iter, struct ie_rsn_info *out_info)
 	if (len < 2)
 		return -EBADMSG;
 
-	info.num_pmkids = l_get_le16(data);
+	out_info->num_pmkids = l_get_le16(data);
 	RSNE_ADVANCE(data, len, 2);
 
-	if (info.num_pmkids > 0) {
-		if (len < 16 * info.num_pmkids)
+	if (out_info->num_pmkids > 0) {
+		if (len < 16 * out_info->num_pmkids)
 			return -EBADMSG;
 
 		/*
@@ -714,8 +747,8 @@ int ie_parse_rsne(struct ie_tlv_iter *iter, struct ie_rsn_info *out_info)
 		 * We simply assign the pointer to the PMKIDs to the structure.
 		 * The PMKIDs are fixed size, 16 bytes each.
 		 */
-		info.pmkids = data;
-		RSNE_ADVANCE(data, len, info.num_pmkids * 16);
+		out_info->pmkids = data;
+		RSNE_ADVANCE(data, len, out_info->num_pmkids * 16);
 	}
 
 	/* Parse Group Management Cipher Suite field */
@@ -723,13 +756,42 @@ int ie_parse_rsne(struct ie_tlv_iter *iter, struct ie_rsn_info *out_info)
 		return -EBADMSG;
 
 	if (!ie_parse_group_management_cipher(data,
-						&info.group_management_cipher))
+					&out_info->group_management_cipher))
 		return -ERANGE;
 
 	RSNE_ADVANCE(data, len, 4);
 
 	return -EBADMSG;
 
+done:
+	return 0;
+}
+
+int ie_parse_rsne(struct ie_tlv_iter *iter, struct ie_rsn_info *out_info)
+{
+	const uint8_t *data = iter->data;
+	size_t len = iter->len;
+	uint16_t version;
+	struct ie_rsn_info info;
+
+	memset(&info, 0, sizeof(info));
+	info.group_cipher = IE_RSN_CIPHER_SUITE_CCMP;
+	info.pairwise_ciphers = IE_RSN_CIPHER_SUITE_CCMP;
+	info.akm_suites = IE_RSN_AKM_SUITE_8021X;
+
+	/* Parse Version field */
+	if (len < 2)
+		return -EMSGSIZE;
+
+	version = l_get_le16(data);
+	if (version != 0x01)
+		return -EBADMSG;
+
+	RSNE_ADVANCE(data, len, 2);
+
+	if (parse_ciphers(data, len, ie_parse_rsn_akm_suite, &info) < 0)
+		return -EBADMSG;
+
 done:
 	if (out_info)
 		memcpy(out_info, &info, sizeof(info));
@@ -753,6 +815,48 @@ int ie_parse_rsne_from_data(const uint8_t *data, size_t len,
 	return ie_parse_rsne(&iter, info);
 }
 
+int ie_parse_osen(struct ie_tlv_iter *iter, struct ie_rsn_info *out_info)
+{
+	const uint8_t *data = iter->data;
+	size_t len = iter->len;
+	struct ie_rsn_info info;
+
+	if (ie_tlv_iter_get_tag(iter) != IE_TYPE_VENDOR_SPECIFIC)
+		return -EPROTOTYPE;
+
+	if (!is_ie_wfa_ie(iter->data, iter->len, IE_WFA_OI_OSEN))
+		return -EPROTOTYPE;
+
+	RSNE_ADVANCE(data, len, 4);
+
+	memset(&info, 0, sizeof(info));
+	info.group_cipher = IE_RSN_CIPHER_SUITE_NO_GROUP_TRAFFIC;
+	info.pairwise_ciphers = IE_RSN_CIPHER_SUITE_CCMP;
+	info.akm_suites = IE_RSN_AKM_SUITE_8021X;
+
+	if (parse_ciphers(data, len, ie_parse_osen_akm_suite, &info) < 0)
+		return -EBADMSG;
+
+done:
+	if (out_info)
+		memcpy(out_info, &info, sizeof(info));
+
+	return 0;
+}
+
+int ie_parse_osen_from_data(const uint8_t *data, size_t len,
+				struct ie_rsn_info *info)
+{
+	struct ie_tlv_iter iter;
+
+	ie_tlv_iter_init(&iter, data, len);
+
+	if (!ie_tlv_iter_next(&iter))
+		return -EMSGSIZE;
+
+	return ie_parse_osen(&iter, info);
+}
+
 /*
  * 802.11, Section 8.4.2.27.2
  * 802.11i, Section 7.3.2.25.1 and WPA_80211_v3_1 Section 2.1
@@ -839,6 +943,8 @@ static bool ie_build_rsn_akm_suite(uint8_t *data, enum ie_rsn_akm_suite suite)
 		RETURN_AKM(data, ieee_oui, 17);
 	case IE_RSN_AKM_SUITE_OWE:
 		RETURN_AKM(data, ieee_oui, 18);
+	case IE_RSN_AKM_SUITE_OSEN:
+		RETURN_AKM(data, wifi_alliance_oui, 1);
 	}
 
 	return false;
@@ -859,15 +965,8 @@ static bool ie_build_wpa_akm_suite(uint8_t *data, enum ie_rsn_akm_suite suite)
 	return false;
 }
 
-/*
- * Generate an RSNE IE based on the information found in info.
- * The to array must be 256 bytes in size
- *
- * In theory it is possible to generate 257 byte IE RSNs (1 byte for IE Type,
- * 1 byte for Length and 255 bytes of data) but we don't support this
- * possibility.
- */
-bool ie_build_rsne(const struct ie_rsn_info *info, uint8_t *to)
+static int build_ciphers_common(const struct ie_rsn_info *info, uint8_t *to,
+				uint8_t max_len, bool force_group_mgmt_cipher)
 {
 	/* These are the only valid pairwise suites */
 	static enum ie_rsn_cipher_suite pairwise_suites[] = {
@@ -877,22 +976,15 @@ bool ie_build_rsne(const struct ie_rsn_info *info, uint8_t *to)
 		IE_RSN_CIPHER_SUITE_WEP40,
 		IE_RSN_CIPHER_SUITE_USE_GROUP_CIPHER,
 	};
-	unsigned int pos;
+	unsigned int pos = 0;
 	unsigned int i;
 	uint8_t *countptr;
 	uint16_t count;
 	enum ie_rsn_akm_suite akm_suite;
 
-	to[0] = IE_TYPE_RSN;
-
-	/* Version field, always 1 */
-	pos = 2;
-	l_put_le16(1, to + pos);
-	pos += 2;
-
 	/* Group Data Cipher Suite */
 	if (!ie_build_cipher_suite(to + pos, ieee_oui, info->group_cipher))
-		return false;
+		return -EINVAL;
 
 	pos += 4;
 
@@ -906,11 +998,11 @@ bool ie_build_rsne(const struct ie_rsn_info *info, uint8_t *to)
 		if (!(info->pairwise_ciphers & suite))
 			continue;
 
-		if (pos + 4 > 242)
-			return false;
+		if (pos + 4 > max_len)
+			return -EBADMSG;
 
 		if (!ie_build_cipher_suite(to + pos, ieee_oui, suite))
-			return false;
+			return -EINVAL;
 
 		pos += 4;
 		count += 1;
@@ -926,16 +1018,16 @@ bool ie_build_rsne(const struct ie_rsn_info *info, uint8_t *to)
 	count = 0;
 
 	for (count = 0, akm_suite = IE_RSN_AKM_SUITE_8021X;
-			akm_suite <= IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384;
+			akm_suite <= IE_RSN_AKM_SUITE_OSEN;
 				akm_suite <<= 1) {
 		if (!(info->akm_suites & akm_suite))
 			continue;
 
-		if (pos + 4 > 248)
-			return false;
+		if (pos + 4 > max_len)
+			return -EBADMSG;
 
 		if (!ie_build_rsn_akm_suite(to + pos, akm_suite))
-			return false;
+			return -EINVAL;
 
 		pos += 4;
 		count += 1;
@@ -984,7 +1076,7 @@ bool ie_build_rsne(const struct ie_rsn_info *info, uint8_t *to)
 	pos += 1;
 
 	/* Short hand the generated RSNE if possible */
-	if (info->num_pmkids == 0) {
+	if (info->num_pmkids == 0 && !force_group_mgmt_cipher) {
 		/* No Group Management Cipher Suite */
 		if (to[pos - 2] == 0 && to[pos - 1] == 0) {
 			pos -= 2;
@@ -1000,26 +1092,81 @@ bool ie_build_rsne(const struct ie_rsn_info *info, uint8_t *to)
 	l_put_le16(info->num_pmkids, to + pos);
 	pos += 2;
 
-	if (pos + info->num_pmkids * 16 > 252)
-		return false;
+	if (pos + info->num_pmkids * 16 > max_len)
+		return -EINVAL;
 
 	/* PMKID List */
-	memcpy(to + pos, info->pmkids, 16 * info->num_pmkids);
-	pos += 16 * info->num_pmkids;
+	if (info->num_pmkids) {
+		memcpy(to + pos, info->pmkids, 16 * info->num_pmkids);
+		pos += 16 * info->num_pmkids;
+	}
 
-	if (!info->mfpc)
+	if (!force_group_mgmt_cipher && !info->mfpc)
 		goto done;
 
-	if (info->group_management_cipher == IE_RSN_CIPHER_SUITE_BIP)
+	if (!force_group_mgmt_cipher && info->group_management_cipher ==
+							IE_RSN_CIPHER_SUITE_BIP)
 		goto done;
 
 	/* Group Management Cipher Suite */
-	if (!ie_build_cipher_suite(to, ieee_oui, info->group_management_cipher))
-		return false;
+	if (!ie_build_cipher_suite(to + pos, ieee_oui,
+					info->group_management_cipher))
+		return -EINVAL;
 
 	pos += 4;
 
 done:
+	return pos;
+}
+
+/*
+ * Generate an RSNE IE based on the information found in info.
+ * The to array must be 256 bytes in size
+ *
+ * In theory it is possible to generate 257 byte IE RSNs (1 byte for IE Type,
+ * 1 byte for Length and 255 bytes of data) but we don't support this
+ * possibility.
+ */
+bool ie_build_rsne(const struct ie_rsn_info *info, uint8_t *to)
+{
+	unsigned int pos;
+	int ret;
+
+	to[0] = IE_TYPE_RSN;
+
+	/* Version field, always 1 */
+	pos = 2;
+	l_put_le16(1, to + pos);
+	pos += 2;
+
+	ret = build_ciphers_common(info, to + 4, 252, false);
+	if (ret < 0)
+		return false;
+
+	pos += ret;
+
+	to[1] = pos - 2;
+
+	return true;
+}
+
+bool ie_build_osen(const struct ie_rsn_info *info, uint8_t *to)
+{
+	unsigned int pos;
+	int ret;
+
+	to[0] = IE_TYPE_VENDOR_SPECIFIC;
+	pos = 2;
+	memcpy(to + pos, wifi_alliance_oui, 3);
+	pos += 3;
+	to[pos++] = 0x12;
+
+	ret = build_ciphers_common(info, to + 6, 250, true);
+	if (ret < 0)
+		return false;
+
+	pos += ret;
+
 	to[1] = pos - 2;
 
 	return true;
@@ -1133,6 +1280,24 @@ static bool ie_parse_wpa_pairwise_cipher(const uint8_t *data,
 	return true;
 }
 
+bool is_ie_wfa_ie(const uint8_t *data, uint8_t len, uint8_t oi_type)
+{
+	if (!data)
+		return false;
+
+	if (oi_type == IE_WFA_OI_OSEN && len < 22)
+		return false;
+	else if (oi_type == IE_WFA_OI_HS20_INDICATION && len < 5)
+		return false;
+	else if (len < 4) /* OI not handled, but at least check length */
+		return false;
+
+	if (!memcmp(data, wifi_alliance_oui, 3) && data[3] == oi_type)
+		return true;
+
+	return false;
+}
+
 bool is_ie_wpa_ie(const uint8_t *data, uint8_t len)
 {
 	if (!data || len < 6)
@@ -2010,14 +2175,14 @@ bool ie_build_mobility_domain(uint16_t mdid, bool ft_over_ds, bool resource_req,
 	return true;
 }
 
-int ie_parse_fast_bss_transition(struct ie_tlv_iter *iter,
-				struct ie_ft_info *info)
+int ie_parse_fast_bss_transition(struct ie_tlv_iter *iter, uint32_t mic_len,
+					struct ie_ft_info *info)
 {
 	const uint8_t *data;
 	uint8_t len, subelem_id, subelem_len;
 
 	len = ie_tlv_iter_get_length(iter);
-	if (len < 82)
+	if (len < 66 + mic_len)
 		return -EINVAL;
 
 	data = ie_tlv_iter_get_data(iter);
@@ -2026,14 +2191,14 @@ int ie_parse_fast_bss_transition(struct ie_tlv_iter *iter,
 
 	info->mic_element_count = data[1];
 
-	memcpy(info->mic, data + 2, 16);
+	memcpy(info->mic, data + 2, mic_len);
 
-	memcpy(info->anonce, data + 18, 32);
+	memcpy(info->anonce, data + mic_len + 2, 32);
 
-	memcpy(info->snonce, data + 50, 32);
+	memcpy(info->snonce, data + mic_len + 34, 32);
 
-	len -= 82;
-	data += 82;
+	len -= 66 + mic_len;
+	data += 66 + mic_len;
 
 	while (len >= 2) {
 		subelem_id = *data++;
@@ -2104,7 +2269,8 @@ int ie_parse_fast_bss_transition(struct ie_tlv_iter *iter,
 }
 
 int ie_parse_fast_bss_transition_from_data(const uint8_t *data, uint8_t len,
-				struct ie_ft_info *info)
+						uint32_t mic_len,
+						struct ie_ft_info *info)
 {
 	struct ie_tlv_iter iter;
 
@@ -2116,28 +2282,29 @@ int ie_parse_fast_bss_transition_from_data(const uint8_t *data, uint8_t len,
 	if (ie_tlv_iter_get_tag(&iter) != IE_TYPE_FAST_BSS_TRANSITION)
 		return -EPROTOTYPE;
 
-	return ie_parse_fast_bss_transition(&iter, info);
+	return ie_parse_fast_bss_transition(&iter, mic_len, info);
 }
 
-bool ie_build_fast_bss_transition(const struct ie_ft_info *info, uint8_t *to)
+bool ie_build_fast_bss_transition(const struct ie_ft_info *info,
+					uint32_t mic_len, uint8_t *to)
 {
 	uint8_t *len;
 
 	*to++ = IE_TYPE_FAST_BSS_TRANSITION;
 
 	len = to++;
-	*len = 82;
+	*len = (mic_len == 16) ? 82 : 90;
 
 	to[0] = 0x00;
 	to[1] = info->mic_element_count;
 
-	memcpy(to + 2, info->mic, 16);
+	memcpy(to + 2, info->mic, mic_len);
 
-	memcpy(to + 18, info->anonce, 32);
+	memcpy(to + mic_len + 2, info->anonce, 32);
 
-	memcpy(to + 50, info->snonce, 32);
+	memcpy(to + mic_len + 34, info->snonce, 32);
 
-	to += 82;
+	to += (mic_len == 16) ? 82 : 90;
 
 	if (info->r1khid_present) {
 		to[0] = 1;
@@ -2220,3 +2387,99 @@ int ie_parse_neighbor_report(struct ie_tlv_iter *iter,
 
 	return 0;
 }
+
+
+int ie_parse_roaming_consortium(struct ie_tlv_iter *iter, size_t *num_anqp_out,
+				const uint8_t **oi1_out, size_t *oi1_len_out,
+				const uint8_t **oi2_out, size_t *oi2_len_out,
+				const uint8_t **oi3_out, size_t *oi3_len_out)
+{
+	unsigned int len = ie_tlv_iter_get_length(iter);
+	const uint8_t *data = ie_tlv_iter_get_data(iter);
+	size_t num_anqp;
+	size_t oi1_len;
+	size_t oi2_len;
+	size_t oi3_len;
+
+	if (len < 4)
+		return -EINVAL;
+
+	num_anqp = l_get_u8(data);
+	oi1_len = util_bit_field(l_get_u8(data + 1), 0, 4);
+	oi2_len = util_bit_field(l_get_u8(data + 1), 4, 4);
+	oi3_len = len - (2 + oi1_len + oi2_len);
+
+	if (!oi1_len)
+		return -EINVAL;
+
+	if (len < oi1_len + oi2_len + oi3_len + 2)
+		return -EINVAL;
+
+	if (num_anqp_out)
+		*num_anqp_out = num_anqp;
+
+	if (oi1_out)
+		*oi1_out = data + 2;
+
+	if (oi1_len_out)
+		*oi1_len_out = oi1_len;
+
+	/* OI2/3 are optional, explicitly set to NULL if not included */
+	if (oi2_len) {
+		if (oi2_out)
+			*oi2_out = data + 2 + oi1_len;
+
+		if (oi2_len_out)
+			*oi2_len_out = oi2_len;
+	} else if (oi2_out)
+		*oi2_out = NULL;
+
+	if (oi3_len) {
+		if (oi3_out)
+			*oi3_out = data + 2 + oi1_len + oi2_len;
+
+		if (oi3_len_out)
+			*oi3_len_out = oi3_len;
+	} else if (oi3_out)
+		*oi3_out = NULL;
+
+	return 0;
+}
+
+int ie_parse_roaming_consortium_from_data(const uint8_t *data, size_t len,
+				size_t *num_anqp_out, const uint8_t **oi1_out,
+				size_t *oi1_len_out, const uint8_t **oi2_out,
+				size_t *oi2_len_out, const uint8_t **oi3_out,
+				size_t *oi3_len_out)
+{
+	struct ie_tlv_iter iter;
+
+	ie_tlv_iter_init(&iter, data, len);
+
+	if (!ie_tlv_iter_next(&iter))
+		return -EMSGSIZE;
+
+	if (ie_tlv_iter_get_tag(&iter) != IE_TYPE_ROAMING_CONSORTIUM)
+		return -EPROTOTYPE;
+
+	return ie_parse_roaming_consortium(&iter, num_anqp_out, oi1_out,
+						oi1_len_out, oi2_out,
+						oi2_len_out, oi3_out,
+						oi3_len_out);
+}
+
+int ie_build_roaming_consortium(const uint8_t *rc, size_t rc_len, uint8_t *to)
+{
+	*to++ = IE_TYPE_VENDOR_SPECIFIC;
+
+	*to++ = rc_len + 4;
+
+	memcpy(to, wifi_alliance_oui, 3);
+	to += 3;
+
+	*to++ = 0x1d;
+
+	memcpy(to, rc, rc_len);
+
+	return 0;
+}
diff --git a/src/ie.h b/src/ie.h
index e621d2e4..61190326 100644
--- a/src/ie.h
+++ b/src/ie.h
@@ -234,6 +234,24 @@ enum ie_type {
 	IE_TYPE_OWE_DH_PARAM                         = 256 + 32,
 };
 
+/*
+ * WiFi Alliance Hotspot 2.0 Specification - Section 3.1 Elements Definitions
+ */
+enum ie_vendor_wfa_oi_type {
+	IE_WFA_OI_HS20_INDICATION = 0x10,
+	IE_WFA_OI_OSEN = 0x12,
+	IE_WFA_OI_ROAMING_SELECTION = 0x1d,
+};
+
+enum ie_advertisement_id {
+	IE_ADVERTISEMENT_ANQP			= 0,
+	IE_ADVERTISEMENT_MIH_SERVICE		= 1,
+	IE_ADVERTISEMENT_MIH_DISCOVERY		= 2,
+	IE_ADVERTISEMENT_EAS			= 3,
+	IE_ADVERTISEMENT_RLQP			= 4,
+	IE_ADVERTISEMENT_VENDOR_SPECIFIC	= 221,
+};
+
 enum ie_rsn_cipher_suite {
 	IE_RSN_CIPHER_SUITE_USE_GROUP_CIPHER	= 0x0001,
 	IE_RSN_CIPHER_SUITE_WEP40		= 0x0002,
@@ -263,6 +281,7 @@ enum ie_rsn_akm_suite {
 	IE_RSN_AKM_SUITE_FILS_SHA384		= 0x8000,
 	IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256	= 0x10000,
 	IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384	= 0x20000,
+	IE_RSN_AKM_SUITE_OSEN			= 0x40000,
 };
 
 #define IE_AKM_IS_SAE(akm) \
@@ -315,16 +334,26 @@ struct ie_rsn_info {
 	enum ie_rsn_cipher_suite group_management_cipher;
 };
 
-/* See chapter 8.4.1.4 for capability details */
+/* IEEE 802.11-2016, Section 9.4.1.4 */
 enum ie_bss_capability {
-	IE_BSS_CAP_ESS     = 0x0001,
-	IE_BSS_CAP_IBSS    = 0x0002,
-	IE_BSS_CAP_PRIVACY = 0x0010,
+	IE_BSS_CAP_ESS			= 0x0001,
+	IE_BSS_CAP_IBSS			= 0x0002,
+	IE_BSS_CAP_CF_POLLABLE		= 0x0004,
+	IE_BSS_CAP_CF_POLL_REQ		= 0x0008,
+	IE_BSS_CAP_PRIVACY		= 0x0010,
+	IE_BSS_CAP_SHORT_PREAMBLE	= 0x0020,
+	IE_BSS_CAP_SPECTRUM_MANAGEMENT	= 0x0100,
+	IE_BSS_CAP_QOS			= 0x0200,
+	IE_BSS_CAP_SHORT_SLOT_TIME	= 0x0400,
+	IE_BSS_CAP_APSD			= 0x0800,
+	IE_BSS_CAP_RM			= 0x1000,
+	IE_BSS_CAP_DELAYED_BLOCK_ACK	= 0x4000,
+	IE_BSS_CAP_IMMEDIATE_BLOCK_ACK	= 0x8000,
 };
 
 struct ie_ft_info {
 	uint8_t mic_element_count;
-	uint8_t mic[16];
+	uint8_t mic[24];
 	uint8_t anonce[32];
 	uint8_t snonce[32];
 	uint8_t r0khid[48];
@@ -366,6 +395,10 @@ struct ie_neighbor_report_info {
 	bool bss_transition_pref_present : 1;
 };
 
+extern const unsigned char ieee_oui[3];
+extern const unsigned char microsoft_oui[3];
+extern const unsigned char wifi_alliance_oui[3];
+
 void ie_tlv_iter_init(struct ie_tlv_iter *iter, const unsigned char *tlv,
 			unsigned int len);
 void ie_tlv_iter_recurse(struct ie_tlv_iter *iter,
@@ -393,6 +426,11 @@ void *ie_tlv_extract_wsc_payload(const uint8_t *ies, size_t len,
 void *ie_tlv_encapsulate_wsc_payload(const uint8_t *data, size_t len,
 							size_t *out_len);
 
+void *ie_tlv_extract_p2p_payload(const uint8_t *ies, size_t len,
+							ssize_t *out_len);
+void *ie_tlv_encapsulate_p2p_payload(const uint8_t *data, size_t len,
+							size_t *out_len);
+
 bool ie_tlv_builder_init(struct ie_tlv_builder *builder, unsigned char *buf,
 				size_t len);
 bool ie_tlv_builder_set_length(struct ie_tlv_builder *builder,
@@ -416,6 +454,7 @@ bool ie_build_rsne(const struct ie_rsn_info *info, uint8_t *to);
 int ie_parse_wpa(struct ie_tlv_iter *iter, struct ie_rsn_info *out_info);
 int ie_parse_wpa_from_data(const uint8_t *data, size_t len,
 						struct ie_rsn_info *info);
+bool is_ie_wfa_ie(const uint8_t *data, uint8_t len, uint8_t oi_type);
 bool is_ie_wpa_ie(const uint8_t *data, uint8_t len);
 bool ie_build_wpa(const struct ie_rsn_info *info, uint8_t *to);
 
@@ -449,10 +488,32 @@ bool ie_build_mobility_domain(uint16_t mdid, bool ft_over_ds,
 				bool resource_req, uint8_t *to);
 
 int ie_parse_fast_bss_transition(struct ie_tlv_iter *iter,
-				struct ie_ft_info *info);
+					uint32_t mic_len,
+					struct ie_ft_info *info);
 int ie_parse_fast_bss_transition_from_data(const uint8_t *data, uint8_t len,
-				struct ie_ft_info *info);
-bool ie_build_fast_bss_transition(const struct ie_ft_info *info, uint8_t *to);
+						uint32_t mic_len,
+						struct ie_ft_info *info);
+bool ie_build_fast_bss_transition(const struct ie_ft_info *info,
+					uint32_t mic_len, uint8_t *to);
 
 int ie_parse_neighbor_report(struct ie_tlv_iter *iter,
 				struct ie_neighbor_report_info *info);
+
+int ie_parse_osen_from_data(const uint8_t *data, size_t len,
+				struct ie_rsn_info *info);
+int ie_parse_osen(struct ie_tlv_iter *iter, struct ie_rsn_info *out_info);
+
+bool ie_build_osen(const struct ie_rsn_info *info, uint8_t *to);
+
+int ie_parse_roaming_consortium(struct ie_tlv_iter *iter, size_t *num_anqp_out,
+				const uint8_t **oi1_out, size_t *oi1_len_out,
+				const uint8_t **oi2_out, size_t *oi2_len_out,
+				const uint8_t **oi3_out, size_t *oi3_len_out);
+
+int ie_parse_roaming_consortium_from_data(const uint8_t *data, size_t len,
+				size_t *num_anqp_out, const uint8_t **oi1_out,
+				size_t *oi1_len_out, const uint8_t **oi2_out,
+				size_t *oi2_len_out, const uint8_t **oi3_out,
+				size_t *oi3_len_out);
+
+int ie_build_roaming_consortium(const uint8_t *rc, size_t rc_len, uint8_t *to);
diff --git a/src/iwd.h b/src/iwd.h
index 629aaee0..dba62fd7 100644
--- a/src/iwd.h
+++ b/src/iwd.h
@@ -22,33 +22,30 @@
 
 #define uninitialized_var(x) x = x
 
+struct l_genl;
 struct l_genl_family;
 
 const struct l_settings *iwd_get_config(void);
+struct l_genl *iwd_get_genl(void);
 
-bool netdev_init(const char *whitelist, const char *blacklist);
+bool netdev_init(void);
 void netdev_exit(void);
 void netdev_set_nl80211(struct l_genl_family *nl80211);
 void netdev_shutdown(void);
 
-void network_init();
-void network_exit();
-
-void sim_auth_init(void);
-void sim_auth_exit(void);
-
-bool wsc_init(void);
-bool wsc_exit();
-
-bool known_networks_init(void);
-void known_networks_exit(void);
-
-bool device_init(void);
-void device_exit(void);
-
-bool station_init(void);
-void station_exit(void);
-
 bool manager_init(struct l_genl_family *in,
 			const char *if_whitelist, const char *if_blacklist);
 void manager_exit(void);
+
+struct iwd_module_desc {
+	const char *name;
+	int (*init)(void);
+	void (*exit)(void);
+	bool active;
+} __attribute__((aligned(8)));
+
+#define IWD_MODULE(name, init, exit)					\
+	static struct iwd_module_desc __iwd_module_ ## name		\
+		__attribute__((used, section("__iwd_module"), aligned(8))) = {\
+			#name, init, exit				\
+		};
diff --git a/src/knownnetworks.c b/src/knownnetworks.c
index dd2c61ff..c6859506 100644
--- a/src/knownnetworks.c
+++ b/src/knownnetworks.c
@@ -605,7 +605,7 @@ static void known_network_frequencies_sync(void)
 	l_settings_free(known_freqs);
 }
 
-bool known_networks_init(void)
+static int known_networks_init(void)
 {
 	struct l_dbus *dbus = dbus_get_bus();
 	DIR *dir;
@@ -616,7 +616,7 @@ bool known_networks_init(void)
 						NULL, false)) {
 		l_info("Unable to register %s interface",
 				IWD_KNOWN_NETWORK_INTERFACE);
-		return false;
+		return -EPERM;
 	}
 
 	dir = opendir(DAEMON_STORAGEDIR);
@@ -624,7 +624,7 @@ bool known_networks_init(void)
 		l_info("Unable to open %s: %s", DAEMON_STORAGEDIR,
 							strerror(errno));
 		l_dbus_unregister_interface(dbus, IWD_KNOWN_NETWORK_INTERFACE);
-		return false;
+		return -ENOENT;
 	}
 
 	known_networks = l_queue_new();
@@ -661,10 +661,10 @@ bool known_networks_init(void)
 						known_networks_watch_cb, NULL,
 						known_networks_watch_destroy);
 
-	return true;
+	return 0;
 }
 
-void known_networks_exit(void)
+static void known_networks_exit(void)
 {
 	struct l_dbus *dbus = dbus_get_bus();
 
@@ -677,3 +677,5 @@ void known_networks_exit(void)
 
 	l_dbus_unregister_interface(dbus, IWD_KNOWN_NETWORK_INTERFACE);
 }
+
+IWD_MODULE(known_networks, known_networks_init, known_networks_exit)
diff --git a/src/main.c b/src/main.c
index 37220c55..35d14c69 100644
--- a/src/main.c
+++ b/src/main.c
@@ -38,15 +38,10 @@
 #include "src/dbus.h"
 #include "src/eap.h"
 #include "src/eapol.h"
-#include "src/scan.h"
 #include "src/rfkill.h"
-#include "src/ap.h"
 #include "src/plugin.h"
-#include "src/simauth.h"
-#include "src/adhoc.h"
-#include "src/blacklist.h"
 #include "src/storage.h"
-#include "src/erp.h"
+#include "src/anqp.h"
 
 #include "src/backtrace.h"
 
@@ -103,6 +98,11 @@ const struct l_settings *iwd_get_config(void)
 	return iwd_config;
 }
 
+struct l_genl *iwd_get_genl(void)
+{
+	return genl;
+}
+
 static void usage(void)
 {
 	printf("iwd - Wireless daemon\n"
@@ -118,6 +118,7 @@ static void usage(void)
 		"\t-l, --plugin           Plugins to include\n"
 		"\t-L, --noplugin         Plugins to exclude\n"
 		"\t-d, --debug            Enable debug output\n"
+		"\t-v, --version          Show version\n"
 		"\t-h, --help             Show help options\n");
 }
 
@@ -143,38 +144,57 @@ static void do_debug(const char *str, void *user_data)
 	l_info("%s%s", prefix, str);
 }
 
-static void nl80211_appeared(void *user_data)
+static void nl80211_appeared(const struct l_genl_family_info *info,
+							void *user_data)
 {
-	struct l_genl_family *nl80211 = user_data;
-
-	if (terminating)
-		return;
-
 	l_debug("Found nl80211 interface");
+	nl80211 = l_genl_family_new(genl, NL80211_GENL_NAME);
 
 	manager_init(nl80211, interfaces, nointerfaces);
+	anqp_init(nl80211);
 
 	if (!wiphy_init(nl80211, phys, nophys))
 		l_error("Unable to init wiphy functionality");
 
 	netdev_set_nl80211(nl80211);
+}
+
+extern struct iwd_module_desc __start___iwd_module[];
+extern struct iwd_module_desc __stop___iwd_module[];
+
+static int iwd_modules_init()
+{
+	struct iwd_module_desc *desc;
+	int r;
 
-	if (!scan_init(nl80211))
-		l_error("Unable to init scan functionality");
+	l_debug("");
 
-	ap_init(nl80211);
-	adhoc_init(nl80211);
+	for (desc = __start___iwd_module; desc < __stop___iwd_module; desc++) {
+		r = desc->init();
+		if (r < 0)
+			return r;
+
+		l_debug("Initialized module: %s", desc->name);
+		desc->active = true;
+	}
+
+	return 0;
 }
 
-static void nl80211_vanished(void *user_data)
+static void iwd_modules_exit()
 {
-	l_debug("Lost nl80211 interface");
+	struct iwd_module_desc *desc;
 
-	manager_exit();
-	ap_exit();
-	adhoc_exit();
-	scan_exit();
-	wiphy_exit();
+	l_debug("");
+
+	for (desc = __stop___iwd_module - 1;
+			desc >= __start___iwd_module; desc--) {
+		if (!desc->active)
+			continue;
+		l_debug("Removing module: %s", desc->name);
+		desc->exit();
+		desc->active = false;
+	}
 }
 
 static void request_name_callback(struct l_dbus *dbus, bool success,
@@ -188,23 +208,9 @@ static void request_name_callback(struct l_dbus *dbus, bool success,
 	if (!l_dbus_object_manager_enable(dbus))
 		l_warn("Unable to register the ObjectManager");
 
-	genl = l_genl_new_default();
-	if (!genl) {
-		l_error("Failed to open generic netlink socket");
-		goto fail_exit;
-	}
-
-	if (getenv("IWD_GENL_DEBUG"))
-		l_genl_set_debug(genl, do_debug, "[GENL] ", NULL);
-
-	nl80211 = l_genl_family_new(genl, NL80211_GENL_NAME);
-	if (!nl80211) {
-		l_error("Failed to open nl80211 interface");
-		goto fail_exit;
-	}
-
-	l_genl_family_set_watches(nl80211, nl80211_appeared, nl80211_vanished,
-								nl80211, NULL);
+	/* TODO: Always request nl80211 for now, ignoring auto-loading */
+	l_genl_request_family(genl, NL80211_GENL_NAME, nl80211_appeared,
+				NULL, NULL);
 	return;
 
 fail_exit:
@@ -480,6 +486,20 @@ int main(int argc, char *argv[])
 		goto fail_dbus;
 	}
 
+	if (create_dirs(DAEMON_STORAGEDIR "/hotspot/")) {
+		l_error("Failed to create " DAEMON_STORAGEDIR "/hotspot/");
+		goto fail_dbus;
+	}
+
+	genl = l_genl_new();
+	if (!genl) {
+		l_error("Failed to open generic netlink socket");
+		goto fail_genl;
+	}
+
+	if (getenv("IWD_GENL_DEBUG"))
+		l_genl_set_debug(genl, do_debug, "[GENL] ", NULL);
+
 	dbus = l_dbus_new_default(L_DBUS_SYSTEM_BUS);
 	if (!dbus) {
 		l_error("Failed to initialize D-Bus");
@@ -497,44 +517,36 @@ int main(int argc, char *argv[])
 	eapol_init();
 	rfkill_init();
 
-	if (!netdev_init(interfaces, nointerfaces))
+	if (!netdev_init())
 		goto fail_netdev;
 
-	if (!device_init())
-		goto fail_device;
+	if (iwd_modules_init() < 0)
+		goto fail_modules;
 
-	station_init();
-	wsc_init();
-	network_init();
-	known_networks_init();
-	sim_auth_init();
 	plugin_init(plugins, noplugins);
-	blacklist_init();
-	erp_init();
-
 	exit_status = l_main_run_with_signal(signal_handler, NULL);
-
-	erp_exit();
-	blacklist_exit();
 	plugin_exit();
-	sim_auth_exit();
-	known_networks_exit();
-	network_exit();
-	wsc_exit();
-	station_exit();
-	device_exit();
-fail_device:
+
+fail_modules:
+	iwd_modules_exit();
 	netdev_exit();
 fail_netdev:
 	rfkill_exit();
 	eapol_exit();
 	eap_exit();
 
-	l_genl_family_unref(nl80211);
-	l_genl_unref(genl);
+	if (nl80211) {
+		manager_exit();
+		anqp_exit();
+		wiphy_exit();
+		l_genl_family_free(nl80211);
+	}
+
 	dbus_exit();
 	l_dbus_destroy(dbus);
 fail_dbus:
+	l_genl_unref(genl);
+fail_genl:
 	l_settings_free(iwd_config);
 
 	l_timeout_remove(timeout);
diff --git a/src/manager.c b/src/manager.c
index 8ca7a926..9fdff811 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -39,10 +39,12 @@
 #include "src/wiphy.h"
 #include "src/util.h"
 #include "src/common.h"
+#include "src/nl80211cmd.h"
 
 static struct l_genl_family *nl80211 = NULL;
 static char **whitelist_filter;
 static char **blacklist_filter;
+static bool randomize;
 
 struct wiphy_setup_state {
 	uint32_t id;
@@ -109,7 +111,7 @@ static bool manager_use_default(struct wiphy_setup_state *state)
 		return false;
 	}
 
-	netdev_create_from_genl(state->default_if_msg);
+	netdev_create_from_genl(state->default_if_msg, randomize);
 	return true;
 }
 
@@ -133,7 +135,9 @@ static void manager_new_interface_cb(struct l_genl_msg *msg, void *user_data)
 		return;
 	}
 
-	netdev_create_from_genl(msg);
+	netdev_create_from_genl(msg, randomize &&
+					!wiphy_has_feature(state->wiphy,
+						NL80211_FEATURE_MAC_ON_CREATE));
 }
 
 static void manager_new_interface_done(void *user_data)
@@ -177,12 +181,24 @@ static void manager_create_interfaces(struct wiphy_setup_state *state)
 				strlen(ifname) + 1, ifname);
 	l_genl_msg_append_attr(msg, NL80211_ATTR_4ADDR, 1, "\0");
 	l_genl_msg_append_attr(msg, NL80211_ATTR_SOCKET_OWNER, 0, "");
+
+	if (randomize && wiphy_has_feature(state->wiphy,
+					NL80211_FEATURE_MAC_ON_CREATE)) {
+		uint8_t random_addr[6];
+
+		wiphy_generate_random_address(state->wiphy, random_addr);
+		l_debug("Creating interface on phy: %s with random addr: "MAC,
+						wiphy_get_name(state->wiphy),
+						MAC_STR(random_addr));
+		l_genl_msg_append_attr(msg, NL80211_ATTR_MAC, 6, random_addr);
+	}
+
 	cmd_id = l_genl_family_send(nl80211, msg,
 					manager_new_interface_cb, state,
 					manager_new_interface_done);
 
 	if (!cmd_id) {
-		l_error("Sending NEW_INTERFACE for %s", ifname);
+		l_error("Error sending NEW_INTERFACE for %s", ifname);
 		return;
 	}
 
@@ -263,7 +279,6 @@ static void manager_get_interface_cb(struct l_genl_msg *msg, void *user_data)
 			wdev_idx = data;
 			break;
 
-
 		case NL80211_ATTR_WIPHY:
 			if (len != sizeof(uint32_t) ||
 					*((uint32_t *) data) != state->id) {
@@ -293,26 +308,31 @@ static void manager_get_interface_cb(struct l_genl_msg *msg, void *user_data)
 		}
 	}
 
-	if (!ifindex || !wdev_idx || !iftype || !ifname)
+	if (!wdev_idx || !iftype)
 		return;
 
-	if (whitelist_filter) {
-		for (i = 0; (pattern = whitelist_filter[i]); i++) {
-			if (fnmatch(pattern, ifname, 0) != 0)
-				continue;
+	if (ifindex) {
+		if (!ifname)
+			return;
 
-			whitelisted = true;
-			break;
+		if (whitelist_filter) {
+			for (i = 0; (pattern = whitelist_filter[i]); i++) {
+				if (fnmatch(pattern, ifname, 0) != 0)
+					continue;
+
+				whitelisted = true;
+				break;
+			}
 		}
-	}
 
-	if (blacklist_filter) {
-		for (i = 0; (pattern = blacklist_filter[i]); i++) {
-			if (fnmatch(pattern, ifname, 0) != 0)
-				continue;
+		if (blacklist_filter) {
+			for (i = 0; (pattern = blacklist_filter[i]); i++) {
+				if (fnmatch(pattern, ifname, 0) != 0)
+					continue;
 
-			blacklisted = true;
-			break;
+				blacklisted = true;
+				break;
+			}
 		}
 	}
 
@@ -334,7 +354,10 @@ static void manager_get_interface_cb(struct l_genl_msg *msg, void *user_data)
 		return;
 
 	del_msg = l_genl_msg_new(NL80211_CMD_DEL_INTERFACE);
-	l_genl_msg_append_attr(del_msg, NL80211_ATTR_IFINDEX, 4, ifindex);
+
+	if (ifindex)
+		l_genl_msg_append_attr(del_msg, NL80211_ATTR_IFINDEX, 4, ifindex);
+
 	l_genl_msg_append_attr(del_msg, NL80211_ATTR_WDEV, 8, wdev_idx);
 	l_genl_msg_append_attr(del_msg, NL80211_ATTR_WIPHY, 4, &state->id);
 	cmd_id = l_genl_family_send(nl80211, del_msg,
@@ -342,7 +365,8 @@ static void manager_get_interface_cb(struct l_genl_msg *msg, void *user_data)
 					manager_setup_cmd_done);
 
 	if (!cmd_id) {
-		l_error("Sending DEL_INTERFACE for %s failed", ifname);
+		l_error("Sending DEL_INTERFACE for %s failed",
+			ifname ?: "unnamed interface");
 		state->use_default = true;
 		return;
 	}
@@ -578,7 +602,8 @@ static void manager_config_notify(struct l_genl_msg *msg, void *user_data)
 
 	cmd = l_genl_msg_get_command(msg);
 
-	l_debug("Notification of command %u", cmd);
+	l_debug("Notification of command %s(%u)",
+					nl80211cmd_to_string(cmd), cmd);
 
 	switch (cmd) {
 	case NL80211_CMD_NEW_WIPHY:
@@ -675,9 +700,11 @@ static void manager_wiphy_dump_callback(struct l_genl_msg *msg, void *user_data)
 bool manager_init(struct l_genl_family *in,
 			const char *if_whitelist, const char *if_blacklist)
 {
+	const struct l_settings *config = iwd_get_config();
 	struct l_genl_msg *msg;
 	unsigned int wiphy_dump;
 	unsigned int interface_dump;
+	const char *randomize_str;
 
 	nl80211 = in;
 
@@ -717,6 +744,11 @@ bool manager_init(struct l_genl_family *in,
 		return false;
 	}
 
+	randomize_str =
+		l_settings_get_value(config, "General", "mac_randomize");
+	if (randomize_str && !strcmp(randomize_str, "once"))
+		randomize = true;
+
 	return true;
 }
 
@@ -725,8 +757,9 @@ void manager_exit(void)
 	l_strfreev(whitelist_filter);
 	l_strfreev(blacklist_filter);
 
-	l_queue_destroy(pending_wiphys, NULL);
+	l_queue_destroy(pending_wiphys, wiphy_setup_state_free);
 	pending_wiphys = NULL;
 
 	nl80211 = NULL;
+	randomize = false;
 }
diff --git a/src/mpdu.c b/src/mpdu.c
index 6e7fb32f..eb141c75 100644
--- a/src/mpdu.c
+++ b/src/mpdu.c
@@ -587,7 +587,7 @@ static bool validate_mgmt_mpdu(const struct mmpdu_header *mpdu, int len,
 		return validate_deauthentication_mmpdu(mpdu, len, offset);
 	case MPDU_MANAGEMENT_SUBTYPE_ACTION:
 	case MPDU_MANAGEMENT_SUBTYPE_ACTION_NO_ACK:
-		return true;
+		return *offset + 1 <= len;
 	default:
 		return false;
 	}
diff --git a/src/netconfig.c b/src/netconfig.c
new file mode 100644
index 00000000..25fc2c63
--- /dev/null
+++ b/src/netconfig.c
@@ -0,0 +1,638 @@
+/*
+ *
+ *  Wireless daemon for Linux
+ *
+ *  Copyright (C) 2019  Intel Corporation. All rights reserved.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+#include <arpa/inet.h>
+#include <linux/rtnetlink.h>
+#include <linux/if_arp.h>
+#include <linux/in.h>
+
+#include <ell/ell.h>
+
+#include "src/iwd.h"
+#include "src/netdev.h"
+#include "src/station.h"
+#include "src/common.h"
+#include "src/network.h"
+#include "src/rtnlutil.h"
+#include "src/resolve.h"
+#include "src/netconfig.h"
+
+struct netconfig {
+	uint32_t ifindex;
+	enum station_state station_state;
+	struct l_dhcp_client *dhcp_client;
+	struct l_queue *ifaddr_list;
+};
+
+struct netconfig_ifaddr {
+	uint8_t family;
+	uint8_t prefix_len;
+	char *ip;
+	char *broadcast;
+};
+
+static struct l_netlink *rtnl;
+static struct l_queue *netconfig_list;
+
+static void do_debug(const char *str, void *user_data)
+{
+	const char *prefix = user_data;
+
+	l_info("%s%s", prefix, str);
+}
+
+static void netconfig_ifaddr_destroy(void *data)
+{
+	struct netconfig_ifaddr *ifaddr = data;
+
+	l_free(ifaddr->ip);
+	l_free(ifaddr->broadcast);
+
+	l_free(ifaddr);
+}
+
+static void netconfig_destroy(void *data)
+{
+	struct netconfig *netconfig = data;
+
+	l_dhcp_client_destroy(netconfig->dhcp_client);
+
+	l_queue_destroy(netconfig->ifaddr_list, netconfig_ifaddr_destroy);
+
+	l_free(netconfig);
+}
+
+static bool netconfig_match(const void *a, const void *b)
+{
+	const struct netconfig *netconfig = a;
+	uint32_t ifindex = L_PTR_TO_UINT(b);
+
+	if (netconfig->ifindex == ifindex)
+		return true;
+
+	return false;
+}
+
+static struct netconfig *netconfig_find(uint32_t ifindex)
+{
+	const struct l_queue_entry *entry;
+
+	for (entry = l_queue_get_entries(netconfig_list); entry;
+							entry = entry->next) {
+		struct netconfig *netconfig = entry->data;
+
+		if (netconfig->ifindex != ifindex)
+			continue;
+
+		return netconfig;
+	}
+
+	return NULL;
+}
+
+static struct netconfig_ifaddr *netconfig_ifaddr_find(
+					const struct netconfig *netconfig,
+					uint8_t family, uint8_t prefix_len,
+					const char *ip)
+{
+	const struct l_queue_entry *entry;
+
+	for (entry = l_queue_get_entries(netconfig->ifaddr_list); entry;
+							entry = entry->next) {
+		struct netconfig_ifaddr *ifaddr = entry->data;
+
+		if (ifaddr->family != family)
+			continue;
+
+		if (ifaddr->prefix_len != prefix_len)
+			continue;
+
+		if (strcmp(ifaddr->ip, ip))
+			continue;
+
+		return ifaddr;
+	}
+
+	return NULL;
+}
+
+static void netconfig_ifaddr_added(struct netconfig *netconfig,
+					const struct ifaddrmsg *ifa, int bytes)
+{
+	struct netconfig_ifaddr *ifaddr;
+	char *label;
+
+	ifaddr = l_new(struct netconfig_ifaddr, 1);
+	ifaddr->family = ifa->ifa_family;
+	ifaddr->prefix_len = ifa->ifa_prefixlen;
+
+	rtnl_ifaddr_extract(ifa, bytes, &label, &ifaddr->ip,
+							&ifaddr->broadcast);
+
+	l_debug("%s: ifaddr %s/%u broadcast %s", label, ifaddr->ip,
+					ifaddr->prefix_len, ifaddr->broadcast);
+	l_free(label);
+
+	l_queue_push_tail(netconfig->ifaddr_list, ifaddr);
+}
+
+static void netconfig_ifaddr_deleted(struct netconfig *netconfig,
+					const struct ifaddrmsg *ifa, int bytes)
+{
+	struct netconfig_ifaddr *ifaddr;
+	char *ip;
+
+	rtnl_ifaddr_extract(ifa, bytes, NULL, &ip, NULL);
+
+	ifaddr = netconfig_ifaddr_find(netconfig, ifa->ifa_family,
+							ifa->ifa_prefixlen, ip);
+
+	l_free(ip);
+
+	if (!ifaddr)
+		return;
+
+	l_debug("ifaddr %s/%u", ifaddr->ip, ifaddr->prefix_len);
+
+	l_queue_remove(netconfig->ifaddr_list, ifaddr);
+
+	netconfig_ifaddr_destroy(ifaddr);
+}
+
+static void netconfig_ifaddr_notify(uint16_t type, const void *data,
+						uint32_t len, void *user_data)
+{
+	const struct ifaddrmsg *ifa = data;
+	struct netconfig *netconfig;
+	unsigned int bytes;
+
+	netconfig = netconfig_find(ifa->ifa_index);
+	if (!netconfig)
+		/* Ignore the interfaces which aren't managed by iwd. */
+		return;
+
+	bytes = len - NLMSG_ALIGN(sizeof(struct ifaddrmsg));
+
+	switch (type) {
+	case RTM_NEWADDR:
+		netconfig_ifaddr_added(netconfig, ifa, bytes);
+		break;
+	case RTM_DELADDR:
+		netconfig_ifaddr_deleted(netconfig, ifa, bytes);
+		break;
+	}
+}
+
+static void netconfig_ifaddr_cmd_cb(int error, uint16_t type,
+						const void *data, uint32_t len,
+						void *user_data)
+{
+	if (error) {
+		l_error("netconfig: ifaddr command failure. "
+				"Error %d: %s", error, strerror(-error));
+		return;
+	}
+
+	if (type != RTM_NEWADDR)
+		return;
+
+	netconfig_ifaddr_notify(type, data, len, user_data);
+}
+
+static bool netconfig_ifaddr_remove(void *data, void *user_data)
+{
+	struct netconfig *netconfig = user_data;
+	struct netconfig_ifaddr *ifaddr = data;
+
+	switch (ifaddr->family) {
+	case AF_INET:
+		if (rtnl_ifaddr_delete(rtnl, netconfig->ifindex,
+					ifaddr->prefix_len, ifaddr->ip,
+					ifaddr->broadcast,
+					netconfig_ifaddr_cmd_cb, NULL, NULL))
+			break;
+
+		l_error("netconfig: Failed to remove ifaddr %s from "
+				"interface %u", ifaddr->ip, netconfig->ifindex);
+		break;
+	default:
+		l_error("netconfig: Unsupported address family: %u",
+								ifaddr->family);
+		break;
+	}
+
+	netconfig_ifaddr_destroy(ifaddr);
+
+	return true;
+}
+
+static bool netconfig_install_addresses(struct netconfig *netconfig,
+					const struct netconfig_ifaddr *ifaddr,
+					const char *gateway, char **dns)
+{
+	if (netconfig_ifaddr_find(netconfig, ifaddr->family, ifaddr->prefix_len,
+								ifaddr->ip))
+		/* The address is already installed. */
+		goto gateway;
+
+	switch (ifaddr->family) {
+	case AF_INET:
+		if (rtnl_ifaddr_add(rtnl, netconfig->ifindex,
+					ifaddr->prefix_len, ifaddr->ip,
+					ifaddr->broadcast,
+					netconfig_ifaddr_cmd_cb, netconfig,
+					NULL))
+			break;
+
+		l_error("netconfig: Failed to set IP %s/%u.", ifaddr->ip,
+							ifaddr->prefix_len);
+		return false;
+	default:
+		l_error("netconfig: Unsupported address family: %u",
+								ifaddr->family);
+		break;
+	}
+
+gateway:
+	/* TODO: Add the routes. */
+
+	resolve_add_dns(netconfig->ifindex, ifaddr->family, dns);
+
+	return true;
+}
+
+static bool netconfig_uninstall_addresses(struct netconfig *netconfig,
+					const struct netconfig_ifaddr *ifaddr,
+					const char *gateway, char **dns)
+{
+
+	if (!netconfig_ifaddr_find(netconfig, ifaddr->family,
+						ifaddr->prefix_len, ifaddr->ip))
+		/* The address is already removed. */
+		goto gateway;
+
+	if (!netconfig_ifaddr_remove(netconfig, (void *) ifaddr)) {
+		l_error("netconfig: Failed to remove IP %s/%u.", ifaddr->ip,
+							ifaddr->prefix_len);
+		return false;
+	}
+
+gateway:
+	/* TODO: Remove the routes. */
+
+	resolve_remove(netconfig->ifindex);
+
+	return true;
+}
+
+enum lease_action {
+	LEASE_ACTION_INSTALL,
+	LEASE_ACTION_UNINSTALL,
+};
+
+static void netconfig_dhcp_lease_received(struct netconfig *netconfig,
+					const struct l_dhcp_client *client,
+					enum lease_action action)
+{
+	const struct l_dhcp_lease *lease;
+	struct netconfig_ifaddr ifaddr;
+	struct in_addr in_addr;
+	char *netmask;
+	char *gateway;
+	char **dns;
+
+	l_debug();
+
+	lease = l_dhcp_client_get_lease(client);
+	if (!lease)
+		return;
+
+	ifaddr.ip = l_dhcp_lease_get_address(lease);
+	gateway = l_dhcp_lease_get_gateway(lease);
+	if (!ifaddr.ip || !gateway)
+		goto no_ip;
+
+	netmask = l_dhcp_lease_get_netmask(lease);
+
+	if (netmask && inet_pton(AF_INET, netmask, &in_addr) > 0)
+		ifaddr.prefix_len =
+			__builtin_popcountl(L_BE32_TO_CPU(in_addr.s_addr));
+	else
+		ifaddr.prefix_len = 24;
+
+	ifaddr.broadcast = l_dhcp_lease_get_broadcast(lease);
+	dns = l_dhcp_lease_get_dns(lease);
+	ifaddr.family = AF_INET;
+
+	switch (action) {
+	case LEASE_ACTION_INSTALL:
+		netconfig_install_addresses(netconfig, &ifaddr, gateway, dns);
+		break;
+	case LEASE_ACTION_UNINSTALL:
+		netconfig_uninstall_addresses(netconfig, &ifaddr, gateway, dns);
+		break;
+	}
+
+	l_strfreev(dns);
+	l_free(netmask);
+	l_free(ifaddr.broadcast);
+no_ip:
+	l_free(ifaddr.ip);
+	l_free(gateway);
+}
+
+static void netconfig_dhcp_event_handler(struct l_dhcp_client *client,
+						enum l_dhcp_client_event event,
+						void *userdata)
+{
+	struct netconfig *netconfig = userdata;
+
+	l_debug("DHCPv4 event %d", event);
+
+	switch (event) {
+	case L_DHCP_CLIENT_EVENT_LEASE_RENEWED:
+	case L_DHCP_CLIENT_EVENT_LEASE_OBTAINED:
+	case L_DHCP_CLIENT_EVENT_IP_CHANGED:
+		netconfig_dhcp_lease_received(netconfig, client,
+							LEASE_ACTION_INSTALL);
+
+		break;
+	case L_DHCP_CLIENT_EVENT_LEASE_EXPIRED:
+		netconfig_dhcp_lease_received(netconfig, client,
+							LEASE_ACTION_UNINSTALL);
+		/* Fall through. */
+	case L_DHCP_CLIENT_EVENT_NO_LEASE:
+		/*
+		 * The requested address is no longer available, try to restart
+		 * the client.
+		 */
+		if (!l_dhcp_client_start(client))
+			l_error("netconfig: Failed to re-start DHCPv4 client "
+					"for interface %u", netconfig->ifindex);
+
+		break;
+	default:
+		l_error("netconfig: Received unsupported DHCPv4 event: %d",
+									event);
+	}
+}
+
+static bool netconfig_dhcp_create(struct netconfig *netconfig,
+							struct station *station)
+{
+	netconfig->dhcp_client = l_dhcp_client_new(netconfig->ifindex);
+
+	l_dhcp_client_set_address(netconfig->dhcp_client, ARPHRD_ETHER,
+					netdev_get_address(
+						station_get_netdev(station)),
+					ETH_ALEN);
+
+	l_dhcp_client_set_event_handler(netconfig->dhcp_client,
+					netconfig_dhcp_event_handler,
+					netconfig, NULL);
+
+	if (getenv("IWD_DHCP_DEBUG"))
+		l_dhcp_client_set_debug(netconfig->dhcp_client, do_debug,
+							"[DHCPv4] ", NULL);
+
+	return true;
+}
+
+static bool netconfig_load_static_addresses(struct netconfig *netconfig,
+						struct station *station)
+{
+	const struct network *network;
+	const struct l_settings *settings;
+	struct netconfig_ifaddr ifaddr;
+	struct in_addr in_addr;
+	char *netmask;
+	char *gateway;
+	char **dns;
+
+	l_debug();
+
+	network = station_get_connected_network(station);
+	if (!network)
+		return false;
+
+	settings = network_get_settings(network);
+	if (!settings)
+		return false;
+
+	ifaddr.ip = l_settings_get_string(settings, "IPv4", "ip");
+	gateway = l_settings_get_string(settings, "IPv4", "gateway");
+	if (!ifaddr.ip || !gateway) {
+		l_free(ifaddr.ip);
+		l_free(gateway);
+
+		return false;
+	}
+
+	netmask = l_settings_get_string(settings, "IPv4", "netmask");
+
+	if (netmask && inet_pton(AF_INET, netmask, &in_addr) > 0)
+		ifaddr.prefix_len =
+			__builtin_popcountl(L_BE32_TO_CPU(in_addr.s_addr));
+	else
+		ifaddr.prefix_len = 24;
+
+	l_free(netmask);
+
+	ifaddr.broadcast = l_settings_get_string(settings, "IPv4", "broadcast");
+	dns = l_settings_get_string_list(settings, "IPv4", "dns", ' ');
+	ifaddr.family = AF_INET;
+
+	netconfig_install_addresses(netconfig, &ifaddr, gateway, dns);
+
+	l_free(ifaddr.ip);
+	l_free(gateway);
+	l_free(ifaddr.broadcast);
+	l_strfreev(dns);
+
+	return true;
+}
+
+static void netconfig_station_state_changed(enum station_state state,
+								void *userdata)
+{
+	struct netconfig *netconfig = userdata;
+	struct station *station;
+
+	l_debug("");
+
+	switch (state) {
+	case STATION_STATE_CONNECTED:
+		station = station_find(netconfig->ifindex);
+		if (!station)
+			break;
+
+		if (netconfig_load_static_addresses(netconfig, station))
+			break;
+
+		if (netconfig->station_state == STATION_STATE_ROAMING) {
+			/*
+			 * TODO l_dhcp_client to try to request a previously
+			 * used address.
+			 *
+			 * break;
+			 */
+		}
+
+		if (!l_dhcp_client_start(netconfig->dhcp_client))
+			l_error("netconfig: Failed to start DHCPv4 client for "
+					"interface %u", netconfig->ifindex);
+
+		break;
+	case STATION_STATE_DISCONNECTED:
+		l_dhcp_client_stop(netconfig->dhcp_client);
+
+		l_queue_foreach_remove(netconfig->ifaddr_list,
+					netconfig_ifaddr_remove, netconfig);
+
+		break;
+	case STATION_STATE_ROAMING:
+		break;
+	default:
+		return;
+	}
+
+	netconfig->station_state = state;
+}
+
+bool netconfig_ifindex_add(uint32_t ifindex)
+{
+	struct netconfig *netconfig;
+	struct station *station;
+
+	if (!netconfig_list)
+		return false;
+
+	l_debug("Starting netconfig for interface: %d", ifindex);
+
+	netconfig = netconfig_find(ifindex);
+	if (netconfig)
+		return true;
+
+	station = station_find(ifindex);
+	if (!station)
+		return false;
+
+	netconfig = l_new(struct netconfig, 1);
+	netconfig->ifindex = ifindex;
+	netconfig->ifaddr_list = l_queue_new();
+
+	netconfig_dhcp_create(netconfig, station);
+
+	station_add_state_watch(station, netconfig_station_state_changed,
+							netconfig, NULL);
+
+	l_queue_push_tail(netconfig_list, netconfig);
+
+	return true;
+}
+
+bool netconfig_ifindex_remove(uint32_t ifindex)
+{
+	struct netconfig *netconfig;
+
+	if (!netconfig_list)
+		return false;
+
+	l_debug();
+
+	netconfig = l_queue_remove_if(netconfig_list, netconfig_match,
+							L_UINT_TO_PTR(ifindex));
+	if (!netconfig)
+		return false;
+
+	netconfig_destroy(netconfig);
+
+	return true;
+}
+
+static int netconfig_init(void)
+{
+	bool enabled;
+	uint32_t r;
+
+	if (netconfig_list)
+		return -EALREADY;
+
+	if (!l_settings_get_bool(iwd_get_config(), "General",
+					"enable_network_config", &enabled) ||
+								!enabled) {
+		l_warn("netconfig: Network configuration with the IP addresses "
+								"is disabled.");
+		return false;
+	}
+
+	rtnl = l_netlink_new(NETLINK_ROUTE);
+	if (!rtnl) {
+		l_error("netconfig: Failed to open route netlink socket");
+		return -EPERM;
+	}
+
+	if (getenv("IWD_RTNL_DEBUG"))
+		l_netlink_set_debug(rtnl, do_debug, "[NETCONFIG RTNL] ", NULL);
+
+	r = l_netlink_register(rtnl, RTNLGRP_IPV4_IFADDR,
+					netconfig_ifaddr_notify, NULL, NULL);
+	if (!r) {
+		l_error("netconfig: Failed to register for RTNL link address"
+							" notifications.");
+		l_netlink_destroy(rtnl);
+		rtnl = NULL;
+
+		return r;
+	}
+
+	r = rtnl_ifaddr_get(rtnl, netconfig_ifaddr_cmd_cb, NULL, NULL);
+	if (!r) {
+		l_error("netconfig: Failed to get addresses from RTNL link.");
+		l_netlink_destroy(rtnl);
+		rtnl = NULL;
+
+		return r;
+	}
+
+	netconfig_list = l_queue_new();
+
+	return 0;
+}
+
+static void netconfig_exit(void)
+{
+	if (!netconfig_list)
+		return;
+
+	l_netlink_destroy(rtnl);
+	rtnl = NULL;
+
+	l_queue_destroy(netconfig_list, netconfig_destroy);
+}
+
+IWD_MODULE(netconfig, netconfig_init, netconfig_exit)
diff --git a/src/adhoc.h b/src/netconfig.h
similarity index 83%
rename from src/adhoc.h
rename to src/netconfig.h
index b7835bdf..1df28cd9 100644
--- a/src/adhoc.h
+++ b/src/netconfig.h
@@ -2,7 +2,7 @@
  *
  *  Wireless daemon for Linux
  *
- *  Copyright (C) 2017  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2019  Intel Corporation. All rights reserved.
  *
  *  This library is free software; you can redistribute it and/or
  *  modify it under the terms of the GNU Lesser General Public
@@ -20,7 +20,5 @@
  *
  */
 
-struct device;
-
-bool adhoc_init(struct l_genl_family *nl);
-void adhoc_exit(void);
+bool netconfig_ifindex_add(uint32_t ifindex);
+bool netconfig_ifindex_remove(uint32_t ifindex);
diff --git a/src/netdev.c b/src/netdev.c
index 3ca6209f..0d7a0bba 100644
--- a/src/netdev.c
+++ b/src/netdev.c
@@ -36,7 +36,6 @@
 #include <linux/filter.h>
 #include <sys/socket.h>
 #include <errno.h>
-#include <fnmatch.h>
 
 #include <ell/ell.h>
 
@@ -58,6 +57,7 @@
 #include "src/watchlist.h"
 #include "src/sae.h"
 #include "src/nl80211util.h"
+#include "src/nl80211cmd.h"
 #include "src/owe.h"
 #include "src/fils.h"
 #include "src/auth-proto.h"
@@ -67,6 +67,8 @@
 #define ENOTSUPP 524
 #endif
 
+static uint32_t unicast_watch;
+
 struct netdev_handshake_state {
 	struct handshake_state super;
 	uint32_t pairwise_new_key_cmd_id;
@@ -82,6 +84,7 @@ struct netdev_handshake_state {
 
 struct netdev {
 	uint32_t index;
+	uint64_t wdev_id;
 	char name[IFNAMSIZ];
 	uint32_t type;
 	uint8_t addr[ETH_ALEN];
@@ -112,6 +115,7 @@ struct netdev {
 	struct l_timeout *neighbor_report_timeout;
 	struct l_timeout *sa_query_timeout;
 	struct l_timeout *group_handshake_timeout;
+	struct l_timeout *gas_timeout;
 	uint16_t sa_query_id;
 	uint8_t prev_bssid[ETH_ALEN];
 	uint8_t prev_snonce[32];
@@ -143,6 +147,7 @@ struct netdev {
 	bool ignore_connect_event : 1;
 	bool expect_connect_failure : 1;
 	bool aborting : 1;
+	bool mac_randomize_once : 1;
 };
 
 struct netdev_preauth_state {
@@ -167,8 +172,6 @@ struct netdev_frame_watch {
 static struct l_netlink *rtnl = NULL;
 static struct l_genl_family *nl80211;
 static struct l_queue *netdev_list;
-static char **whitelist_filter;
-static char **blacklist_filter;
 static struct watchlist netdev_watches;
 
 static void do_debug(const char *str, void *user_data)
@@ -258,6 +261,11 @@ uint32_t netdev_get_ifindex(struct netdev *netdev)
 	return netdev->index;
 }
 
+uint64_t netdev_get_wdev_id(struct netdev *netdev)
+{
+	return netdev->wdev_id;
+}
+
 enum netdev_iftype netdev_get_iftype(struct netdev *netdev)
 {
 	switch (netdev->type) {
@@ -1617,14 +1625,14 @@ static void netdev_connect_event(struct l_genl_msg *msg, struct netdev *netdev)
 
 		switch (ie_tlv_iter_get_tag(&iter)) {
 		case IE_TYPE_RSN:
-			handshake_state_set_supplicant_rsn(netdev->handshake,
+			handshake_state_set_supplicant_ie(netdev->handshake,
 								data - 2);
 			break;
 		case IE_TYPE_VENDOR_SPECIFIC:
 			if (!is_ie_wpa_ie(data, ie_tlv_iter_get_length(&iter)))
 				break;
 
-			handshake_state_set_supplicant_wpa(netdev->handshake,
+			handshake_state_set_supplicant_ie(netdev->handshake,
 								data - 2);
 			break;
 		case IE_TYPE_MOBILITY_DOMAIN:
@@ -1633,7 +1641,10 @@ static void netdev_connect_event(struct l_genl_msg *msg, struct netdev *netdev)
 		}
 	}
 
-	if (resp_ies) {
+	/* FILS handles its own FT key derivation */
+	if (resp_ies && !(netdev->handshake->akm_suite &
+			(IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256 |
+			IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384))) {
 		const uint8_t *fte = NULL;
 		struct ie_ft_info ft_info;
 
@@ -1650,6 +1661,8 @@ static void netdev_connect_event(struct l_genl_msg *msg, struct netdev *netdev)
 		}
 
 		if (fte) {
+			uint32_t kck_len =
+				handshake_state_get_kck_len(netdev->handshake);
 			/*
 			 * If we are here, then most likely we have a FullMac
 			 * hw performing initial mobility association.  We need
@@ -1658,7 +1671,7 @@ static void netdev_connect_event(struct l_genl_msg *msg, struct netdev *netdev)
 			 * sanitize the contents and just assume they're okay.
 			 */
 			if (ie_parse_fast_bss_transition_from_data(fte,
-						fte[1] + 2, &ft_info) >= 0) {
+					fte[1] + 2, kck_len, &ft_info) >= 0) {
 				handshake_state_set_fte(netdev->handshake, fte);
 				handshake_state_set_kh_ids(netdev->handshake,
 							ft_info.r0khid,
@@ -1740,6 +1753,8 @@ static unsigned int ie_rsn_akm_suite_to_nl80211(enum ie_rsn_akm_suite akm)
 		return CRYPTO_AKM_FT_OVER_FILS_SHA384;
 	case IE_RSN_AKM_SUITE_OWE:
 		return CRYPTO_AKM_OWE;
+	case IE_RSN_AKM_SUITE_OSEN:
+		return CRYPTO_AKM_OSEN;
 	}
 
 	return 0;
@@ -2207,13 +2222,16 @@ static void netdev_fils_tx_associate(struct iovec *iov, size_t iov_len,
 static struct l_genl_msg *netdev_build_cmd_connect(struct netdev *netdev,
 						struct scan_bss *bss,
 						struct handshake_state *hs,
-						const uint8_t *prev_bssid)
+						const uint8_t *prev_bssid,
+						struct iovec *vendor_ies,
+						size_t num_vendor_ies)
 {
 	uint32_t auth_type = NL80211_AUTHTYPE_OPEN_SYSTEM;
 	struct l_genl_msg *msg;
-	struct iovec iov[2];
+	struct iovec iov[4 + num_vendor_ies];
 	int iov_elems = 0;
 	bool is_rsn = hs->supplicant_ie != NULL;
+	const uint8_t *extended_capabilities;
 
 	msg = l_genl_msg_new_sized(NL80211_CMD_CONNECT, 512);
 	l_genl_msg_append_attr(msg, NL80211_ATTR_IFINDEX, 4, &netdev->index);
@@ -2285,12 +2303,41 @@ static struct l_genl_msg *netdev_build_cmd_connect(struct netdev *netdev,
 				NL80211_ATTR_CONTROL_PORT_OVER_NL80211,
 				0, NULL);
 
+	if (wiphy_rrm_capable(netdev->wiphy) &&
+			bss->capability & IE_BSS_CAP_RM) {
+		uint8_t rm_cap_ie[7] = { IE_TYPE_RM_ENABLED_CAPABILITIES, 5,
+					0x00, 0x00, 0x00, 0x00, 0x00 };
+
+		/* TODO: Send an empty IE for now */
+		iov[iov_elems].iov_base = rm_cap_ie;
+		iov[iov_elems].iov_len = rm_cap_ie[1] + 2;
+		iov_elems += 1;
+
+		l_genl_msg_append_attr(msg, NL80211_ATTR_USE_RRM, 0, NULL);
+	}
+
 	if (hs->mde) {
 		iov[iov_elems].iov_base = (void *) hs->mde;
 		iov[iov_elems].iov_len = hs->mde[1] + 2;
 		iov_elems += 1;
 	}
 
+	/*
+	 * This element should be added after MDE
+	 * See 802.11-2016, Section 9.3.3.6
+	 */
+	extended_capabilities = wiphy_get_extended_capabilities(netdev->wiphy,
+								netdev->type);
+	iov[iov_elems].iov_base = (void *) extended_capabilities;
+	iov[iov_elems].iov_len = extended_capabilities[1] + 2;
+	iov_elems += 1;
+
+	if (vendor_ies) {
+		memcpy(iov + iov_elems, vendor_ies,
+					sizeof(*vendor_ies) * num_vendor_ies);
+		iov_elems += num_vendor_ies;
+	}
+
 	if (iov_elems)
 		l_genl_msg_append_attrv(msg, NL80211_ATTR_IE, iov, iov_elems);
 
@@ -2341,6 +2388,8 @@ static int netdev_connect_common(struct netdev *netdev,
 
 int netdev_connect(struct netdev *netdev, struct scan_bss *bss,
 				struct handshake_state *hs,
+				struct iovec *vendor_ies,
+				size_t num_vendor_ies,
 				netdev_event_func_t event_filter,
 				netdev_connect_cb_t cb, void *user_data)
 {
@@ -2368,12 +2417,15 @@ int netdev_connect(struct netdev *netdev, struct scan_bss *bss,
 		break;
 	case IE_RSN_AKM_SUITE_FILS_SHA256:
 	case IE_RSN_AKM_SUITE_FILS_SHA384:
+	case IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256:
+	case IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384:
 		netdev->ap = fils_sm_new(hs, netdev_fils_tx_authenticate,
 						netdev_fils_tx_associate,
 						netdev);
 		break;
 	default:
-		cmd_connect = netdev_build_cmd_connect(netdev, bss, hs, NULL);
+		cmd_connect = netdev_build_cmd_connect(netdev, bss, hs,
+					NULL, vendor_ies, num_vendor_ies);
 
 		if (!cmd_connect)
 			return -EINVAL;
@@ -2407,7 +2459,7 @@ int netdev_connect_wsc(struct netdev *netdev, struct scan_bss *bss,
 	if (netdev->connected)
 		return -EISCONN;
 
-	cmd_connect = netdev_build_cmd_connect(netdev, bss, hs, NULL);
+	cmd_connect = netdev_build_cmd_connect(netdev, bss, hs, NULL, NULL, 0);
 	if (!cmd_connect)
 		return -EINVAL;
 
@@ -2496,7 +2548,7 @@ int netdev_reassociate(struct netdev *netdev, struct scan_bss *target_bss,
 	int err;
 
 	cmd_connect = netdev_build_cmd_connect(netdev, target_bss, hs,
-						orig_bss->addr);
+						orig_bss->addr, NULL, 0);
 	if (!cmd_connect)
 		return -EINVAL;
 
@@ -2640,28 +2692,11 @@ static uint32_t netdev_send_action_framev(struct netdev *netdev,
 					uint32_t freq,
 					l_genl_msg_func_t callback)
 {
-	struct l_genl_msg *msg;
-	struct iovec iovs[iov_len + 1];
-	const uint16_t frame_type = 0x00d0;
-	uint8_t action_frame[24];
 	uint32_t id;
-
-	memset(action_frame, 0, 24);
-
-	l_put_le16(frame_type, action_frame + 0);
-	memcpy(action_frame + 4, to, 6);
-	memcpy(action_frame + 10, netdev->addr, 6);
-	memcpy(action_frame + 16, to, 6);
-
-	iovs[0].iov_base = action_frame;
-	iovs[0].iov_len = sizeof(action_frame);
-	memcpy(iovs + 1, iov, sizeof(*iov) * iov_len);
-
-	msg = l_genl_msg_new_sized(NL80211_CMD_FRAME, 128 + 512);
-
-	l_genl_msg_append_attr(msg, NL80211_ATTR_IFINDEX, 4, &netdev->index);
-	l_genl_msg_append_attr(msg, NL80211_ATTR_WIPHY_FREQ, 4, &freq);
-	l_genl_msg_append_attrv(msg, NL80211_ATTR_FRAME, iovs, iov_len + 1);
+	struct l_genl_msg *msg = nl80211_build_cmd_frame(netdev->index,
+								netdev->addr,
+								to, freq,
+								iov, iov_len);
 
 	id = l_genl_family_send(nl80211, msg, callback, netdev, NULL);
 
@@ -2870,7 +2905,7 @@ static int fast_transition(struct netdev *netdev, struct scan_bss *target_bss,
 	handshake_state_set_authenticator_address(netdev->handshake,
 							target_bss->addr);
 
-	handshake_state_set_authenticator_rsn(netdev->handshake,
+	handshake_state_set_authenticator_ie(netdev->handshake,
 							target_bss->rsne);
 	memcpy(netdev->handshake->mde + 2, target_bss->mde, 3);
 
@@ -3298,7 +3333,7 @@ static void netdev_mlme_notify(struct l_genl_msg *msg, void *user_data)
 
 	cmd = l_genl_msg_get_command(msg);
 
-	l_debug("MLME notification %u", cmd);
+	l_debug("MLME notification %s(%u)", nl80211cmd_to_string(cmd), cmd);
 
 	if (!l_genl_attr_init(&attr, msg))
 		return;
@@ -3640,10 +3675,8 @@ static void netdev_unicast_notify(struct l_genl_msg *msg, void *user_data)
 		}
 	}
 
-	if (!netdev) {
-		l_warn("Unicast notification is missing ifindex attribute");
+	if (!netdev)
 		return;
-	}
 
 	switch (cmd) {
 	case NL80211_CMD_FRAME:
@@ -4164,6 +4197,20 @@ static void netdev_initial_up_cb(int error, uint16_t type, const void *data,
 				netdev, NETDEV_WATCH_EVENT_NEW);
 }
 
+static void netdev_set_mac_cb(int error, uint16_t type, const void *data,
+					uint32_t len, void *user_data)
+{
+	struct netdev *netdev = user_data;
+
+	if (error)
+		l_error("Error setting mac address on %d: %s", netdev->index,
+			strerror(-error));
+
+	netdev->set_powered_cmd_id =
+		rtnl_set_powered(netdev->index, true, netdev_initial_up_cb,
+					netdev, NULL);
+}
+
 static void netdev_initial_down_cb(int error, uint16_t type, const void *data,
 					uint32_t len, void *user_data)
 {
@@ -4179,6 +4226,18 @@ static void netdev_initial_down_cb(int error, uint16_t type, const void *data,
 		return;
 	}
 
+	if (netdev->mac_randomize_once) {
+		uint8_t addr[ETH_ALEN];
+
+		wiphy_generate_random_address(netdev->wiphy, addr);
+		l_debug("Setting initial random address on "
+			"ifindex: %d to: "MAC, netdev->index, MAC_STR(addr));
+		netdev->set_powered_cmd_id =
+			rtnl_set_mac(rtnl, netdev->index, addr,
+					netdev_set_mac_cb, netdev, NULL);
+		return;
+	}
+
 	netdev->set_powered_cmd_id =
 		rtnl_set_powered(netdev->index, true, netdev_initial_up_cb,
 					netdev, NULL);
@@ -4213,46 +4272,28 @@ static void netdev_getlink_cb(int error, uint16_t type, const void *data,
 	netdev_newlink_notify(ifi, bytes);
 
 	/*
-	 * If the interface is UP, reset it to ensure a clean state,
-	 * otherwise just bring it UP.
+	 * If the interface is UP, reset it to ensure a clean state.
+	 * Otherwise, if we need to set a random mac, do so.  If not, just
+	 * bring the interface UP.
 	 */
 	powered = netdev_get_is_up(netdev);
-	cb = powered ? netdev_initial_down_cb : netdev_initial_up_cb;
-
-	netdev->set_powered_cmd_id =
-		rtnl_set_powered(ifi->ifi_index, !powered, cb, netdev, NULL);
-}
-
-static bool netdev_is_managed(const char *ifname)
-{
-	char *pattern;
-	unsigned int i;
 
-	if (!whitelist_filter)
-		goto check_blacklist;
+	if (!powered && netdev->mac_randomize_once) {
+		uint8_t addr[ETH_ALEN];
 
-	for (i = 0; (pattern = whitelist_filter[i]); i++) {
-		if (fnmatch(pattern, ifname, 0) != 0)
-			continue;
-
-		goto check_blacklist;
+		wiphy_generate_random_address(netdev->wiphy, addr);
+		l_debug("Setting initial random address on "
+			"ifindex: %d to: "MAC, netdev->index, MAC_STR(addr));
+		netdev->set_powered_cmd_id =
+			rtnl_set_mac(rtnl, netdev->index, addr,
+					netdev_set_mac_cb, netdev, NULL);
+		return;
 	}
 
-	l_debug("whitelist filtered ifname: %s", ifname);
-	return false;
-
-check_blacklist:
-	if (!blacklist_filter)
-		return true;
-
-	for (i = 0; (pattern = blacklist_filter[i]); i++) {
-		if (fnmatch(pattern, ifname, 0) == 0) {
-			l_debug("blacklist filtered ifname: %s", ifname);
-			return false;
-		}
-	}
+	cb = powered ? netdev_initial_down_cb : netdev_initial_up_cb;
 
-	return true;
+	netdev->set_powered_cmd_id =
+		rtnl_set_powered(ifi->ifi_index, !powered, cb, netdev, NULL);
 }
 
 static void netdev_frame_watch_free(struct watchlist_item *item)
@@ -4377,15 +4418,16 @@ error:
 	return NULL;
 }
 
-struct netdev *netdev_create_from_genl(struct l_genl_msg *msg)
+struct netdev *netdev_create_from_genl(struct l_genl_msg *msg, bool random_mac)
 {
 	struct l_genl_attr attr;
 	uint16_t type, len;
 	const void *data;
 	const char *ifname = NULL;
 	uint16_t ifname_len = 0;
-	const uint8_t *ifaddr;
+	const uint8_t *ifaddr = NULL;
 	const uint32_t *ifindex = NULL, *iftype = NULL;
+	const uint64_t *wdev = NULL;
 	struct netdev *netdev;
 	struct wiphy *wiphy = NULL;
 	struct ifinfomsg *rtmmsg;
@@ -4412,6 +4454,15 @@ struct netdev *netdev_create_from_genl(struct l_genl_msg *msg)
 			ifindex = data;
 			break;
 
+		case NL80211_ATTR_WDEV:
+			if (len != sizeof(uint64_t)) {
+				l_warn("Invalid wdev attribute");
+				return NULL;
+			}
+
+			wdev = data;
+			break;
+
 		case NL80211_ATTR_IFNAME:
 			if (len > IFNAMSIZ) {
 				l_warn("Invalid interface name attribute");
@@ -4451,15 +4502,12 @@ struct netdev *netdev_create_from_genl(struct l_genl_msg *msg)
 		}
 	}
 
-	if (!wiphy)
-		return NULL;
-
 	if (!iftype) {
 		l_warn("Missing iftype attribute");
 		return NULL;
 	}
 
-	if (!ifindex || !ifaddr | !ifname) {
+	if (!wiphy || !ifindex || !wdev || !ifaddr || !ifname) {
 		l_warn("Unable to parse interface information");
 		return NULL;
 	}
@@ -4469,11 +4517,6 @@ struct netdev *netdev_create_from_genl(struct l_genl_msg *msg)
 		return NULL;
 	}
 
-	if (!netdev_is_managed(ifname)) {
-		l_debug("interface %s filtered out", ifname);
-		return NULL;
-	}
-
 	if (!l_settings_get_bool(settings, "General",
 				"ControlPortOverNL80211", &pae_over_nl80211)) {
 		pae_over_nl80211 = true;
@@ -4498,12 +4541,14 @@ struct netdev *netdev_create_from_genl(struct l_genl_msg *msg)
 
 	netdev = l_new(struct netdev, 1);
 	netdev->index = *ifindex;
+	netdev->wdev_id = *wdev;
 	netdev->type = *iftype;
 	netdev->rekey_offload_support = true;
 	memcpy(netdev->addr, ifaddr, sizeof(netdev->addr));
 	memcpy(netdev->name, ifname, ifname_len);
 	netdev->wiphy = wiphy;
 	netdev->pae_over_nl80211 = pae_over_nl80211;
+	netdev->mac_randomize_once = random_mac;
 
 	if (pae_io) {
 		netdev->pae_io = pae_io;
@@ -4516,7 +4561,8 @@ struct netdev *netdev_create_from_genl(struct l_genl_msg *msg)
 
 	l_queue_push_tail(netdev_list, netdev);
 
-	l_debug("Created interface %s[%d]", netdev->name, netdev->index);
+	l_debug("Created interface %s[%d %" PRIx64 "]", netdev->name,
+		netdev->index, netdev->wdev_id);
 
 	/* Query interface flags */
 	bufsize = NLMSG_ALIGN(sizeof(struct ifinfomsg));
@@ -4607,8 +4653,9 @@ bool netdev_watch_remove(uint32_t id)
 	return watchlist_remove(&netdev_watches, id);
 }
 
-bool netdev_init(const char *whitelist, const char *blacklist)
+bool netdev_init(void)
 {
+	struct l_genl *genl = iwd_get_genl();
 	const struct l_settings *settings = iwd_get_config();
 
 	if (rtnl)
@@ -4646,11 +4693,11 @@ bool netdev_init(const char *whitelist, const char *blacklist)
 	__eapol_set_rekey_offload_func(netdev_set_rekey_offload);
 	__eapol_set_tx_packet_func(netdev_control_port_frame);
 
-	if (whitelist)
-		whitelist_filter = l_strsplit(whitelist, ',');
-
-	if (blacklist)
-		blacklist_filter = l_strsplit(blacklist, ',');
+	unicast_watch = l_genl_add_unicast_watch(genl, NL80211_GENL_NAME,
+						netdev_unicast_notify,
+						NULL, NULL);
+	if (!unicast_watch)
+		l_error("Registering for unicast notification failed");
 
 	return true;
 }
@@ -4662,19 +4709,16 @@ void netdev_set_nl80211(struct l_genl_family *in)
 	if (!l_genl_family_register(nl80211, "mlme", netdev_mlme_notify,
 								NULL, NULL))
 		l_error("Registering for MLME notification failed");
-
-	if (!l_genl_family_set_unicast_handler(nl80211, netdev_unicast_notify,
-								NULL, NULL))
-		l_error("Registering for unicast notification failed");
 }
 
 void netdev_exit(void)
 {
+	struct l_genl *genl = iwd_get_genl();
+
 	if (!rtnl)
 		return;
 
-	l_strfreev(whitelist_filter);
-	l_strfreev(blacklist_filter);
+	l_genl_remove_unicast_watch(genl, unicast_watch);
 
 	watchlist_destroy(&netdev_watches);
 	nl80211 = NULL;
diff --git a/src/netdev.h b/src/netdev.h
index 98b17876..2d699c60 100644
--- a/src/netdev.h
+++ b/src/netdev.h
@@ -127,6 +127,7 @@ typedef void (*netdev_station_watch_func_t)(struct netdev *netdev,
 struct wiphy *netdev_get_wiphy(struct netdev *netdev);
 const uint8_t *netdev_get_address(struct netdev *netdev);
 uint32_t netdev_get_ifindex(struct netdev *netdev);
+uint64_t netdev_get_wdev_id(struct netdev *netdev);
 enum netdev_iftype netdev_get_iftype(struct netdev *netdev);
 int netdev_set_iftype(struct netdev *netdev, enum netdev_iftype type,
 			netdev_command_cb_t cb, void *user_data,
@@ -145,6 +146,8 @@ struct handshake_state *netdev_get_handshake(struct netdev *netdev);
 
 int netdev_connect(struct netdev *netdev, struct scan_bss *bss,
 				struct handshake_state *hs,
+				struct iovec *vendor_ies,
+				size_t num_vendor_ies,
 				netdev_event_func_t event_filter,
 				netdev_connect_cb_t cb, void *user_data);
 int netdev_connect_wsc(struct netdev *netdev, struct scan_bss *bss,
@@ -207,5 +210,5 @@ uint32_t netdev_station_watch_add(struct netdev *netdev,
 
 bool netdev_station_watch_remove(struct netdev *netdev, uint32_t id);
 
-struct netdev *netdev_create_from_genl(struct l_genl_msg *msg);
+struct netdev *netdev_create_from_genl(struct l_genl_msg *msg, bool random_mac);
 bool netdev_destroy(struct netdev *netdev);
diff --git a/src/network.c b/src/network.c
index e3197ad0..5e46bb71 100644
--- a/src/network.c
+++ b/src/network.c
@@ -48,6 +48,8 @@
 #include "src/knownnetworks.h"
 #include "src/network.h"
 #include "src/blacklist.h"
+#include "src/util.h"
+#include "src/hotspot.h"
 
 struct network {
 	char *object_path;
@@ -60,6 +62,9 @@ struct network {
 	struct l_settings *settings;
 	struct l_queue *secrets;
 	struct l_queue *blacklist; /* temporary blacklist for BSS's */
+	uint8_t hessid[6];
+	char **nai_realms;
+	uint8_t *rc_ie;
 	bool update_psk:1;  /* Whether PSK should be written to storage */
 	bool ask_passphrase:1; /* Whether we should force-ask agent */
 	int rank;
@@ -72,8 +77,23 @@ static bool network_settings_load(struct network *network)
 	if (network->settings)
 		return true;
 
-	network->settings = storage_network_open(network_get_security(network),
-							network->info->ssid);
+	/*
+	 * If this network contains NAI realm info OR we have a Hotspot
+	 * provisioning file containing the HESSID we know this is a Hotspot
+	 * network.
+	 */
+	if (network->nai_realms || !util_mem_is_zero(network->hessid, 6)) {
+		network->settings = l_settings_new();
+
+		if (!l_settings_load_from_file(network->settings,
+					hs20_find_settings_file(network))) {
+			l_settings_free(network->settings);
+			network->settings = NULL;
+		}
+	} else
+		network->settings = storage_network_open(
+						network_get_security(network),
+						network->info->ssid);
 
 	return network->settings != NULL;
 }
@@ -520,6 +540,34 @@ void network_sync_psk(struct network *network)
 					network->settings);
 }
 
+void network_set_hessid(struct network *network, uint8_t *hessid)
+{
+	memcpy(network->hessid, hessid, 6);
+}
+
+void network_set_nai_realms(struct network *network, char **realms)
+{
+	if (network->nai_realms)
+		l_strv_free(network->nai_realms);
+
+	network->nai_realms = realms;
+}
+
+uint8_t *network_get_hessid(struct network *network)
+{
+	return network->hessid;
+}
+
+char **network_get_nai_realms(struct network *network)
+{
+	return network->nai_realms;
+}
+
+const uint8_t *network_get_roaming_consortium(struct network *network)
+{
+	return network->rc_ie;
+}
+
 static inline bool __bss_is_sae(const struct scan_bss *bss,
 						const struct ie_rsn_info *rsn)
 {
@@ -659,6 +707,12 @@ bool network_bss_add(struct network *network, struct scan_bss *bss)
 
 	l_queue_push_head(network->info->known_frequencies, known_freq);
 
+	if (!util_mem_is_zero(bss->hessid, 6))
+		memcpy(network->hessid, bss->hessid, 6);
+
+	if (bss->rc_ie && !network->rc_ie)
+		network->rc_ie = l_memdup(bss->rc_ie, bss->rc_ie[1] + 2);
+
 	return true;
 }
 
@@ -1270,29 +1324,6 @@ static bool network_property_get_known_network(struct l_dbus *dbus,
 	return true;
 }
 
-static void setup_network_interface(struct l_dbus_interface *interface)
-{
-	l_dbus_interface_method(interface, "Connect", 0,
-				network_connect,
-				"", "");
-
-	l_dbus_interface_property(interface, "Name", 0, "s",
-					network_property_get_name, NULL);
-
-	l_dbus_interface_property(interface, "Connected", 0, "b",
-					network_property_is_connected,
-					NULL);
-
-	l_dbus_interface_property(interface, "Device", 0, "o",
-					network_property_get_device, NULL);
-
-	l_dbus_interface_property(interface, "Type", 0, "s",
-					network_property_get_type, NULL);
-
-	l_dbus_interface_property(interface, "KnownNetwork", 0, "o",
-				network_property_get_known_network, NULL);
-}
-
 bool network_register(struct network *network, const char *path)
 {
 	if (!l_dbus_object_add_interface(dbus_get_bus(), path,
@@ -1338,25 +1369,13 @@ void network_remove(struct network *network, int reason)
 
 	l_queue_destroy(network->blacklist, NULL);
 
-	l_free(network);
-}
+	if (network->nai_realms)
+		l_strv_free(network->nai_realms);
 
-void network_init()
-{
-	if (!l_dbus_register_interface(dbus_get_bus(), IWD_NETWORK_INTERFACE,
-					setup_network_interface, NULL, false))
-		l_error("Unable to register %s interface",
-						IWD_NETWORK_INTERFACE);
+	if (network->rc_ie)
+		l_free(network->rc_ie);
 
-	networks = l_queue_new();
-}
-
-void network_exit()
-{
-	l_queue_destroy(networks, network_info_free);
-	networks = NULL;
-
-	l_dbus_unregister_interface(dbus_get_bus(), IWD_NETWORK_INTERFACE);
+	l_free(network);
 }
 
 int network_rank_compare(const void *a, const void *b, void *user)
@@ -1473,3 +1492,47 @@ void network_info_forget_known(struct network_info *network)
 	else
 		network_info_free(network);
 }
+
+static void setup_network_interface(struct l_dbus_interface *interface)
+{
+	l_dbus_interface_method(interface, "Connect", 0,
+				network_connect,
+				"", "");
+
+	l_dbus_interface_property(interface, "Name", 0, "s",
+					network_property_get_name, NULL);
+
+	l_dbus_interface_property(interface, "Connected", 0, "b",
+					network_property_is_connected,
+					NULL);
+
+	l_dbus_interface_property(interface, "Device", 0, "o",
+					network_property_get_device, NULL);
+
+	l_dbus_interface_property(interface, "Type", 0, "s",
+					network_property_get_type, NULL);
+
+	l_dbus_interface_property(interface, "KnownNetwork", 0, "o",
+				network_property_get_known_network, NULL);
+}
+
+static int network_init(void)
+{
+	if (!l_dbus_register_interface(dbus_get_bus(), IWD_NETWORK_INTERFACE,
+					setup_network_interface, NULL, false))
+		l_error("Unable to register %s interface",
+						IWD_NETWORK_INTERFACE);
+
+	networks = l_queue_new();
+	return 0;
+}
+
+static void network_exit(void)
+{
+	l_queue_destroy(networks, network_info_free);
+	networks = NULL;
+
+	l_dbus_unregister_interface(dbus_get_bus(), IWD_NETWORK_INTERFACE);
+}
+
+IWD_MODULE(network, network_init, network_exit)
diff --git a/src/network.h b/src/network.h
index ba66b097..a1a81072 100644
--- a/src/network.h
+++ b/src/network.h
@@ -48,6 +48,12 @@ struct l_settings *network_get_settings(const struct network *network);
 bool network_set_psk(struct network *network, const uint8_t *psk);
 void network_sync_psk(struct network *network);
 
+void network_set_hessid(struct network *network, uint8_t *hessid);
+void network_set_nai_realms(struct network *network, char **realms);
+uint8_t *network_get_hessid(struct network *network);
+char **network_get_nai_realms(struct network *network);
+const uint8_t *network_get_roaming_consortium(struct network *network);
+
 int network_autoconnect(struct network *network, struct scan_bss *bss);
 void network_connect_failed(struct network *network);
 bool network_bss_add(struct network *network, struct scan_bss *bss);
diff --git a/src/nl80211cmd.c b/src/nl80211cmd.c
new file mode 100644
index 00000000..c2944567
--- /dev/null
+++ b/src/nl80211cmd.c
@@ -0,0 +1,165 @@
+/*
+ *
+ *  Wireless daemon for Linux
+ *
+ *  Copyright (C) 2019 Intel Corporation. All rights reserved.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdint.h>
+
+#include "linux/nl80211.h"
+#include "src/nl80211cmd.h"
+
+static const struct {
+	uint8_t cmd;
+	const char *str;
+} cmd_table[] = {
+	{ NL80211_CMD_GET_WIPHY,		"Get Wiphy"		},
+	{ NL80211_CMD_SET_WIPHY,		"Set Wiphy"		},
+	{ NL80211_CMD_NEW_WIPHY,		"New Wiphy"		},
+	{ NL80211_CMD_DEL_WIPHY,		"Del Wiphy"		},
+	{ NL80211_CMD_GET_INTERFACE,		"Get Interface"		},
+	{ NL80211_CMD_SET_INTERFACE,		"Set Interface"		},
+	{ NL80211_CMD_NEW_INTERFACE,		"New Interface"		},
+	{ NL80211_CMD_DEL_INTERFACE,		"Del Interface"		},
+	{ NL80211_CMD_GET_KEY,			"Get Key"		},
+	{ NL80211_CMD_SET_KEY,			"Set Key"		},
+	{ NL80211_CMD_NEW_KEY,			"New Key"		},
+	{ NL80211_CMD_DEL_KEY,			"Del Key"		},
+	{ NL80211_CMD_GET_BEACON,		"Get Beacon"		},
+	{ NL80211_CMD_SET_BEACON,		"Set Beacon"		},
+	{ NL80211_CMD_START_AP,			"Start AP"		},
+	{ NL80211_CMD_STOP_AP,			"Stop AP"		},
+	{ NL80211_CMD_GET_STATION,		"Get Station"		},
+	{ NL80211_CMD_SET_STATION,		"Set Station"		},
+	{ NL80211_CMD_NEW_STATION,		"New Station"		},
+	{ NL80211_CMD_DEL_STATION,		"Del Station"		},
+	{ NL80211_CMD_GET_MPATH,		"Get Mesh Path"		},
+	{ NL80211_CMD_SET_MPATH,		"Set Mesh Path"		},
+	{ NL80211_CMD_NEW_MPATH,		"New Mesh Path"		},
+	{ NL80211_CMD_DEL_MPATH,		"Del Mesh Path"		},
+	{ NL80211_CMD_SET_BSS,			"Set BSS"		},
+	{ NL80211_CMD_SET_REG,			"Set Reg"		},
+	{ NL80211_CMD_REQ_SET_REG,		"Req Set Reg"		},
+	{ NL80211_CMD_GET_MESH_CONFIG,		"Get Mesh Config"	},
+	{ NL80211_CMD_SET_MESH_CONFIG,		"Set Mesh Config"	},
+	{ NL80211_CMD_SET_MGMT_EXTRA_IE,	"Mgmt Extra IE"		},
+	{ NL80211_CMD_GET_REG,			"Get Reg"		},
+	{ NL80211_CMD_GET_SCAN,			"Get Scan"		},
+	{ NL80211_CMD_TRIGGER_SCAN,		"Trigger Scan"		},
+	{ NL80211_CMD_NEW_SCAN_RESULTS,		"New Scan Results"	},
+	{ NL80211_CMD_SCAN_ABORTED,		"Scan Aborted"		},
+	{ NL80211_CMD_REG_CHANGE,		"Reg Change"		},
+	{ NL80211_CMD_AUTHENTICATE,		"Authenticate"		},
+	{ NL80211_CMD_ASSOCIATE,		"Associate"		},
+	{ NL80211_CMD_DEAUTHENTICATE,		"Deauthenticate"	},
+	{ NL80211_CMD_DISASSOCIATE,		"Disassociate"		},
+	{ NL80211_CMD_MICHAEL_MIC_FAILURE,	"Michael MIC Failure"	},
+	{ NL80211_CMD_REG_BEACON_HINT,		"Reg Beacon Hint"	},
+	{ NL80211_CMD_JOIN_IBSS,		"Join IBSS"		},
+	{ NL80211_CMD_LEAVE_IBSS,		"Leave IBSS"		},
+	{ NL80211_CMD_TESTMODE,			"Test Mode"		},
+	{ NL80211_CMD_CONNECT,			"Connect"		},
+	{ NL80211_CMD_ROAM,			"Roam"			},
+	{ NL80211_CMD_DISCONNECT,		"Disconnect"		},
+	{ NL80211_CMD_SET_WIPHY_NETNS,		"Set Wiphy Netns"	},
+	{ NL80211_CMD_GET_SURVEY,		"Get Survey"		},
+	{ NL80211_CMD_NEW_SURVEY_RESULTS,	"New Survey Results"	},
+	{ NL80211_CMD_SET_PMKSA,		"Set PMKSA"		},
+	{ NL80211_CMD_DEL_PMKSA,		"Del PMKSA"		},
+	{ NL80211_CMD_FLUSH_PMKSA,		"Flush PMKSA"		},
+	{ NL80211_CMD_REMAIN_ON_CHANNEL,	"Remain on Channel"	},
+	{ NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,	"Cancel Remain on Channel"},
+	{ NL80211_CMD_SET_TX_BITRATE_MASK,	"Set TX Bitrate Mask"	},
+	{ NL80211_CMD_REGISTER_FRAME,		"Register Frame"	},
+	{ NL80211_CMD_FRAME,			"Frame"			},
+	{ NL80211_CMD_FRAME_TX_STATUS,		"Frame TX Status"	},
+	{ NL80211_CMD_SET_POWER_SAVE,		"Set Power Save"	},
+	{ NL80211_CMD_GET_POWER_SAVE,		"Get Power Save"	},
+	{ NL80211_CMD_SET_CQM,			"Set CQM"		},
+	{ NL80211_CMD_NOTIFY_CQM,		"Notify CQM"		},
+	{ NL80211_CMD_SET_CHANNEL,		"Set Channel"		},
+	{ NL80211_CMD_SET_WDS_PEER,		"Set WDS Peer"		},
+	{ NL80211_CMD_FRAME_WAIT_CANCEL,	"Frame Wait Cancel"	},
+	{ NL80211_CMD_JOIN_MESH,		"Join Mesh"		},
+	{ NL80211_CMD_LEAVE_MESH,		"Leave Mesh"		},
+	{ NL80211_CMD_UNPROT_DEAUTHENTICATE,	"Unprot Deauthenticate"	},
+	{ NL80211_CMD_UNPROT_DISASSOCIATE,	"Unprot Disassociate"	},
+	{ NL80211_CMD_NEW_PEER_CANDIDATE,	"New Peer Candidate"	},
+	{ NL80211_CMD_GET_WOWLAN,		"Get WoWLAN"		},
+	{ NL80211_CMD_SET_WOWLAN,		"Set WoWLAN"		},
+	{ NL80211_CMD_START_SCHED_SCAN,		"Start Sched Scan"	},
+	{ NL80211_CMD_STOP_SCHED_SCAN,		"Stop Sched Scan"	},
+	{ NL80211_CMD_SCHED_SCAN_RESULTS,	"Sched Scan Results"	},
+	{ NL80211_CMD_SCHED_SCAN_STOPPED,	"Sched Scan Stopped"	},
+	{ NL80211_CMD_SET_REKEY_OFFLOAD,	"Set Rekey Offload"	},
+	{ NL80211_CMD_PMKSA_CANDIDATE,		"PMKSA Candidate"	},
+	{ NL80211_CMD_TDLS_OPER,		"TDLS Oper"		},
+	{ NL80211_CMD_TDLS_MGMT,		"TDLS Mgmt"		},
+	{ NL80211_CMD_UNEXPECTED_FRAME,		"Unexpected Frame"	},
+	{ NL80211_CMD_PROBE_CLIENT,		"Probe Client"		},
+	{ NL80211_CMD_REGISTER_BEACONS,		"Register Beacons"	},
+	{ NL80211_CMD_UNEXPECTED_4ADDR_FRAME,	"Unexpected 4addr Frame"},
+	{ NL80211_CMD_SET_NOACK_MAP,		"Set NoAck Map"		},
+	{ NL80211_CMD_CH_SWITCH_NOTIFY,		"Channel Switch Notify"	},
+	{ NL80211_CMD_START_P2P_DEVICE,		"Start P2P Device"	},
+	{ NL80211_CMD_STOP_P2P_DEVICE,		"Stop P2P Device"	},
+	{ NL80211_CMD_CONN_FAILED,		"Conn Failed"		},
+	{ NL80211_CMD_SET_MCAST_RATE,		"Set Mcast Rate"	},
+	{ NL80211_CMD_SET_MAC_ACL,		"Set MAC ACL"		},
+	{ NL80211_CMD_RADAR_DETECT,		"Radar Detect"		},
+	{ NL80211_CMD_GET_PROTOCOL_FEATURES,	"Get Protocol Features"	},
+	{ NL80211_CMD_UPDATE_FT_IES,		"Update FT IEs"		},
+	{ NL80211_CMD_FT_EVENT,			"FT Event"		},
+	{ NL80211_CMD_CRIT_PROTOCOL_START,	"Crit Protocol Start"	},
+	{ NL80211_CMD_CRIT_PROTOCOL_STOP,	"Crit Protocol Stop"	},
+	{ NL80211_CMD_GET_COALESCE,		"Get Coalesce"		},
+	{ NL80211_CMD_SET_COALESCE,		"Set Coalesce"		},
+	{ NL80211_CMD_CHANNEL_SWITCH,		"Channel Switch"	},
+	{ NL80211_CMD_VENDOR,			"Vendor"		},
+	{ NL80211_CMD_SET_QOS_MAP,		"Set QoS Map"		},
+	{ NL80211_CMD_ADD_TX_TS,		"Add Traffic Stream"	},
+	{ NL80211_CMD_DEL_TX_TS,		"Delete Traffic Stream" },
+	{ NL80211_CMD_GET_MPP,			"Get Mesh Proxy Path"	},
+	{ NL80211_CMD_JOIN_OCB,			"Join OCB Network"	},
+	{ NL80211_CMD_LEAVE_OCB,		"Leave OCB Network"	},
+	{ NL80211_CMD_CH_SWITCH_STARTED_NOTIFY, "Channel Switch Notify"	},
+	{ NL80211_CMD_TDLS_CHANNEL_SWITCH,	"TDLS Channel Switch"	},
+	{ NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH,
+						"Cancel TLDS Channel Switch" },
+	{ NL80211_CMD_WIPHY_REG_CHANGE,		"Wiphy Reg Change"	},
+	{ }
+};
+
+const char *nl80211cmd_to_string(uint32_t cmd)
+{
+	unsigned int i;
+
+	for (i = 0; cmd_table[i].str; i++) {
+		if (cmd_table[i].cmd != cmd)
+			continue;
+
+		return cmd_table[i].str;
+	}
+
+	return "Unknown";
+}
diff --git a/src/ap.h b/src/nl80211cmd.h
similarity index 85%
rename from src/ap.h
rename to src/nl80211cmd.h
index 299c80ac..5f6d661c 100644
--- a/src/ap.h
+++ b/src/nl80211cmd.h
@@ -2,7 +2,7 @@
  *
  *  Wireless daemon for Linux
  *
- *  Copyright (C) 2017  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2019 Intel Corporation. All rights reserved.
  *
  *  This library is free software; you can redistribute it and/or
  *  modify it under the terms of the GNU Lesser General Public
@@ -20,7 +20,4 @@
  *
  */
 
-struct device;
-
-bool ap_init(struct l_genl_family *in);
-void ap_exit(void);
+const char *nl80211cmd_to_string(uint32_t cmd);
diff --git a/src/nl80211util.c b/src/nl80211util.c
index a9c3914a..fa7a591c 100644
--- a/src/nl80211util.c
+++ b/src/nl80211util.c
@@ -194,3 +194,35 @@ const void *nl80211_parse_get_key_seq(struct l_genl_msg *msg)
 
 	return data;
 }
+
+struct l_genl_msg *nl80211_build_cmd_frame(uint32_t ifindex,
+						const uint8_t *addr,
+						const uint8_t *to,
+						uint32_t freq,
+						struct iovec *iov,
+						size_t iov_len)
+{
+	struct l_genl_msg *msg;
+	struct iovec iovs[iov_len + 1];
+	const uint16_t frame_type = 0x00d0;
+	uint8_t action_frame[24];
+
+	memset(action_frame, 0, 24);
+
+	l_put_le16(frame_type, action_frame + 0);
+	memcpy(action_frame + 4, to, 6);
+	memcpy(action_frame + 10, addr, 6);
+	memcpy(action_frame + 16, to, 6);
+
+	iovs[0].iov_base = action_frame;
+	iovs[0].iov_len = sizeof(action_frame);
+	memcpy(iovs + 1, iov, sizeof(*iov) * iov_len);
+
+	msg = l_genl_msg_new_sized(NL80211_CMD_FRAME, 128 + 512);
+
+	l_genl_msg_append_attr(msg, NL80211_ATTR_IFINDEX, 4, &ifindex);
+	l_genl_msg_append_attr(msg, NL80211_ATTR_WIPHY_FREQ, 4, &freq);
+	l_genl_msg_append_attrv(msg, NL80211_ATTR_FRAME, iovs, iov_len + 1);
+
+	return msg;
+}
diff --git a/src/nl80211util.h b/src/nl80211util.h
index 41188c1a..c3e534cb 100644
--- a/src/nl80211util.h
+++ b/src/nl80211util.h
@@ -42,3 +42,10 @@ struct l_genl_msg *nl80211_build_set_key(uint32_t ifindex, uint8_t key_index);
 struct l_genl_msg *nl80211_build_get_key(uint32_t ifindex, uint8_t key_index);
 
 const void *nl80211_parse_get_key_seq(struct l_genl_msg *msg);
+
+struct l_genl_msg *nl80211_build_cmd_frame(uint32_t ifindex,
+						const uint8_t *addr,
+						const uint8_t *to,
+						uint32_t freq,
+						struct iovec *iov,
+						size_t iov_len);
diff --git a/src/owe.c b/src/owe.c
index a8e66da2..daaf1f30 100644
--- a/src/owe.c
+++ b/src/owe.c
@@ -256,7 +256,8 @@ static int owe_rx_associate(struct auth_proto *ap, const uint8_t *frame,
 
 	body = mmpdu_body(mpdu);
 
-	if (body->status_code == MMPDU_STATUS_CODE_UNSUPP_FINITE_CYCLIC_GROUP) {
+	if (L_LE16_TO_CPU(body->status_code) ==
+				MMPDU_STATUS_CODE_UNSUPP_FINITE_CYCLIC_GROUP) {
 		if (!owe_retry(owe))
 			goto owe_bad_status;
 
@@ -326,7 +327,7 @@ invalid_ies:
 	return MMPDU_STATUS_CODE_INVALID_ELEMENT;
 
 owe_bad_status:
-	return (int)body->status_code;
+	return L_LE16_TO_CPU(body->status_code);
 }
 
 struct auth_proto *owe_sm_new(struct handshake_state *hs,
diff --git a/src/p2putil.c b/src/p2putil.c
new file mode 100644
index 00000000..ce7e342b
--- /dev/null
+++ b/src/p2putil.c
@@ -0,0 +1,2547 @@
+/*
+ *
+ *  Wireless daemon for Linux
+ *
+ *  Copyright (C) 2019  Intel Corporation. All rights reserved.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdbool.h>
+#include <stdarg.h>
+#include <errno.h>
+#include <stdio.h>
+
+#include <ell/ell.h>
+
+#include "src/p2putil.h"
+#include "src/ie.h"
+
+void p2p_attr_iter_init(struct p2p_attr_iter *iter, const uint8_t *pdu,
+			size_t len)
+
+{
+	iter->pos = pdu;
+	iter->end = pdu + len;
+	iter->type = -1;
+}
+
+/* Wi-Fi P2P Technical Specification v1.7 Section 4.1.1 */
+bool p2p_attr_iter_next(struct p2p_attr_iter *iter)
+{
+	if (iter->type != (enum p2p_attr) -1)
+		iter->pos += 3 + iter->len;
+
+	if (iter->pos + 3 > iter->end ||
+			iter->pos + 3 + l_get_le16(iter->pos + 1) > iter->end)
+		return false;
+
+	iter->type = iter->pos[0];
+	iter->len = l_get_le16(iter->pos + 1);
+	return true;
+}
+
+enum attr_flag {
+	ATTR_FLAG_REQUIRED  = 0x1,  /* Always required */
+};
+
+typedef bool (*attr_handler)(const uint8_t *, size_t, void *);
+
+static bool extract_p2p_byte(const uint8_t *attr, size_t len,
+				void *data)
+{
+	uint8_t *out = data;
+
+	if (len != 1)
+		return false;
+
+	*out = attr[0];
+	return true;
+}
+
+/* Section 4.1.2 */
+static bool extract_p2p_status(const uint8_t *attr, size_t len,
+				void *data)
+{
+	enum p2p_attr_status_code *out = data;
+
+	if (len != 1)
+		return false;
+
+	*out = attr[0];
+	return true;
+}
+
+/* Section 4.1.4 */
+static bool extract_p2p_capability(const uint8_t *attr, size_t len,
+					void *data)
+{
+	struct p2p_capability_attr *out = data;
+
+	if (len != 2)
+		return false;
+
+	out->device_caps = attr[0];
+	out->group_caps = attr[1];
+	return true;
+}
+
+/* Section 4.1.5, 4.1.9, 4.1.11, ... */
+static bool extract_p2p_addr(const uint8_t *attr, size_t len,
+				void *data)
+{
+	uint8_t *out = data;
+
+	if (len != 6)
+		return false;
+
+	memcpy(out, attr, 6);
+	return true;
+}
+
+struct p2p_go_intent_attr {
+	uint8_t intent;
+	bool tie_breaker;
+};
+
+/* Section 4.1.6 */
+static bool extract_p2p_go_intent(const uint8_t *attr, size_t len,
+					void *data)
+{
+	struct p2p_go_intent_attr *out = data;
+	uint8_t intent;
+
+	if (len != 1)
+		return false;
+
+	intent = attr[0] >> 1;
+
+	if (intent & ~15)
+		return false;
+
+	out->intent = intent;
+	out->tie_breaker = attr[0] & 1;
+
+	return true;
+}
+
+/* Section 4.1.7 */
+static bool extract_p2p_config_timeout(const uint8_t *attr, size_t len,
+					void *data)
+{
+	struct p2p_config_timeout_attr *out = data;
+
+	if (len != 2)
+		return false;
+
+	out->go_config_timeout = attr[0];
+	out->client_config_timeout = attr[1];
+	return true;
+}
+
+/* Section 4.1.8, 4.1.19, ... */
+static bool extract_p2p_channel(const uint8_t *attr, size_t len,
+				void *data)
+{
+	struct p2p_channel_attr *out = data;
+
+	if (len != 5)
+		return false;
+
+	out->country[0] = attr[0];
+	out->country[1] = attr[1];
+	out->country[2] = attr[2];
+	out->oper_class = attr[3];
+	out->channel_num = attr[4];
+	return true;
+}
+
+/* Section 4.1.10 */
+static bool extract_p2p_listen_timing(const uint8_t *attr, size_t len,
+					void *data)
+{
+	struct p2p_extended_listen_timing_attr *out = data;
+
+	if (len != 4)
+		return false;
+
+	out->avail_period_ms = l_get_le16(attr + 0);
+	out->avail_interval_ms = l_get_le16(attr + 2);
+	return true;
+}
+
+/* Section 4.1.13 */
+static bool extract_p2p_channel_list(const uint8_t *attr, size_t len,
+					void *data)
+{
+	struct p2p_channel_list_attr *out = data;
+
+	if (len < 6)
+		return false;
+
+	out->country[0] = *attr++;
+	out->country[1] = *attr++;
+	out->country[2] = *attr++;
+	len -= 3;
+
+	out->channel_entries = l_queue_new();
+
+	while (len) {
+		struct p2p_channel_entries *entries;
+
+		if (len < 2 || len < (size_t) 2 + attr[1]) {
+			l_queue_destroy(out->channel_entries, l_free);
+			out->channel_entries = NULL;
+			return false;
+		}
+
+		entries = l_malloc(sizeof(struct p2p_channel_entries) + attr[1]);
+		entries->oper_class = *attr++;
+		entries->n_channels = *attr++;
+		memcpy(entries->channels, attr, entries->n_channels);
+		l_queue_push_tail(out->channel_entries, entries);
+
+		attr += entries->n_channels;
+		len -= entries->n_channels;
+	}
+
+	return true;
+}
+
+/* Section 4.1.14 */
+static bool extract_p2p_notice_of_absence(const uint8_t *attr, size_t len,
+						void *data)
+{
+	struct p2p_notice_of_absence_attr *out = data;
+	uint8_t index;
+	uint8_t ct_window;
+	bool opp_ps;
+
+	if (len % 13 != 2)
+		return false;
+
+	index = *attr++;
+	ct_window = *attr & 127;
+	opp_ps = *attr++ >> 7;
+	len -= 2;
+
+	if (opp_ps && !ct_window)
+		return false;
+
+	out->index = index;
+	out->opp_ps = opp_ps;
+	out->ct_window = ct_window;
+	out->descriptors = l_queue_new();
+
+	while (len) {
+		struct p2p_notice_of_absence_desc *desc;
+
+		desc = l_new(struct p2p_notice_of_absence_desc, 1);
+		desc->count_type = attr[0];
+		desc->duration = l_get_le32(attr + 1);
+		desc->interval = l_get_le32(attr + 5);
+		desc->start_time = l_get_le32(attr + 9);
+		l_queue_push_tail(out->descriptors, desc);
+
+		attr += 13;
+		len -= 13;
+	}
+
+	return true;
+}
+
+/* Section 4.1.15 */
+static bool extract_p2p_device_info(const uint8_t *attr, size_t len,
+					void *data)
+{
+	struct p2p_device_info_attr *out = data;
+	int r;
+	int name_len;
+	int i;
+	int types_num;
+
+	if (len < 21)
+		return false;
+
+	memcpy(out->device_addr, attr + 0, 6);
+	out->wsc_config_methods = l_get_be16(attr + 6);
+
+	r = wsc_parse_primary_device_type(attr + 8, 8,
+						&out->primary_device_type);
+	if (r < 0)
+		return false;
+
+	types_num = attr[16];
+	if (len < 17u + types_num * 8 + 4)
+		return false;
+
+	if (l_get_be16(attr + 17 + types_num * 8) != WSC_ATTR_DEVICE_NAME)
+		return false;
+
+	name_len = l_get_be16(attr + 17 + types_num * 8 + 2);
+	if (len < 17u + types_num * 8 + 4 + name_len || name_len > 32)
+		return false;
+
+	out->secondary_device_types = l_queue_new();
+
+	for (i = 0; i < types_num; i++) {
+		struct wsc_primary_device_type *device_type =
+			l_new(struct wsc_primary_device_type, 1);
+
+		l_queue_push_tail(out->secondary_device_types, device_type);
+
+		r = wsc_parse_primary_device_type(attr + 17 + i * 8, 8,
+							device_type);
+		if (r < 0) {
+			l_queue_destroy(out->secondary_device_types, l_free);
+			out->secondary_device_types = NULL;
+			return false;
+		}
+	}
+
+	memcpy(out->device_name, attr + 17 + types_num * 8 + 4, name_len);
+
+	return true;
+}
+
+static void p2p_free_client_info_descriptor(void *data)
+{
+	struct p2p_client_info_descriptor *desc = data;
+
+	l_queue_destroy(desc->secondary_device_types, l_free);
+	l_free(desc);
+}
+
+/* Section 4.1.16 */
+static bool extract_p2p_group_info(const uint8_t *attr, size_t len,
+					void *data)
+{
+	struct l_queue **out = data;
+
+	while (len) {
+		uint8_t desc_len = *attr++;
+		struct p2p_client_info_descriptor *desc;
+		int r, name_len, i, types_num;
+
+		if (len < 1u + desc_len)
+			goto error;
+
+		if (!*out)
+			*out = l_queue_new();
+
+		desc = l_new(struct p2p_client_info_descriptor, 1);
+		l_queue_push_tail(*out, desc);
+
+		memcpy(desc->device_addr, attr + 0, 6);
+		memcpy(desc->interface_addr, attr + 6, 6);
+		desc->device_caps = attr[12];
+		desc->wsc_config_methods = l_get_be16(attr + 13);
+
+		r = wsc_parse_primary_device_type(attr + 15, 8,
+						&desc->primary_device_type);
+		if (r < 0)
+			goto error;
+
+		types_num = attr[23];
+		if (desc_len < 24 + types_num * 8 + 4)
+			goto error;
+
+		if (l_get_be16(attr + 24 + types_num * 8) !=
+				WSC_ATTR_DEVICE_NAME)
+			goto error;
+
+		name_len = l_get_be16(attr + 24 + types_num * 8 + 2);
+		if (desc_len < 24 + types_num * 8 + 4 + name_len ||
+				name_len > 32)
+			goto error;
+
+		desc->secondary_device_types = l_queue_new();
+
+		for (i = 0; i < types_num; i++) {
+			struct wsc_primary_device_type *device_type =
+				l_new(struct wsc_primary_device_type, 1);
+
+			l_queue_push_tail(desc->secondary_device_types,
+						device_type);
+
+			r = wsc_parse_primary_device_type(attr + 24 + i * 8, 8,
+								device_type);
+			if (r < 0)
+				goto error;
+		}
+
+		memcpy(desc->device_name, attr + 24 + types_num * 8 + 4,
+			name_len);
+
+		attr += 24 + types_num * 8 + 4 + name_len;
+		len -= 1 + desc_len;
+	}
+
+	return true;
+
+error:
+	l_queue_destroy(*out, p2p_free_client_info_descriptor);
+	*out = NULL;
+
+	return false;
+}
+
+/* Section 4.1.17, 4.1.29, ... */
+static bool extract_p2p_group_id(const uint8_t *attr, size_t len,
+					void *data)
+{
+	struct p2p_group_id_attr *out = data;
+
+	if (len < 6 || len > 38)
+		return false;
+
+	memcpy(out->device_addr, attr + 0, 6);
+	memcpy(out->ssid, attr + 6, len - 6);
+	return true;
+}
+
+/* Section 4.1.18 */
+static bool extract_p2p_interface(const uint8_t *attr, size_t len,
+					void *data)
+{
+	struct p2p_interface_attr *out = data;
+	int addr_count;
+
+	if (len < 7)
+		return false;
+
+	addr_count = attr[6];
+
+	if (len < 7u + addr_count * 6)
+		return false;
+
+	memcpy(out->device_addr, attr + 0, 6);
+	out->interface_addrs = l_queue_new();
+	attr += 7;
+
+	while (addr_count--) {
+		l_queue_push_tail(out->interface_addrs, l_memdup(attr, 6));
+		attr += 6;
+	}
+
+	return true;
+}
+
+/* Section 4.1.20 */
+static bool extract_p2p_invitation_flags(const uint8_t *attr, size_t len,
+						void *data)
+{
+	bool *out = data;
+
+	if (len != 1)
+		return false;
+
+	*out = attr[0] & 1; /* Invitation Type flag */
+	return true;
+}
+
+/* Section 4.1.22 */
+static bool extract_p2p_service_hashes(const uint8_t *attr, size_t len,
+					void *data)
+{
+	struct l_queue **out = data;
+
+	if (len % 6 != 0)
+		return false;
+
+	*out = l_queue_new();
+
+	while (len) {
+		l_queue_push_tail(*out, l_memdup(attr, 6));
+		attr += 6;
+		len -= 6;
+	}
+
+	return true;
+}
+
+/* Section 4.1.23 */
+static bool extract_p2p_session_info(const uint8_t *attr, size_t len,
+					void *data)
+{
+	struct p2p_session_info_data_attr *out = data;
+
+	out->data_len = len;
+	memcpy(out->data, data, len);
+	return true;
+}
+
+/* Section 4.1.25 */
+static bool extract_p2p_advertisement_id(const uint8_t *attr, size_t len,
+						void *data)
+{
+	struct p2p_advertisement_id_info_attr *out = data;
+
+	if (len != 10)
+		return false;
+
+	out->advertisement_id = l_get_le32(attr + 0);
+	memcpy(out->service_mac_addr, attr + 4, 6);
+	return true;
+}
+
+static void p2p_free_advertised_service_descriptor(void *data)
+{
+	struct p2p_advertised_service_descriptor *desc = data;
+
+	l_free(desc->service_name);
+	l_free(desc);
+}
+
+/* Section 4.1.26 */
+static bool extract_p2p_advertised_service_info(const uint8_t *attr, size_t len,
+						void *data)
+{
+	struct l_queue **out = data;
+
+	while (len) {
+		struct p2p_advertised_service_descriptor *desc;
+		int name_len;
+
+		if (len < 7)
+			goto error;
+
+		name_len = attr[6];
+		if (len < 7u + name_len)
+			goto error;
+
+		if (!l_utf8_validate((const char *) attr + 7, name_len, NULL))
+			goto error;
+
+		if (!*out)
+			*out = l_queue_new();
+
+		desc = l_new(struct p2p_advertised_service_descriptor, 1);
+		l_queue_push_tail(*out, desc);
+
+		desc->advertisement_id = l_get_le32(attr + 0);
+		desc->wsc_config_methods = l_get_be16(attr + 4);
+		desc->service_name = l_strndup((const char *) attr + 7,
+						name_len);
+
+		attr += 7 + name_len;
+		len -= 7 + name_len;
+	}
+
+	return true;
+
+error:
+	l_queue_destroy(*out, p2p_free_advertised_service_descriptor);
+	return false;
+}
+
+/* Section 4.1.27 */
+static bool extract_p2p_session_id(const uint8_t *attr, size_t len, void *data)
+{
+	struct p2p_session_id_info_attr *out = data;
+
+	if (len != 10)
+		return false;
+
+	out->session_id = l_get_le32(attr + 0);
+	memcpy(out->session_mac_addr, attr + 4, 6);
+	return true;
+}
+
+/* Section 4.1.28 */
+static bool extract_p2p_feature_capability(const uint8_t *attr, size_t len,
+						void *data)
+{
+	enum p2p_asp_coordination_transport_protocol *out = data;
+
+	if (len != 2)
+		return false;
+
+	if (attr[0] == 0x01)
+		*out = P2P_ASP_TRANSPORT_UDP;
+	else
+		*out = P2P_ASP_TRANSPORT_UNKNOWN;
+
+	return true;
+}
+
+static attr_handler handler_for_type(enum p2p_attr type)
+{
+	switch (type) {
+	case P2P_ATTR_STATUS:
+		return extract_p2p_status;
+	case P2P_ATTR_MINOR_REASON_CODE:
+		return extract_p2p_byte;
+	case P2P_ATTR_P2P_CAPABILITY:
+		return extract_p2p_capability;
+	case P2P_ATTR_P2P_DEVICE_ID:
+	case P2P_ATTR_P2P_GROUP_BSSID:
+	case P2P_ATTR_INTENDED_P2P_INTERFACE_ADDR:
+		return extract_p2p_addr;
+	case P2P_ATTR_GO_INTENT:
+		return extract_p2p_go_intent;
+	case P2P_ATTR_CONFIGURATION_TIMEOUT:
+		return extract_p2p_config_timeout;
+	case P2P_ATTR_LISTEN_CHANNEL:
+	case P2P_ATTR_OPERATING_CHANNEL:
+		return extract_p2p_channel;
+	case P2P_ATTR_EXTENDED_LISTEN_TIMING:
+		return extract_p2p_listen_timing;
+	case P2P_ATTR_P2P_MANAGEABILITY:
+		break;
+	case P2P_ATTR_CHANNEL_LIST:
+		return extract_p2p_channel_list;
+	case P2P_ATTR_NOTICE_OF_ABSENCE:
+		return extract_p2p_notice_of_absence;
+	case P2P_ATTR_P2P_DEVICE_INFO:
+		return extract_p2p_device_info;
+	case P2P_ATTR_P2P_GROUP_INFO:
+		return extract_p2p_group_info;
+	case P2P_ATTR_P2P_GROUP_ID:
+	case P2P_ATTR_PERSISTENT_GROUP_INFO:
+		return extract_p2p_group_id;
+	case P2P_ATTR_P2P_INTERFACE:
+		return extract_p2p_interface;
+	case P2P_ATTR_INVITATION_FLAGS:
+		return extract_p2p_invitation_flags;
+	case P2P_ATTR_OOB_GO_NEGOTIATION_CHANNEL:
+		break;
+	case P2P_ATTR_SVC_HASH:
+		return extract_p2p_service_hashes;
+	case P2P_ATTR_SESSION_INFO_DATA_INFO:
+		return extract_p2p_session_info;
+	case P2P_ATTR_CONNECTION_CAPABILITY_INFO:
+		return extract_p2p_byte;
+	case P2P_ATTR_ADVERTISEMENT_ID_INFO:
+		return extract_p2p_advertisement_id;
+	case P2P_ATTR_ADVERTISED_SVC_INFO:
+		return extract_p2p_advertised_service_info;
+	case P2P_ATTR_SESSION_ID_INFO:
+		return extract_p2p_session_id;
+	case P2P_ATTR_FEATURE_CAPABILITY:
+		return extract_p2p_feature_capability;
+	case P2P_ATTR_VENDOR_SPECIFIC_ATTR:
+		break;
+	}
+
+	return NULL;
+}
+
+struct attr_handler_entry {
+	enum p2p_attr type;
+	unsigned int flags;
+	void *data;
+	bool present;
+};
+
+/*
+ * This function may find an error after having parsed part of the message
+ * and may have allocated memory so the output needs to be deallocated
+ * properly even on error return values.
+ */
+static int p2p_parse_attrs(const uint8_t *pdu, size_t len, int type, ...)
+{
+	struct p2p_attr_iter iter;
+	uint8_t *p2p_data;
+	ssize_t p2p_len;
+	struct l_queue *entries;
+	va_list args;
+	bool have_required = true;
+	bool parse_error = false;
+	struct attr_handler_entry *entry;
+	const struct l_queue_entry *e;
+
+	p2p_data = ie_tlv_extract_p2p_payload(pdu, len, &p2p_len);
+	if (!p2p_data)
+		return p2p_len;
+
+	p2p_attr_iter_init(&iter, p2p_data, p2p_len);
+
+	va_start(args, type);
+
+	entries = l_queue_new();
+
+	while (type != -1) {
+		entry = l_new(struct attr_handler_entry, 1);
+
+		entry->type = type;
+		entry->flags = va_arg(args, unsigned int);
+		entry->data = va_arg(args, void *);
+
+		type = va_arg(args, enum p2p_attr);
+		l_queue_push_tail(entries, entry);
+	}
+
+	va_end(args);
+
+	while (p2p_attr_iter_next(&iter)) {
+		attr_handler handler;
+
+		for (e = l_queue_get_entries(entries); e; e = e->next) {
+			entry = e->data;
+
+			if (p2p_attr_iter_get_type(&iter) == entry->type)
+				break;
+		}
+
+		if (!e || entry->present) {
+			parse_error = true;
+			goto done;
+		}
+
+		entry->present = true;
+		handler = handler_for_type(entry->type);
+
+		if (!handler(p2p_attr_iter_get_data(&iter),
+				p2p_attr_iter_get_length(&iter), entry->data)) {
+			parse_error = true;
+			goto done;
+		}
+	}
+
+	for (e = l_queue_get_entries(entries); e; e = e->next) {
+		entry = e->data;
+
+		if (!entry->present && (entry->flags & ATTR_FLAG_REQUIRED)) {
+			parse_error = true;
+			goto done;
+		}
+	}
+
+done:
+	l_free(p2p_data);
+	l_queue_destroy(entries, l_free);
+
+	if (!have_required)
+		return -EINVAL;
+	if (parse_error)
+		return -EBADMSG;
+
+	return 0;
+}
+
+#define REQUIRED(attr, out) \
+	P2P_ATTR_ ## attr, ATTR_FLAG_REQUIRED, out
+
+#define OPTIONAL(attr, out) \
+	P2P_ATTR_ ## attr, 0, out
+
+/* Section 4.2.1 */
+int p2p_parse_beacon(const uint8_t *pdu, size_t len, struct p2p_beacon *out)
+{
+	struct p2p_beacon d = {};
+	int r;
+
+	r = p2p_parse_attrs(pdu, len,
+			REQUIRED(P2P_CAPABILITY, &d.capability),
+			REQUIRED(P2P_DEVICE_ID, &d.device_addr),
+			OPTIONAL(NOTICE_OF_ABSENCE, &d.notice_of_absence),
+			-1);
+
+	if (r >= 0)
+		memcpy(out, &d, sizeof(d));
+	else
+		p2p_free_beacon(&d);
+
+	return r;
+}
+
+/* Section 4.2.2 */
+int p2p_parse_probe_req(const uint8_t *pdu, size_t len,
+			struct p2p_probe_req *out)
+{
+	struct p2p_probe_req d = {};
+	int r;
+
+	r = p2p_parse_attrs(pdu, len,
+			REQUIRED(P2P_CAPABILITY, &d.capability),
+			OPTIONAL(P2P_DEVICE_ID, &d.device_addr),
+			OPTIONAL(LISTEN_CHANNEL, &d.listen_channel),
+			OPTIONAL(EXTENDED_LISTEN_TIMING,
+					&d.listen_availability),
+			OPTIONAL(P2P_DEVICE_INFO, &d.device_info),
+			OPTIONAL(OPERATING_CHANNEL, &d.operating_channel),
+			OPTIONAL(SVC_HASH, &d.service_hashes),
+			-1);
+
+	if (r >= 0)
+		memcpy(out, &d, sizeof(d));
+	else
+		p2p_free_probe_req(&d);
+
+	/*
+	 * The additional WSC IE attributes are already covered by
+	 * wsc_parse_probe_request.
+	 */
+
+	return r;
+}
+
+/* Section 4.2.3 */
+int p2p_parse_probe_resp(const uint8_t *pdu, size_t len,
+				struct p2p_probe_resp *out)
+{
+	struct p2p_probe_resp d = {};
+	int r;
+
+	r = p2p_parse_attrs(pdu, len,
+			REQUIRED(P2P_CAPABILITY, &d.capability),
+			OPTIONAL(EXTENDED_LISTEN_TIMING,
+					&d.listen_availability),
+			OPTIONAL(NOTICE_OF_ABSENCE, &d.notice_of_absence),
+			REQUIRED(P2P_DEVICE_INFO, &d.device_info),
+			OPTIONAL(P2P_GROUP_INFO, &d.group_clients),
+			OPTIONAL(ADVERTISED_SVC_INFO, &d.advertised_svcs),
+			-1);
+
+	if (r >= 0)
+		memcpy(out, &d, sizeof(d));
+	else
+		p2p_free_probe_resp(&d);
+
+	return r;
+}
+
+/* Section 4.2.4 */
+int p2p_parse_association_req(const uint8_t *pdu, size_t len,
+				struct p2p_association_req *out)
+{
+	struct p2p_association_req d = {};
+	int r;
+
+	r = p2p_parse_attrs(pdu, len,
+			REQUIRED(P2P_CAPABILITY, &d.capability),
+			OPTIONAL(EXTENDED_LISTEN_TIMING,
+					&d.listen_availability),
+			OPTIONAL(P2P_DEVICE_INFO, &d.device_info),
+			OPTIONAL(P2P_INTERFACE, &d.interface),
+			-1);
+
+	if (r >= 0)
+		memcpy(out, &d, sizeof(d));
+	else
+		p2p_free_association_req(&d);
+
+	return r;
+}
+
+/* Section 4.2.5 */
+int p2p_parse_association_resp(const uint8_t *pdu, size_t len,
+				struct p2p_association_resp *out)
+{
+	struct p2p_association_resp d = {};
+	int r;
+
+	r = p2p_parse_attrs(pdu, len,
+			OPTIONAL(STATUS, &d.status),
+			OPTIONAL(EXTENDED_LISTEN_TIMING,
+					&d.listen_availability),
+			-1);
+
+	if (r >= 0)
+		memcpy(out, &d, sizeof(d));
+
+	return r;
+}
+
+/* Section 4.2.6 */
+int p2p_parse_deauthentication(const uint8_t *pdu, size_t len,
+				struct p2p_deauthentication *out)
+{
+	int r;
+	uint8_t reason = 0;
+
+	r = p2p_parse_attrs(pdu, len,
+			REQUIRED(MINOR_REASON_CODE, &reason),
+			-1);
+
+	/* The P2P IE is optional */
+	if (r < 0 && r != -ENOENT)
+		return r;
+
+	out->minor_reason_code = reason;
+	return 0;
+}
+
+/* Section 4.2.7 */
+int p2p_parse_disassociation(const uint8_t *pdu, size_t len,
+				struct p2p_disassociation *out)
+{
+	int r;
+	uint8_t reason = 0;
+
+	r = p2p_parse_attrs(pdu, len,
+			REQUIRED(MINOR_REASON_CODE, &reason),
+			-1);
+
+	/* The P2P IE is optional */
+	if (r < 0 && r != -ENOENT)
+		return r;
+
+	out->minor_reason_code = reason;
+	return 0;
+}
+
+#define WSC_REQUIRED(attr, out) \
+	WSC_ATTR_ ## attr, WSC_ATTR_FLAG_REQUIRED, out
+
+#define WSC_OPTIONAL(attr, out) \
+	WSC_ATTR_ ## attr, 0, out
+
+/* Section 4.2.9.2 */
+int p2p_parse_go_negotiation_req(const uint8_t *pdu, size_t len,
+					struct p2p_go_negotiation_req *out)
+{
+	struct p2p_go_negotiation_req d = {};
+	int r;
+	struct p2p_go_intent_attr go_intent;
+	uint8_t *wsc_data;
+	ssize_t wsc_len;
+	uint8_t wsc_version;
+
+	if (len < 1)
+		return -EINVAL;
+
+	d.dialog_token = pdu[0];
+	if (d.dialog_token == 0)
+		return -EINVAL;
+
+	r = p2p_parse_attrs(pdu + 1, len - 1,
+			REQUIRED(P2P_CAPABILITY, &d.capability),
+			REQUIRED(GO_INTENT, &go_intent),
+			REQUIRED(CONFIGURATION_TIMEOUT, &d.config_timeout),
+			REQUIRED(LISTEN_CHANNEL, &d.listen_channel),
+			OPTIONAL(EXTENDED_LISTEN_TIMING,
+					&d.listen_availability),
+			REQUIRED(INTENDED_P2P_INTERFACE_ADDR,
+					&d.intended_interface_addr),
+			REQUIRED(CHANNEL_LIST, &d.channel_list),
+			REQUIRED(P2P_DEVICE_INFO, &d.device_info),
+			REQUIRED(OPERATING_CHANNEL, &d.operating_channel),
+			-1);
+	if (r < 0)
+		goto error;
+
+	wsc_data = ie_tlv_extract_wsc_payload(pdu + 1, len - 1, &wsc_len);
+	if (!wsc_data) {
+		r = wsc_len;
+		goto error;
+	}
+
+	r = wsc_parse_attrs(wsc_data, wsc_len, NULL, NULL, 0, NULL,
+			WSC_REQUIRED(VERSION, &wsc_version),
+			WSC_REQUIRED(DEVICE_PASSWORD_ID, &d.device_password_id),
+			WSC_ATTR_INVALID);
+	l_free(wsc_data);
+
+	if (r < 0)
+		goto error;
+
+	d.go_intent = go_intent.intent;
+	d.go_tie_breaker = go_intent.tie_breaker;
+
+	memcpy(out, &d, sizeof(d));
+	return 0;
+
+error:
+	p2p_free_go_negotiation_req(&d);
+	return r;
+}
+
+/* Section 4.2.9.3 */
+int p2p_parse_go_negotiation_resp(const uint8_t *pdu, size_t len,
+					struct p2p_go_negotiation_resp *out)
+{
+	struct p2p_go_negotiation_resp d = {};
+	int r;
+	struct p2p_go_intent_attr go_intent;
+	uint8_t *wsc_data;
+	ssize_t wsc_len;
+	uint8_t wsc_version;
+
+	if (len < 1)
+		return -EINVAL;
+
+	d.dialog_token = pdu[0];
+	if (d.dialog_token == 0)
+		return -EINVAL;
+
+	r = p2p_parse_attrs(pdu + 1, len - 1,
+			REQUIRED(STATUS, &d.status),
+			REQUIRED(P2P_CAPABILITY, &d.capability),
+			REQUIRED(GO_INTENT, &go_intent),
+			REQUIRED(CONFIGURATION_TIMEOUT, &d.config_timeout),
+			OPTIONAL(OPERATING_CHANNEL, &d.operating_channel),
+			REQUIRED(INTENDED_P2P_INTERFACE_ADDR,
+					&d.intended_interface_addr),
+			REQUIRED(CHANNEL_LIST, &d.channel_list),
+			REQUIRED(P2P_DEVICE_INFO, &d.device_info),
+			OPTIONAL(P2P_GROUP_ID, &d.group_id),
+			-1);
+	if (r < 0)
+		goto error;
+
+	wsc_data = ie_tlv_extract_wsc_payload(pdu + 1, len - 1, &wsc_len);
+	if (!wsc_data) {
+		r = wsc_len;
+		goto error;
+	}
+
+	r = wsc_parse_attrs(wsc_data, wsc_len, NULL, NULL, 0, NULL,
+			WSC_REQUIRED(VERSION, &wsc_version),
+			WSC_REQUIRED(DEVICE_PASSWORD_ID, &d.device_password_id),
+			WSC_ATTR_INVALID);
+	l_free(wsc_data);
+
+	if (r < 0)
+		goto error;
+
+	d.go_intent = go_intent.intent;
+	d.go_tie_breaker = go_intent.tie_breaker;
+
+	memcpy(out, &d, sizeof(d));
+	return 0;
+
+error:
+	p2p_free_go_negotiation_resp(&d);
+	return r;
+}
+
+/* Section 4.2.9.4 */
+int p2p_parse_go_negotiation_confirmation(const uint8_t *pdu, size_t len,
+				struct p2p_go_negotiation_confirmation *out)
+{
+	struct p2p_go_negotiation_confirmation d = {};
+	int r;
+
+	if (len < 1)
+		return -EINVAL;
+
+	d.dialog_token = pdu[0];
+	if (d.dialog_token == 0)
+		return -EINVAL;
+
+	r = p2p_parse_attrs(pdu + 1, len - 1,
+			REQUIRED(STATUS, &d.status),
+			REQUIRED(P2P_CAPABILITY, &d.capability),
+			REQUIRED(OPERATING_CHANNEL, &d.operating_channel),
+			REQUIRED(CHANNEL_LIST, &d.channel_list),
+			OPTIONAL(P2P_GROUP_ID, &d.group_id),
+			-1);
+
+	if (r >= 0)
+		memcpy(out, &d, sizeof(d));
+	else
+		p2p_free_go_negotiation_confirmation(&d);
+
+	return r;
+}
+
+/* Section 4.2.9.5 */
+int p2p_parse_invitation_req(const uint8_t *pdu, size_t len,
+				struct p2p_invitation_req *out)
+{
+	struct p2p_invitation_req d = {};
+	int r;
+	uint8_t *wsc_data;
+	ssize_t wsc_len;
+	bool wsc_version2;
+
+	if (len < 1)
+		return -EINVAL;
+
+	d.dialog_token = pdu[0];
+	if (d.dialog_token == 0)
+		return -EINVAL;
+
+	r = p2p_parse_attrs(pdu + 1, len - 1,
+			REQUIRED(CONFIGURATION_TIMEOUT, &d.config_timeout),
+			REQUIRED(INVITATION_FLAGS,
+					&d.reinvoke_persistent_group),
+			OPTIONAL(OPERATING_CHANNEL, &d.operating_channel),
+			OPTIONAL(P2P_GROUP_BSSID, &d.group_bssid),
+			REQUIRED(CHANNEL_LIST, &d.channel_list),
+			REQUIRED(P2P_GROUP_ID, &d.group_id),
+			REQUIRED(P2P_DEVICE_INFO, &d.device_info),
+			-1);
+	if (r < 0)
+		goto done;
+
+	/* A WSC IE is optional */
+	wsc_data = ie_tlv_extract_wsc_payload(pdu + 1, len - 1, &wsc_len);
+	if (!wsc_data)
+		goto done;
+
+	r = wsc_parse_attrs(wsc_data, wsc_len, &wsc_version2, NULL, 0, NULL,
+			WSC_REQUIRED(DEVICE_PASSWORD_ID, &d.device_password_id),
+			WSC_ATTR_INVALID);
+	l_free(wsc_data);
+
+	if (r >= 0 && !wsc_version2)
+		r = -EINVAL;
+
+done:
+	if (r >= 0)
+		memcpy(out, &d, sizeof(d));
+	else
+		p2p_free_invitation_req(&d);
+
+	return r;
+}
+
+/* Section 4.2.9.6 */
+int p2p_parse_invitation_resp(const uint8_t *pdu, size_t len,
+				struct p2p_invitation_resp *out)
+{
+	struct p2p_invitation_resp d = {};
+	int r;
+
+	if (len < 1)
+		return -EINVAL;
+
+	d.dialog_token = pdu[0];
+	if (d.dialog_token == 0)
+		return -EINVAL;
+
+	r = p2p_parse_attrs(pdu + 1, len - 1,
+			REQUIRED(STATUS, &d.status),
+			REQUIRED(CONFIGURATION_TIMEOUT, &d.config_timeout),
+			OPTIONAL(OPERATING_CHANNEL, &d.operating_channel),
+			OPTIONAL(P2P_GROUP_BSSID, &d.group_bssid),
+			OPTIONAL(CHANNEL_LIST, &d.channel_list),
+			-1);
+
+	if (r >= 0)
+		memcpy(out, &d, sizeof(d));
+	else
+		p2p_free_invitation_resp(&d);
+
+	return r;
+}
+
+/* Section 4.2.9.7 */
+int p2p_parse_device_disc_req(const uint8_t *pdu, size_t len,
+				struct p2p_device_discoverability_req *out)
+{
+	struct p2p_device_discoverability_req d = {};
+	int r;
+
+	if (len < 1)
+		return -EINVAL;
+
+	d.dialog_token = pdu[0];
+	if (d.dialog_token == 0)
+		return -EINVAL;
+
+	r = p2p_parse_attrs(pdu + 1, len - 1,
+			REQUIRED(P2P_DEVICE_ID, &d.device_addr),
+			REQUIRED(P2P_GROUP_ID, &d.group_id),
+			-1);
+
+	if (r >= 0)
+		memcpy(out, &d, sizeof(d));
+
+	return r;
+}
+
+/* Section 4.2.9.8 */
+int p2p_parse_device_disc_resp(const uint8_t *pdu, size_t len,
+				struct p2p_device_discoverability_resp *out)
+{
+	struct p2p_device_discoverability_resp d = {};
+	int r;
+
+	if (len < 1)
+		return -EINVAL;
+
+	d.dialog_token = pdu[0];
+	if (d.dialog_token == 0)
+		return -EINVAL;
+
+	r = p2p_parse_attrs(pdu + 1, len - 1,
+			REQUIRED(STATUS, &d.status),
+			-1);
+
+	if (r >= 0)
+		memcpy(out, &d, sizeof(d));
+
+	return r;
+}
+
+/* Section 4.2.9.9 */
+int p2p_parse_provision_disc_req(const uint8_t *pdu, size_t len,
+				struct p2p_provision_discovery_req *out)
+{
+	struct p2p_provision_discovery_req d = {};
+	int r;
+	uint8_t *wsc_data;
+	ssize_t wsc_len;
+
+	if (len < 1)
+		return -EINVAL;
+
+	d.status = -1;
+
+	d.dialog_token = pdu[0];
+	if (d.dialog_token == 0)
+		return -EINVAL;
+
+	r = p2p_parse_attrs(pdu + 1, len - 1,
+			REQUIRED(P2P_CAPABILITY, &d.capability),
+			REQUIRED(P2P_DEVICE_INFO, &d.device_info),
+			OPTIONAL(P2P_GROUP_ID, &d.group_id),
+			OPTIONAL(INTENDED_P2P_INTERFACE_ADDR,
+					&d.intended_interface_addr),
+			OPTIONAL(STATUS, &d.status),
+			OPTIONAL(OPERATING_CHANNEL, &d.operating_channel),
+			OPTIONAL(CHANNEL_LIST, &d.channel_list),
+			OPTIONAL(SESSION_INFO_DATA_INFO, &d.session_info),
+			OPTIONAL(CONNECTION_CAPABILITY_INFO,
+					&d.connection_capability),
+			OPTIONAL(ADVERTISEMENT_ID_INFO, &d.advertisement_id),
+			OPTIONAL(CONFIGURATION_TIMEOUT, &d.config_timeout),
+			OPTIONAL(LISTEN_CHANNEL, &d.listen_channel),
+			OPTIONAL(SESSION_ID_INFO, &d.session_id),
+			OPTIONAL(FEATURE_CAPABILITY, &d.transport_protocol),
+			OPTIONAL(PERSISTENT_GROUP_INFO,
+					&d.persistent_group_info),
+			-1);
+	if (r < 0)
+		goto error;
+
+	wsc_data = ie_tlv_extract_wsc_payload(pdu + 1, len - 1, &wsc_len);
+	if (wsc_len < 0) {
+		r = wsc_len;
+		goto error;
+	}
+
+	r = wsc_parse_attrs(wsc_data, wsc_len, NULL, NULL, 0, NULL,
+			WSC_REQUIRED(CONFIGURATION_METHODS,
+					&d.wsc_config_method),
+			WSC_ATTR_INVALID);
+	l_free(wsc_data);
+
+	if (r < 0)
+		goto error;
+
+	/*
+	 * 4.2.9.9: "A single method shall be set in the Config Methods
+	 * attribute."
+	 */
+	if (__builtin_popcount(d.wsc_config_method) != 1) {
+		r = -EINVAL;
+		goto error;
+	}
+
+	memcpy(out, &d, sizeof(d));
+	return 0;
+
+error:
+	p2p_free_provision_disc_req(&d);
+	return r;
+}
+
+/* Section 4.2.9.10 */
+int p2p_parse_provision_disc_resp(const uint8_t *pdu, size_t len,
+				struct p2p_provision_discovery_resp *out)
+{
+	struct p2p_provision_discovery_resp d = {};
+	int r;
+	uint8_t *wsc_data;
+	ssize_t wsc_len;
+
+	if (len < 1)
+		return -EINVAL;
+
+	d.status = -1;
+
+	d.dialog_token = pdu[0];
+	if (d.dialog_token == 0)
+		return -EINVAL;
+
+	/*
+	 * The P2P IE is optional but, if present, some of the attributes
+	 * are required for this frame type.
+	 */
+	r = p2p_parse_attrs(pdu + 1, len - 1,
+			REQUIRED(STATUS, &d.status),
+			REQUIRED(P2P_CAPABILITY, &d.capability),
+			REQUIRED(P2P_DEVICE_INFO, &d.device_info),
+			OPTIONAL(P2P_GROUP_ID, &d.group_id),
+			OPTIONAL(INTENDED_P2P_INTERFACE_ADDR,
+					&d.intended_interface_addr),
+			OPTIONAL(OPERATING_CHANNEL, &d.operating_channel),
+			OPTIONAL(CHANNEL_LIST, &d.channel_list),
+			OPTIONAL(CONNECTION_CAPABILITY_INFO,
+					&d.connection_capability),
+			REQUIRED(ADVERTISEMENT_ID_INFO, &d.advertisement_id),
+			OPTIONAL(CONFIGURATION_TIMEOUT, &d.config_timeout),
+			REQUIRED(SESSION_ID_INFO, &d.session_id),
+			REQUIRED(FEATURE_CAPABILITY, &d.transport_protocol),
+			OPTIONAL(PERSISTENT_GROUP_INFO,
+					&d.persistent_group_info),
+			REQUIRED(SESSION_INFO_DATA_INFO, &d.session_info),
+			-1);
+	if (r < 0 && r != -ENOENT)
+		goto error;
+
+	wsc_data = ie_tlv_extract_wsc_payload(pdu + 1, len - 1, &wsc_len);
+	if (wsc_len < 0) {
+		r = wsc_len;
+		goto error;
+	}
+
+	r = wsc_parse_attrs(wsc_data, wsc_len, NULL, NULL, 0, NULL,
+			WSC_REQUIRED(CONFIGURATION_METHODS,
+					&d.wsc_config_method),
+			WSC_ATTR_INVALID);
+	l_free(wsc_data);
+
+	if (r < 0)
+		goto error;
+
+	/*
+	 * 4.2.9.10: "The value of the Config Methods attribute shall be
+	 * set to the same value received in the Provision Discovery
+	 * Request frame to indicate success or shall be null to indicate
+	 * failure of the request."
+	 */
+	if (__builtin_popcount(d.wsc_config_method) > 1) {
+		r = -EINVAL;
+		goto error;
+	}
+
+	memcpy(out, &d, sizeof(d));
+	return 0;
+
+error:
+	p2p_free_provision_disc_resp(&d);
+	return r;
+}
+
+/* Section 4.2.10.2 */
+int p2p_parse_notice_of_absence(const uint8_t *pdu, size_t len,
+				struct p2p_notice_of_absence *out)
+{
+	struct p2p_notice_of_absence d = {};
+	int r;
+
+	if (len < 1)
+		return -EINVAL;
+
+	r = p2p_parse_attrs(pdu + 1, len - 1,
+			REQUIRED(NOTICE_OF_ABSENCE, &d.notice_of_absence),
+			-1);
+
+	if (r >= 0)
+		memcpy(out, &d, sizeof(d));
+	else
+		p2p_free_notice_of_absence(&d);
+
+	return r;
+}
+
+/* Section 4.2.10.3 */
+int p2p_parse_presence_req(const uint8_t *pdu, size_t len,
+				struct p2p_presence_req *out)
+{
+	struct p2p_presence_req d = {};
+	int r;
+
+	if (len < 1)
+		return -EINVAL;
+
+	d.dialog_token = pdu[0];
+	if (d.dialog_token == 0)
+		return -EINVAL;
+
+	r = p2p_parse_attrs(pdu + 1, len - 1,
+			REQUIRED(NOTICE_OF_ABSENCE, &d.notice_of_absence),
+			-1);
+
+	if (r >= 0)
+		memcpy(out, &d, sizeof(d));
+	else
+		p2p_free_presence_req(&d);
+
+	return r;
+}
+
+/* Section 4.2.10.4 */
+int p2p_parse_presence_resp(const uint8_t *pdu, size_t len,
+				struct p2p_presence_resp *out)
+{
+	struct p2p_presence_resp d = {};
+	int r;
+
+	if (len < 1)
+		return -EINVAL;
+
+	d.dialog_token = pdu[0];
+	if (d.dialog_token == 0)
+		return -EINVAL;
+
+	r = p2p_parse_attrs(pdu + 1, len - 1,
+			REQUIRED(STATUS, &d.status),
+			REQUIRED(NOTICE_OF_ABSENCE, &d.notice_of_absence),
+			-1);
+
+	if (r >= 0)
+		memcpy(out, &d, sizeof(d));
+	else
+		p2p_free_presence_resp(&d);
+
+	return r;
+}
+
+/* Section 4.2.10.5 */
+int p2p_parse_go_disc_req(const uint8_t *pdu, size_t len)
+{
+	if (len != 1 || pdu[0] != 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+static void p2p_free_channel_list_attr(struct p2p_channel_list_attr *attr)
+{
+	l_queue_destroy(attr->channel_entries, l_free);
+	attr->channel_entries = NULL;
+}
+
+static void p2p_free_notice_of_absence_attr(
+					struct p2p_notice_of_absence_attr *attr)
+{
+	l_queue_destroy(attr->descriptors, l_free);
+	attr->descriptors = NULL;
+}
+
+static void p2p_free_device_info_attr(struct p2p_device_info_attr *attr)
+{
+	l_queue_destroy(attr->secondary_device_types, l_free);
+	attr->secondary_device_types = NULL;
+}
+
+static void p2p_free_group_info_attr(struct l_queue **group_clients)
+{
+	l_queue_destroy(*group_clients, p2p_free_client_info_descriptor);
+	*group_clients = NULL;
+}
+
+static void p2p_free_interface_attr(struct p2p_interface_attr *attr)
+{
+	l_queue_destroy(attr->interface_addrs, l_free);
+	attr->interface_addrs = NULL;
+}
+
+static void p2p_free_svc_hash_attr(struct l_queue **hashes)
+{
+	l_queue_destroy(*hashes, l_free);
+	*hashes = NULL;
+}
+
+static void p2p_free_advertised_service_info_attr(struct l_queue **descriptors)
+{
+	l_queue_destroy(*descriptors, p2p_free_advertised_service_descriptor);
+	*descriptors = NULL;
+}
+
+void p2p_free_beacon(struct p2p_beacon *data)
+{
+	p2p_free_notice_of_absence_attr(&data->notice_of_absence);
+}
+
+void p2p_free_probe_req(struct p2p_probe_req *data)
+{
+	p2p_free_device_info_attr(&data->device_info);
+	p2p_free_svc_hash_attr(&data->service_hashes);
+}
+
+void p2p_free_probe_resp(struct p2p_probe_resp *data)
+{
+	p2p_free_notice_of_absence_attr(&data->notice_of_absence);
+	p2p_free_device_info_attr(&data->device_info);
+	p2p_free_group_info_attr(&data->group_clients);
+	p2p_free_advertised_service_info_attr(&data->advertised_svcs);
+}
+
+void p2p_free_association_req(struct p2p_association_req *data)
+{
+	p2p_free_device_info_attr(&data->device_info);
+	p2p_free_interface_attr(&data->interface);
+}
+
+void p2p_free_association_resp(struct p2p_association_resp *data)
+{
+}
+
+void p2p_free_go_negotiation_req(struct p2p_go_negotiation_req *data)
+{
+	p2p_free_channel_list_attr(&data->channel_list);
+	p2p_free_device_info_attr(&data->device_info);
+}
+
+void p2p_free_go_negotiation_resp(struct p2p_go_negotiation_resp *data)
+{
+	p2p_free_channel_list_attr(&data->channel_list);
+	p2p_free_device_info_attr(&data->device_info);
+}
+
+void p2p_free_go_negotiation_confirmation(
+				struct p2p_go_negotiation_confirmation *data)
+{
+	p2p_free_channel_list_attr(&data->channel_list);
+}
+
+void p2p_free_invitation_req(struct p2p_invitation_req *data)
+{
+	p2p_free_channel_list_attr(&data->channel_list);
+	p2p_free_device_info_attr(&data->device_info);
+}
+
+void p2p_free_invitation_resp(struct p2p_invitation_resp *data)
+{
+	p2p_free_channel_list_attr(&data->channel_list);
+}
+
+void p2p_free_provision_disc_req(struct p2p_provision_discovery_req *data)
+{
+	p2p_free_channel_list_attr(&data->channel_list);
+	p2p_free_device_info_attr(&data->device_info);
+}
+
+void p2p_free_provision_disc_resp(struct p2p_provision_discovery_resp *data)
+{
+	p2p_free_channel_list_attr(&data->channel_list);
+	p2p_free_device_info_attr(&data->device_info);
+}
+
+void p2p_free_notice_of_absence(struct p2p_notice_of_absence *data)
+{
+	p2p_free_notice_of_absence_attr(&data->notice_of_absence);
+}
+
+void p2p_free_presence_req(struct p2p_presence_req *data)
+{
+	p2p_free_notice_of_absence_attr(&data->notice_of_absence);
+}
+
+void p2p_free_presence_resp(struct p2p_presence_resp *data)
+{
+	p2p_free_notice_of_absence_attr(&data->notice_of_absence);
+}
+
+struct p2p_attr_builder {
+	size_t capacity;
+	uint8_t *buf;
+	uint16_t offset;
+	uint16_t curlen;
+};
+
+static void p2p_attr_builder_grow(struct p2p_attr_builder *builder)
+{
+	builder->buf = l_realloc(builder->buf, builder->capacity * 2);
+	builder->capacity *= 2;
+}
+
+/* Section 4.1.1 */
+static void p2p_attr_builder_start_attr(struct p2p_attr_builder *builder,
+					enum p2p_attr type)
+{
+	/* Record previous attribute's length */
+	if (builder->curlen || builder->offset) {
+		l_put_le16(builder->curlen, builder->buf + builder->offset + 1);
+		builder->offset += 3 + builder->curlen;
+		builder->curlen = 0;
+	}
+
+	if (builder->offset + 3u >= builder->capacity)
+		p2p_attr_builder_grow(builder);
+
+	builder->buf[builder->offset] = type;
+}
+
+static void p2p_attr_builder_put_u8(struct p2p_attr_builder *builder, uint8_t v)
+{
+	if (builder->offset + 3u + builder->curlen + 1u >= builder->capacity)
+		p2p_attr_builder_grow(builder);
+
+	builder->buf[builder->offset + 3 + builder->curlen] = v;
+	builder->curlen += 1;
+}
+
+static void p2p_attr_builder_put_u16(struct p2p_attr_builder *builder,
+					uint16_t v)
+{
+	if (builder->offset + 3u + builder->curlen + 2u >= builder->capacity)
+		p2p_attr_builder_grow(builder);
+
+	l_put_le16(v, builder->buf + builder->offset + 3 + builder->curlen);
+	builder->curlen += 2;
+}
+
+static void p2p_attr_builder_put_be16(struct p2p_attr_builder *builder,
+					uint16_t v)
+{
+	if (builder->offset + 3u + builder->curlen + 2u >= builder->capacity)
+		p2p_attr_builder_grow(builder);
+
+	l_put_be16(v, builder->buf + builder->offset + 3 + builder->curlen);
+	builder->curlen += 2;
+}
+
+static void p2p_attr_builder_put_u32(struct p2p_attr_builder *builder,
+					uint32_t v)
+{
+	if (builder->offset + 3u + builder->curlen + 4u >= builder->capacity)
+		p2p_attr_builder_grow(builder);
+
+	l_put_le32(v, builder->buf + builder->offset + 3 + builder->curlen);
+	builder->curlen += 4;
+}
+
+static void p2p_attr_builder_put_bytes(struct p2p_attr_builder *builder,
+					const void *bytes, size_t size)
+{
+	while (builder->offset + 3u + builder->curlen + size >=
+			builder->capacity)
+		p2p_attr_builder_grow(builder);
+
+	memcpy(builder->buf + builder->offset + 3 + builder->curlen,
+		bytes, size);
+	builder->curlen += size;
+}
+
+static void p2p_attr_builder_put_oui(struct p2p_attr_builder *builder,
+					const uint8_t *oui)
+{
+	if (builder->offset + 3u + builder->curlen + 3u >= builder->capacity)
+		p2p_attr_builder_grow(builder);
+
+	memcpy(builder->buf + builder->offset + 3 + builder->curlen, oui, 3);
+	builder->curlen += 3;
+}
+
+static struct p2p_attr_builder *p2p_attr_builder_new(size_t initial_capacity)
+{
+	struct p2p_attr_builder *builder;
+
+	if (initial_capacity == 0)
+		return NULL;
+
+	builder = l_new(struct p2p_attr_builder, 1);
+	builder->buf = l_malloc(initial_capacity);
+	builder->capacity = initial_capacity;
+
+	return builder;
+}
+
+static uint8_t *p2p_attr_builder_free(struct p2p_attr_builder *builder,
+					bool free_contents, size_t *out_size)
+{
+	uint8_t *ret;
+
+	if (builder->curlen > 0 || builder->offset) {
+		l_put_le16(builder->curlen, builder->buf + builder->offset + 1);
+		builder->offset += 3 + builder->curlen;
+	}
+
+	if (free_contents) {
+		l_free(builder->buf);
+		ret = NULL;
+	} else
+		ret = builder->buf;
+
+	if (out_size)
+		*out_size = builder->offset;
+
+	l_free(builder);
+
+	return ret;
+}
+
+static void p2p_build_u8_attr(struct p2p_attr_builder *builder,
+				enum p2p_attr type, uint8_t value)
+{
+	p2p_attr_builder_start_attr(builder, type);
+	p2p_attr_builder_put_u8(builder, value);
+}
+
+/* Section 4.1.4 */
+static void p2p_build_capability(struct p2p_attr_builder *builder,
+					const struct p2p_capability_attr *attr)
+{
+	/* Always required */
+	p2p_attr_builder_start_attr(builder, P2P_ATTR_P2P_CAPABILITY);
+	p2p_attr_builder_put_u8(builder, attr->device_caps);
+	p2p_attr_builder_put_u8(builder, attr->group_caps);
+}
+
+static const uint8_t zero_addr[6];
+
+/* Section 4.1.5, 4.1.9, 4.1.11, ... */
+static void p2p_build_addr(struct p2p_attr_builder *builder, bool optional,
+				enum p2p_attr type, const uint8_t *addr)
+{
+	if (optional && !memcmp(addr, zero_addr, 6))
+		return;
+
+	p2p_attr_builder_start_attr(builder, type);
+	p2p_attr_builder_put_bytes(builder, addr, 6);
+}
+
+/* Section 4.1.6 */
+static void p2p_build_go_intent(struct p2p_attr_builder *builder,
+				uint8_t intent, bool tie_breaker)
+{
+	/* Always required */
+	p2p_attr_builder_start_attr(builder, P2P_ATTR_GO_INTENT);
+	p2p_attr_builder_put_u8(builder, tie_breaker | (intent << 1));
+}
+
+/* Section 4.1.7 */
+static void p2p_build_config_timeout(struct p2p_attr_builder *builder,
+				bool optional,
+				const struct p2p_config_timeout_attr *attr)
+{
+	if (optional && !attr->go_config_timeout &&
+			!attr->client_config_timeout)
+		return;
+
+	p2p_attr_builder_start_attr(builder, P2P_ATTR_CONFIGURATION_TIMEOUT);
+	p2p_attr_builder_put_u8(builder, attr->go_config_timeout);
+	p2p_attr_builder_put_u8(builder, attr->client_config_timeout);
+}
+
+/* Section 4.1.8, 4.1.19, ... */
+static void p2p_build_channel(struct p2p_attr_builder *builder, bool optional,
+				enum p2p_attr type,
+				const struct p2p_channel_attr *attr)
+{
+	if (optional && !attr->country[0])
+		return;
+
+	p2p_attr_builder_start_attr(builder, type);
+	p2p_attr_builder_put_bytes(builder, attr->country, 3);
+	p2p_attr_builder_put_u8(builder, attr->oper_class);
+	p2p_attr_builder_put_u8(builder, attr->channel_num);
+}
+
+/* Section 4.1.10 */
+static void p2p_build_extended_listen_timing(struct p2p_attr_builder *builder,
+			const struct p2p_extended_listen_timing_attr *attr)
+{
+	/* Always optional */
+	if (!attr->avail_period_ms && !attr->avail_interval_ms)
+		return;
+
+	p2p_attr_builder_start_attr(builder, P2P_ATTR_EXTENDED_LISTEN_TIMING);
+	p2p_attr_builder_put_u16(builder, attr->avail_period_ms);
+	p2p_attr_builder_put_u16(builder, attr->avail_interval_ms);
+}
+
+/* Section 4.1.13 */
+static void p2p_build_channel_list(struct p2p_attr_builder *builder,
+			bool optional,
+			const struct p2p_channel_list_attr *attr)
+{
+	const struct l_queue_entry *entry;
+
+	if (optional && !attr->channel_entries)
+		return;
+
+	p2p_attr_builder_start_attr(builder, P2P_ATTR_CHANNEL_LIST);
+	p2p_attr_builder_put_bytes(builder, attr->country, 3);
+
+	for (entry = l_queue_get_entries(attr->channel_entries); entry;
+			entry = entry->next) {
+		const struct p2p_channel_entries *entries = entry->data;
+
+		p2p_attr_builder_put_u8(builder, entries->oper_class);
+		p2p_attr_builder_put_u8(builder, entries->n_channels);
+		p2p_attr_builder_put_bytes(builder, entries->channels,
+						entries->n_channels);
+	}
+}
+
+/* Section 4.1.14 */
+static void p2p_build_notice_of_absence_attr(struct p2p_attr_builder *builder,
+				bool optional,
+				const struct p2p_notice_of_absence_attr *attr)
+{
+	const struct l_queue_entry *entry;
+
+	if (optional && !attr->ct_window && !attr->descriptors)
+		return;
+
+	p2p_attr_builder_start_attr(builder, P2P_ATTR_NOTICE_OF_ABSENCE);
+	p2p_attr_builder_put_u8(builder, attr->index);
+	p2p_attr_builder_put_u8(builder,
+				attr->ct_window | (attr->opp_ps ? 0x80 : 0));
+
+	for (entry = l_queue_get_entries(attr->descriptors); entry;
+			entry = entry->next) {
+		const struct p2p_notice_of_absence_desc *desc = entry->data;
+
+		p2p_attr_builder_put_u8(builder, desc->count_type);
+		p2p_attr_builder_put_u32(builder, desc->duration);
+		p2p_attr_builder_put_u32(builder, desc->interval);
+		p2p_attr_builder_put_u32(builder, desc->start_time);
+	}
+}
+
+static void p2p_build_wsc_device_type(struct p2p_attr_builder *builder,
+				const struct wsc_primary_device_type *pdt)
+{
+	p2p_attr_builder_put_be16(builder, pdt->category);
+	p2p_attr_builder_put_oui(builder, pdt->oui);
+	p2p_attr_builder_put_u8(builder, pdt->oui_type);
+	p2p_attr_builder_put_be16(builder, pdt->subcategory);
+}
+
+/* Section 4.1.15 */
+static void p2p_build_device_info(struct p2p_attr_builder *builder,
+					bool optional,
+					const struct p2p_device_info_attr *attr)
+{
+	const struct l_queue_entry *entry;
+
+	if (optional && !memcmp(attr->device_addr, zero_addr, 6))
+		return;
+
+	p2p_attr_builder_start_attr(builder, P2P_ATTR_P2P_DEVICE_INFO);
+	p2p_attr_builder_put_bytes(builder, attr->device_addr, 6);
+	p2p_attr_builder_put_be16(builder, attr->wsc_config_methods);
+	p2p_build_wsc_device_type(builder, &attr->primary_device_type);
+	p2p_attr_builder_put_u8(builder,
+				l_queue_length(attr->secondary_device_types));
+
+	for (entry = l_queue_get_entries(attr->secondary_device_types); entry;
+			entry = entry->next)
+		p2p_build_wsc_device_type(builder, entry->data);
+
+	p2p_attr_builder_put_be16(builder, WSC_ATTR_DEVICE_NAME);
+	p2p_attr_builder_put_be16(builder, strlen(attr->device_name));
+	p2p_attr_builder_put_bytes(builder, attr->device_name,
+					strlen(attr->device_name));
+}
+
+/* Section 4.1.16 */
+static void p2p_build_group_info(struct p2p_attr_builder *builder,
+					struct l_queue *clients)
+{
+	const struct l_queue_entry *entry;
+
+	/* Always optional */
+	if (!clients)
+		return;
+
+	p2p_attr_builder_start_attr(builder, P2P_ATTR_P2P_GROUP_INFO);
+
+	for (entry = l_queue_get_entries(clients); entry; entry = entry->next) {
+		const struct l_queue_entry *entry2;
+		const struct p2p_client_info_descriptor *desc = entry->data;
+
+		p2p_attr_builder_put_bytes(builder, desc->device_addr, 6);
+		p2p_attr_builder_put_bytes(builder, desc->interface_addr, 6);
+		p2p_attr_builder_put_u8(builder, desc->device_caps);
+		p2p_attr_builder_put_be16(builder, desc->wsc_config_methods);
+		p2p_build_wsc_device_type(builder, &desc->primary_device_type);
+		p2p_attr_builder_put_u8(builder,
+				l_queue_length(desc->secondary_device_types));
+
+		for (entry2 = l_queue_get_entries(desc->secondary_device_types);
+				entry2; entry2 = entry->next)
+			p2p_build_wsc_device_type(builder, entry2->data);
+
+		p2p_attr_builder_put_be16(builder, WSC_ATTR_DEVICE_NAME);
+		p2p_attr_builder_put_be16(builder, strlen(desc->device_name));
+		p2p_attr_builder_put_bytes(builder, desc->device_name,
+						strlen(desc->device_name));
+	}
+}
+
+/* Section 4.1.17, 4.1.29 */
+static void p2p_build_group_id(struct p2p_attr_builder *builder, bool optional,
+				enum p2p_attr type,
+				const struct p2p_group_id_attr *attr)
+{
+	if (optional && !memcmp(attr->device_addr, zero_addr, 6))
+		return;
+
+	p2p_attr_builder_start_attr(builder, type);
+	p2p_attr_builder_put_bytes(builder, attr->device_addr, 6);
+	p2p_attr_builder_put_bytes(builder, attr->ssid, strlen(attr->ssid));
+}
+
+/* Section 4.1.18 */
+static void p2p_build_interface(struct p2p_attr_builder *builder,
+				const struct p2p_interface_attr *attr)
+{
+	const struct l_queue_entry *entry;
+
+	/* Always optional */
+	if (!memcmp(attr->device_addr, zero_addr, 6))
+		return;
+
+	p2p_attr_builder_start_attr(builder, P2P_ATTR_P2P_INTERFACE);
+	p2p_attr_builder_put_bytes(builder, attr->device_addr, 6);
+	p2p_attr_builder_put_u8(builder, l_queue_length(attr->interface_addrs));
+
+	for (entry = l_queue_get_entries(attr->interface_addrs); entry;
+			entry = entry->next)
+		p2p_attr_builder_put_bytes(builder, entry->data, 6);
+}
+
+/* Section 4.1.22 */
+static void p2p_build_svc_hash(struct p2p_attr_builder *builder,
+				struct l_queue *service_hashes)
+{
+	const struct l_queue_entry *entry;
+
+	/* Always optional */
+	if (!service_hashes)
+		return;
+
+	p2p_attr_builder_start_attr(builder, P2P_ATTR_SVC_HASH);
+
+	for (entry = l_queue_get_entries(service_hashes); entry;
+			entry = entry->next)
+		p2p_attr_builder_put_bytes(builder, entry->data, 6);
+}
+
+/* Section 4.1.23 */
+static void p2p_build_session_data(struct p2p_attr_builder *builder,
+				const struct p2p_session_info_data_attr *attr)
+{
+	/* Always optional */
+	if (!attr->data_len)
+		return;
+
+	p2p_attr_builder_start_attr(builder, P2P_ATTR_SESSION_INFO_DATA_INFO);
+	p2p_attr_builder_put_bytes(builder, attr->data, attr->data_len);
+}
+
+/* Section 4.1.25 */
+static void p2p_build_advertisement_id(struct p2p_attr_builder *builder,
+			bool optional,
+			const struct p2p_advertisement_id_info_attr *attr)
+{
+	if (optional && !memcmp(attr->service_mac_addr, zero_addr, 6))
+		return;
+
+	p2p_attr_builder_start_attr(builder, P2P_ATTR_ADVERTISEMENT_ID_INFO);
+	p2p_attr_builder_put_u32(builder, attr->advertisement_id);
+	p2p_attr_builder_put_bytes(builder, attr->service_mac_addr, 6);
+}
+
+/* Section 4.1.26 */
+static void p2p_build_advertised_service_info(struct p2p_attr_builder *builder,
+						struct l_queue *services)
+{
+	const struct l_queue_entry *entry;
+
+	/* Always optional */
+	if (!services)
+		return;
+
+	p2p_attr_builder_start_attr(builder, P2P_ATTR_ADVERTISED_SVC_INFO);
+
+	for (entry = l_queue_get_entries(services); entry;
+			entry = entry->next) {
+		const struct p2p_advertised_service_descriptor *desc =
+			entry->data;
+
+		p2p_attr_builder_put_u32(builder, desc->advertisement_id);
+		p2p_attr_builder_put_be16(builder, desc->wsc_config_methods);
+		p2p_attr_builder_put_u8(builder, strlen(desc->service_name));
+		p2p_attr_builder_put_bytes(builder, desc->service_name,
+						strlen(desc->service_name));
+	}
+}
+
+/* Section 4.1.27 */
+static void p2p_build_session_id(struct p2p_attr_builder *builder,
+				bool optional,
+				const struct p2p_session_id_info_attr *attr)
+{
+	if (optional && !memcmp(attr->session_mac_addr, zero_addr, 6))
+		return;
+
+	p2p_attr_builder_start_attr(builder, P2P_ATTR_SESSION_ID_INFO);
+	p2p_attr_builder_put_u32(builder, attr->session_id);
+	p2p_attr_builder_put_bytes(builder, attr->session_mac_addr, 6);
+}
+
+/* Section 4.1.28 */
+static void p2p_build_feature_capability(struct p2p_attr_builder *builder,
+			bool optional,
+			enum p2p_asp_coordination_transport_protocol attr)
+{
+	if (optional && attr == P2P_ASP_TRANSPORT_UNKNOWN)
+		return;
+
+	p2p_attr_builder_start_attr(builder, P2P_ATTR_FEATURE_CAPABILITY);
+	p2p_attr_builder_put_u8(builder, 0x01); /* P2P_ASP_TRANSPORT_UDP */
+	p2p_attr_builder_put_u8(builder, 0x00); /* Reserved */
+}
+
+/* Section 4.2.1 */
+uint8_t *p2p_build_beacon(const struct p2p_beacon *data, size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+	uint8_t *ret;
+	uint8_t *tlv;
+	size_t tlv_len;
+
+	builder = p2p_attr_builder_new(512);
+	p2p_build_capability(builder, &data->capability);
+	p2p_build_addr(builder, false, P2P_ATTR_P2P_DEVICE_ID,
+			data->device_addr);
+	p2p_build_notice_of_absence_attr(builder, true,
+						&data->notice_of_absence);
+
+	tlv = p2p_attr_builder_free(builder, false, &tlv_len);
+	ret = ie_tlv_encapsulate_p2p_payload(tlv, tlv_len, out_len);
+	l_free(tlv);
+	return ret;
+}
+
+/* Section 4.2.2 */
+uint8_t *p2p_build_probe_req(const struct p2p_probe_req *data, size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+	uint8_t *ret;
+	uint8_t *tlv;
+	size_t tlv_len;
+
+	builder = p2p_attr_builder_new(512);
+	p2p_build_capability(builder, &data->capability);
+	p2p_build_addr(builder, true, P2P_ATTR_P2P_DEVICE_ID,
+			data->device_addr);
+	p2p_build_channel(builder, true, P2P_ATTR_LISTEN_CHANNEL,
+				&data->listen_channel);
+	p2p_build_extended_listen_timing(builder, &data->listen_availability);
+	p2p_build_device_info(builder, true, &data->device_info);
+	p2p_build_channel(builder, true, P2P_ATTR_OPERATING_CHANNEL,
+				&data->operating_channel);
+	p2p_build_svc_hash(builder, data->service_hashes);
+
+	tlv = p2p_attr_builder_free(builder, false, &tlv_len);
+	ret = ie_tlv_encapsulate_p2p_payload(tlv, tlv_len, out_len);
+	l_free(tlv);
+	return ret;
+}
+
+/* Section 4.2.3 */
+uint8_t *p2p_build_probe_resp(const struct p2p_probe_resp *data,
+				size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+	uint8_t *ret;
+	uint8_t *tlv;
+	size_t tlv_len;
+
+	builder = p2p_attr_builder_new(512);
+	p2p_build_capability(builder, &data->capability);
+	p2p_build_extended_listen_timing(builder, &data->listen_availability);
+	p2p_build_notice_of_absence_attr(builder, true,
+						&data->notice_of_absence);
+	p2p_build_device_info(builder, false, &data->device_info);
+	p2p_build_group_info(builder, data->group_clients);
+	p2p_build_advertised_service_info(builder, data->advertised_svcs);
+
+	tlv = p2p_attr_builder_free(builder, false, &tlv_len);
+	ret = ie_tlv_encapsulate_p2p_payload(tlv, tlv_len, out_len);
+	l_free(tlv);
+	return ret;
+}
+
+/* Section 4.2.4 */
+uint8_t *p2p_build_association_req(const struct p2p_association_req *data,
+					size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+	uint8_t *ret;
+	uint8_t *tlv;
+	size_t tlv_len;
+
+	builder = p2p_attr_builder_new(512);
+	p2p_build_capability(builder, &data->capability);
+	p2p_build_extended_listen_timing(builder, &data->listen_availability);
+	p2p_build_device_info(builder, true, &data->device_info);
+	p2p_build_interface(builder, &data->interface);
+
+	tlv = p2p_attr_builder_free(builder, false, &tlv_len);
+	ret = ie_tlv_encapsulate_p2p_payload(tlv, tlv_len, out_len);
+	l_free(tlv);
+	return ret;
+}
+
+/* Section 4.2.5 */
+uint8_t *p2p_build_association_resp(const struct p2p_association_resp *data,
+					size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+	uint8_t *ret;
+	uint8_t *tlv;
+	size_t tlv_len;
+
+	builder = p2p_attr_builder_new(32);
+
+	/*
+	 * 4.2.5: "The Status attribute shall be present [...] when a
+	 * (Re) association Request frame is denied."
+	 *
+	 * Note the P2P IE may end up being empty but is required for
+	 * this frame type nevertheless.
+	 */
+	if (data->status != P2P_STATUS_SUCCESS &&
+			data->status != P2P_STATUS_SUCCESS_ACCEPTED_BY_USER)
+		p2p_build_u8_attr(builder, P2P_ATTR_STATUS, data->status);
+
+	p2p_build_extended_listen_timing(builder, &data->listen_availability);
+
+	tlv = p2p_attr_builder_free(builder, false, &tlv_len);
+	ret = ie_tlv_encapsulate_p2p_payload(tlv, tlv_len, out_len);
+	l_free(tlv);
+	return ret;
+}
+
+/* Section 4.2.6 */
+uint8_t *p2p_build_deauthentication(const struct p2p_deauthentication *data,
+					size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+	uint8_t *ret;
+	uint8_t *tlv;
+	size_t tlv_len;
+
+	if (!data->minor_reason_code) {
+		*out_len = 0;
+		return (uint8_t *) "";
+	}
+
+	builder = p2p_attr_builder_new(512);
+	p2p_build_u8_attr(builder, P2P_ATTR_MINOR_REASON_CODE,
+				data->minor_reason_code);
+
+	tlv = p2p_attr_builder_free(builder, false, &tlv_len);
+	ret = ie_tlv_encapsulate_p2p_payload(tlv, tlv_len, out_len);
+	l_free(tlv);
+	return ret;
+}
+
+/* Section 4.2.7 */
+uint8_t *p2p_build_disassociation(const struct p2p_disassociation *data,
+					size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+	uint8_t *ret;
+	uint8_t *tlv;
+	size_t tlv_len;
+
+	if (!data->minor_reason_code) {
+		*out_len = 0;
+		return (uint8_t *) "";
+	}
+
+	builder = p2p_attr_builder_new(512);
+	p2p_build_u8_attr(builder, P2P_ATTR_MINOR_REASON_CODE,
+				data->minor_reason_code);
+
+	tlv = p2p_attr_builder_free(builder, false, &tlv_len);
+	ret = ie_tlv_encapsulate_p2p_payload(tlv, tlv_len, out_len);
+	l_free(tlv);
+	return ret;
+}
+
+/* Sections 4.2.9.1, 4.2.10.1.  Note: consumes @p2p_attrs */
+static uint8_t *p2p_build_action_frame(bool public, uint8_t frame_subtype,
+					uint8_t dialog_token,
+					struct p2p_attr_builder *p2p_attrs,
+					const struct wsc_p2p_attrs *wsc_attrs,
+					size_t *out_len)
+{
+	uint8_t *p2p_ie, *wsc_ie, *ret;
+	size_t p2p_ie_len, wsc_ie_len;
+	int pos = 0;
+
+	if (p2p_attrs) {
+		uint8_t *payload;
+		size_t payload_len;
+
+		payload = p2p_attr_builder_free(p2p_attrs, false, &payload_len);
+		p2p_ie = ie_tlv_encapsulate_p2p_payload(payload, payload_len,
+							&p2p_ie_len);
+		l_free(payload);
+	} else
+		p2p_ie = NULL;
+
+	if (wsc_attrs) {
+		uint8_t *payload;
+		size_t payload_len;
+
+		payload = wsc_build_p2p_attrs(wsc_attrs, &payload_len);
+		wsc_ie = ie_tlv_encapsulate_wsc_payload(payload, payload_len,
+							&wsc_ie_len);
+		l_free(payload);
+	} else
+		wsc_ie = NULL;
+
+	*out_len = (public ? 8 : 7) + (p2p_ie ? p2p_ie_len : 0) +
+		(wsc_ie ? wsc_ie_len : 0);
+	ret = l_malloc(*out_len);
+
+	if (public) {
+		ret[pos++] = 0x04; /* Category: Public Action */
+		ret[pos++] = 0x09; /* Action: Vendor Specific */
+	} else
+		ret[pos++] = 0x7f; /* Category: Vendor Specific */
+
+	ret[pos++] = 0x50;	/* OUI: Wi-Fi Alliance */
+	ret[pos++] = 0x6f;
+	ret[pos++] = 0x9a;
+	ret[pos++] = 0x09;	/* OUI type: Wi-Fi Alliance P2P v1.0 */
+	ret[pos++] = frame_subtype;
+	ret[pos++] = dialog_token;
+
+	if (p2p_ie) {
+		memcpy(ret + pos, p2p_ie, p2p_ie_len);
+		l_free(p2p_ie);
+		pos += p2p_ie_len;
+	}
+
+	if (wsc_ie) {
+		memcpy(ret + pos, wsc_ie, wsc_ie_len);
+		l_free(wsc_ie);
+	}
+
+	return ret;
+}
+
+/* Section 4.2.9.2 */
+uint8_t *p2p_build_go_negotiation_req(const struct p2p_go_negotiation_req *data,
+					size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+	struct wsc_p2p_attrs wsc_attrs = {};
+
+	builder = p2p_attr_builder_new(512);
+	p2p_build_capability(builder, &data->capability);
+	p2p_build_go_intent(builder, data->go_intent, data->go_tie_breaker);
+	p2p_build_config_timeout(builder, false, &data->config_timeout);
+	p2p_build_channel(builder, true, P2P_ATTR_LISTEN_CHANNEL,
+				&data->listen_channel);
+	p2p_build_extended_listen_timing(builder, &data->listen_availability);
+	p2p_build_addr(builder, false, P2P_ATTR_INTENDED_P2P_INTERFACE_ADDR,
+			data->intended_interface_addr);
+	p2p_build_channel_list(builder, false, &data->channel_list);
+	p2p_build_device_info(builder, false, &data->device_info);
+	p2p_build_channel(builder, true, P2P_ATTR_OPERATING_CHANNEL,
+				&data->operating_channel);
+
+	wsc_attrs.version = true;
+	wsc_attrs.device_password_id = data->device_password_id;
+
+	return p2p_build_action_frame(true, P2P_ACTION_GO_NEGOTIATION_REQ,
+					data->dialog_token, builder, &wsc_attrs,
+					out_len);
+}
+
+/* Section 4.2.9.3 */
+uint8_t *p2p_build_go_negotiation_resp(
+				const struct p2p_go_negotiation_resp *data,
+				size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+	struct wsc_p2p_attrs wsc_attrs = {};
+
+	builder = p2p_attr_builder_new(512);
+	p2p_build_u8_attr(builder, P2P_ATTR_STATUS, data->status);
+	p2p_build_capability(builder, &data->capability);
+	p2p_build_go_intent(builder, data->go_intent, data->go_tie_breaker);
+	p2p_build_config_timeout(builder, false, &data->config_timeout);
+	p2p_build_channel(builder, true, P2P_ATTR_OPERATING_CHANNEL,
+				&data->operating_channel);
+	p2p_build_addr(builder, false, P2P_ATTR_INTENDED_P2P_INTERFACE_ADDR,
+			data->intended_interface_addr);
+	p2p_build_channel_list(builder, false, &data->channel_list);
+	p2p_build_device_info(builder, false, &data->device_info);
+	p2p_build_group_id(builder, true, P2P_ATTR_P2P_GROUP_ID,
+				&data->group_id);
+
+	wsc_attrs.version = true;
+	wsc_attrs.device_password_id = data->device_password_id;
+
+	return p2p_build_action_frame(true, P2P_ACTION_GO_NEGOTIATION_RESP,
+					data->dialog_token, builder, &wsc_attrs,
+					out_len);
+}
+
+/* Section 4.2.9.4 */
+uint8_t *p2p_build_go_negotiation_confirmation(
+			const struct p2p_go_negotiation_confirmation *data,
+			size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+
+	builder = p2p_attr_builder_new(512);
+	p2p_build_u8_attr(builder, P2P_ATTR_STATUS, data->status);
+	p2p_build_capability(builder, &data->capability);
+	p2p_build_channel(builder, false, P2P_ATTR_OPERATING_CHANNEL,
+				&data->operating_channel);
+	p2p_build_channel_list(builder, false, &data->channel_list);
+	p2p_build_group_id(builder, true, P2P_ATTR_P2P_GROUP_ID,
+				&data->group_id);
+
+	return p2p_build_action_frame(true, P2P_ACTION_GO_NEGOTIATION_CONFIRM,
+					data->dialog_token, builder, NULL,
+					out_len);
+}
+
+/* Section 4.2.9.5 */
+uint8_t *p2p_build_invitation_req(const struct p2p_invitation_req *data,
+					size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+	struct wsc_p2p_attrs wsc_attrs = {};
+
+	builder = p2p_attr_builder_new(512);
+	p2p_build_config_timeout(builder, false, &data->config_timeout);
+	p2p_build_u8_attr(builder, P2P_ATTR_INVITATION_FLAGS,
+				data->reinvoke_persistent_group ? 0x01 : 0x00);
+	p2p_build_channel(builder, true, P2P_ATTR_OPERATING_CHANNEL,
+				&data->operating_channel);
+	p2p_build_addr(builder, true, P2P_ATTR_P2P_GROUP_BSSID,
+			data->group_bssid);
+	p2p_build_channel_list(builder, false, &data->channel_list);
+	p2p_build_group_id(builder, false, P2P_ATTR_P2P_GROUP_ID,
+				&data->group_id);
+	p2p_build_device_info(builder, false, &data->device_info);
+
+	/* Optional WSC IE for NFC Static Handover */
+	wsc_attrs.version2 = true;
+	wsc_attrs.device_password_id = data->device_password_id;
+
+	return p2p_build_action_frame(true, P2P_ACTION_INVITATION_REQ,
+					data->dialog_token, builder,
+					data->device_password_id ?
+					&wsc_attrs : NULL, out_len);
+}
+
+/* Section 4.2.9.6 */
+uint8_t *p2p_build_invitation_resp(const struct p2p_invitation_resp *data,
+					size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+
+	builder = p2p_attr_builder_new(512);
+	p2p_build_u8_attr(builder, P2P_ATTR_STATUS, data->status);
+	p2p_build_config_timeout(builder, false, &data->config_timeout);
+
+	if (data->status == P2P_STATUS_SUCCESS ||
+			data->status == P2P_STATUS_SUCCESS_ACCEPTED_BY_USER) {
+		p2p_build_channel(builder, false, P2P_ATTR_OPERATING_CHANNEL,
+					&data->operating_channel);
+		p2p_build_addr(builder, false, P2P_ATTR_P2P_GROUP_BSSID,
+				data->group_bssid);
+		p2p_build_channel_list(builder, false, &data->channel_list);
+	}
+
+	return p2p_build_action_frame(true, P2P_ACTION_INVITATION_RESP,
+					data->dialog_token, builder, NULL,
+					out_len);
+}
+
+/* Section 4.2.9.7 */
+uint8_t *p2p_build_device_disc_req(
+			const struct p2p_device_discoverability_req *data,
+			size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+
+	builder = p2p_attr_builder_new(64);
+	p2p_build_addr(builder, false, P2P_ATTR_P2P_DEVICE_ID,
+			data->device_addr);
+	p2p_build_group_id(builder, false, P2P_ATTR_P2P_GROUP_ID,
+				&data->group_id);
+
+	return p2p_build_action_frame(true,
+					P2P_ACTION_DEVICE_DISCOVERABILITY_REQ,
+					data->dialog_token, builder, NULL,
+					out_len);
+}
+
+/* Section 4.2.9.8 */
+uint8_t *p2p_build_device_disc_resp(
+			const struct p2p_device_discoverability_resp *data,
+			size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+
+	builder = p2p_attr_builder_new(16);
+	p2p_build_u8_attr(builder, P2P_ATTR_STATUS, data->status);
+
+	return p2p_build_action_frame(true,
+					P2P_ACTION_DEVICE_DISCOVERABILITY_RESP,
+					data->dialog_token, builder, NULL,
+					out_len);
+}
+
+/* Section 4.2.9.9 */
+uint8_t *p2p_build_provision_disc_req(
+				const struct p2p_provision_discovery_req *data,
+				size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+	struct wsc_p2p_attrs wsc_attrs = {};
+
+	builder = p2p_attr_builder_new(512);
+	p2p_build_capability(builder, &data->capability);
+	p2p_build_device_info(builder, false, &data->device_info);
+	p2p_build_group_id(builder, true, P2P_ATTR_P2P_GROUP_ID,
+				&data->group_id);
+	p2p_build_addr(builder, true, P2P_ATTR_INTENDED_P2P_INTERFACE_ADDR,
+			data->intended_interface_addr);
+
+	if (data->status != (enum p2p_attr_status_code) -1)
+		p2p_build_u8_attr(builder, P2P_ATTR_STATUS, data->status);
+
+	p2p_build_channel(builder, true, P2P_ATTR_OPERATING_CHANNEL,
+				&data->operating_channel);
+	p2p_build_channel_list(builder, true, &data->channel_list);
+	p2p_build_session_data(builder, &data->session_info);
+
+	if (data->connection_capability)
+		p2p_build_u8_attr(builder, P2P_ATTR_CONNECTION_CAPABILITY_INFO,
+					data->connection_capability);
+
+	p2p_build_advertisement_id(builder, true, &data->advertisement_id);
+	p2p_build_config_timeout(builder, true, &data->config_timeout);
+	p2p_build_channel(builder, true, P2P_ATTR_LISTEN_CHANNEL,
+				&data->listen_channel);
+	p2p_build_session_id(builder, true, &data->session_id);
+	p2p_build_feature_capability(builder, true, data->transport_protocol);
+	p2p_build_group_id(builder, true, P2P_ATTR_PERSISTENT_GROUP_INFO,
+				&data->persistent_group_info);
+
+	wsc_attrs.config_methods = data->wsc_config_method;
+
+	return p2p_build_action_frame(true, P2P_ACTION_PROVISION_DISCOVERY_REQ,
+					data->dialog_token, builder, &wsc_attrs,
+					out_len);
+}
+
+/* Section 4.2.9.10 */
+uint8_t *p2p_build_provision_disc_resp(
+				const struct p2p_provision_discovery_resp *data,
+				size_t *out_len)
+{
+	struct p2p_attr_builder *builder = NULL;
+	struct wsc_p2p_attrs wsc_attrs = {};
+
+	if (data->status != (enum p2p_attr_status_code) -1) {
+		builder = p2p_attr_builder_new(512);
+		p2p_build_u8_attr(builder, P2P_ATTR_STATUS, data->status);
+		p2p_build_capability(builder, &data->capability);
+		p2p_build_device_info(builder, false, &data->device_info);
+		p2p_build_group_id(builder, true, P2P_ATTR_P2P_GROUP_ID,
+					&data->group_id);
+		p2p_build_addr(builder, true,
+				P2P_ATTR_INTENDED_P2P_INTERFACE_ADDR,
+				data->intended_interface_addr);
+		p2p_build_channel(builder, true, P2P_ATTR_OPERATING_CHANNEL,
+					&data->operating_channel);
+		p2p_build_channel_list(builder, true, &data->channel_list);
+
+		if (data->connection_capability)
+			p2p_build_u8_attr(builder,
+					P2P_ATTR_CONNECTION_CAPABILITY_INFO,
+					data->connection_capability);
+
+		p2p_build_advertisement_id(builder, false,
+						&data->advertisement_id);
+		p2p_build_config_timeout(builder, true, &data->config_timeout);
+		p2p_build_session_id(builder, false, &data->session_id);
+		p2p_build_feature_capability(builder, false,
+						data->transport_protocol);
+		p2p_build_group_id(builder, true,
+					P2P_ATTR_PERSISTENT_GROUP_INFO,
+					&data->persistent_group_info);
+		p2p_build_session_data(builder, &data->session_info);
+	}
+
+	wsc_attrs.config_methods = data->wsc_config_method;
+
+	return p2p_build_action_frame(true, P2P_ACTION_PROVISION_DISCOVERY_RESP,
+					data->dialog_token, builder, &wsc_attrs,
+					out_len);
+}
+
+/* Section 4.2.10.2 */
+uint8_t *p2p_build_notice_of_absence(const struct p2p_notice_of_absence *data,
+					size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+
+	builder = p2p_attr_builder_new(128);
+	p2p_build_notice_of_absence_attr(builder, false,
+						&data->notice_of_absence);
+
+	return p2p_build_action_frame(false, P2P_ACTION_NOTICE_OF_ABSENCE,
+					0, builder, NULL, out_len);
+}
+
+/* Section 4.2.10.3 */
+uint8_t *p2p_build_presence_req(const struct p2p_presence_req *data,
+				size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+
+	builder = p2p_attr_builder_new(128);
+	p2p_build_notice_of_absence_attr(builder, false,
+						&data->notice_of_absence);
+
+	return p2p_build_action_frame(false, P2P_ACTION_PRESENCE_REQ,
+					0, builder, NULL, out_len);
+}
+
+/* Section 4.2.10.4 */
+uint8_t *p2p_build_presence_resp(const struct p2p_presence_resp *data,
+					size_t *out_len)
+{
+	struct p2p_attr_builder *builder;
+
+	builder = p2p_attr_builder_new(128);
+	p2p_build_u8_attr(builder, P2P_ATTR_STATUS, data->status);
+	p2p_build_notice_of_absence_attr(builder, false,
+						&data->notice_of_absence);
+
+	return p2p_build_action_frame(false, P2P_ACTION_PRESENCE_RESP,
+					0, builder, NULL, out_len);
+}
+
+/* Section 4.2.10.5 */
+uint8_t *p2p_build_go_disc_req(size_t *out_len)
+{
+	return p2p_build_action_frame(false, P2P_ACTION_GO_DISCOVERABILITY_REQ,
+					0, NULL, NULL, out_len);
+}
diff --git a/src/p2putil.h b/src/p2putil.h
new file mode 100644
index 00000000..681d9e33
--- /dev/null
+++ b/src/p2putil.h
@@ -0,0 +1,524 @@
+/*
+ *
+ *  Wireless daemon for Linux
+ *
+ *  Copyright (C) 2019  Intel Corporation. All rights reserved.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <stdint.h>
+
+#include "src/wscutil.h"
+
+struct l_queue;
+
+/* Wi-Fi P2P Technical Specification v1.7, Section 4.1.1, Table 6 */
+enum p2p_attr {
+	P2P_ATTR_STATUS = 0,
+	P2P_ATTR_MINOR_REASON_CODE = 1,
+	P2P_ATTR_P2P_CAPABILITY = 2,
+	P2P_ATTR_P2P_DEVICE_ID = 3,
+	P2P_ATTR_GO_INTENT = 4,
+	P2P_ATTR_CONFIGURATION_TIMEOUT = 5,
+	P2P_ATTR_LISTEN_CHANNEL = 6,
+	P2P_ATTR_P2P_GROUP_BSSID = 7,
+	P2P_ATTR_EXTENDED_LISTEN_TIMING = 8,
+	P2P_ATTR_INTENDED_P2P_INTERFACE_ADDR = 9,
+	P2P_ATTR_P2P_MANAGEABILITY = 10,
+	P2P_ATTR_CHANNEL_LIST = 11,
+	P2P_ATTR_NOTICE_OF_ABSENCE = 12,
+	P2P_ATTR_P2P_DEVICE_INFO = 13,
+	P2P_ATTR_P2P_GROUP_INFO = 14,
+	P2P_ATTR_P2P_GROUP_ID = 15,
+	P2P_ATTR_P2P_INTERFACE = 16,
+	P2P_ATTR_OPERATING_CHANNEL = 17,
+	P2P_ATTR_INVITATION_FLAGS = 18,
+	P2P_ATTR_OOB_GO_NEGOTIATION_CHANNEL = 19,
+	P2P_ATTR_SVC_HASH = 21,
+	P2P_ATTR_SESSION_INFO_DATA_INFO = 22,
+	P2P_ATTR_CONNECTION_CAPABILITY_INFO = 23,
+	P2P_ATTR_ADVERTISEMENT_ID_INFO = 24,
+	P2P_ATTR_ADVERTISED_SVC_INFO = 25,
+	P2P_ATTR_SESSION_ID_INFO = 26,
+	P2P_ATTR_FEATURE_CAPABILITY = 27,
+	P2P_ATTR_PERSISTENT_GROUP_INFO = 28,
+	P2P_ATTR_VENDOR_SPECIFIC_ATTR = 221,
+};
+
+/* Table 8 */
+enum p2p_attr_status_code {
+	P2P_STATUS_SUCCESS = 0,
+	P2P_STATUS_FAIL_INFO_NOT_AVAIL = 1,
+	P2P_STATUS_FAIL_INCOMPATIBLE_PARAMS = 2,
+	P2P_STATUS_FAIL_LIMIT_REACHED = 3,
+	P2P_STATUS_FAIL_INVALID_PARAMS = 4,
+	P2P_STATUS_FAIL_UNABLE_TO_ACCOMMODATE_REQUEST = 5,
+	P2P_STATUS_FAIL_PREV_PROTOCOL_ERROR = 6,
+	P2P_STATUS_FAIL_NO_COMMON_CHANNELS = 7,
+	P2P_STATUS_FAIL_UNKNOWN_P2P_GROUP = 8,
+	P2P_STATUS_FAIL_INTENT_15_IN_GO_NEGOTIATION = 9,
+	P2P_STATUS_FAIL_INCOMPATIBLE_PROVISIONING = 10,
+	P2P_STATUS_FAIL_REJECTED_BY_USER = 11,
+	P2P_STATUS_SUCCESS_ACCEPTED_BY_USER = 12,
+};
+
+/* Table 12 */
+enum p2p_device_capability_bitmap {
+	P2P_DEVICE_CAP_SVC_DISCOVERY		= 0x01,
+	P2P_DEVICE_CAP_CLIENT_DISCOVERABILITY	= 0x02,
+	P2P_DEVICE_CAP_CONCURRENT_OP		= 0x04,
+	P2P_DEVICE_CAP_INFRASTRUCTURE_MANAGED	= 0x08,
+	P2P_DEVICE_CAP_DEVICE_LIMIT		= 0x10,
+	P2P_DEVICE_CAP_INVITATION_PROCEDURE	= 0x20,
+};
+
+/* Table 13 */
+enum p2p_group_capability_bitmap {
+	P2P_GROUP_CAP_GO			= 0x01,
+	P2P_GROUP_CAP_PERSISTENT_GROUP		= 0x02,
+	P2P_GROUP_CAP_GROUP_LIMIT		= 0x04,
+	P2P_GROUP_CAP_INTRA_BSS_DISTRIBUTION	= 0x08,
+	P2P_GROUP_CAP_CROSS_CONNECT		= 0x10,
+	P2P_GROUP_CAP_PERSISTENT_RECONNECT	= 0x20,
+	P2P_GROUP_CAP_GROUP_FORMATION		= 0x40,
+	P2P_GROUP_CAP_IP_ALLOCATION		= 0x80,
+};
+
+/* Table 23 */
+enum p2p_manageability_bitmap {
+	P2P_MANAGEABILITY_DEVICE_MGMT		= 0x01,
+	P2P_MANAGEABILITY_CROSS_CONNECT		= 0x02,
+	P2P_MANAGEABILITY_COEXIST_OPTIONAL	= 0x04,
+};
+
+/* Table 61 */
+enum p2p_public_action_frame_type {
+	P2P_ACTION_GO_NEGOTIATION_REQ		= 0,
+	P2P_ACTION_GO_NEGOTIATION_RESP		= 1,
+	P2P_ACTION_GO_NEGOTIATION_CONFIRM	= 2,
+	P2P_ACTION_INVITATION_REQ		= 3,
+	P2P_ACTION_INVITATION_RESP		= 4,
+	P2P_ACTION_DEVICE_DISCOVERABILITY_REQ	= 5,
+	P2P_ACTION_DEVICE_DISCOVERABILITY_RESP	= 6,
+	P2P_ACTION_PROVISION_DISCOVERY_REQ	= 7,
+	P2P_ACTION_PROVISION_DISCOVERY_RESP	= 8,
+};
+
+/* Table 75 */
+enum p2p_action_frame_type {
+	P2P_ACTION_NOTICE_OF_ABSENCE		= 0,
+	P2P_ACTION_PRESENCE_REQ 		= 1,
+	P2P_ACTION_PRESENCE_RESP 		= 2,
+	P2P_ACTION_GO_DISCOVERABILITY_REQ	= 3,
+};
+
+struct p2p_attr_iter {
+	const uint8_t *pos;
+	const uint8_t *end;
+	enum p2p_attr type;
+	size_t len;
+};
+
+void p2p_attr_iter_init(struct p2p_attr_iter *iter, const uint8_t *pdu,
+			size_t len);
+bool p2p_attr_iter_next(struct p2p_attr_iter *iter);
+
+static inline enum p2p_attr p2p_attr_iter_get_type(struct p2p_attr_iter *iter)
+{
+	return iter->type;
+}
+
+static inline size_t p2p_attr_iter_get_length(struct p2p_attr_iter *iter)
+{
+	return iter->len;
+}
+
+static inline const uint8_t *p2p_attr_iter_get_data(struct p2p_attr_iter *iter)
+{
+	return iter->pos + 3;
+}
+
+struct p2p_capability_attr {
+	uint8_t device_caps;
+	uint8_t group_caps;
+};
+
+struct p2p_config_timeout_attr {
+	uint8_t go_config_timeout;
+	uint8_t client_config_timeout;
+};
+
+struct p2p_channel_attr {
+	char country[3];
+	uint8_t oper_class;
+	uint8_t channel_num;
+};
+
+struct p2p_extended_listen_timing_attr {
+	uint16_t avail_period_ms;
+	uint16_t avail_interval_ms;
+};
+
+struct p2p_channel_entries {
+	uint8_t oper_class;
+	int n_channels;
+	uint8_t channels[];
+};
+
+struct p2p_channel_list_attr {
+	char country[3];
+	struct l_queue *channel_entries;
+};
+
+struct p2p_notice_of_absence_desc {
+	uint8_t count_type;
+	uint32_t duration;
+	uint32_t interval;
+	uint32_t start_time;
+};
+
+struct p2p_notice_of_absence_attr {
+	uint8_t index;
+	bool opp_ps;
+	uint8_t ct_window;
+	struct l_queue *descriptors;
+};
+
+struct p2p_device_info_attr {
+	uint8_t device_addr[6];
+	uint16_t wsc_config_methods;
+	struct wsc_primary_device_type primary_device_type;
+	struct l_queue *secondary_device_types;
+	char device_name[33];
+};
+
+struct p2p_client_info_descriptor {
+	uint8_t device_addr[6];
+	uint8_t interface_addr[6];
+	uint8_t device_caps;
+	uint16_t wsc_config_methods;
+	struct wsc_primary_device_type primary_device_type;
+	struct l_queue *secondary_device_types;
+	char device_name[33];
+};
+
+struct p2p_group_id_attr {
+	uint8_t device_addr[6];
+	char ssid[33];
+};
+
+struct p2p_interface_attr {
+	uint8_t device_addr[6];
+	struct l_queue *interface_addrs;
+};
+
+struct p2p_session_info_data_attr {
+	size_t data_len;
+	uint8_t data[144];
+};
+
+struct p2p_advertisement_id_info_attr {
+	uint32_t advertisement_id;
+	uint8_t service_mac_addr[6];
+};
+
+struct p2p_advertised_service_descriptor {
+	uint32_t advertisement_id;
+	uint16_t wsc_config_methods;
+	char *service_name;
+};
+
+struct p2p_session_id_info_attr {
+	uint32_t session_id;
+	uint8_t session_mac_addr[6];
+};
+
+enum p2p_asp_coordination_transport_protocol {
+	P2P_ASP_TRANSPORT_UNKNOWN = 0,
+	P2P_ASP_TRANSPORT_UDP,
+};
+
+struct p2p_beacon {
+	struct p2p_capability_attr capability;
+	uint8_t device_addr[6];
+	struct p2p_notice_of_absence_attr notice_of_absence;
+};
+
+struct p2p_probe_req {
+	struct p2p_capability_attr capability;
+	uint8_t device_addr[6];
+	struct p2p_channel_attr listen_channel;
+	struct p2p_extended_listen_timing_attr listen_availability;
+	struct p2p_device_info_attr device_info;
+	struct p2p_channel_attr operating_channel;
+	struct l_queue *service_hashes;
+};
+
+struct p2p_probe_resp {
+	struct p2p_capability_attr capability;
+	struct p2p_extended_listen_timing_attr listen_availability;
+	struct p2p_notice_of_absence_attr notice_of_absence;
+	struct p2p_device_info_attr device_info;
+	struct l_queue *group_clients;
+	struct l_queue *advertised_svcs;
+};
+
+struct p2p_association_req {
+	struct p2p_capability_attr capability;
+	struct p2p_extended_listen_timing_attr listen_availability;
+	struct p2p_device_info_attr device_info;
+	struct p2p_interface_attr interface;
+};
+
+struct p2p_association_resp {
+	enum p2p_attr_status_code status;
+	struct p2p_extended_listen_timing_attr listen_availability;
+};
+
+struct p2p_deauthentication {
+	uint8_t minor_reason_code;
+};
+
+struct p2p_disassociation {
+	uint8_t minor_reason_code;
+};
+
+struct p2p_go_negotiation_req {
+	uint8_t dialog_token;
+	struct p2p_capability_attr capability;
+	uint8_t go_intent;
+	bool go_tie_breaker;
+	struct p2p_config_timeout_attr config_timeout;
+	struct p2p_channel_attr listen_channel;
+	struct p2p_extended_listen_timing_attr listen_availability;
+	uint8_t intended_interface_addr[6];
+	struct p2p_channel_list_attr channel_list;
+	struct p2p_device_info_attr device_info;
+	struct p2p_channel_attr operating_channel;
+	enum wsc_device_password_id device_password_id;
+};
+
+struct p2p_go_negotiation_resp {
+	uint8_t dialog_token;
+	enum p2p_attr_status_code status;
+	struct p2p_capability_attr capability;
+	uint8_t go_intent;
+	bool go_tie_breaker;
+	struct p2p_config_timeout_attr config_timeout;
+	struct p2p_channel_attr operating_channel;
+	uint8_t intended_interface_addr[6];
+	struct p2p_channel_list_attr channel_list;
+	struct p2p_device_info_attr device_info;
+	struct p2p_group_id_attr group_id;
+	enum wsc_device_password_id device_password_id;
+};
+
+struct p2p_go_negotiation_confirmation {
+	uint8_t dialog_token;
+	enum p2p_attr_status_code status;
+	struct p2p_capability_attr capability;
+	struct p2p_channel_attr operating_channel;
+	struct p2p_channel_list_attr channel_list;
+	struct p2p_group_id_attr group_id;
+};
+
+struct p2p_invitation_req {
+	uint8_t dialog_token;
+	struct p2p_config_timeout_attr config_timeout;
+	bool reinvoke_persistent_group;
+	struct p2p_channel_attr operating_channel;
+	uint8_t group_bssid[6];
+	struct p2p_channel_list_attr channel_list;
+	struct p2p_group_id_attr group_id;
+	struct p2p_device_info_attr device_info;
+	enum wsc_device_password_id device_password_id;
+};
+
+struct p2p_invitation_resp {
+	uint8_t dialog_token;
+	enum p2p_attr_status_code status;
+	struct p2p_config_timeout_attr config_timeout;
+	struct p2p_channel_attr operating_channel;
+	uint8_t group_bssid[6];
+	struct p2p_channel_list_attr channel_list;
+};
+
+struct p2p_device_discoverability_req {
+	uint8_t dialog_token;
+	uint8_t device_addr[6];
+	struct p2p_group_id_attr group_id;
+};
+
+struct p2p_device_discoverability_resp {
+	uint8_t dialog_token;
+	enum p2p_attr_status_code status;
+};
+
+struct p2p_provision_discovery_req {
+	uint8_t dialog_token;
+	struct p2p_capability_attr capability;
+	struct p2p_device_info_attr device_info;
+	struct p2p_group_id_attr group_id;
+	uint8_t intended_interface_addr[6];
+	enum p2p_attr_status_code status;
+	struct p2p_channel_attr operating_channel;
+	struct p2p_channel_list_attr channel_list;
+	struct p2p_session_info_data_attr session_info;
+	uint8_t connection_capability;
+	struct p2p_advertisement_id_info_attr advertisement_id;
+	struct p2p_config_timeout_attr config_timeout;
+	struct p2p_channel_attr listen_channel;
+	struct p2p_session_id_info_attr session_id;
+	enum p2p_asp_coordination_transport_protocol transport_protocol;
+	struct p2p_group_id_attr persistent_group_info;
+	uint16_t wsc_config_method;
+};
+
+struct p2p_provision_discovery_resp {
+	uint8_t dialog_token;
+	enum p2p_attr_status_code status;
+	struct p2p_capability_attr capability;
+	struct p2p_device_info_attr device_info;
+	struct p2p_group_id_attr group_id;
+	uint8_t intended_interface_addr[6];
+	struct p2p_channel_attr operating_channel;
+	struct p2p_channel_list_attr channel_list;
+	uint8_t connection_capability;
+	struct p2p_advertisement_id_info_attr advertisement_id;
+	struct p2p_config_timeout_attr config_timeout;
+	struct p2p_session_id_info_attr session_id;
+	enum p2p_asp_coordination_transport_protocol transport_protocol;
+	struct p2p_group_id_attr persistent_group_info;
+	struct p2p_session_info_data_attr session_info;
+	uint16_t wsc_config_method;
+};
+
+struct p2p_notice_of_absence {
+	struct p2p_notice_of_absence_attr notice_of_absence;
+};
+
+struct p2p_presence_req {
+	uint8_t dialog_token;
+	struct p2p_notice_of_absence_attr notice_of_absence;
+};
+
+struct p2p_presence_resp {
+	uint8_t dialog_token;
+	enum p2p_attr_status_code status;
+	struct p2p_notice_of_absence_attr notice_of_absence;
+};
+
+int p2p_parse_beacon(const uint8_t *pdu, size_t len,
+			struct p2p_beacon *out);
+int p2p_parse_probe_req(const uint8_t *pdu, size_t len,
+			struct p2p_probe_req *out);
+int p2p_parse_probe_resp(const uint8_t *pdu, size_t len,
+				struct p2p_probe_resp *out);
+int p2p_parse_association_req(const uint8_t *pdu, size_t len,
+				struct p2p_association_req *out);
+int p2p_parse_association_resp(const uint8_t *pdu, size_t len,
+				struct p2p_association_resp *out);
+int p2p_parse_deauthentication(const uint8_t *pdu, size_t len,
+				struct p2p_deauthentication *out);
+int p2p_parse_disassociation(const uint8_t *pdu, size_t len,
+				struct p2p_disassociation *out);
+int p2p_parse_go_negotiation_req(const uint8_t *pdu, size_t len,
+					struct p2p_go_negotiation_req *out);
+int p2p_parse_go_negotiation_resp(const uint8_t *pdu, size_t len,
+					struct p2p_go_negotiation_resp *out);
+int p2p_parse_go_negotiation_confirmation(const uint8_t *pdu, size_t len,
+				struct p2p_go_negotiation_confirmation *out);
+int p2p_parse_invitation_req(const uint8_t *pdu, size_t len,
+				struct p2p_invitation_req *out);
+int p2p_parse_invitation_resp(const uint8_t *pdu, size_t len,
+				struct p2p_invitation_resp *out);
+int p2p_parse_device_disc_req(const uint8_t *pdu, size_t len,
+				struct p2p_device_discoverability_req *out);
+int p2p_parse_device_disc_resp(const uint8_t *pdu, size_t len,
+				struct p2p_device_discoverability_resp *out);
+int p2p_parse_provision_disc_req(const uint8_t *pdu, size_t len,
+				struct p2p_provision_discovery_req *out);
+int p2p_parse_provision_disc_resp(const uint8_t *pdu, size_t len,
+				struct p2p_provision_discovery_resp *out);
+int p2p_parse_notice_of_absence(const uint8_t *pdu, size_t len,
+				struct p2p_notice_of_absence *out);
+int p2p_parse_presence_req(const uint8_t *pdu, size_t len,
+				struct p2p_presence_req *out);
+int p2p_parse_presence_resp(const uint8_t *pdu, size_t len,
+				struct p2p_presence_resp *out);
+int p2p_parse_go_disc_req(const uint8_t *pdu, size_t len);
+
+void p2p_free_beacon(struct p2p_beacon *data);
+void p2p_free_probe_req(struct p2p_probe_req *data);
+void p2p_free_probe_resp(struct p2p_probe_resp *data);
+void p2p_free_association_req(struct p2p_association_req *data);
+void p2p_free_association_resp(struct p2p_association_resp *data);
+void p2p_free_go_negotiation_req(struct p2p_go_negotiation_req *data);
+void p2p_free_go_negotiation_resp(struct p2p_go_negotiation_resp *data);
+void p2p_free_go_negotiation_confirmation(
+				struct p2p_go_negotiation_confirmation *data);
+void p2p_free_invitation_req(struct p2p_invitation_req *data);
+void p2p_free_invitation_resp(struct p2p_invitation_resp *data);
+void p2p_free_provision_disc_req(struct p2p_provision_discovery_req *data);
+void p2p_free_provision_disc_resp(struct p2p_provision_discovery_resp *data);
+void p2p_free_notice_of_absence(struct p2p_notice_of_absence *data);
+void p2p_free_presence_req(struct p2p_presence_req *data);
+void p2p_free_presence_resp(struct p2p_presence_resp *data);
+
+uint8_t *p2p_build_beacon(const struct p2p_beacon *data, size_t *out_len);
+uint8_t *p2p_build_probe_req(const struct p2p_probe_req *data, size_t *out_len);
+uint8_t *p2p_build_probe_resp(const struct p2p_probe_resp *data,
+				size_t *out_len);
+uint8_t *p2p_build_association_req(const struct p2p_association_req *data,
+					size_t *out_len);
+uint8_t *p2p_build_association_resp(const struct p2p_association_resp *data,
+					size_t *out_len);
+uint8_t *p2p_build_deauthentication(const struct p2p_deauthentication *data,
+					size_t *out_len);
+uint8_t *p2p_build_disassociation(const struct p2p_disassociation *data,
+					size_t *out_len);
+uint8_t *p2p_build_go_negotiation_req(const struct p2p_go_negotiation_req *data,
+					size_t *out_len);
+uint8_t *p2p_build_go_negotiation_resp(
+				const struct p2p_go_negotiation_resp *data,
+				size_t *out_len);
+uint8_t *p2p_build_go_negotiation_confirmation(
+			const struct p2p_go_negotiation_confirmation *data,
+			size_t *out_len);
+uint8_t *p2p_build_invitation_req(const struct p2p_invitation_req *data,
+					size_t *out_len);
+uint8_t *p2p_build_invitation_resp(const struct p2p_invitation_resp *data,
+					size_t *out_len);
+uint8_t *p2p_build_device_disc_req(
+			const struct p2p_device_discoverability_req *data,
+			size_t *out_len);
+uint8_t *p2p_build_device_disc_resp(
+			const struct p2p_device_discoverability_resp *data,
+			size_t *out_len);
+uint8_t *p2p_build_provision_disc_req(
+				const struct p2p_provision_discovery_req *data,
+				size_t *out_len);
+uint8_t *p2p_build_provision_disc_resp(
+				const struct p2p_provision_discovery_resp *data,
+				size_t *out_len);
+uint8_t *p2p_build_notice_of_absence(const struct p2p_notice_of_absence *data,
+					size_t *out_len);
+uint8_t *p2p_build_presence_req(const struct p2p_presence_req *data,
+				size_t *out_len);
+uint8_t *p2p_build_presence_resp(const struct p2p_presence_resp *data,
+					size_t *out_len);
+uint8_t *p2p_build_go_disc_req(size_t *out_len);
diff --git a/src/resolve.c b/src/resolve.c
new file mode 100644
index 00000000..976f8ea3
--- /dev/null
+++ b/src/resolve.c
@@ -0,0 +1,314 @@
+/*
+ *
+ *  Wireless daemon for Linux
+ *
+ *  Copyright (C) 2019  Intel Corporation. All rights reserved.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+#include <arpa/inet.h>
+
+#include <ell/ell.h>
+
+#include "src/iwd.h"
+#include "src/dbus.h"
+#include "src/resolve.h"
+
+struct resolve_method_ops {
+	void *(*init)(void);
+	void (*exit)(void *data);
+	void (*add_dns)(uint32_t ifindex, uint8_t type, char **dns_list,
+								void *data);
+	void (*remove)(uint32_t ifindex, void *data);
+};
+
+struct resolve_method {
+	void *data;
+	const struct resolve_method_ops *ops;
+};
+
+static struct resolve_method method;
+
+#define SYSTEMD_RESOLVED_SERVICE           "org.freedesktop.resolve1"
+#define SYSTEMD_RESOLVED_MANAGER_PATH      "/org/freedesktop/resolve1"
+#define SYSTEMD_RESOLVED_MANAGER_INTERFACE "org.freedesktop.resolve1.Manager"
+
+struct systemd_state {
+	uint32_t service_watch;
+	bool is_ready:1;
+};
+
+static void systemd_link_dns_reply(struct l_dbus_message *message,
+								void *user_data)
+{
+	const char *name;
+	const char *text;
+
+	if (!l_dbus_message_is_error(message))
+		return;
+
+	l_dbus_message_get_error(message, &name, &text);
+
+	l_error("resolve-systemd: Failed to modify the DNS entries. %s: %s",
+								name, text);
+}
+
+static bool systemd_builder_add_dns(struct l_dbus_message_builder *builder,
+						uint8_t type, const char *dns)
+{
+	uint8_t buf[16];
+	uint8_t buf_size;
+	uint8_t i;
+	int t = (int) type;
+
+	l_debug("installing DNS: %s %u", dns, type);
+
+	l_dbus_message_builder_append_basic(builder, 'i', &t);
+	l_dbus_message_builder_enter_array(builder, "y");
+
+	switch (type) {
+	case AF_INET:
+		if (inet_pton(AF_INET, dns, buf) < 1)
+			return false;
+
+		buf_size = 4;
+
+		break;
+	default:
+		return false;
+	}
+
+	for (i = 0; i < buf_size; i++)
+		l_dbus_message_builder_append_basic(builder, 'y', &buf[i]);
+
+	l_dbus_message_builder_leave_array(builder);
+
+	return true;
+}
+
+static void resolve_systemd_add_dns(uint32_t ifindex, uint8_t type,
+						char **dns_list, void *data)
+{
+	struct systemd_state *state = data;
+	struct l_dbus_message_builder *builder;
+	struct l_dbus_message *message;
+
+	l_debug("ifindex: %u", ifindex);
+
+	if (!state->is_ready) {
+		l_error("resolve-systemd: Failed to add DNS entries. "
+				"Is 'systemd-resolved' service running?");
+
+		return;
+	}
+
+	message =
+		l_dbus_message_new_method_call(dbus_get_bus(),
+					SYSTEMD_RESOLVED_SERVICE,
+					SYSTEMD_RESOLVED_MANAGER_PATH,
+					SYSTEMD_RESOLVED_MANAGER_INTERFACE,
+					"SetLinkDNS");
+
+	if (!message)
+		return;
+
+	builder = l_dbus_message_builder_new(message);
+	if (!builder) {
+		l_dbus_message_unref(message);
+		return;
+	}
+
+	l_dbus_message_builder_append_basic(builder, 'i', &ifindex);
+
+	l_dbus_message_builder_enter_array(builder, "(iay)");
+
+	for (; *dns_list; dns_list++) {
+		l_dbus_message_builder_enter_struct(builder, "iay");
+
+		if (systemd_builder_add_dns(builder, type, *dns_list)) {
+			l_dbus_message_builder_leave_struct(builder);
+
+			continue;
+		}
+
+		l_dbus_message_builder_destroy(builder);
+		l_dbus_message_unref(message);
+
+		return;
+	}
+
+	l_dbus_message_builder_leave_array(builder);
+
+	l_dbus_message_builder_finalize(builder);
+	l_dbus_message_builder_destroy(builder);
+
+	l_dbus_send_with_reply(dbus_get_bus(), message, systemd_link_dns_reply,
+								state, NULL);
+}
+
+static void resolve_systemd_remove(uint32_t ifindex, void *data)
+{
+	struct systemd_state *state = data;
+	struct l_dbus_message *message;
+
+	l_debug("ifindex: %u", ifindex);
+
+	if (!state->is_ready) {
+		l_error("resolve-systemd: Failed to remove DNS entries. "
+				"Is 'systemd-resolved' service running?");
+
+		return;
+	}
+
+	message =
+		l_dbus_message_new_method_call(dbus_get_bus(),
+					SYSTEMD_RESOLVED_SERVICE,
+					SYSTEMD_RESOLVED_MANAGER_PATH,
+					SYSTEMD_RESOLVED_MANAGER_INTERFACE,
+					"RevertLink");
+	if (!message)
+		return;
+
+	l_dbus_message_set_arguments(message, "i", ifindex);
+
+	l_dbus_send_with_reply(dbus_get_bus(), message, systemd_link_dns_reply,
+								state, NULL);
+}
+
+static void systemd_appeared(struct l_dbus *dbus, void *user_data)
+{
+	struct systemd_state *state = user_data;
+
+	state->is_ready = true;
+}
+
+static void systemd_disappeared(struct l_dbus *dbus, void *user_data)
+{
+	struct systemd_state *state = user_data;
+
+	state->is_ready = false;
+}
+
+static void *resolve_systemd_init(void)
+{
+	struct systemd_state *state;
+
+	state = l_new(struct systemd_state, 1);
+
+	state->service_watch =
+		l_dbus_add_service_watch(dbus_get_bus(),
+						SYSTEMD_RESOLVED_SERVICE,
+						systemd_appeared,
+						systemd_disappeared,
+						state, NULL);
+
+	return state;
+}
+
+static void resolve_systemd_exit(void *data)
+{
+	struct systemd_state *state = data;
+
+	l_dbus_remove_watch(dbus_get_bus(), state->service_watch);
+
+	l_free(state);
+}
+
+static const struct resolve_method_ops resolve_method_systemd = {
+	.init = resolve_systemd_init,
+	.exit = resolve_systemd_exit,
+	.add_dns = resolve_systemd_add_dns,
+	.remove = resolve_systemd_remove,
+};
+
+void resolve_add_dns(uint32_t ifindex, uint8_t type, char **dns_list)
+{
+	if (!dns_list || !*dns_list)
+		return;
+
+	if (!method.ops || !method.ops->add_dns)
+		return;
+
+	method.ops->add_dns(ifindex, type, dns_list, method.data);
+}
+
+void resolve_remove(uint32_t ifindex)
+{
+	if (!method.ops || !method.ops->remove)
+		return;
+
+	method.ops->remove(ifindex, method.data);
+}
+
+static const struct {
+	const char *name;
+	const struct resolve_method_ops *method_ops;
+} resolve_method_ops_list[] = {
+	{ "systemd", &resolve_method_systemd },
+	{ }
+};
+
+static int resolve_init(void)
+{
+	const char *method_name;
+	bool enabled;
+	uint8_t i;
+
+	if (!l_settings_get_bool(iwd_get_config(), "General",
+					"enable_network_config", &enabled) ||
+								!enabled)
+		return 0;
+
+	method_name = l_settings_get_value(iwd_get_config(), "General",
+							"dns_resolve_method");
+
+	if (!method_name)
+		/* Default to systemd-resolved service. */
+		method_name = "systemd";
+
+	for (i = 0; resolve_method_ops_list[i].name; i++) {
+		if (strcmp(resolve_method_ops_list[i].name, method_name))
+			continue;
+
+		method.ops = resolve_method_ops_list[i].method_ops;
+
+		break;
+	}
+
+	if (!method.ops)
+		return -EINVAL;
+
+	if (method.ops->init)
+		method.data = method.ops->init();
+
+	return 0;
+}
+
+static void resolve_exit(void)
+{
+	if (!method.ops || !method.ops->exit)
+		return;
+
+	method.ops->exit(method.data);
+}
+
+IWD_MODULE(resolve, resolve_init, resolve_exit)
diff --git a/src/resolve.h b/src/resolve.h
new file mode 100644
index 00000000..b0335868
--- /dev/null
+++ b/src/resolve.h
@@ -0,0 +1,24 @@
+/*
+ *
+ *  Wireless daemon for Linux
+ *
+ *  Copyright (C) 2019  Intel Corporation. All rights reserved.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+void resolve_add_dns(uint32_t ifindex, uint8_t type, char **dns_list);
+void resolve_remove(uint32_t ifindex);
diff --git a/src/rfkill.c b/src/rfkill.c
index d62cca1a..34bdbde5 100644
--- a/src/rfkill.c
+++ b/src/rfkill.c
@@ -38,12 +38,6 @@
 #include "src/common.h"
 #include "src/rfkill.h"
 
-#ifdef TEMP_FAILURE_RETRY
-#define TFR TEMP_FAILURE_RETRY
-#else
-#define TFR
-#endif
-
 struct rfkill_map_entry {
 	unsigned int wiphy_id;
 	unsigned int rfkill_id;
@@ -89,14 +83,14 @@ static struct rfkill_map_entry *map_wiphy(unsigned int rfkill_id)
 
 	path = l_strdup_printf("/sys/class/rfkill/rfkill%u/device/index", rfkill_id);
 
-	fd = TFR(open(path, O_RDONLY));
+	fd = L_TFR(open(path, O_RDONLY));
 
 	l_free(path);
 
 	if (fd < 0)
 		return NULL;
 
-	bytes = TFR(read(fd, buf, sizeof(buf) - 1));
+	bytes = L_TFR(read(fd, buf, sizeof(buf) - 1));
 
 	close(fd);
 
@@ -131,7 +125,7 @@ static bool rfkill_read(struct l_io *io, void *user_data)
 	int bytes;
 	struct rfkill_map_entry *entry;
 
-	bytes = TFR(read(fd, &e, sizeof(e)));
+	bytes = L_TFR(read(fd, &e, sizeof(e)));
 	if (bytes < (int) sizeof(e)) {
 		if (bytes <= 0)
 			l_error("rfkill read: %s", strerror(errno));
@@ -208,7 +202,7 @@ bool rfkill_set_soft_state(unsigned int wiphy_id, bool state)
 	e.op = RFKILL_OP_CHANGE;
 	e.soft = state ? 1 : 0;
 
-	bytes = TFR(write(fd, &e, sizeof(e)));
+	bytes = L_TFR(write(fd, &e, sizeof(e)));
 	if (bytes < (int) sizeof(e)) {
 		if (bytes <= 0)
 			l_error("rfkill write: %s", strerror(errno));
@@ -284,7 +278,7 @@ int rfkill_init(void)
 {
 	int fd;
 
-	fd = TFR(open("/dev/rfkill", O_RDWR | O_CLOEXEC));
+	fd = L_TFR(open("/dev/rfkill", O_RDWR | O_CLOEXEC));
 	if (fd < 0)
 		return -errno;
 
diff --git a/src/rtnlutil.c b/src/rtnlutil.c
index 57196ff8..cdba33b2 100644
--- a/src/rtnlutil.c
+++ b/src/rtnlutil.c
@@ -26,6 +26,7 @@
 
 #include <sys/socket.h>
 #include <linux/rtnetlink.h>
+#include <arpa/inet.h>
 
 #include <ell/ell.h>
 
@@ -42,6 +43,18 @@ static size_t rta_add_u8(void *rta_buf, unsigned short type, uint8_t value)
 	return RTA_SPACE(sizeof(uint8_t));
 }
 
+static size_t rta_add_data(void *rta_buf, unsigned short type, void *data,
+								size_t data_len)
+{
+	struct rtattr *rta = rta_buf;
+
+	rta->rta_len = RTA_LENGTH(data_len);
+	rta->rta_type = type;
+	memcpy(RTA_DATA(rta), data, data_len);
+
+	return RTA_SPACE(data_len);
+}
+
 uint32_t rtnl_set_linkmode_and_operstate(struct l_netlink *rtnl, int ifindex,
 					uint8_t linkmode, uint8_t operstate,
 					l_netlink_command_func_t cb,
@@ -74,3 +87,167 @@ uint32_t rtnl_set_linkmode_and_operstate(struct l_netlink *rtnl, int ifindex,
 
 	return id;
 }
+
+uint32_t rtnl_set_mac(struct l_netlink *rtnl, int ifindex,
+					const uint8_t addr[static 6],
+					l_netlink_command_func_t cb,
+					void *user_data,
+					l_netlink_destroy_func_t destroy)
+{
+	struct ifinfomsg *rtmmsg;
+	void *rta_buf;
+	size_t bufsize;
+	uint32_t id;
+
+	bufsize = NLMSG_ALIGN(sizeof(struct ifinfomsg)) + RTA_SPACE(6);
+
+	rtmmsg = l_malloc(bufsize);
+	memset(rtmmsg, 0, bufsize);
+
+	rtmmsg->ifi_family = AF_UNSPEC;
+	rtmmsg->ifi_index = ifindex;
+
+	rta_buf = (void *) rtmmsg + NLMSG_ALIGN(sizeof(struct ifinfomsg));
+
+	rta_buf += rta_add_data(rta_buf, IFLA_ADDRESS, (void *) addr, 6);
+
+	id = l_netlink_send(rtnl, RTM_SETLINK, 0, rtmmsg,
+					rta_buf - (void *) rtmmsg,
+					cb, user_data, destroy);
+	l_free(rtmmsg);
+
+	return id;
+}
+
+void rtnl_ifaddr_extract(const struct ifaddrmsg *ifa, int bytes,
+				char **label, char **ip, char **broadcast)
+{
+	struct in_addr in_addr;
+	struct rtattr *attr;
+
+	for (attr = IFA_RTA(ifa); RTA_OK(attr, bytes);
+						attr = RTA_NEXT(attr, bytes)) {
+		switch (attr->rta_type) {
+		case IFA_LOCAL:
+			if (!ip)
+				break;
+
+			in_addr = *((struct in_addr *) RTA_DATA(attr));
+			*ip = l_strdup(inet_ntoa(in_addr));
+
+			break;
+		case IFA_BROADCAST:
+			if (!broadcast)
+				break;
+
+			in_addr = *((struct in_addr *) RTA_DATA(attr));
+			*broadcast = l_strdup(inet_ntoa(in_addr));
+
+			break;
+		case IFA_LABEL:
+			if (!label)
+				break;
+
+			*label = l_strdup(RTA_DATA(attr));
+			break;
+		}
+	}
+}
+
+uint32_t rtnl_ifaddr_get(struct l_netlink *rtnl, l_netlink_command_func_t cb,
+					void *user_data,
+					l_netlink_destroy_func_t destroy)
+{
+	struct ifaddrmsg *rtmmsg;
+	uint32_t id;
+
+	rtmmsg = l_malloc(sizeof(struct ifaddrmsg));
+	memset(rtmmsg, 0, sizeof(struct ifaddrmsg));
+
+	rtmmsg->ifa_family = AF_INET;
+
+	id = l_netlink_send(rtnl, RTM_GETADDR, NLM_F_DUMP, rtmmsg,
+				sizeof(struct ifaddrmsg), cb, user_data,
+				destroy);
+
+	l_free(rtmmsg);
+
+	return id;
+}
+
+static uint32_t rtnl_ifaddr_change(struct l_netlink *rtnl, uint16_t nlmsg_type,
+					int ifindex, uint8_t prefix_len,
+					const char *ip, const char *broadcast,
+					l_netlink_command_func_t
+					cb, void *user_data,
+					l_netlink_destroy_func_t destroy)
+{
+	struct ifaddrmsg *rtmmsg;
+	struct in_addr in_addr;
+	void *rta_buf;
+	size_t bufsize;
+	uint32_t id;
+
+	bufsize = NLMSG_ALIGN(sizeof(struct ifaddrmsg)) +
+					RTA_SPACE(sizeof(struct in_addr)) +
+					RTA_SPACE(sizeof(struct in_addr));
+
+	rtmmsg = l_malloc(bufsize);
+	memset(rtmmsg, 0, bufsize);
+
+	rtmmsg->ifa_index = ifindex;
+	rtmmsg->ifa_family = AF_INET;
+	rtmmsg->ifa_flags = IFA_F_PERMANENT;
+	rtmmsg->ifa_scope = RT_SCOPE_UNIVERSE;
+	rtmmsg->ifa_prefixlen = prefix_len;
+
+	rta_buf = (void *) rtmmsg + NLMSG_ALIGN(sizeof(struct ifaddrmsg));
+
+	if (inet_pton(AF_INET, ip, &in_addr) < 1) {
+		l_free(rtmmsg);
+		return 0;
+	}
+
+	rta_buf += rta_add_data(rta_buf, IFA_LOCAL, &in_addr,
+							sizeof(struct in_addr));
+
+	if (broadcast) {
+		if (inet_pton(AF_INET, broadcast, &in_addr) < 1) {
+			l_free(rtmmsg);
+			return 0;
+		}
+	} else {
+		in_addr.s_addr = in_addr.s_addr |
+					htonl(0xFFFFFFFFLU >> prefix_len);
+	}
+
+	rta_buf += rta_add_data(rta_buf, IFA_BROADCAST, &in_addr,
+							sizeof(struct in_addr));
+
+	id = l_netlink_send(rtnl, nlmsg_type, 0, rtmmsg,
+						rta_buf - (void *) rtmmsg, cb,
+						user_data, destroy);
+	l_free(rtmmsg);
+
+	return id;
+}
+
+uint32_t rtnl_ifaddr_add(struct l_netlink *rtnl, int ifindex,
+				uint8_t prefix_len, const char *ip,
+				const char *broadcast,
+				l_netlink_command_func_t cb, void *user_data,
+				l_netlink_destroy_func_t destroy)
+{
+	return rtnl_ifaddr_change(rtnl, RTM_NEWADDR, ifindex, prefix_len, ip,
+					broadcast, cb, user_data, destroy);
+}
+
+uint32_t rtnl_ifaddr_delete(struct l_netlink *rtnl, int ifindex,
+				uint8_t prefix_len, const char *ip,
+				const char *broadcast,
+				l_netlink_command_func_t cb, void *user_data,
+				l_netlink_destroy_func_t destroy)
+{
+	return rtnl_ifaddr_change(rtnl, RTM_DELADDR, ifindex, prefix_len, ip,
+					broadcast, cb, user_data, destroy);
+}
diff --git a/src/rtnlutil.h b/src/rtnlutil.h
index 0caa7179..4e1a0857 100644
--- a/src/rtnlutil.h
+++ b/src/rtnlutil.h
@@ -25,3 +25,25 @@ uint32_t rtnl_set_linkmode_and_operstate(struct l_netlink *rtnl, int ifindex,
 					l_netlink_command_func_t cb,
 					void *user_data,
 					l_netlink_destroy_func_t destroy);
+
+uint32_t rtnl_set_mac(struct l_netlink *rtnl, int ifindex,
+					const uint8_t addr[static 6],
+					l_netlink_command_func_t cb,
+					void *user_data,
+					l_netlink_destroy_func_t destroy);
+
+void rtnl_ifaddr_extract(const struct ifaddrmsg *ifa, int bytes,
+				char **label, char **ip, char **broadcast);
+uint32_t rtnl_ifaddr_get(struct l_netlink *rtnl, l_netlink_command_func_t cb,
+				void *user_data,
+				l_netlink_destroy_func_t destroy);
+uint32_t rtnl_ifaddr_add(struct l_netlink *rtnl, int ifindex,
+				uint8_t prefix_len, const char *ip,
+				const char *broadcast,
+				l_netlink_command_func_t cb, void *user_data,
+				l_netlink_destroy_func_t destroy);
+uint32_t rtnl_ifaddr_delete(struct l_netlink *rtnl, int ifindex,
+				uint8_t prefix_len, const char *ip,
+				const char *broadcast,
+				l_netlink_command_func_t cb, void *user_data,
+				l_netlink_destroy_func_t destroy);
diff --git a/src/sae.c b/src/sae.c
index fafd6731..8f9425f1 100644
--- a/src/sae.c
+++ b/src/sae.c
@@ -651,10 +651,15 @@ static void sae_process_anti_clogging(struct sae_sm *sm, const uint8_t *ptr,
 	/*
 	 * IEEE 802.11-2016 - Section 12.4.6 Anti-clogging tokens
 	 *
-	 * It is suggested that an Anti-Clogging Token not exceed 256 octets
+	 * "It is suggested that an Anti-Clogging Token not exceed 256 octets"
+	 *
+	 * Also ensure the token is at least 1 byte. The packet passed in will
+	 * contain the group number, meaning the anti-clogging token length is
+	 * going to be 2 bytes less than the passed in length. This is why we
+	 * are checking 3 > len > 258.
 	 */
-	if (len > 256) {
-		l_error("anti-clogging token size %zu too large, 256 max", len);
+	if (len < 3 || len > 258) {
+		l_error("anti-clogging token size invalid %zu", len);
 		return;
 	}
 
@@ -1031,16 +1036,17 @@ static int sae_rx_authenticate(struct auth_proto *ap,
 	 * code, as well as add the check in the verify function to allow for
 	 * this missing group number.
 	 */
-	if (len == 4 && auth->status !=
+	if (len == 4 && L_LE16_TO_CPU(auth->status) !=
 				MMPDU_STATUS_CODE_UNSUPP_FINITE_CYCLIC_GROUP)
 		goto reject;
 
-	ret = sae_verify_packet(sm, auth->transaction_sequence, auth->status,
+	ret = sae_verify_packet(sm, L_LE16_TO_CPU(auth->transaction_sequence),
+					L_LE16_TO_CPU(auth->status),
 					auth->ies, len - 6);
 	if (ret != 0)
 		return ret;
 
-	switch (auth->transaction_sequence) {
+	switch (L_LE16_TO_CPU(auth->transaction_sequence)) {
 	case SAE_STATE_COMMITTED:
 		return sae_process_commit(sm, hdr->address_2, auth->ies,
 						len - 2);
@@ -1049,7 +1055,7 @@ static int sae_rx_authenticate(struct auth_proto *ap,
 						len - 2);
 	default:
 		l_error("invalid transaction sequence %u",
-					auth->transaction_sequence);
+				L_LE16_TO_CPU(auth->transaction_sequence));
 	}
 
 reject:
@@ -1073,7 +1079,7 @@ static int sae_rx_associate(struct auth_proto *ap, const uint8_t *frame,
 	body = mmpdu_body(mpdu);
 
 	if (body->status_code != 0)
-		return (int) body->status_code;
+		return L_LE16_TO_CPU(body->status_code);
 
 	return 0;
 }
diff --git a/src/scan.c b/src/scan.c
index fd377baa..b8c790d9 100644
--- a/src/scan.c
+++ b/src/scan.c
@@ -38,11 +38,11 @@
 #include "linux/nl80211.h"
 #include "src/iwd.h"
 #include "src/wiphy.h"
-#include "src/netdev.h"
 #include "src/ie.h"
 #include "src/common.h"
 #include "src/network.h"
 #include "src/knownnetworks.h"
+#include "src/nl80211cmd.h"
 #include "src/util.h"
 #include "src/scan.h"
 
@@ -52,7 +52,6 @@
 static struct l_queue *scan_contexts;
 
 static struct l_genl_family *nl80211;
-static uint32_t scan_id;
 static uint32_t next_scan_request_id;
 
 struct scan_periodic {
@@ -77,7 +76,7 @@ struct scan_request {
 };
 
 struct scan_context {
-	uint32_t ifindex;
+	uint64_t wdev_id;
 	/*
 	 * Tells us whether a scan, our own or external, is running.
 	 * Set when scan gets triggered, cleared when scan done and
@@ -101,12 +100,12 @@ struct scan_context {
 	bool triggered:1;
 	/* Whether any commands from current request's queue have started */
 	bool started:1;
+	bool suspended:1;
 	struct wiphy *wiphy;
 };
 
 struct scan_results {
-	uint32_t wiphy;
-	uint32_t ifindex;
+	struct scan_context *sc;
 	struct l_queue *bss_list;
 	struct scan_freq_set *freqs;
 	uint64_t time_stamp;
@@ -119,9 +118,9 @@ static void scan_periodic_rearm(struct scan_context *sc);
 static bool scan_context_match(const void *a, const void *b)
 {
 	const struct scan_context *sc = a;
-	uint32_t ifindex = L_PTR_TO_UINT(b);
+	const uint64_t *wdev_id = b;
 
-	return (sc->ifindex == ifindex);
+	return sc->wdev_id == *wdev_id;
 }
 
 static bool scan_request_match(const void *a, const void *b)
@@ -157,22 +156,17 @@ static void scan_request_failed(struct scan_context *sc,
 	scan_request_free(sr);
 }
 
-static struct scan_context *scan_context_new(uint32_t ifindex)
+static struct scan_context *scan_context_new(uint64_t wdev_id)
 {
-	struct netdev *netdev = netdev_find(ifindex);
-	struct wiphy *wiphy;
+	struct wiphy *wiphy = wiphy_find(wdev_id >> 32);
 	struct scan_context *sc;
 
-	if (!netdev)
-		return NULL;
-
-	wiphy = netdev_get_wiphy(netdev);
 	if (!wiphy)
 		return NULL;
 
 	sc = l_new(struct scan_context, 1);
 
-	sc->ifindex = ifindex;
+	sc->wdev_id = wdev_id;
 	sc->wiphy = wiphy;
 	sc->state = SCAN_STATE_NOT_RUNNING;
 	sc->requests = l_queue_new();
@@ -198,41 +192,6 @@ static void scan_context_free(struct scan_context *sc)
 	l_free(sc);
 }
 
-bool scan_ifindex_add(uint32_t ifindex)
-{
-	struct scan_context *sc;
-
-	sc = l_queue_find(scan_contexts, scan_context_match,
-				L_UINT_TO_PTR(ifindex));
-
-	if (sc)
-		return false;
-
-	sc = scan_context_new(ifindex);
-	if (!sc)
-		return false;
-
-	l_queue_push_head(scan_contexts, sc);
-
-	return true;
-}
-
-bool scan_ifindex_remove(uint32_t ifindex)
-{
-	struct scan_context *sc;
-
-	sc = l_queue_remove_if(scan_contexts, scan_context_match,
-				L_UINT_TO_PTR(ifindex));
-
-	if (!sc)
-		return false;
-
-	l_info("Removing scan context for ifindex: %u", ifindex);
-	scan_context_free(sc);
-
-	return true;
-}
-
 static void scan_request_triggered(struct l_genl_msg *msg, void *userdata)
 {
 	struct scan_context *sc = userdata;
@@ -263,8 +222,8 @@ static void scan_request_triggered(struct l_genl_msg *msg, void *userdata)
 	}
 
 	sc->state = sr->passive ? SCAN_STATE_PASSIVE : SCAN_STATE_ACTIVE;
-	l_debug("%s scan triggered for ifindex: %u",
-		sr->passive ? "Passive" : "Active", sc->ifindex);
+	l_debug("%s scan triggered for wdev %" PRIx64,
+		sr->passive ? "Passive" : "Active", sc->wdev_id);
 
 	sc->triggered = true;
 	sc->started = true;
@@ -327,7 +286,7 @@ static struct l_genl_msg *scan_build_cmd(struct scan_context *sc,
 
 	msg = l_genl_msg_new(NL80211_CMD_TRIGGER_SCAN);
 
-	l_genl_msg_append_attr(msg, NL80211_ATTR_IFINDEX, 4, &sc->ifindex);
+	l_genl_msg_append_attr(msg, NL80211_ATTR_WDEV, 8, &sc->wdev_id);
 
 	if (params->extra_ie && params->extra_ie_size)
 		l_genl_msg_append_attr(msg, NL80211_ATTR_IE,
@@ -356,6 +315,10 @@ static struct l_genl_msg *scan_build_cmd(struct scan_context *sc,
 	if (flags)
 		l_genl_msg_append_attr(msg, NL80211_ATTR_SCAN_FLAGS, 4, &flags);
 
+	if (params->no_cck_rates)
+		l_genl_msg_append_attr(msg, NL80211_ATTR_TX_NO_CCK_RATE, 0,
+					NULL);
+
 	return msg;
 }
 
@@ -461,7 +424,7 @@ static int scan_request_send_trigger(struct scan_context *sc,
 	return -EIO;
 }
 
-static uint32_t scan_common(uint32_t ifindex, bool passive,
+static uint32_t scan_common(uint64_t wdev_id, bool passive,
 				const struct scan_parameters *params,
 				scan_trigger_func_t trigger,
 				scan_notify_func_t notify, void *userdata,
@@ -470,8 +433,7 @@ static uint32_t scan_common(uint32_t ifindex, bool passive,
 	struct scan_context *sc;
 	struct scan_request *sr;
 
-	sc = l_queue_find(scan_contexts, scan_context_match,
-				L_UINT_TO_PTR(ifindex));
+	sc = l_queue_find(scan_contexts, scan_context_match, &wdev_id);
 
 	if (!sc)
 		return 0;
@@ -506,17 +468,17 @@ done:
 	return sr->id;
 }
 
-uint32_t scan_passive(uint32_t ifindex, struct scan_freq_set *freqs,
+uint32_t scan_passive(uint64_t wdev_id, struct scan_freq_set *freqs,
 			scan_trigger_func_t trigger, scan_notify_func_t notify,
 			void *userdata, scan_destroy_func_t destroy)
 {
 	struct scan_parameters params = { .freqs = freqs };
 
-	return scan_common(ifindex, true, &params, trigger, notify,
+	return scan_common(wdev_id, true, &params, trigger, notify,
 							userdata, destroy);
 }
 
-uint32_t scan_active(uint32_t ifindex, uint8_t *extra_ie, size_t extra_ie_size,
+uint32_t scan_active(uint64_t wdev_id, uint8_t *extra_ie, size_t extra_ie_size,
 			scan_trigger_func_t trigger,
 			scan_notify_func_t notify, void *userdata,
 			scan_destroy_func_t destroy)
@@ -526,26 +488,27 @@ uint32_t scan_active(uint32_t ifindex, uint8_t *extra_ie, size_t extra_ie_size,
 	params.extra_ie = extra_ie;
 	params.extra_ie_size = extra_ie_size;
 
-	return scan_common(ifindex, false, &params,
+	return scan_common(wdev_id, false, &params,
 					trigger, notify, userdata, destroy);
 }
 
-uint32_t scan_active_full(uint32_t ifindex,
+uint32_t scan_active_full(uint64_t wdev_id,
 			const struct scan_parameters *params,
 			scan_trigger_func_t trigger, scan_notify_func_t notify,
 			void *userdata, scan_destroy_func_t destroy)
 {
-	return scan_common(ifindex, false, params,
+	return scan_common(wdev_id, false, params,
 					trigger, notify, userdata, destroy);
 }
 
-bool scan_cancel(uint32_t ifindex, uint32_t id)
+bool scan_cancel(uint64_t wdev_id, uint32_t id)
 {
 	struct scan_context *sc;
 	struct scan_request *sr;
 
-	sc = l_queue_find(scan_contexts, scan_context_match,
-				L_UINT_TO_PTR(ifindex));
+	l_debug("Trying to cancel scan id %u for wdev %" PRIx64, id, wdev_id);
+
+	sc = l_queue_find(scan_contexts, scan_context_match, &wdev_id);
 	if (!sc)
 		return false;
 
@@ -555,6 +518,8 @@ bool scan_cancel(uint32_t ifindex, uint32_t id)
 
 	/* If already triggered, just zero out the callback */
 	if (sr == l_queue_peek_head(sc->requests) && sc->triggered) {
+		l_debug("Scan is at the top of the queue and triggered");
+
 		sr->callback = NULL;
 
 		if (sr->destroy) {
@@ -567,6 +532,8 @@ bool scan_cancel(uint32_t ifindex, uint32_t id)
 
 	/* If we already sent the trigger command, cancel the scan */
 	if (sr == l_queue_peek_head(sc->requests)) {
+		l_debug("Scan is at the top of the queue, but not triggered");
+
 		if (sc->start_cmd_id)
 			l_genl_family_cancel(nl80211, sc->start_cmd_id);
 
@@ -574,7 +541,6 @@ bool scan_cancel(uint32_t ifindex, uint32_t id)
 			l_genl_family_cancel(nl80211, sc->get_scan_cmd_id);
 
 		sc->start_cmd_id = 0;
-		sc->get_scan_cmd_id = 0;
 		l_queue_remove(sc->requests, sr);
 		sc->started = false;
 		start_next_scan_request(sc);
@@ -594,7 +560,7 @@ static void scan_periodic_triggered(int err, void *user_data)
 		return;
 	}
 
-	l_debug("Periodic scan triggered for ifindex: %u", sc->ifindex);
+	l_debug("Periodic scan triggered for wdev %" PRIx64, sc->wdev_id);
 
 	if (sc->sp.trigger)
 		sc->sp.trigger(0, sc->sp.userdata);
@@ -627,11 +593,11 @@ static bool scan_periodic_queue(struct scan_context *sc)
 
 		sc->sp.needs_active_scan = false;
 
-		sc->sp.id = scan_active_full(sc->ifindex, &params,
+		sc->sp.id = scan_active_full(sc->wdev_id, &params,
 						scan_periodic_triggered,
 						scan_periodic_notify, sc, NULL);
 	} else
-		sc->sp.id = scan_passive(sc->ifindex, NULL,
+		sc->sp.id = scan_passive(sc->wdev_id, NULL,
 						scan_periodic_triggered,
 						scan_periodic_notify, sc, NULL);
 
@@ -650,7 +616,7 @@ static bool scan_periodic_is_disabled(void)
 	return disabled;
 }
 
-void scan_periodic_start(uint32_t ifindex, scan_trigger_func_t trigger,
+void scan_periodic_start(uint64_t wdev_id, scan_trigger_func_t trigger,
 				scan_notify_func_t func, void *userdata)
 {
 	struct scan_context *sc;
@@ -658,18 +624,17 @@ void scan_periodic_start(uint32_t ifindex, scan_trigger_func_t trigger,
 	if (scan_periodic_is_disabled())
 		return;
 
-	sc = l_queue_find(scan_contexts, scan_context_match,
-				L_UINT_TO_PTR(ifindex));
+	sc = l_queue_find(scan_contexts, scan_context_match, &wdev_id);
 
 	if (!sc) {
-		l_error("scan_periodic_start called without scan_ifindex_add");
+		l_error("scan_periodic_start called without scan_wdev_add");
 		return;
 	}
 
 	if (sc->sp.interval)
 		return;
 
-	l_debug("Starting periodic scan for ifindex: %u", ifindex);
+	l_debug("Starting periodic scan for wdev %" PRIx64, wdev_id);
 
 	sc->sp.interval = SCAN_INIT_INTERVAL;
 	sc->sp.trigger = trigger;
@@ -680,12 +645,11 @@ void scan_periodic_start(uint32_t ifindex, scan_trigger_func_t trigger,
 	scan_periodic_queue(sc);
 }
 
-bool scan_periodic_stop(uint32_t ifindex)
+bool scan_periodic_stop(uint64_t wdev_id)
 {
 	struct scan_context *sc;
 
-	sc = l_queue_find(scan_contexts, scan_context_match,
-				L_UINT_TO_PTR(ifindex));
+	sc = l_queue_find(scan_contexts, scan_context_match, &wdev_id);
 
 	if (!sc)
 		return false;
@@ -693,13 +657,13 @@ bool scan_periodic_stop(uint32_t ifindex)
 	if (!sc->sp.interval)
 		return false;
 
-	l_debug("Stopping periodic scan for ifindex: %u", ifindex);
+	l_debug("Stopping periodic scan for wdev %" PRIx64, wdev_id);
 
 	if (sc->sp.timeout)
 		l_timeout_remove(sc->sp.timeout);
 
 	if (sc->sp.id) {
-		scan_cancel(ifindex, sc->sp.id);
+		scan_cancel(wdev_id, sc->sp.id);
 		sc->sp.id = 0;
 	}
 
@@ -717,7 +681,7 @@ static void scan_periodic_timeout(struct l_timeout *timeout, void *user_data)
 {
 	struct scan_context *sc = user_data;
 
-	l_debug("scan_periodic_timeout: %u", sc->ifindex);
+	l_debug("scan_periodic_timeout: %" PRIx64, sc->wdev_id);
 
 	sc->sp.interval *= 2;
 
@@ -747,6 +711,9 @@ static bool start_next_scan_request(struct scan_context *sc)
 {
 	struct scan_request *sr = l_queue_peek_head(sc->requests);
 
+	if (sc->suspended)
+		return true;
+
 	if (sc->state != SCAN_STATE_NOT_RUNNING)
 		return true;
 
@@ -767,6 +734,70 @@ static bool start_next_scan_request(struct scan_context *sc)
 	return false;
 }
 
+static bool scan_parse_vendor_specific(struct scan_bss *bss, const void *data,
+					uint16_t len)
+{
+	if (!bss->wpa && is_ie_wpa_ie(data, len))
+		bss->wpa = l_memdup(data - 2, len + 2);
+	else if (!bss->osen && is_ie_wfa_ie(data, len, IE_WFA_OI_OSEN))
+		bss->osen = l_memdup(data - 2, len + 2);
+	else if (is_ie_wfa_ie(data, len, IE_WFA_OI_HS20_INDICATION))
+		bss->hs20_ie = l_memdup(data - 2, len + 2);
+	else
+		return false;
+
+	return true;
+}
+
+/*
+ * Fully parses the Advertisement Protocol Element. The only thing being looked
+ * for is the ANQP protocol ID, but this could be burried behind several other
+ * advertisement tuples so the entire IE may need to be parsed.
+ */
+static bool scan_parse_advertisement_protocol(struct scan_bss *bss,
+						const void *data, uint16_t len)
+{
+	const uint8_t *ptr = data;
+
+	l_debug("");
+
+	while (len) {
+		/*
+		 * TODO: Store query info for GAS response length verification
+		 */
+		uint8_t id = ptr[1];
+
+		switch (id) {
+		/*
+		 * IEEE 802.11-2016 Section 11.25.3.3.1
+		 *
+		 * "A non-AP STA shall not transmit an ANQP request to
+		 * an AP for any ANQP-element unless the ANQP
+		 * Advertisement Protocol ID is included..."
+		 */
+		case IE_ADVERTISEMENT_ANQP:
+			bss->anqp_capable = true;
+			return true;
+		case IE_ADVERTISEMENT_MIH_SERVICE:
+		case IE_ADVERTISEMENT_MIH_DISCOVERY:
+		case IE_ADVERTISEMENT_EAS:
+		case IE_ADVERTISEMENT_RLQP:
+			len -= 2;
+			ptr += 2;
+			break;
+		case IE_ADVERTISEMENT_VENDOR_SPECIFIC:
+			/* IEEE 802.11-2016 Section 9.4.2.26 */
+			len -= ptr[3];
+			ptr += ptr[3];
+			break;
+		default:
+			return false;
+		}
+	}
+
+	return true;
+}
+
 static bool scan_parse_bss_information_elements(struct scan_bss *bss,
 					const void *data, uint16_t len)
 {
@@ -814,10 +845,8 @@ static bool scan_parse_bss_information_elements(struct scan_bss *bss,
 
 			break;
 		case IE_TYPE_VENDOR_SPECIFIC:
-			/* Interested only in WPA IE from Vendor data */
-			if (!bss->wpa && is_ie_wpa_ie(iter.data, iter.len))
-				bss->wpa = l_memdup(iter.data - 2,
-								iter.len + 2);
+			/* Interested only in WPA/WFA IE from Vendor data */
+			scan_parse_vendor_specific(bss, iter.data, iter.len);
 			break;
 		case IE_TYPE_MOBILITY_DOMAIN:
 			if (!bss->mde_present && iter.len == 3) {
@@ -860,6 +889,31 @@ static bool scan_parse_bss_information_elements(struct scan_bss *bss,
 			bss->vht_capable = true;
 			memcpy(bss->vht_ie, iter.data - 2, iter.len + 2);
 
+			break;
+		case IE_TYPE_ADVERTISEMENT_PROTOCOL:
+			if (iter.len < 2)
+				return false;
+
+			scan_parse_advertisement_protocol(bss, iter.data,
+								iter.len);
+			break;
+		case IE_TYPE_INTERWORKING:
+			/*
+			 * No bits indicate if venue/HESSID is included, so the
+			 * length is the only way to know.
+			 * (IEEE 802.11-2016 - Figure 9-439)
+			 */
+			if (iter.len == 9)
+				memcpy(bss->hessid, iter.data + 3, 6);
+			else if (iter.len == 7)
+				memcpy(bss->hessid, iter.data + 1, 6);
+			break;
+		case IE_TYPE_ROAMING_CONSORTIUM:
+			if (iter.len < 2)
+				return false;
+
+			bss->rc_ie = l_memdup(iter.data - 2, iter.len + 2);
+
 			break;
 		}
 	}
@@ -909,6 +963,8 @@ static struct scan_bss *scan_parse_attr_bss(struct l_genl_attr *attr)
 
 			bss->wsc = ie_tlv_extract_wsc_payload(data, len,
 								&bss->wsc_size);
+			bss->p2p = ie_tlv_extract_p2p_payload(data, len,
+								&bss->p2p_size);
 
 			break;
 		}
@@ -944,14 +1000,12 @@ static struct scan_freq_set *scan_parse_attr_scan_frequencies(
 }
 
 static struct scan_bss *scan_parse_result(struct l_genl_msg *msg,
-					uint32_t *out_ifindex,
-					uint64_t *out_wdev)
+						uint64_t *out_wdev)
 {
 	struct l_genl_attr attr, nested;
 	uint16_t type, len;
 	const void *data;
-	uint32_t ifindex;
-	uint64_t wdev;
+	const uint64_t *wdev = NULL;
 	struct scan_bss *bss = NULL;
 
 	if (!l_genl_attr_init(&attr, msg))
@@ -959,18 +1013,11 @@ static struct scan_bss *scan_parse_result(struct l_genl_msg *msg,
 
 	while (l_genl_attr_next(&attr, &type, &len, &data)) {
 		switch (type) {
-		case NL80211_ATTR_IFINDEX:
-			if (len != sizeof(uint32_t))
-				return NULL;
-
-			ifindex = *((uint32_t *) data);
-			break;
-
 		case NL80211_ATTR_WDEV:
 			if (len != sizeof(uint64_t))
 				return NULL;
 
-			wdev = *((uint64_t *) data);
+			wdev = data;
 			break;
 
 		case NL80211_ATTR_BSS:
@@ -985,11 +1032,13 @@ static struct scan_bss *scan_parse_result(struct l_genl_msg *msg,
 	if (!bss)
 		return NULL;
 
-	if (out_ifindex)
-		*out_ifindex = ifindex;
+	if (!wdev) {
+		scan_bss_free(bss);
+		return NULL;
+	}
 
 	if (out_wdev)
-		*out_wdev = wdev;
+		*out_wdev = *wdev;
 
 	return bss;
 }
@@ -1080,6 +1129,10 @@ void scan_bss_free(struct scan_bss *bss)
 	l_free(bss->rsne);
 	l_free(bss->wpa);
 	l_free(bss->wsc);
+	l_free(bss->p2p);
+	l_free(bss->osen);
+	l_free(bss->rc_ie);
+	l_free(bss->hs20_ie);
 	l_free(bss);
 }
 
@@ -1105,6 +1158,14 @@ int scan_bss_get_rsn_info(const struct scan_bss *bss, struct ie_rsn_info *info)
 					res, strerror(-res));
 			return res;
 		}
+	} else if (bss->osen) {
+		int res = ie_parse_osen_from_data(bss->osen, bss->osen[1] + 2,
+							info);
+		if (res < 0) {
+			l_debug("Cannot parse OSEN IE (%d, %s)",
+					res, strerror(-res));
+			return res;
+		}
 	} else
 		return -ENOENT;
 
@@ -1121,20 +1182,21 @@ int scan_bss_rank_compare(const void *a, const void *b, void *user_data)
 static void get_scan_callback(struct l_genl_msg *msg, void *user_data)
 {
 	struct scan_results *results = user_data;
+	struct scan_context *sc = results->sc;
 	struct scan_bss *bss;
-	uint32_t ifindex;
+	uint64_t wdev_id;
 
 	l_debug("get_scan_callback");
 
 	if (!results->bss_list)
 		results->bss_list = l_queue_new();
 
-	bss = scan_parse_result(msg, &ifindex, NULL);
+	bss = scan_parse_result(msg, &wdev_id);
 	if (!bss)
 		return;
 
-	if (ifindex != results->ifindex) {
-		l_warn("ifindex mismatch in get_scan_callback");
+	if (wdev_id != sc->wdev_id) {
+		l_warn("wdev mismatch in get_scan_callback");
 		scan_bss_free(bss);
 		return;
 	}
@@ -1161,7 +1223,7 @@ static void discover_hidden_network_bsses(struct scan_context *sc,
 	}
 }
 
-static void scan_finished(struct scan_context *sc, uint32_t wiphy,
+static void scan_finished(struct scan_context *sc,
 				int err, struct l_queue *bss_list,
 				struct scan_request *sr)
 {
@@ -1174,6 +1236,9 @@ static void scan_finished(struct scan_context *sc, uint32_t wiphy,
 		l_queue_remove(sc->requests, sr);
 		sc->started = false;
 
+		if (sr->callback)
+			new_owner = sr->callback(err, bss_list, sr->userdata);
+
 		/*
 		 * Can start a new scan now that we've removed this one from
 		 * the queue.  If this were an external scan request (sr NULL)
@@ -1183,9 +1248,6 @@ static void scan_finished(struct scan_context *sc, uint32_t wiphy,
 		 */
 		start_next_scan_request(sc);
 
-		if (sr->callback)
-			new_owner = sr->callback(err, bss_list, sr->userdata);
-
 		scan_request_free(sr);
 	} else if (sc->sp.callback)
 		new_owner = sc->sp.callback(err, bss_list, sc->sp.userdata);
@@ -1198,15 +1260,14 @@ static void scan_finished(struct scan_context *sc, uint32_t wiphy,
 static void get_scan_done(void *user)
 {
 	struct scan_results *results = user;
-	struct scan_context *sc;
+	struct scan_context *sc = results->sc;
 
 	l_debug("get_scan_done");
 
-	sc = l_queue_find(scan_contexts, scan_context_match,
-					L_UINT_TO_PTR(results->ifindex));
-	if (sc)
-		scan_finished(sc, results->wiphy, 0, results->bss_list,
-				results->sr);
+	sc->get_scan_cmd_id = 0;
+
+	if (l_queue_peek_head(sc->requests) == results->sr)
+		scan_finished(sc, 0, results->bss_list, results->sr);
 	else
 		l_queue_destroy(results->bss_list,
 				(l_queue_destroy_func_t) scan_bss_free);
@@ -1264,8 +1325,8 @@ static void scan_notify(struct l_genl_msg *msg, void *user_data)
 	uint16_t type, len;
 	const void *data;
 	uint8_t cmd;
-	uint32_t uninitialized_var(attr_ifindex);
-	bool have_ifindex;
+	uint64_t uninitialized_var(attr_wdev_id);
+	bool have_wdev_id;
 	uint32_t uninitialized_var(attr_wiphy);
 	bool have_wiphy;
 	struct scan_context *sc;
@@ -1273,7 +1334,7 @@ static void scan_notify(struct l_genl_msg *msg, void *user_data)
 
 	cmd = l_genl_msg_get_command(msg);
 
-	l_debug("Scan notification %u", cmd);
+	l_debug("Scan notification %s(%u)", nl80211cmd_to_string(cmd), cmd);
 
 	if (!l_genl_attr_init(&attr, msg))
 		return;
@@ -1289,14 +1350,14 @@ static void scan_notify(struct l_genl_msg *msg, void *user_data)
 			have_wiphy = true;
 			attr_wiphy = *((uint32_t *) data);
 			break;
-		case NL80211_ATTR_IFINDEX:
-			if (len != sizeof(uint32_t)) {
-				l_warn("Invalid interface index attribute");
+		case NL80211_ATTR_WDEV:
+			if (len != sizeof(uint64_t)) {
+				l_warn("Invalid wdev index attribute");
 				return;
 			}
 
-			have_ifindex = true;
-			attr_ifindex = *((uint32_t *) data);
+			have_wdev_id = true;
+			attr_wdev_id = *((uint64_t *) data);
 			break;
 		case NL80211_ATTR_SCAN_SSIDS:
 			active_scan = true;
@@ -1309,13 +1370,12 @@ static void scan_notify(struct l_genl_msg *msg, void *user_data)
 		return;
 	}
 
-	if (!have_ifindex) {
-		l_warn("Scan results do not contain ifindex attribute");
+	if (!have_wdev_id) {
+		l_warn("Scan results do not contain wdev attribute");
 		return;
 	}
 
-	sc = l_queue_find(scan_contexts, scan_context_match,
-					L_UINT_TO_PTR(attr_ifindex));
+	sc = l_queue_find(scan_contexts, scan_context_match, &attr_wdev_id);
 	if (!sc)
 		return;
 
@@ -1335,13 +1395,13 @@ static void scan_notify(struct l_genl_msg *msg, void *user_data)
 
 		/* Was this our own scan or an external scan */
 		if (sc->triggered) {
+			sc->triggered = false;
+
 			if (!sr->callback) {
-				scan_finished(sc, attr_wiphy, -ECANCELED, NULL, sr);
+				scan_finished(sc, -ECANCELED, NULL, sr);
 				break;
 			}
 
-			sc->triggered = false;
-
 			/*
 			 * If this was the last command for the current request
 			 * avoid starting the next request until the GET_SCAN
@@ -1361,7 +1421,7 @@ static void scan_notify(struct l_genl_msg *msg, void *user_data)
 
 			/* An external scan may have flushed our results */
 			if (sc->started && scan_parse_flush_flag_from_msg(msg))
-				scan_finished(sc, attr_wiphy, -EAGAIN, NULL, sr);
+				scan_finished(sc, -EAGAIN, NULL, sr);
 			else if (sr && !sc->start_cmd_id)
 				send_next = true;
 
@@ -1376,18 +1436,18 @@ static void scan_notify(struct l_genl_msg *msg, void *user_data)
 			break;
 
 		results = l_new(struct scan_results, 1);
-		results->wiphy = attr_wiphy;
-		results->ifindex = attr_ifindex;
+		results->sc = sc;
 		results->time_stamp = l_time_now();
 		results->sr = sr;
 
 		scan_parse_new_scan_results(msg, results);
 
 		scan_msg = l_genl_msg_new_sized(NL80211_CMD_GET_SCAN, 8);
-		l_genl_msg_append_attr(scan_msg, NL80211_ATTR_IFINDEX, 4,
-						&attr_ifindex);
-		l_genl_family_dump(nl80211, scan_msg, get_scan_callback,
-					results, get_scan_done);
+		l_genl_msg_append_attr(scan_msg, NL80211_ATTR_WDEV, 8,
+					&sc->wdev_id);
+		sc->get_scan_cmd_id = l_genl_family_dump(nl80211, scan_msg,
+							get_scan_callback,
+							results, get_scan_done);
 
 		break;
 	}
@@ -1412,7 +1472,7 @@ static void scan_notify(struct l_genl_msg *msg, void *user_data)
 		if (sc->triggered) {
 			sc->triggered = false;
 
-			scan_finished(sc, attr_wiphy, -ECANCELED, NULL,
+			scan_finished(sc, -ECANCELED, NULL,
 					l_queue_peek_head(sc->requests));
 		} else if (sr && !sc->start_cmd_id && !sc->get_scan_cmd_id) {
 			/*
@@ -1775,45 +1835,95 @@ void scan_freq_set_constrain(struct scan_freq_set *set,
 	set->channels_2ghz &= constraint->channels_2ghz;
 }
 
-bool scan_init(struct l_genl_family *in)
+bool scan_wdev_add(uint64_t wdev_id)
 {
-	const struct l_settings *config = iwd_get_config();
+	struct scan_context *sc;
 
-	nl80211 = in;
-	scan_id = l_genl_family_register(nl80211, "scan", scan_notify,
-						NULL, NULL);
+	if (l_queue_find(scan_contexts, scan_context_match, &wdev_id))
+		return false;
 
-	if (!scan_id) {
-		l_error("Registering for scan notification failed");
+	sc = scan_context_new(wdev_id);
+	if (!sc)
 		return false;
-	}
 
-	scan_contexts = l_queue_new();
+	l_queue_push_head(scan_contexts, sc);
 
-	if (!l_settings_get_double(config, "Rank", "rank_5g_factor",
-					&RANK_5G_FACTOR))
-		RANK_5G_FACTOR = 1.0;
+	if (l_queue_length(scan_contexts) > 1)
+		goto done;
+
+	nl80211 = l_genl_family_new(iwd_get_genl(), NL80211_GENL_NAME);
+	l_genl_family_register(nl80211, "scan", scan_notify, NULL, NULL);
 
+done:
 	return true;
 }
 
-bool scan_exit()
+bool scan_wdev_remove(uint64_t wdev_id)
 {
-	bool r;
+	struct scan_context *sc;
 
-	l_debug("");
+	sc = l_queue_remove_if(scan_contexts, scan_context_match, &wdev_id);
 
-	if (!nl80211)
+	if (!sc)
 		return false;
 
-	l_queue_destroy(scan_contexts,
-				(l_queue_destroy_func_t) scan_context_free);
-	scan_contexts = NULL;
+	l_info("Removing scan context for wdev %" PRIx64, wdev_id);
+	scan_context_free(sc);
+
+	if (l_queue_isempty(scan_contexts)) {
+		l_genl_family_free(nl80211);
+		nl80211 = NULL;
+	}
+
+	return true;
+}
+
+bool scan_suspend(uint64_t wdev_id)
+{
+	struct scan_context *sc;
+
+	sc = l_queue_find(scan_contexts, scan_context_match, &wdev_id);
+	if (!sc)
+		return false;
+
+	sc->suspended = true;
+
+	return true;
+}
+
+void scan_resume(uint64_t wdev_id)
+{
+	struct scan_context *sc;
+
+	sc = l_queue_find(scan_contexts, scan_context_match, &wdev_id);
+	if (!sc)
+		return;
+
+	sc->suspended = false;
+
+	start_next_scan_request(sc);
+}
+
+static int scan_init(void)
+{
+	const struct l_settings *config = iwd_get_config();
+
+	scan_contexts = l_queue_new();
 
-	r = l_genl_family_unregister(nl80211, scan_id);
-	scan_id = 0;
+	if (!l_settings_get_double(config, "Rank", "rank_5g_factor",
+					&RANK_5G_FACTOR))
+		RANK_5G_FACTOR = 1.0;
 
-	nl80211 = 0;
+	return 0;
+}
 
-	return r;
+static void scan_exit()
+{
+	l_queue_destroy(scan_contexts,
+				(l_queue_destroy_func_t) scan_context_free);
+	scan_contexts = NULL;
+	l_genl_family_free(nl80211);
+	nl80211 = NULL;
 }
+
+IWD_MODULE(scan, scan_init, scan_exit)
diff --git a/src/scan.h b/src/scan.h
index ce7a1a34..4d482681 100644
--- a/src/scan.h
+++ b/src/scan.h
@@ -48,8 +48,11 @@ struct scan_bss {
 	uint16_t capability;
 	uint8_t *rsne;
 	uint8_t *wpa;
+	uint8_t *osen;
 	uint8_t *wsc;		/* Concatenated WSC IEs */
 	ssize_t wsc_size;	/* Size of Concatenated WSC IEs */
+	uint8_t *p2p;		/* Concatenated P2P IEs */
+	ssize_t p2p_size;	/* Size of Concatenated P2P IEs */
 	uint8_t mde[3];
 	uint8_t ssid[32];
 	uint8_t ssid_len;
@@ -61,12 +64,16 @@ struct scan_bss {
 	uint8_t ht_ie[28];
 	uint8_t vht_ie[14];
 	uint64_t time_stamp;
+	uint8_t hessid[6];
+	uint8_t *rc_ie;		/* Roaming consortium IE */
+	uint8_t *hs20_ie;
 	bool mde_present : 1;
 	bool cc_present : 1;
 	bool cap_rm_neighbor_report : 1;
 	bool has_sup_rates : 1;
 	bool ht_capable : 1;
 	bool vht_capable : 1;
+	bool anqp_capable : 1;
 };
 
 struct scan_parameters {
@@ -75,37 +82,38 @@ struct scan_parameters {
 	struct scan_freq_set *freqs;
 	bool flush : 1;
 	bool randomize_mac_addr_hint : 1;
+	bool no_cck_rates : 1;
 	const char *ssid;	/* Used for direct probe request */
 };
 
 static inline int scan_bss_addr_cmp(const struct scan_bss *a1,
 					const struct scan_bss *a2)
 {
-        return memcmp(a1->addr, a2->addr, sizeof(a1->addr));
+	return memcmp(a1->addr, a2->addr, sizeof(a1->addr));
 }
 
 static inline bool scan_bss_addr_eq(const struct scan_bss *a1,
 					const struct scan_bss *a2)
 {
-        return !memcmp(a1->addr, a2->addr, sizeof(a1->addr));
+	return !memcmp(a1->addr, a2->addr, sizeof(a1->addr));
 }
 
-uint32_t scan_passive(uint32_t ifindex, struct scan_freq_set *freqs,
+uint32_t scan_passive(uint64_t wdev_id, struct scan_freq_set *freqs,
 			scan_trigger_func_t trigger, scan_notify_func_t notify,
 			void *userdata, scan_destroy_func_t destroy);
-uint32_t scan_active(uint32_t ifindex, uint8_t *extra_ie, size_t extra_ie_size,
+uint32_t scan_active(uint64_t wdev_id, uint8_t *extra_ie, size_t extra_ie_size,
 			scan_trigger_func_t trigger,
 			scan_notify_func_t notify, void *userdata,
 			scan_destroy_func_t destroy);
-uint32_t scan_active_full(uint32_t ifindex,
+uint32_t scan_active_full(uint64_t wdev_id,
 			const struct scan_parameters *params,
 			scan_trigger_func_t trigger, scan_notify_func_t notify,
 			void *userdata, scan_destroy_func_t destroy);
-bool scan_cancel(uint32_t ifindex, uint32_t id);
+bool scan_cancel(uint64_t wdev_id, uint32_t id);
 
-void scan_periodic_start(uint32_t ifindex, scan_trigger_func_t trigger,
+void scan_periodic_start(uint64_t wdev_id, scan_trigger_func_t trigger,
 				scan_notify_func_t func, void *userdata);
-bool scan_periodic_stop(uint32_t ifindex);
+bool scan_periodic_stop(uint64_t wdev_id);
 
 void scan_bss_free(struct scan_bss *bss);
 int scan_bss_rank_compare(const void *a, const void *b, void *user);
@@ -129,8 +137,8 @@ void scan_freq_set_merge(struct scan_freq_set *to,
 void scan_freq_set_constrain(struct scan_freq_set *set,
 					const struct scan_freq_set *constraint);
 
-bool scan_ifindex_add(uint32_t ifindex);
-bool scan_ifindex_remove(uint32_t ifindex);
+bool scan_wdev_add(uint64_t wdev_id);
+bool scan_wdev_remove(uint64_t wdev_id);
 
-bool scan_init(struct l_genl_family *in);
-bool scan_exit();
+bool scan_suspend(uint64_t wdev_id);
+void scan_resume(uint64_t wdev_id);
diff --git a/src/simauth.c b/src/simauth.c
index 4244304a..51f2bdbe 100644
--- a/src/simauth.c
+++ b/src/simauth.c
@@ -179,15 +179,18 @@ void sim_auth_cancel_request(struct iwd_sim_auth *auth, int id)
 		auth->driver->cancel_request(auth, id);
 }
 
-void sim_auth_init(void)
+static int sim_auth_init(void)
 {
 	auth_providers = l_queue_new();
+	return 0;
 }
 
-void sim_auth_exit(void)
+static void sim_auth_exit(void)
 {
 	if (l_queue_length(auth_providers) > 0)
 		l_warn("Auth provider queue was not empty on exit!");
 
 	l_queue_destroy(auth_providers, destroy_provider);
 }
+
+IWD_MODULE(simauth, sim_auth_init, sim_auth_exit)
diff --git a/src/station.c b/src/station.c
index 36eac34c..593b05b0 100644
--- a/src/station.c
+++ b/src/station.c
@@ -50,6 +50,10 @@
 #include "src/blacklist.h"
 #include "src/mpdu.h"
 #include "src/erp.h"
+#include "src/netconfig.h"
+#include "src/anqp.h"
+#include "src/anqputil.h"
+#include "src/hotspot.h"
 
 static struct l_queue *station_list;
 static uint32_t netdev_watch;
@@ -81,6 +85,8 @@ struct station {
 	struct wiphy *wiphy;
 	struct netdev *netdev;
 
+	struct l_queue *anqp_pending;
+
 	bool preparing_roam : 1;
 	bool signal_low : 1;
 	bool roam_no_orig_ap : 1;
@@ -89,6 +95,12 @@ struct station {
 	bool autoconnect : 1;
 };
 
+struct anqp_entry {
+	struct station *station;
+	struct network *network;
+	uint32_t pending;
+};
+
 struct wiphy *station_get_wiphy(struct station *station)
 {
 	return station->wiphy;
@@ -200,10 +212,6 @@ static void station_add_autoconnect_bss(struct station *station,
 static void bss_free(void *data)
 {
 	struct scan_bss *bss = data;
-	const char *addr;
-
-	addr = util_address_to_string(bss->addr);
-	l_debug("Freeing BSS %s", addr);
 
 	scan_bss_free(bss);
 }
@@ -391,6 +399,124 @@ static void station_bss_list_remove_expired_bsses(struct station *station)
 	l_queue_foreach_remove(station->bss_list, bss_free_if_expired, &data);
 }
 
+static void station_anqp_response_cb(enum anqp_result result,
+					const void *anqp, size_t anqp_len,
+					void *user_data)
+{
+	struct anqp_entry *entry = user_data;
+	struct station *station = entry->station;
+	struct network *network = entry->network;
+	struct anqp_iter iter;
+	uint16_t id;
+	uint16_t len;
+	const void *data;
+	char **realms = NULL;
+
+	entry->pending = 0;
+
+	l_debug("");
+
+	if (result == ANQP_TIMEOUT) {
+		l_queue_remove(station->anqp_pending, entry);
+		/* TODO: try next BSS */
+		goto request_done;
+	}
+
+	anqp_iter_init(&iter, anqp, anqp_len);
+
+	while (anqp_iter_next(&iter, &id, &len, &data)) {
+		switch (id) {
+		case ANQP_NAI_REALM:
+			if (realms)
+				break;
+
+			realms = anqp_parse_nai_realms(data, len);
+			if (!realms)
+				goto request_done;
+
+			break;
+		default:
+			continue;
+		}
+	}
+
+	network_set_nai_realms(network, realms);
+
+request_done:
+	l_queue_remove(station->anqp_pending, entry);
+
+	/* If no more requests, resume scanning */
+	if (l_queue_isempty(station->anqp_pending))
+		scan_resume(netdev_get_wdev_id(station->netdev));
+}
+
+static bool station_start_anqp(struct station *station, struct network *network,
+					struct scan_bss *bss)
+{
+	uint8_t anqp[256];
+	uint8_t *ptr = anqp;
+	struct anqp_entry *entry;
+	bool anqp_disabled = true;
+
+	if (!bss->hs20_ie)
+		return false;
+
+	/* Network already has ANQP data/HESSID */
+	if (hs20_find_settings_file(network))
+		return false;
+
+	l_settings_get_bool(iwd_get_config(), "General", "disable_anqp",
+				&anqp_disabled);
+
+	if (anqp_disabled) {
+		l_debug("Not querying AP for ANQP data (disabled)");
+		return false;
+	}
+
+	entry = l_new(struct anqp_entry, 1);
+	entry->station = station;
+	entry->network = network;
+
+	l_put_le16(ANQP_QUERY_LIST, ptr);
+	ptr += 2;
+	l_put_le16(2, ptr);
+	ptr += 2;
+	l_put_le16(ANQP_NAI_REALM, ptr);
+	ptr += 2;
+	l_put_le16(ANQP_VENDOR_SPECIFIC, ptr);
+	ptr += 2;
+	/* vendor length */
+	l_put_le16(7, ptr);
+	ptr += 2;
+	*ptr++ = 0x50;
+	*ptr++ = 0x6f;
+	*ptr++ = 0x9a;
+	*ptr++ = 0x11; /* HS20 ANQP Element type */
+	*ptr++ = ANQP_HS20_QUERY_LIST;
+	*ptr++ = 0; /* reserved */
+	*ptr++ = ANQP_HS20_OSU_PROVIDERS_NAI_LIST;
+
+	/*
+	 * TODO: Additional roaming consortiums can be queried if indicated
+	 * by the roaming consortium IE. The IE contains up to the first 3, and
+	 * these are checked in hs20_find_settings_file.
+	 */
+
+	entry->pending = anqp_request(netdev_get_ifindex(station->netdev),
+					netdev_get_address(station->netdev),
+					bss, anqp, ptr - anqp,
+					station_anqp_response_cb,
+					entry, l_free);
+	if (!entry->pending) {
+		l_free(entry);
+		return false;
+	}
+
+	l_queue_push_head(station->anqp_pending, entry);
+
+	return true;
+}
+
 /*
  * Used when scan results were obtained; either from scan running
  * inside station module or scans running in other state machines, e.g. wsc
@@ -401,6 +527,7 @@ void station_set_scan_results(struct station *station,
 {
 	const struct l_queue_entry *bss_entry;
 	struct network *network;
+	bool wait_for_anqp = false;
 
 	while ((network = l_queue_pop_head(station->networks_sorted)))
 		network_bss_list_clear(network);
@@ -442,7 +569,13 @@ void station_set_scan_results(struct station *station,
 		struct scan_bss *bss = bss_entry->data;
 		struct network *network = station_add_seen_bss(station, bss);
 
-		if (!network || !add_to_autoconnect)
+		if (!network)
+			continue;
+
+		if (station_start_anqp(station, network, bss))
+			wait_for_anqp = true;
+
+		if (!add_to_autoconnect)
 			continue;
 
 		station_add_autoconnect_bss(station, network, bss);
@@ -451,6 +584,19 @@ void station_set_scan_results(struct station *station,
 	station->bss_list = new_bss_list;
 
 	l_hashmap_foreach_remove(station->networks, process_network, station);
+
+	/*
+	 * ANQP requests are scheduled in the same manor as scans, and cannot
+	 * be done simultaneously. To avoid long queue times (waiting for a
+	 * scan to finish) its best to stop scanning, do ANQP, then resume
+	 * scanning.
+	 *
+	 * TODO: It may be possible for some hardware to actually scan and do
+	 * ANQP at the same time. Detecting this could allow us to continue
+	 * scanning.
+	 */
+	if (wait_for_anqp)
+		scan_suspend(netdev_get_wdev_id(station->netdev));
 }
 
 static void station_reconnect(struct station *station);
@@ -543,6 +689,7 @@ static int station_build_handshake_rsn(struct handshake_state *hs,
 	uint8_t rsne_buf[256];
 	struct ie_rsn_info info;
 	uint32_t mfp_setting;
+	uint8_t *ap_ie;
 
 	memset(&info, 0, sizeof(info));
 
@@ -582,6 +729,13 @@ static int station_build_handshake_rsn(struct handshake_state *hs,
 	if (!info.pairwise_ciphers || !info.group_cipher)
 		goto not_supported;
 
+	/* Management frame protection is explicitly off for OSEN */
+	if (info.akm_suites & IE_RSN_AKM_SUITE_OSEN) {
+		info.group_management_cipher =
+					IE_RSN_CIPHER_SUITE_NO_GROUP_TRAFFIC;
+		goto build_ie;
+	}
+
 	if (!l_settings_get_uint(settings, "General",
 			"ManagementFrameProtection", &mfp_setting))
 		mfp_setting = 1;
@@ -620,20 +774,31 @@ static int station_build_handshake_rsn(struct handshake_state *hs,
 	if (bss_info.mfpr && !info.mfpc)
 		goto not_supported;
 
+build_ie:
 	/* RSN takes priority */
 	if (bss->rsne) {
+		ap_ie = bss->rsne;
 		ie_build_rsne(&info, rsne_buf);
-		handshake_state_set_authenticator_rsn(hs, bss->rsne);
-		handshake_state_set_supplicant_rsn(hs, rsne_buf);
-	} else {
+	} else if (bss->wpa) {
+		ap_ie = bss->wpa;
 		ie_build_wpa(&info, rsne_buf);
-		handshake_state_set_authenticator_wpa(hs, bss->wpa);
-		handshake_state_set_supplicant_wpa(hs, rsne_buf);
-	}
+	} else if (bss->osen) {
+		ap_ie = bss->osen;
+		ie_build_osen(&info, rsne_buf);
+	} else
+		goto not_supported;
+
+	if (!handshake_state_set_authenticator_ie(hs, ap_ie))
+		goto not_supported;
+
+	if (!handshake_state_set_supplicant_ie(hs, rsne_buf))
+		goto not_supported;
 
 	if (info.akm_suites & (IE_RSN_AKM_SUITE_FT_OVER_8021X |
 				IE_RSN_AKM_SUITE_FT_USING_PSK |
-				IE_RSN_AKM_SUITE_FT_OVER_SAE_SHA256))
+				IE_RSN_AKM_SUITE_FT_OVER_SAE_SHA256 |
+				IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256 |
+				IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384))
 		add_mde = true;
 
 open_network:
@@ -663,9 +828,11 @@ static struct handshake_state *station_handshake_setup(struct station *station,
 							struct scan_bss *bss)
 {
 	enum security security = network_get_security(network);
+	struct l_settings *settings = network_get_settings(network);
 	struct wiphy *wiphy = station->wiphy;
 	struct handshake_state *hs;
 	const char *ssid;
+	uint32_t eapol_proto_version;
 
 	hs = netdev_handshake_state_new(station->netdev);
 
@@ -677,6 +844,21 @@ static struct handshake_state *station_handshake_setup(struct station *station,
 	ssid = network_get_ssid(network);
 	handshake_state_set_ssid(hs, (void *) ssid, strlen(ssid));
 
+	if (settings && l_settings_get_uint(settings, "EAPoL",
+						"ProtocolVersion",
+						&eapol_proto_version)) {
+		if (eapol_proto_version > 3) {
+			l_warn("Invalid ProtocolVersion value - should be 0-3");
+			eapol_proto_version = 0;
+		}
+
+		if (eapol_proto_version)
+			l_debug("Overriding EAPoL protocol version to: %u",
+					eapol_proto_version);
+
+		handshake_state_set_protocol_version(hs, eapol_proto_version);
+	}
+
 	if (security == SECURITY_PSK) {
 		/* SAE will generate/set the PMK */
 		if (IE_AKM_IS_SAE(hs->akm_suite)) {
@@ -704,8 +886,10 @@ static struct handshake_state *station_handshake_setup(struct station *station,
 	 * wait to get it until here because at this point so there are no
 	 * failure paths before fils_sm_new
 	 */
-	if (hs->akm_suite == IE_RSN_AKM_SUITE_FILS_SHA256 ||
-			hs->akm_suite == IE_RSN_AKM_SUITE_FILS_SHA384)
+	if (hs->akm_suite & (IE_RSN_AKM_SUITE_FILS_SHA256 |
+				IE_RSN_AKM_SUITE_FILS_SHA384 |
+				IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256 |
+				IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384))
 		hs->erp_cache = erp_cache_get(network_get_ssid(network));
 
 	return hs;
@@ -746,9 +930,9 @@ static void periodic_scan_trigger(int err, void *user_data)
 
 static void periodic_scan_stop(struct station *station)
 {
-	uint32_t index = netdev_get_ifindex(station->netdev);
+	uint64_t id = netdev_get_wdev_id(station->netdev);
 
-	scan_periodic_stop(index);
+	scan_periodic_stop(id);
 
 	station_property_set_scanning(station, false);
 }
@@ -765,7 +949,7 @@ static uint32_t station_scan_trigger(struct station *station,
 					scan_notify_func_t notify,
 					scan_destroy_func_t destroy)
 {
-	uint32_t index = netdev_get_ifindex(station->netdev);
+	uint64_t id = netdev_get_wdev_id(station->netdev);
 
 	if (wiphy_can_randomize_mac_addr(station->wiphy) ||
 				station_needs_hidden_network_scan(station) ||
@@ -780,11 +964,11 @@ static uint32_t station_scan_trigger(struct station *station,
 
 		params.freqs = freqs;
 
-		return scan_active_full(index, &params, triggered, notify,
-							station, destroy);
+		return scan_active_full(id, &params, triggered, notify,
+					station, destroy);
 	}
 
-	return scan_passive(index, freqs, triggered, notify, station, destroy);
+	return scan_passive(id, freqs, triggered, notify, station, destroy);
 }
 
 static bool station_quick_scan_results(int err, struct l_queue *bss_list,
@@ -893,7 +1077,7 @@ static const char *station_state_to_string(enum station_state state)
 static void station_enter_state(struct station *station,
 						enum station_state state)
 {
-	uint32_t index = netdev_get_ifindex(station->netdev);
+	uint64_t id = netdev_get_wdev_id(station->netdev);
 	struct l_dbus *dbus = dbus_get_bus();
 	bool disconnected;
 
@@ -913,7 +1097,7 @@ static void station_enter_state(struct station *station,
 		station_quick_scan_trigger(station);
 		break;
 	case STATION_STATE_AUTOCONNECT_FULL:
-		scan_periodic_start(index, periodic_scan_trigger,
+		scan_periodic_start(id, periodic_scan_trigger,
 					new_scan_results, station);
 		break;
 	case STATION_STATE_CONNECTING:
@@ -981,7 +1165,7 @@ static void station_roam_state_clear(struct station *station)
 	station->roam_min_time.tv_sec = 0;
 
 	if (station->roam_scan_id)
-		scan_cancel(netdev_get_ifindex(station->netdev),
+		scan_cancel(netdev_get_wdev_id(station->netdev),
 						station->roam_scan_id);
 }
 
@@ -1195,7 +1379,7 @@ static void station_preauthenticate_cb(struct netdev *netdev,
 		rsn_info.pmkids = pmkid;
 
 		ie_build_rsne(&rsn_info, rsne_buf);
-		handshake_state_set_supplicant_rsn(new_hs, rsne_buf);
+		handshake_state_set_supplicant_ie(new_hs, rsne_buf);
 	}
 
 	station_transition_reassociate(station, bss, new_hs);
@@ -1453,7 +1637,7 @@ static void station_roam_scan(struct station *station,
 		params.ssid = network_get_ssid(station->connected_network);
 
 	station->roam_scan_id =
-		scan_active_full(netdev_get_ifindex(station->netdev), &params,
+		scan_active_full(netdev_get_wdev_id(station->netdev), &params,
 					station_roam_scan_triggered,
 					station_roam_scan_notify, station,
 					station_roam_scan_destroy);
@@ -1994,6 +2178,11 @@ static void station_connect_cb(struct netdev *netdev, enum netdev_result result,
 int __station_connect_network(struct station *station, struct network *network,
 				struct scan_bss *bss)
 {
+	const uint8_t *rc = NULL;
+	size_t rc_len = 0;
+	uint8_t rc_buf[32];
+	struct iovec iov[2];
+	int iov_elems = 0;
 	struct handshake_state *hs;
 	int r;
 
@@ -2001,8 +2190,30 @@ int __station_connect_network(struct station *station, struct network *network,
 	if (!hs)
 		return -ENOTSUP;
 
-	r = netdev_connect(station->netdev, bss, hs, station_netdev_event,
-					station_connect_cb, station);
+	if (bss->hs20_ie) {
+		/* Include HS20 Indication with (Re)Association */
+		iov[iov_elems].iov_base = bss->hs20_ie;
+		iov[iov_elems].iov_len = bss->hs20_ie[1] + 2;
+		iov_elems++;
+
+		/*
+		 * If a matching roaming consortium OI is found for the network
+		 * this single RC value will be set in the handshake and used
+		 * during (Re)Association.
+		 */
+		rc = hs20_get_roaming_consortium(network, &rc_len);
+		if (rc) {
+			ie_build_roaming_consortium(rc, rc_len, rc_buf);
+
+			iov[iov_elems].iov_base = rc_buf;
+			iov[iov_elems].iov_len = rc_buf[1] + 2;
+			iov_elems++;
+		}
+	}
+
+	r = netdev_connect(station->netdev, bss, hs, iov_elems ? iov : NULL,
+				iov_elems, station_netdev_event,
+				station_connect_cb, station);
 	if (r < 0) {
 		handshake_state_free(hs);
 		return r;
@@ -2135,7 +2346,7 @@ static struct l_dbus_message *station_dbus_connect_hidden_network(
 						void *user_data)
 {
 	struct station *station = user_data;
-	uint32_t index = netdev_get_ifindex(station->netdev);
+	uint64_t id = netdev_get_wdev_id(station->netdev);
 	struct scan_parameters params = {
 		.flush = true,
 		.randomize_mac_addr_hint = true,
@@ -2163,7 +2374,7 @@ static struct l_dbus_message *station_dbus_connect_hidden_network(
 
 	params.ssid = ssid;
 
-	station->hidden_network_scan_id = scan_active_full(index, &params,
+	station->hidden_network_scan_id = scan_active_full(id, &params,
 				station_hidden_network_scan_triggered,
 				station_hidden_network_scan_results,
 				station, station_hidden_network_scan_destroy);
@@ -2674,6 +2885,10 @@ static struct station *station_create(struct netdev *netdev)
 	l_dbus_object_add_interface(dbus, netdev_get_path(netdev),
 					IWD_STATION_INTERFACE, station);
 
+	netconfig_ifindex_add(netdev_get_ifindex(netdev));
+
+	station->anqp_pending = l_queue_new();
+
 	return station;
 }
 
@@ -2687,6 +2902,8 @@ static void station_free(struct station *station)
 	if (station->connected_bss)
 		netdev_disconnect(station->netdev, NULL, NULL);
 
+	netconfig_ifindex_remove(netdev_get_ifindex(station->netdev));
+
 	periodic_scan_stop(station);
 
 	if (station->signal_agent) {
@@ -2708,15 +2925,15 @@ static void station_free(struct station *station)
 			dbus_error_aborted(station->scan_pending));
 
 	if (station->dbus_scan_id)
-		scan_cancel(netdev_get_ifindex(station->netdev),
+		scan_cancel(netdev_get_wdev_id(station->netdev),
 				station->dbus_scan_id);
 
 	if (station->quick_scan_id)
-		scan_cancel(netdev_get_ifindex(station->netdev),
+		scan_cancel(netdev_get_wdev_id(station->netdev),
 				station->quick_scan_id);
 
 	if (station->hidden_network_scan_id)
-		scan_cancel(netdev_get_ifindex(station->netdev),
+		scan_cancel(netdev_get_wdev_id(station->netdev),
 				station->hidden_network_scan_id);
 
 	station_roam_state_clear(station);
@@ -2729,6 +2946,8 @@ static void station_free(struct station *station)
 
 	watchlist_destroy(&station->state_watches);
 
+	l_queue_destroy(station->anqp_pending, l_free);
+
 	l_free(station);
 }
 
@@ -2792,7 +3011,7 @@ static void station_netdev_watch(struct netdev *netdev,
 	}
 }
 
-bool station_init(void)
+static int station_init(void)
 {
 	station_list = l_queue_new();
 	netdev_watch = netdev_watch_add(station_netdev_watch, NULL, NULL);
@@ -2802,10 +3021,12 @@ bool station_init(void)
 	return true;
 }
 
-void station_exit(void)
+static void station_exit(void)
 {
 	l_dbus_unregister_interface(dbus_get_bus(), IWD_STATION_INTERFACE);
 	netdev_watch_remove(netdev_watch);
 	l_queue_destroy(station_list, NULL);
 	station_list = NULL;
 }
+
+IWD_MODULE(station, station_init, station_exit)
diff --git a/src/storage.c b/src/storage.c
index 6a323391..e636bfae 100644
--- a/src/storage.c
+++ b/src/storage.c
@@ -43,12 +43,6 @@
 #include "src/common.h"
 #include "src/storage.h"
 
-#ifdef TEMP_FAILURE_RETRY
-#define TFR TEMP_FAILURE_RETRY
-#else
-#define TFR
-#endif
-
 #define STORAGE_DIR_MODE (S_IRUSR | S_IWUSR | S_IXUSR)
 #define STORAGE_FILE_MODE (S_IRUSR | S_IWUSR)
 
@@ -97,16 +91,16 @@ ssize_t read_file(void *buffer, size_t len, const char *path_fmt, ...)
 	path = l_strdup_vprintf(path_fmt, ap);
 	va_end(ap);
 
-	fd = TFR(open(path, O_RDONLY));
+	fd = L_TFR(open(path, O_RDONLY));
 
 	l_free(path);
 
 	if (fd == -1)
 		return -1;
 
-	r = TFR(read(fd, buffer, len));
+	r = L_TFR(read(fd, buffer, len));
 
-	TFR(close(fd));
+	L_TFR(close(fd));
 
 	return r;
 }
@@ -139,12 +133,12 @@ ssize_t write_file(const void *buffer, size_t len,
 	if (create_dirs(path) != 0)
 		goto error_create_dirs;
 
-	fd = TFR(mkostemps(tmp_path, 4, O_CLOEXEC));
+	fd = L_TFR(mkostemps(tmp_path, 4, O_CLOEXEC));
 	if (fd == -1)
 		goto error_mkostemps;
 
-	r = TFR(write(fd, buffer, len));
-	TFR(close(fd));
+	r = L_TFR(write(fd, buffer, len));
+	L_TFR(close(fd));
 
 	if (r != (ssize_t) len) {
 		r = -1;
diff --git a/src/wiphy.c b/src/wiphy.c
index cb66c037..2ff652fe 100644
--- a/src/wiphy.c
+++ b/src/wiphy.c
@@ -50,14 +50,18 @@
 #include "src/common.h"
 #include "src/watchlist.h"
 
+#define EXT_CAP_LEN 10
+
 static struct l_genl_family *nl80211 = NULL;
 static struct l_hwdb *hwdb;
 static char **whitelist_filter;
 static char **blacklist_filter;
+static int mac_randomize_bytes = 6;
 
 struct wiphy {
 	uint32_t id;
 	char name[20];
+	uint8_t permanent_addr[ETH_ALEN];
 	uint32_t feature_flags;
 	uint8_t ext_features[(NUM_NL80211_EXT_FEATURES + 7) / 8];
 	uint8_t max_num_ssids_per_scan;
@@ -68,12 +72,15 @@ struct wiphy {
 	char *vendor_str;
 	char *driver_str;
 	struct watchlist state_watches;
+	uint8_t extended_capabilities[EXT_CAP_LEN + 2]; /* max bitmap size + IE header */
+	uint8_t *iftype_extended_capabilities[NUM_NL80211_IFTYPES];
 
 	bool support_scheduled_scan:1;
 	bool support_rekey_offload:1;
 	bool support_adhoc_rsn:1;
 	bool soft_rfkill : 1;
 	bool hard_rfkill : 1;
+	bool offchannel_tx_ok : 1;
 };
 
 static struct l_queue *wiphy_list = NULL;
@@ -117,6 +124,16 @@ enum ie_rsn_akm_suite wiphy_select_akm(struct wiphy *wiphy,
 	if (security == SECURITY_8021X) {
 		if (wiphy_has_feature(wiphy, NL80211_EXT_FEATURE_FILS_STA) &&
 				fils_capable_hint) {
+			if ((info.akm_suites &
+					IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384) &&
+					bss->rsne && bss->mde_present)
+				return IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384;
+
+			if ((info.akm_suites &
+					IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256) &&
+					bss->rsne && bss->mde_present)
+				return IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256;
+
 			if (info.akm_suites & IE_RSN_AKM_SUITE_FILS_SHA384)
 				return IE_RSN_AKM_SUITE_FILS_SHA384;
 
@@ -175,6 +192,8 @@ static struct wiphy *wiphy_new(uint32_t id)
 	wiphy->id = id;
 	wiphy->supported_freqs = scan_freq_set_new();
 	watchlist_init(&wiphy->state_watches, NULL);
+	wiphy->extended_capabilities[0] = IE_TYPE_EXTENDED_CAPABILITIES;
+	wiphy->extended_capabilities[1] = EXT_CAP_LEN;
 
 	return wiphy;
 }
@@ -182,9 +201,13 @@ static struct wiphy *wiphy_new(uint32_t id)
 static void wiphy_free(void *data)
 {
 	struct wiphy *wiphy = data;
+	uint32_t i;
 
 	l_debug("Freeing wiphy %s[%u]", wiphy->name, wiphy->id);
 
+	for (i = 0; i < NUM_NL80211_IFTYPES; i++)
+		l_free(wiphy->iftype_extended_capabilities[i]);
+
 	scan_freq_set_free(wiphy->supported_freqs);
 	watchlist_destroy(&wiphy->state_watches);
 	l_free(wiphy->model_str);
@@ -305,6 +328,19 @@ bool wiphy_can_randomize_mac_addr(struct wiphy *wiphy)
 	return wiphy_has_feature(wiphy, NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR);
 }
 
+bool wiphy_rrm_capable(struct wiphy *wiphy)
+{
+	if (wiphy_has_feature(wiphy,
+				NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES) &&
+			wiphy_has_feature(wiphy, NL80211_FEATURE_QUIET))
+		return true;
+
+	if (wiphy_has_ext_feature(wiphy, NL80211_EXT_FEATURE_RRM))
+		return true;
+
+	return false;
+}
+
 bool wiphy_has_ext_feature(struct wiphy *wiphy, uint32_t feature)
 {
 	return feature < sizeof(wiphy->ext_features) * 8 &&
@@ -321,11 +357,64 @@ bool wiphy_supports_adhoc_rsn(struct wiphy *wiphy)
 	return wiphy->support_adhoc_rsn;
 }
 
+bool wiphy_can_offchannel_tx(struct wiphy *wiphy)
+{
+	return wiphy->offchannel_tx_ok;
+}
+
 const char *wiphy_get_driver(struct wiphy *wiphy)
 {
 	return wiphy->driver_str;
 }
 
+const char *wiphy_get_name(struct wiphy *wiphy)
+{
+	return wiphy->name;
+}
+
+const uint8_t *wiphy_get_permanent_address(struct wiphy *wiphy)
+{
+	return wiphy->permanent_addr;
+}
+
+const uint8_t *wiphy_get_extended_capabilities(struct wiphy *wiphy,
+							uint32_t iftype)
+{
+	if (wiphy->iftype_extended_capabilities[iftype])
+		return wiphy->iftype_extended_capabilities[iftype];
+
+	return wiphy->extended_capabilities;
+}
+
+void wiphy_generate_random_address(struct wiphy *wiphy, uint8_t addr[static 6])
+{
+	switch (mac_randomize_bytes) {
+	case 6:
+		l_getrandom(addr, 6);
+
+		/* Set the locally administered bit */
+		addr[0] |= 0x2;
+
+		/* Reset multicast bit */
+		addr[0] &= 0xfe;
+		break;
+	case 3:
+		l_getrandom(addr + 3, 3);
+		memcpy(addr, wiphy->permanent_addr, 3);
+		break;
+	}
+
+	/*
+	 * Constrain the last NIC byte to 0x00 .. 0xfe, otherwise we might be
+	 * able to generate an address of 0xff 0xff 0xff which might be
+	 * interpreted as a vendor broadcast.  Similarly, 0x00 0x00 0x00 is
+	 * also not valid
+	 */
+	addr[5] &= 0xfe;
+	if (util_mem_is_zero(addr + 3, 3))
+		addr[5] = 0x01;
+}
+
 bool wiphy_constrain_freq_set(const struct wiphy *wiphy,
 						struct scan_freq_set *set)
 {
@@ -385,6 +474,7 @@ static void wiphy_print_basic_info(struct wiphy *wiphy)
 	char buf[1024];
 
 	l_info("Wiphy: %d, Name: %s", wiphy->id, wiphy->name);
+	l_info("\tPermanent Address: "MAC, MAC_STR(wiphy->permanent_addr));
 
 	bands = scan_freq_set_get_bands(wiphy->supported_freqs);
 
@@ -554,6 +644,45 @@ static void parse_supported_iftypes(struct wiphy *wiphy,
 	}
 }
 
+static void parse_iftype_extended_capabilities(struct wiphy *wiphy,
+						struct l_genl_attr *attr)
+{
+	uint16_t type;
+	uint16_t len;
+	const void *data;
+	struct l_genl_attr nested;
+
+	while (l_genl_attr_next(attr, &type, &len, &data)) {
+		uint32_t iftype;
+
+		if (!l_genl_attr_recurse(attr, &nested))
+			continue;
+
+		if (!l_genl_attr_next(&nested, &type, &len, &data))
+			continue;
+
+		if (type != NL80211_ATTR_IFTYPE)
+			continue;
+
+		iftype = l_get_u32(data);
+
+		if (!l_genl_attr_next(&nested, &type, &len, &data))
+			continue;
+
+		if (type != NL80211_ATTR_EXT_CAPA)
+			continue;
+
+		wiphy->iftype_extended_capabilities[iftype] =
+					l_new(uint8_t, EXT_CAP_LEN + 2);
+		wiphy->iftype_extended_capabilities[iftype][0] =
+					IE_TYPE_EXTENDED_CAPABILITIES;
+		wiphy->iftype_extended_capabilities[iftype][1] =
+					EXT_CAP_LEN;
+		memcpy(wiphy->iftype_extended_capabilities[iftype] + 2,
+				data, minsize(len, EXT_CAP_LEN));
+	}
+}
+
 static void wiphy_parse_attributes(struct wiphy *wiphy,
 					struct l_genl_attr *attr)
 {
@@ -603,6 +732,19 @@ static void wiphy_parse_attributes(struct wiphy *wiphy,
 			if (l_genl_attr_recurse(attr, &nested))
 				parse_supported_iftypes(wiphy, &nested);
 			break;
+		case NL80211_ATTR_OFFCHANNEL_TX_OK:
+			wiphy->offchannel_tx_ok = true;
+			break;
+		case NL80211_ATTR_EXT_CAPA:
+			memcpy(wiphy->extended_capabilities + 2,
+				data, minsize(EXT_CAP_LEN, len));
+			break;
+		case NL80211_ATTR_IFTYPE_EXT_CAPA:
+			if (!l_genl_attr_recurse(attr, &nested))
+				break;
+
+			parse_iftype_extended_capabilities(wiphy, &nested);
+			break;
 		}
 	}
 }
@@ -689,6 +831,29 @@ static bool wiphy_get_driver_name(struct wiphy *wiphy)
 	return true;
 }
 
+static int wiphy_get_permanent_addr_from_sysfs(struct wiphy *wiphy)
+{
+	char addr[32];
+	ssize_t len;
+
+	len = read_file(addr, sizeof(addr),
+				"/sys/class/ieee80211/%s/macaddress",
+				wiphy->name);
+	if (len != 18) {
+		if (len < 0)
+			return -errno;
+		return -EINVAL;
+	}
+
+	/* Sysfs appends a \n at the end, strip it */
+	addr[17] = '\0';
+
+	if (!util_string_to_address(addr, wiphy->permanent_addr))
+		return -EINVAL;
+
+	return 0;
+}
+
 static void wiphy_register(struct wiphy *wiphy)
 {
 	struct l_dbus *dbus = dbus_get_bus();
@@ -788,6 +953,14 @@ void wiphy_update_from_genl(struct wiphy *wiphy, struct l_genl_msg *msg)
 
 void wiphy_create_complete(struct wiphy *wiphy)
 {
+	if (util_mem_is_zero(wiphy->permanent_addr, 6)) {
+		int err = wiphy_get_permanent_addr_from_sysfs(wiphy);
+
+		if (err < 0)
+			l_error("Can't read sysfs maccaddr for %s: %s",
+					wiphy->name, strerror(-err));
+	}
+
 	wiphy_print_basic_info(wiphy);
 }
 
@@ -804,74 +977,6 @@ bool wiphy_destroy(struct wiphy *wiphy)
 	return true;
 }
 
-static void wiphy_regulatory_notify(struct l_genl_msg *msg, void *user_data)
-{
-	struct l_genl_attr attr;
-	uint16_t type, len;
-	const void *data;
-	uint8_t cmd;
-
-	cmd = l_genl_msg_get_command(msg);
-
-	l_debug("Regulatory notification %u", cmd);
-
-	if (!l_genl_attr_init(&attr, msg))
-		return;
-
-	while (l_genl_attr_next(&attr, &type, &len, &data)) {
-	}
-}
-
-static void regulatory_info_callback(struct l_genl_msg *msg, void *user_data)
-{
-	struct l_genl_attr attr;
-	uint16_t type, len;
-	const void *data;
-
-	if (!l_genl_attr_init(&attr, msg))
-		return;
-
-	while (l_genl_attr_next(&attr, &type, &len, &data)) {
-		switch (type) {
-		case NL80211_ATTR_REG_ALPHA2:
-			if (len != 3) {
-				l_warn("Invalid regulatory alpha2 attribute");
-				return;
-			}
-
-			l_debug("Regulatory alpha2 is %s", (char *) data);
-			break;
-		}
-	}
-}
-
-static void protocol_features_callback(struct l_genl_msg *msg, void *user_data)
-{
-	struct l_genl_attr attr;
-	uint16_t type, len;
-	const void *data;
-	uint32_t features = 0;
-
-	if (!l_genl_attr_init(&attr, msg))
-		return;
-
-	while (l_genl_attr_next(&attr, &type, &len, &data)) {
-		switch (type) {
-		case NL80211_ATTR_PROTOCOL_FEATURES:
-			if (len != sizeof(uint32_t)) {
-				l_warn("Invalid protocol features attribute");
-				return;
-			}
-
-			features = *((uint32_t *) data);
-			break;
-		}
-	}
-
-	if (features & NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP)
-		l_debug("Found split wiphy dump support");
-}
-
 static void wiphy_rfkill_cb(unsigned int wiphy_id, bool soft, bool hard,
 				void *user_data)
 {
@@ -1043,7 +1148,12 @@ static void setup_wiphy_interface(struct l_dbus_interface *interface)
 bool wiphy_init(struct l_genl_family *in, const char *whitelist,
 							const char *blacklist)
 {
-	struct l_genl_msg *msg;
+	const struct l_settings *config = iwd_get_config();
+	const char *s = l_settings_get_value(config, "General",
+							"mac_randomize_bytes");
+
+	if (s && !strcmp(s, "nic"))
+		mac_randomize_bytes = 3;
 
 	/*
 	 * This is an extra sanity check so that no memory is leaked
@@ -1056,22 +1166,8 @@ bool wiphy_init(struct l_genl_family *in, const char *whitelist,
 
 	nl80211 = in;
 
-	if (!l_genl_family_register(nl80211, "regulatory",
-					wiphy_regulatory_notify, NULL, NULL))
-		l_error("Registering for regulatory notification failed");
-
 	wiphy_list = l_queue_new();
 
-	msg = l_genl_msg_new(NL80211_CMD_GET_PROTOCOL_FEATURES);
-	if (!l_genl_family_send(nl80211, msg, protocol_features_callback,
-								NULL, NULL))
-		l_error("Getting protocol features failed");
-
-	msg = l_genl_msg_new(NL80211_CMD_GET_REG);
-	if (!l_genl_family_send(nl80211, msg, regulatory_info_callback,
-								NULL, NULL))
-		l_error("Getting regulatory info failed");
-
 	rfkill_watch_add(wiphy_rfkill_cb, NULL);
 
 	if (!l_dbus_register_interface(dbus_get_bus(),
@@ -1101,6 +1197,7 @@ bool wiphy_exit(void)
 	wiphy_list = NULL;
 
 	nl80211 = NULL;
+	mac_randomize_bytes = 6;
 
 	l_dbus_unregister_interface(dbus_get_bus(), IWD_WIPHY_INTERFACE);
 
diff --git a/src/wiphy.h b/src/wiphy.h
index c187d3e5..b41fae2c 100644
--- a/src/wiphy.h
+++ b/src/wiphy.h
@@ -62,12 +62,20 @@ const struct scan_freq_set *wiphy_get_supported_freqs(
 						const struct wiphy *wiphy);
 bool wiphy_can_connect(struct wiphy *wiphy, struct scan_bss *bss);
 bool wiphy_can_randomize_mac_addr(struct wiphy *wiphy);
+bool wiphy_rrm_capable(struct wiphy *wiphy);
 bool wiphy_has_feature(struct wiphy *wiphy, uint32_t feature);
 bool wiphy_has_ext_feature(struct wiphy *wiphy, uint32_t feature);
 uint8_t wiphy_get_max_num_ssids_per_scan(struct wiphy *wiphy);
 bool wiphy_supports_iftype(struct wiphy *wiphy, uint32_t iftype);
 bool wiphy_supports_adhoc_rsn(struct wiphy *wiphy);
+bool wiphy_can_offchannel_tx(struct wiphy *wiphy);
 const char *wiphy_get_driver(struct wiphy *wiphy);
+const char *wiphy_get_name(struct wiphy *wiphy);
+const uint8_t *wiphy_get_permanent_address(struct wiphy *wiphy);
+const uint8_t *wiphy_get_extended_capabilities(struct wiphy *wiphy,
+							uint32_t iftype);
+
+void wiphy_generate_random_address(struct wiphy *wiphy, uint8_t addr[static 6]);
 
 uint32_t wiphy_state_watch_add(struct wiphy *wiphy,
 				wiphy_state_watch_func_t func, void *user_data,
diff --git a/src/wsc.c b/src/wsc.c
index 274ed762..d238388f 100644
--- a/src/wsc.c
+++ b/src/wsc.c
@@ -535,7 +535,7 @@ static void wsc_cancel_scan(struct wsc *wsc)
 	wsc->wsc_ies = 0;
 
 	if (wsc->scan_id > 0) {
-		scan_cancel(netdev_get_ifindex(wsc->netdev), wsc->scan_id);
+		scan_cancel(netdev_get_wdev_id(wsc->netdev), wsc->scan_id);
 		wsc->scan_id = 0;
 	}
 
@@ -665,7 +665,7 @@ static bool push_button_scan_results(int err, struct l_queue *bss_list,
 		target = bss_2g;
 	else {
 		l_debug("No PBC APs found, running the scan again");
-		wsc->scan_id = scan_active(netdev_get_ifindex(wsc->netdev),
+		wsc->scan_id = scan_active(netdev_get_wdev_id(wsc->netdev),
 						wsc->wsc_ies, wsc->wsc_ies_size,
 						NULL, push_button_scan_results,
 						wsc, NULL);
@@ -811,7 +811,7 @@ static bool pin_scan_results(int err, struct l_queue *bss_list, void *userdata)
 
 	if (!target) {
 		l_debug("No PIN APs found, running the scan again");
-		wsc->scan_id = scan_active(netdev_get_ifindex(wsc->netdev),
+		wsc->scan_id = scan_active(netdev_get_wdev_id(wsc->netdev),
 						wsc->wsc_ies, wsc->wsc_ies_size,
 						NULL, pin_scan_results,
 						wsc, NULL);
@@ -879,7 +879,7 @@ static bool wsc_initiate_scan(struct wsc *wsc,
 	if (!wsc->wsc_ies)
 		return false;
 
-	wsc->scan_id = scan_active(netdev_get_ifindex(wsc->netdev),
+	wsc->scan_id = scan_active(netdev_get_wdev_id(wsc->netdev),
 					wsc->wsc_ies, wsc->wsc_ies_size,
 					NULL, callback, wsc, NULL);
 	if (!wsc->scan_id) {
@@ -903,7 +903,7 @@ static struct l_dbus_message *wsc_push_button(struct l_dbus *dbus,
 	if (wsc->pending)
 		return dbus_error_busy(message);
 
-	wsc->station = station_find(netdev_get_ifindex(wsc->netdev));
+	wsc->station = station_find(netdev_get_wdev_id(wsc->netdev));
 	if (!wsc->station)
 		return dbus_error_not_available(message);
 
@@ -1100,21 +1100,21 @@ static void wsc_netdev_watch(struct netdev *netdev,
 	}
 }
 
-bool wsc_init(void)
+static int wsc_init(void)
 {
 	l_debug("");
 	netdev_watch = netdev_watch_add(wsc_netdev_watch, NULL, NULL);
 	l_dbus_register_interface(dbus_get_bus(), IWD_WSC_INTERFACE,
 					setup_wsc_interface,
 					wsc_free, false);
-	return true;
+	return 0;
 }
 
-bool wsc_exit()
+static void wsc_exit(void)
 {
 	l_debug("");
 	l_dbus_unregister_interface(dbus_get_bus(), IWD_WSC_INTERFACE);
 	netdev_watch_remove(netdev_watch);
-
-	return true;
 }
+
+IWD_MODULE(wsc, wsc_init, wsc_exit)
diff --git a/src/wscutil.c b/src/wscutil.c
index 15b5a407..2806b249 100644
--- a/src/wscutil.c
+++ b/src/wscutil.c
@@ -125,12 +125,6 @@ bool wsc_attr_iter_recurse_wfa_ext(struct wsc_attr_iter *iter,
 	return true;
 }
 
-enum attr_flag {
-	ATTR_FLAG_REQUIRED  = 0x1,  /* Always required */
-	ATTR_FLAG_VERSION2  = 0x2,  /* Included if Version2 is present */
-	ATTR_FLAG_REGISTRAR = 0x4,  /* Included if Selected Registrar is true */
-};
-
 typedef bool (*attr_handler)(struct wsc_attr_iter *, void *);
 
 static bool extract_uint8(struct wsc_attr_iter *iter, void *data)
@@ -423,26 +417,30 @@ static bool extract_public_key(struct wsc_attr_iter *iter, void *data)
 	return true;
 }
 
-static bool extract_primary_device_type(struct wsc_attr_iter *iter, void *data)
+int wsc_parse_primary_device_type(const uint8_t *pdu, size_t len,
+					struct wsc_primary_device_type *out)
 {
-	struct wsc_primary_device_type *out = data;
-	const uint8_t *p;
 	uint16_t category;
 
-	if (wsc_attr_iter_get_length(iter) != 8)
-		return false;
-
-	p = wsc_attr_iter_get_data(iter);
-	category = l_get_be16(p);
+	if (len != 8)
+		return -EINVAL;
 
+	category = l_get_be16(pdu);
 	if (category > 12 && category != 255)
-		return false;
+		return -EINVAL;
 
 	out->category = category;
-	memcpy(out->oui, p + 2, 3);
-	out->oui_type = p[5];
-	out->subcategory = l_get_be16(p + 6);
-	return true;
+	memcpy(out->oui, pdu + 2, 3);
+	out->oui_type = pdu[5];
+	out->subcategory = l_get_be16(pdu + 6);
+	return 0;
+}
+
+static bool extract_primary_device_type(struct wsc_attr_iter *iter, void *data)
+{
+	return wsc_parse_primary_device_type(wsc_attr_iter_get_data(iter),
+						wsc_attr_iter_get_length(iter),
+						data) == 0;
 }
 
 static bool extract_request_type(struct wsc_attr_iter *iter, void *data)
@@ -652,12 +650,10 @@ static bool verify_version2(struct wsc_wfa_ext_iter *ext_iter)
 	return true;
 }
 
-static int wsc_parse_attrs(const unsigned char *pdu, unsigned int len,
-				bool *out_version2,
-				struct wsc_wfa_ext_iter *ext_iter,
-				enum wsc_attr authenticator_type,
-				uint8_t *authenticator,
-				int type, ...)
+int wsc_parse_attrs(const unsigned char *pdu, unsigned int len,
+			bool *out_version2, struct wsc_wfa_ext_iter *ext_iter,
+			enum wsc_attr authenticator_type,
+			uint8_t *authenticator, int type, ...)
 {
 	struct wsc_attr_iter iter;
 	struct l_queue *entries;
@@ -706,7 +702,7 @@ static int wsc_parse_attrs(const unsigned char *pdu, unsigned int len,
 				break;
 			}
 
-			if (entry->flags & ATTR_FLAG_REQUIRED) {
+			if (entry->flags & WSC_ATTR_FLAG_REQUIRED) {
 				have_required = false;
 				goto done;
 			}
@@ -748,7 +744,7 @@ static int wsc_parse_attrs(const unsigned char *pdu, unsigned int len,
 	for (; e; e = e->next) {
 		struct attr_handler_entry *entry = e->data;
 
-		if (entry->flags & ATTR_FLAG_REQUIRED) {
+		if (entry->flags & WSC_ATTR_FLAG_REQUIRED) {
 			parse_error = true;
 			goto done;
 		}
@@ -791,7 +787,7 @@ static int wsc_parse_attrs(const unsigned char *pdu, unsigned int len,
 		for (e = l_queue_get_entries(entries); e; e = e->next) {
 			entry = e->data;
 
-			if (!(entry->flags & ATTR_FLAG_VERSION2))
+			if (!(entry->flags & WSC_ATTR_FLAG_VERSION2))
 				continue;
 
 			if (entry->present)
@@ -812,7 +808,7 @@ static int wsc_parse_attrs(const unsigned char *pdu, unsigned int len,
 		for (e = l_queue_get_entries(entries); e; e = e->next) {
 			entry = e->data;
 
-			if (!(entry->flags & ATTR_FLAG_REGISTRAR))
+			if (!(entry->flags & WSC_ATTR_FLAG_REGISTRAR))
 				continue;
 
 			if (entry->present)
@@ -880,16 +876,16 @@ static bool wfa_extract_registrar_configuration_methods(
 }
 
 #define REQUIRED(attr, out) \
-	WSC_ATTR_ ## attr, ATTR_FLAG_REQUIRED, out
+	WSC_ATTR_ ## attr, WSC_ATTR_FLAG_REQUIRED, out
 
 #define OPTIONAL(attr, out) \
 	WSC_ATTR_ ## attr, 0, out
 
 #define REGISTRAR(attr, out) \
-	WSC_ATTR_ ## attr, ATTR_FLAG_REGISTRAR, out
+	WSC_ATTR_ ## attr, WSC_ATTR_FLAG_REGISTRAR, out
 
 #define VERSION2(attr, out) \
-	WSC_ATTR_ ## attr, ATTR_FLAG_VERSION2, out
+	WSC_ATTR_ ## attr, WSC_ATTR_FLAG_VERSION2, out
 
 int wsc_parse_credential(const uint8_t *pdu, uint32_t len,
 						struct wsc_credential *out)
@@ -2461,6 +2457,32 @@ done:
 	return ret;
 }
 
+uint8_t *wsc_build_p2p_attrs(const struct wsc_p2p_attrs *attrs, size_t *out_len)
+{
+	struct wsc_attr_builder *builder;
+	uint8_t *ret;
+
+	builder = wsc_attr_builder_new(512);
+
+	if (attrs->version)
+		build_version(builder, 0x10);
+
+	if (attrs->device_password_id)
+		build_device_password_id(builder, attrs->device_password_id);
+
+	if (attrs->config_methods)
+		build_configuration_methods(builder, attrs->config_methods);
+
+	if (!attrs->version2)
+		goto done;
+
+	START_WFA_VENDOR_EXTENSION();
+
+done:
+	ret = wsc_attr_builder_free(builder, false, out_len);
+	return ret;
+}
+
 bool wsc_uuid_from_addr(const uint8_t addr[], uint8_t *out_uuid)
 {
 	/* Reuse the NSID from WPA Supplicant for compatibility */
diff --git a/src/wscutil.h b/src/wscutil.h
index 23ba9f48..515344b7 100644
--- a/src/wscutil.h
+++ b/src/wscutil.h
@@ -544,6 +544,20 @@ struct wsc_done {
 	uint8_t registrar_nonce[16];
 };
 
+int wsc_parse_primary_device_type(const uint8_t *pdu, size_t len,
+					struct wsc_primary_device_type *out);
+
+enum wsc_attr_flag {
+	WSC_ATTR_FLAG_REQUIRED  = 0x1,  /* Always required */
+	WSC_ATTR_FLAG_VERSION2  = 0x2,  /* Included if Version2 is present */
+	WSC_ATTR_FLAG_REGISTRAR = 0x4,  /* Included if Selected Registrar is true */
+};
+
+int wsc_parse_attrs(const unsigned char *pdu, unsigned int len,
+			bool *out_version2, struct wsc_wfa_ext_iter *ext_iter,
+			enum wsc_attr authenticator_type,
+			uint8_t *authenticator, int type, ...);
+
 int wsc_parse_credential(const uint8_t *pdu, uint32_t len,
 						struct wsc_credential *out);
 
@@ -628,6 +642,16 @@ uint8_t *wsc_build_wsc_nack(const struct wsc_nack *nack, size_t *out_len);
 
 uint8_t *wsc_build_wsc_done(const struct wsc_done *done, size_t *out_len);
 
+struct wsc_p2p_attrs {
+	bool version;
+	bool version2;
+	enum wsc_device_password_id device_password_id;
+	uint16_t config_methods;
+};
+
+uint8_t *wsc_build_p2p_attrs(const struct wsc_p2p_attrs *attrs,
+				size_t *out_len);
+
 bool wsc_uuid_from_addr(const uint8_t addr[], uint8_t *out_uuid);
 
 struct wsc_session_key {
diff --git a/tools/hwsim.c b/tools/hwsim.c
index 3b70daaa..cade6a02 100644
--- a/tools/hwsim.c
+++ b/tools/hwsim.c
@@ -41,6 +41,7 @@
 #include "src/util.h"
 #include "src/storage.h"
 #include "src/mpdu.h"
+#include "src/crypto.h"
 
 #define HWSIM_SERVICE "net.connman.hwsim"
 
@@ -86,10 +87,25 @@ enum {
 	HWSIM_ATTR_PAD,
 	HWSIM_ATTR_TX_INFO_FLAGS,
 	HWSIM_ATTR_PERM_ADDR,
+	HWSIM_ATTR_IFTYPE_SUPPORT,
+	HWSIM_ATTR_CIPHER_SUPPORT,
 	__HWSIM_ATTR_MAX,
 };
 #define HWSIM_ATTR_MAX (__HWSIM_ATTR_MAX - 1)
 
+/*
+ * Should be kept in sync with HWSIM_IFTYPE_SUPPORT_MASK in mac80211_hwsim
+ */
+#define HWSIM_DEFAULT_IFTYPES \
+	( \
+		(1 << NL80211_IFTYPE_STATION) | \
+		(1 << NL80211_IFTYPE_AP) | \
+		(1 << NL80211_IFTYPE_P2P_CLIENT) | \
+		(1 << NL80211_IFTYPE_P2P_GO) | \
+		(1 << NL80211_IFTYPE_ADHOC) | \
+		(1 << NL80211_IFTYPE_MESH_POINT) \
+	)
+
 enum hwsim_tx_control_flags {
 	HWSIM_TX_CTL_REQ_TX_STATUS		= 1 << 0,
 	HWSIM_TX_CTL_NO_ACK			= 1 << 1,
@@ -111,6 +127,11 @@ struct hwsim_rule {
 	int signal;
 };
 
+struct hwsim_support {
+	const char *name;
+	uint32_t value;
+};
+
 static struct l_genl *genl;
 static struct l_genl_family *hwsim;
 static struct l_genl_family *nl80211;
@@ -133,6 +154,37 @@ static struct l_dbus *dbus;
 static struct l_queue *rules;
 static unsigned int next_rule_id;
 
+static uint32_t hwsim_iftypes = HWSIM_DEFAULT_IFTYPES;
+static const uint32_t hwsim_supported_ciphers[] = {
+	CRYPTO_CIPHER_WEP40,
+	CRYPTO_CIPHER_WEP104,
+	CRYPTO_CIPHER_TKIP,
+	CRYPTO_CIPHER_CCMP,
+	CRYPTO_CIPHER_BIP,
+};
+static uint32_t hwsim_ciphers[L_ARRAY_SIZE(hwsim_supported_ciphers)];
+static int hwsim_num_ciphers = 0;
+
+/* list of disableable iftypes */
+static const struct hwsim_support iftype_map[] = {
+	{ "station", 1 << NL80211_IFTYPE_STATION },
+	{ "ap", 1 << NL80211_IFTYPE_AP },
+	{ "adhoc", 1 << NL80211_IFTYPE_ADHOC },
+	{ "p2p_client", 1 << NL80211_IFTYPE_P2P_CLIENT },
+	{ "p2p_go", 1 << NL80211_IFTYPE_P2P_GO },
+	{ "mesh_point", 1 << NL80211_IFTYPE_MESH_POINT },
+	{ }
+};
+
+static const struct hwsim_support cipher_map[] = {
+	{ "wep40", CRYPTO_CIPHER_WEP40 },
+	{ "wep104", CRYPTO_CIPHER_WEP104 },
+	{ "tkip", CRYPTO_CIPHER_TKIP },
+	{ "ccmp", CRYPTO_CIPHER_CCMP },
+	{ "bip", CRYPTO_CIPHER_BIP },
+	{ }
+};
+
 static void do_debug(const char *str, void *user_data)
 {
 	const char *prefix = user_data;
@@ -2277,25 +2329,7 @@ error:
 	l_main_quit();
 }
 
-static void nl80211_ready(void *user_data)
-{
-	struct l_genl_msg *msg;
-
-	msg = l_genl_msg_new(HWSIM_CMD_GET_RADIO);
-	if (!l_genl_family_dump(hwsim, msg, get_radio_callback,
-				NULL, get_radio_done_initial)) {
-		l_error("Getting hwsim radio information failed");
-		goto error;
-	}
-
-	return;
-
-error:
-	exit_status = EXIT_FAILURE;
-	l_main_quit();
-}
-
-static void hwsim_ready(void *user_data)
+static void hwsim_ready(void)
 {
 	struct l_genl_msg *msg;
 	size_t msg_size;
@@ -2347,6 +2381,15 @@ static void hwsim_ready(void *user_data)
 						HWSIM_ATTR_SUPPORT_P2P_DEVICE,
 						0, NULL);
 
+		if (hwsim_iftypes != HWSIM_DEFAULT_IFTYPES)
+			l_genl_msg_append_attr(msg, HWSIM_ATTR_IFTYPE_SUPPORT,
+						4, &hwsim_iftypes);
+
+		if (hwsim_num_ciphers)
+			l_genl_msg_append_attr(msg, HWSIM_ATTR_CIPHER_SUPPORT,
+					sizeof(uint32_t) * hwsim_num_ciphers,
+					hwsim_ciphers);
+
 		l_genl_family_send(hwsim, msg, create_callback, NULL, NULL);
 
 		break;
@@ -2370,11 +2413,15 @@ static void hwsim_ready(void *user_data)
 			goto error;
 		}
 
-		l_genl_family_set_watches(nl80211, nl80211_ready, NULL,
-						NULL, NULL);
+		msg = l_genl_msg_new(HWSIM_CMD_GET_RADIO);
+		if (!l_genl_family_dump(hwsim, msg, get_radio_callback,
+					NULL, get_radio_done_initial)) {
+			l_error("Getting hwsim radio information failed");
+			goto error;
+		}
 
-		if (!l_genl_family_set_unicast_handler(hwsim, unicast_handler,
-						NULL, NULL)) {
+		if (!l_genl_add_unicast_watch(genl, "MAC80211_HWSIM",
+						unicast_handler, NULL, NULL)) {
 			l_error("Failed to set unicast handler");
 			goto error;
 		}
@@ -2389,8 +2436,91 @@ error:
 	l_main_quit();
 }
 
-static void hwsim_disappeared(void *user_data)
+static void hwsim_disable_support(char *disable,
+		const struct hwsim_support *map, uint32_t *mask)
 {
+	char **list = l_strsplit(disable, ',');
+	char **iter = list;
+	int i;
+
+	while (*iter) {
+		for (i = 0; map[i].name; i++) {
+			if (!strcmp(map[i].name, *iter))
+				*mask &= ~(map[i].value);
+		}
+
+		iter++;
+	}
+
+	l_strfreev(list);
+}
+
+static bool is_cipher_disabled(char *args, enum crypto_cipher cipher)
+{
+	char **list = l_strsplit(args, ',');
+	char **iter = list;
+	int i;
+
+	while (*iter) {
+		for (i = 0; cipher_map[i].name; i++) {
+			if (!strcmp(*iter, cipher_map[i].name) &&
+					cipher == cipher_map[i].value) {
+				printf("disable cipher: %s\n", cipher_map[i].name);
+				l_strfreev(list);
+				return true;
+			}
+		}
+
+		iter++;
+	}
+
+	l_strfreev(list);
+
+	return false;
+}
+
+static void hwsim_disable_ciphers(char *disable)
+{
+	uint8_t i;
+
+	for (i = 0; i < L_ARRAY_SIZE(hwsim_supported_ciphers); i++) {
+		if (is_cipher_disabled(disable, hwsim_supported_ciphers[i]))
+			continue;
+
+		hwsim_ciphers[hwsim_num_ciphers] = hwsim_supported_ciphers[i];
+		hwsim_num_ciphers++;
+	}
+}
+
+static void family_discovered(const struct l_genl_family_info *info,
+							void *user_data)
+{
+	if (!strcmp(l_genl_family_info_get_name(info), "MAC80211_HWSIM"))
+		hwsim = l_genl_family_new(genl, "MAC80211_HWSIM");
+	else if (!strcmp(l_genl_family_info_get_name(info), NL80211_GENL_NAME))
+		nl80211 = l_genl_family_new(genl, NL80211_GENL_NAME);
+}
+
+static void discovery_done(void *user_data)
+{
+	if (!hwsim) {
+		fprintf(stderr, "MAC80211_HWSIM doesn't exist.\n"
+			"Load it manually using modprobe mac80211_hwsim\n");
+		goto quit;
+	}
+
+	if (!nl80211) {
+		fprintf(stderr, "nl80211 doesn't exist.\n"
+			"Load it manually using modprobe cfg80211\n");
+		goto quit;
+	}
+
+	hwsim_ready();
+
+	return;
+
+quit:
+	exit_status = EXIT_FAILURE;
 	l_main_quit();
 }
 
@@ -2416,6 +2546,8 @@ static void usage(void)
 		"\t-n, --name <name>      Name of a radio to be created\n"
 		"\t-i, --nointerface      Do not create VIF\n"
 		"\t-p, --p2p              Support P2P\n"
+		"\t-t, --iftype-disable   List of disabled iftypes\n"
+		"\t-c, --cipher-disable   List of disabled ciphers\n"
 		"\t-h, --help             Show help options\n");
 }
 
@@ -2427,6 +2559,8 @@ static const struct option main_options[] = {
 	{ "nointerface", no_argument,		NULL, 'i' },
 	{ "p2p",	 no_argument,		NULL, 'p' },
 	{ "version",	 no_argument,		NULL, 'v' },
+	{ "iftype-disable", required_argument,	NULL, 't' },
+	{ "cipher-disable", required_argument,	NULL, 'c' },
 	{ "help",	 no_argument,		NULL, 'h' },
 	{ }
 };
@@ -2438,7 +2572,7 @@ int main(int argc, char *argv[])
 	for (;;) {
 		int opt;
 
-		opt = getopt_long(argc, argv, ":L:CD:kn:ipvh", main_options,
+		opt = getopt_long(argc, argv, ":L:CD:kndetc:ipvh", main_options,
 									NULL);
 		if (opt < 0)
 			break;
@@ -2477,6 +2611,13 @@ int main(int argc, char *argv[])
 		case 'p':
 			p2p_attr = true;
 			break;
+		case 't':
+			hwsim_disable_support(optarg, iftype_map,
+						&hwsim_iftypes);
+			break;
+		case 'c':
+			hwsim_disable_ciphers(optarg);
+			break;
 		case 'v':
 			printf("%s\n", VERSION);
 			return EXIT_SUCCESS;
@@ -2504,43 +2645,30 @@ int main(int argc, char *argv[])
 		return EXIT_FAILURE;
 
 	l_log_set_stderr();
+	exit_status = EXIT_FAILURE;
 
 	printf("Wireless simulator ver %s\n", VERSION);
 
-	genl = l_genl_new_default();
+	genl = l_genl_new();
 	if (!genl) {
 		fprintf(stderr, "Failed to initialize generic netlink\n");
-		exit_status = EXIT_FAILURE;
 		goto done;
 	}
 
 	if (getenv("HWSIM_DEBUG"))
 		l_genl_set_debug(genl, do_debug, "[GENL] ", NULL);
 
-	hwsim = l_genl_family_new(genl, "MAC80211_HWSIM");
-	if (!hwsim) {
-		fprintf(stderr, "Failed to create generic netlink family\n");
-		l_genl_unref(genl);
-		exit_status = EXIT_FAILURE;
-		goto done;
-	}
-
-	nl80211 = l_genl_family_new(genl, NL80211_GENL_NAME);
-	if (!nl80211) {
-		fprintf(stderr, "Failed to create nl80211 genl family\n");
-		l_genl_family_unref(hwsim);
+	if (!l_genl_discover_families(genl, family_discovered, NULL,
+						discovery_done)) {
+		fprintf(stderr, "Unable to start family discovery\n");
 		l_genl_unref(genl);
-		exit_status = EXIT_FAILURE;
 		goto done;
 	}
 
-	l_genl_family_set_watches(hwsim, hwsim_ready, hwsim_disappeared,
-					NULL, NULL);
-
 	exit_status = l_main_run_with_signal(signal_handler, NULL);
 
-	l_genl_family_unref(hwsim);
-	l_genl_family_unref(nl80211);
+	l_genl_family_free(hwsim);
+	l_genl_family_free(nl80211);
 	l_genl_unref(genl);
 
 	if (pending_create_msg)
diff --git a/tools/test-runner.c b/tools/test-runner.c
index 0415ae6a..16f599ac 100644
--- a/tools/test-runner.c
+++ b/tools/test-runner.c
@@ -152,13 +152,14 @@ static const char * const qemu_table[] = { NULL };
 
 struct wiphy {
 	char name[20];
-	uint32_t id;
+	int id;
 	unsigned int interface_index;
 	bool interface_created : 1;
 	bool used_by_hostapd : 1;
 	char *interface_name;
 	char *hostapd_ctrl_interface;
 	char *hostapd_config;
+	bool can_ap;
 };
 
 static bool check_verbosity(const char *app)
@@ -742,31 +743,50 @@ static bool list_hwsim_radios(void)
 	return true;
 }
 
-static uint32_t read_radio_id(void)
+static int read_radio_id(void)
 {
 	static int current_radio_id;
 
-	return ++current_radio_id;
+	return current_radio_id++;
 }
 
-static uint32_t create_hwsim_radio(const char *radio_name,
-				const unsigned int channels, bool p2p_device,
-							bool use_chanctx)
+struct hwsim_radio_params {
+	unsigned int channels;
+	bool p2p_device;
+	bool use_chanctx;
+	char *iftype_disable;
+	char *cipher_disable;
+};
+
+static int create_hwsim_radio(const char *radio_name,
+				struct hwsim_radio_params *params)
 {
-	char *argv[7];
+	char *argv[10];
 	pid_t pid;
+	int idx = 0;
 
 	/*TODO add the rest of params*/
-	argv[0] = BIN_HWSIM;
-	argv[1] = "--create";
-	argv[2] = "--name";
-	argv[3] = (char *) radio_name;
-	argv[4] = "--nointerface";
-	argv[5] = NULL;
+	argv[idx++] = BIN_HWSIM;
+	argv[idx++] = "--create";
+	argv[idx++] = "--name";
+	argv[idx++] = (char *) radio_name;
+	argv[idx++] = "--nointerface";
+
+	if (params->iftype_disable) {
+		argv[idx++] = "--iftype-disable";
+		argv[idx++] = params->iftype_disable;
+	}
+
+	if (params->cipher_disable) {
+		argv[idx++] = "--cipher-disable";
+		argv[idx++] = params->cipher_disable;
+	}
+
+	argv[idx] = NULL;
 
 	pid = execute_program(argv, true, check_verbosity(BIN_HWSIM));
 	if (pid < 0)
-		return 0;
+		return -1;
 
 	return read_radio_id();
 }
@@ -988,16 +1008,15 @@ static int is_test_dir(const char *dir)
 }
 
 static bool find_test_configuration(const char *path, int level,
-						struct l_hashmap *config_map)
+						struct l_hashmap *config_map);
+
+static bool add_path(const char *path, int level, struct l_hashmap *config_map)
 {
 	DIR *dir = NULL;
 	struct l_queue *py_test_queue = NULL;
 	struct dirent *entry;
 	char *npath;
 
-	if (!config_map)
-		return false;
-
 	dir = opendir(path);
 	if (!dir) {
 		l_error("Test directory does not exist: %s", path);
@@ -1034,6 +1053,32 @@ static bool find_test_configuration(const char *path, int level,
 	return true;
 }
 
+static bool find_test_configuration(const char *path, int level,
+						struct l_hashmap *config_map)
+{
+	glob_t glist;
+	int i = 0;
+	int ret;
+
+	if (!config_map)
+		return false;
+
+	ret = glob(path, 0, NULL, &glist);
+	if (ret != 0) {
+		l_error("Could not match glob %s", path);
+		return false;
+	}
+
+	while (glist.gl_pathv[i]) {
+		if (!add_path(glist.gl_pathv[i], level, config_map))
+			return false;
+
+		i++;
+	}
+
+	return true;
+}
+
 #define HW_CONFIG_FILE_NAME		"hw.conf"
 #define HW_CONFIG_GROUP_HOSTAPD		"HOSTAPD"
 #define HW_CONFIG_GROUP_SETUP		"SETUP"
@@ -1079,6 +1124,8 @@ error_exit:
 #define HW_CONFIG_PHY_CHANNELS	"channels"
 #define HW_CONFIG_PHY_CHANCTX	"use_chanctx"
 #define HW_CONFIG_PHY_P2P	"p2p_device"
+#define HW_CONFIG_PHY_IFTYPE_DISABLE "iftype_disable"
+#define HW_CONFIG_PHY_CIPHER_DISABLE "cipher_disable"
 
 #define HW_MIN_NUM_RADIOS	1
 
@@ -1090,9 +1137,8 @@ static bool configure_hw_radios(struct l_settings *hw_settings,
 						struct l_queue *wiphy_list)
 {
 	char **radio_conf_list;
-	int num_radios_requested, num_radios_created;
+	int i, num_radios_requested;
 	bool status = false;
-	bool has_hw_conf;
 
 	l_settings_get_int(hw_settings, HW_CONFIG_GROUP_SETUP,
 						HW_CONFIG_SETUP_NUM_RADIOS,
@@ -1104,96 +1150,57 @@ static bool configure_hw_radios(struct l_settings *hw_settings,
 		return false;
 	}
 
-	has_hw_conf = l_settings_has_key(hw_settings, HW_CONFIG_GROUP_SETUP,
-						HW_CONFIG_SETUP_RADIO_CONFS);
-
 	radio_conf_list =
 		l_settings_get_string_list(hw_settings, HW_CONFIG_GROUP_SETUP,
 						HW_CONFIG_SETUP_RADIO_CONFS,
 									':');
-	if (has_hw_conf && !radio_conf_list) {
-		l_error("%s doesn't parse", HW_CONFIG_SETUP_RADIO_CONFS);
-		return false;
-	}
-
-	if (has_hw_conf) {
-		int i;
-
-		for (i = 0; radio_conf_list[i]; i++) {
-			size_t len = strlen(radio_conf_list[i]);
-
-			if (len >= sizeof(((struct wiphy *) 0)->name)) {
-				l_error("Radio name: '%s' is too big",
-						radio_conf_list[i]);
-				goto exit;
-			}
-
-			if (len == 0) {
-				l_error("Radio name cannot be empty");
-				goto exit;
-			}
-
-			if (!l_settings_has_group(hw_settings,
-							radio_conf_list[i])) {
-				l_error("No radio configuration group [%s]"
-						" found in config file.",
-						radio_conf_list[i]);
-				goto exit;
-			}
-		}
-
-		if (i != num_radios_requested) {
-			l_error(HW_CONFIG_SETUP_RADIO_CONFS "should contain"
-					" %d radios", num_radios_requested);
-			goto exit;
-		}
-	}
-
-	num_radios_created = 0;
-
-	while (num_radios_requested > num_radios_created) {
+	for (i = 0; i < num_radios_requested; i++) {
 		struct wiphy *wiphy;
-
-		unsigned int channels;
-		bool p2p_device;
-		bool use_chanctx;
+		struct hwsim_radio_params params = { 0 };
 
 		wiphy = l_new(struct wiphy, 1);
 
-		if (!has_hw_conf) {
-			channels = 1;
-			p2p_device = true;
-			use_chanctx = true;
+		sprintf(wiphy->name, "rad%d", i);
 
-			sprintf(wiphy->name, "rad%d", num_radios_created);
-			goto configure;
+		/* radio not in radio_confs, use default parameters */
+		if (!l_strv_contains(radio_conf_list, wiphy->name)) {
+			params.channels = 1;
+			params.p2p_device = true;
+			params.use_chanctx = true;
+			goto create;
 		}
 
-		strcpy(wiphy->name, radio_conf_list[num_radios_created]);
-
 		if (!l_settings_get_uint(hw_settings, wiphy->name,
-					HW_CONFIG_PHY_CHANNELS, &channels))
-			channels = 1;
+					HW_CONFIG_PHY_CHANNELS,
+					&params.channels))
+			params.channels = 1;
 
 		if (!l_settings_get_bool(hw_settings, wiphy->name,
-					HW_CONFIG_PHY_P2P, &p2p_device))
-			p2p_device = true;
+					HW_CONFIG_PHY_P2P, &params.p2p_device))
+			params.p2p_device = true;
 
 		if (!l_settings_get_bool(hw_settings, wiphy->name,
-					HW_CONFIG_PHY_CHANCTX, &use_chanctx))
-			use_chanctx = true;
-
-configure:
-		wiphy->id = create_hwsim_radio(wiphy->name, channels,
-						p2p_device, use_chanctx);
-
-		if (wiphy->id == 0) {
+					HW_CONFIG_PHY_CHANCTX,
+					&params.use_chanctx))
+			params.use_chanctx = true;
+
+		params.iftype_disable = l_settings_get_string(hw_settings,
+					wiphy->name,
+					HW_CONFIG_PHY_IFTYPE_DISABLE);
+		params.cipher_disable = l_settings_get_string(hw_settings,
+					wiphy->name,
+					HW_CONFIG_PHY_CIPHER_DISABLE);
+
+create:
+		wiphy->id = create_hwsim_radio(wiphy->name, &params);
+		wiphy->can_ap = true;
+
+		if (wiphy->id < 0) {
 			l_free(wiphy);
 			goto exit;
 		}
 
 		l_queue_push_tail(wiphy_list, wiphy);
-		num_radios_created++;
 	}
 
 	status = true;
@@ -1313,6 +1320,9 @@ static bool configure_hostapd_instances(struct l_settings *hw_settings,
 				goto done;
 			}
 
+			if (!wiphy->can_ap)
+				continue;
+
 			wiphys[i] = wiphy;
 			break;
 		}
@@ -1322,6 +1332,9 @@ static bool configure_hostapd_instances(struct l_settings *hw_settings,
 			goto done;
 		}
 
+		if (native_hw)
+			goto hostapd_done;
+
 		wiphys[i]->interface_name = l_strdup_printf("%s%d",
 							HW_INTERFACE_PREFIX,
 							wiphy_idx);
@@ -1344,6 +1357,7 @@ static bool configure_hostapd_instances(struct l_settings *hw_settings,
 			goto done;
 		}
 
+hostapd_done:
 		wiphys[i]->used_by_hostapd = true;
 		wiphys[i]->hostapd_ctrl_interface =
 			l_strdup_printf("%s/%s", HOSTAPD_CTRL_INTERFACE_PREFIX,
@@ -2301,64 +2315,86 @@ exit:
 static bool wiphy_match(const void *a, const void *b)
 {
 	const struct wiphy *wiphy = a;
-	uint32_t id = L_PTR_TO_UINT(b);
+	int id = L_PTR_TO_INT(b);
 
 	return (wiphy->id == id);
 }
 
 static struct wiphy *wiphy_find(int wiphy_id)
 {
-	return l_queue_find(wiphy_list, wiphy_match, L_UINT_TO_PTR(wiphy_id));
+	return l_queue_find(wiphy_list, wiphy_match, L_INT_TO_PTR(wiphy_id));
+}
+
+static void parse_supported_iftypes(uint16_t *iftypes,
+						struct l_genl_attr *attr)
+{
+	uint16_t type, len;
+	const void *data;
+
+	while (l_genl_attr_next(attr, &type, &len, &data)) {
+		/*
+		 * NL80211_IFTYPE_UNSPECIFIED can be ignored, so we start
+		 * at the first bit
+		 */
+		if (type > sizeof(uint16_t) * 8) {
+			l_warn("unsupported iftype: %u", type);
+			continue;
+		}
+
+		*iftypes |= 1 << (type - 1);
+	}
 }
 
 static void wiphy_dump_callback(struct l_genl_msg *msg, void *user_data)
 {
 	struct wiphy *wiphy;
 	struct l_genl_attr attr;
-	uint32_t id;
+	struct l_genl_attr nested;
+	uint32_t id = UINT32_MAX;
 	uint16_t type, len;
 	const void *data;
-	const char *name;
-	uint32_t name_len;
+	const char *name = NULL;
+	uint32_t name_len = 0;
+	uint16_t iftypes = 0;
 
 	if (!l_genl_attr_init(&attr, msg))
 		return;
 
-	/*
-	 * The wiphy attribute, name and generation are always the first
-	 * three attributes (in that order) in every NEW_WIPHY & DEL_WIPHY
-	 * message.  If not, then error out with a warning and ignore the
-	 * whole message.
-	 */
-	if (!l_genl_attr_next(&attr, &type, &len, &data))
-		return;
+	while (l_genl_attr_next(&attr, &type, &len, &data)) {
+		switch (type) {
+		case NL80211_ATTR_WIPHY:
+			if (len != sizeof(uint32_t))
+				return;
 
-	if (type != NL80211_ATTR_WIPHY)
-		return;
+			id = *((uint32_t *) data);
 
-	if (len != sizeof(uint32_t))
-		return;
+			if (wiphy_find(id))
+				return;
 
-	id = *((uint32_t *) data);
+			break;
+		case NL80211_ATTR_WIPHY_NAME:
+			if (len > sizeof(((struct wiphy *) 0)->name))
+				return;
 
-	if (wiphy_find(id))
-		return;
+			name = data;
+			name_len = len;
 
-	if (!l_genl_attr_next(&attr, &type, &len, &data))
-		return;
+			break;
+		case NL80211_ATTR_SUPPORTED_IFTYPES:
+			if (l_genl_attr_recurse(&attr, &nested))
+				parse_supported_iftypes(&iftypes, &nested);
 
-	if (type != NL80211_ATTR_WIPHY_NAME)
-		return;
+			break;
+		}
+	}
 
-	if (len > sizeof(((struct wiphy *) 0)->name))
+	if (id == UINT32_MAX || !name)
 		return;
 
-	name = data;
-	name_len = len;
-
 	wiphy = l_new(struct wiphy, 1);
 	strncpy(wiphy->name, name, name_len);
 	wiphy->id = id;
+	wiphy->can_ap = iftypes & (1 << NL80211_IFTYPE_AP);
 
 	l_queue_push_tail(wiphy_list, wiphy);
 }
@@ -2423,7 +2459,7 @@ static void iface_dump_done(void *user_data)
 
 	l_queue_destroy(wiphy_list, wiphy_free);
 
-	l_genl_family_unref(data->nl80211);
+	l_genl_family_free(data->nl80211);
 	l_genl_unref(data->genl);
 	l_free(data);
 
@@ -2443,25 +2479,29 @@ static void wiphy_dump_done(void *user_data)
 		l_error("Getting all interface information failed");
 }
 
-static void nl80211_appeared(void *user_data)
+static void nl80211_requested(const struct l_genl_family_info *info,
+							void *user_data)
 {
 	struct nl_data *data = user_data;
 	struct l_genl_msg *msg;
 
-	wiphy_list = l_queue_new();
+	if (info == NULL) {
+		l_info("No nl80211 family found");
+		goto done;
+	}
 
 	l_debug("Found nl80211 interface");
 
+	data->nl80211 = l_genl_family_new(data->genl, NL80211_GENL_NAME);
+	wiphy_list = l_queue_new();
+
 	msg = l_genl_msg_new(NL80211_CMD_GET_WIPHY);
 	if (!l_genl_family_dump(data->nl80211, msg, wiphy_dump_callback,
 						data, wiphy_dump_done))
 		l_error("Getting all wiphy devices failed");
-}
-
-static void nl80211_vanished(void *user_data)
-{
-	l_debug("Lost nl80211 interface");
 
+	return;
+done:
 	l_main_quit();
 }
 
@@ -2469,12 +2509,9 @@ static void start_hw_discovery(void)
 {
 	struct nl_data *data = l_new(struct nl_data, 1);
 
-	data->genl = l_genl_new_default();
-	data->nl80211 = l_genl_family_new(data->genl, NL80211_GENL_NAME);
-
-	l_genl_family_set_watches(data->nl80211, nl80211_appeared,
-					nl80211_vanished, data, NULL);
-
+	data->genl = l_genl_new();
+	l_genl_request_family(data->genl, NL80211_GENL_NAME,
+				nl80211_requested, data, NULL);
 	/*
 	 * This is somewhat of a mystery, but it appears that
 	 * calling lshw causes the OS to re-enumerate the USB
diff --git a/unit/test-eapol.c b/unit/test-eapol.c
index 48a95cd8..84d07656 100644
--- a/unit/test-eapol.c
+++ b/unit/test-eapol.c
@@ -2170,21 +2170,21 @@ static void eapol_sm_test_ptk(const void *data)
 	expected_step4_frame_size = sizeof(eapol_key_data_6);
 
 	hs = test_handshake_state_new(1);
+	/* key_data_3 uses 2004 while key_data_3 uses 2001, so force 2001 */
+	handshake_state_set_protocol_version(hs, EAPOL_PROTOCOL_VERSION_2001);
+
 	sm = eapol_sm_new(hs);
 	eapol_register(sm);
 
-	/* key_data_3 uses 2004 while key_data_3 uses 2001, so force 2001 */
-	eapol_sm_set_protocol_version(sm, EAPOL_PROTOCOL_VERSION_2001);
-
 	handshake_state_set_pmk(hs, psk, sizeof(psk));
 	handshake_state_set_authenticator_address(hs, aa);
 	handshake_state_set_supplicant_address(hs, spa);
 
-	r =  handshake_state_set_supplicant_rsn(hs,
+	r =  handshake_state_set_supplicant_ie(hs,
 				eapol_key_data_4 + EAPOL_FRAME_LEN(16));
 	assert(r);
 
-	handshake_state_set_authenticator_rsn(hs, ap_rsne);
+	handshake_state_set_authenticator_ie(hs, ap_rsne);
 	eapol_start(sm);
 
 	__eapol_set_tx_packet_func(verify_step2);
@@ -2234,21 +2234,21 @@ static void eapol_sm_test_igtk(const void *data)
 	expected_step4_frame_size = sizeof(eapol_key_data_32);
 
 	hs = test_handshake_state_new(1);
+	/* key_data_29 uses 2004 while key_data_30 uses 2001, so force 2001 */
+	handshake_state_set_protocol_version(hs, EAPOL_PROTOCOL_VERSION_2001);
+
 	sm = eapol_sm_new(hs);
 	eapol_register(sm);
 
-	/* key_data_29 uses 2004 while key_data_30 uses 2001, so force 2001 */
-	eapol_sm_set_protocol_version(sm, EAPOL_PROTOCOL_VERSION_2001);
-
 	handshake_state_set_pmk(hs, psk, sizeof(psk));
 	handshake_state_set_authenticator_address(hs, aa);
 	handshake_state_set_supplicant_address(hs, spa);
 
-	r =  handshake_state_set_supplicant_rsn(hs,
+	r =  handshake_state_set_supplicant_ie(hs,
 				eapol_key_data_30 + EAPOL_FRAME_LEN(16));
 	assert(r);
 
-	handshake_state_set_authenticator_rsn(hs, ap_rsne);
+	handshake_state_set_authenticator_ie(hs, ap_rsne);
 	eapol_start(sm);
 
 	__eapol_set_tx_packet_func(verify_step2);
@@ -2308,11 +2308,11 @@ static void eapol_sm_test_wpa2_ptk_gtk(const void *data)
 	handshake_state_set_authenticator_address(hs, aa);
 	handshake_state_set_supplicant_address(hs, spa);
 
-	r = handshake_state_set_supplicant_rsn(hs,
+	r = handshake_state_set_supplicant_ie(hs,
 				eapol_key_data_8 + EAPOL_FRAME_LEN(16));
 	assert(r);
 
-	handshake_state_set_authenticator_rsn(hs, ap_rsne);
+	handshake_state_set_authenticator_ie(hs, ap_rsne);
 	eapol_start(sm);
 
 	__eapol_set_tx_packet_func(verify_step2);
@@ -2375,11 +2375,11 @@ static void eapol_sm_test_wpa_ptk_gtk(const void *data)
 	handshake_state_set_pmk(hs, psk, sizeof(psk));
 	handshake_state_set_authenticator_address(hs, ap_address);
 	handshake_state_set_supplicant_address(hs, sta_address);
-	r = handshake_state_set_supplicant_wpa(hs,
+	r = handshake_state_set_supplicant_ie(hs,
 				eapol_key_data_14 + EAPOL_FRAME_LEN(16));
 	assert(r);
 
-	handshake_state_set_authenticator_wpa(hs, ap_wpa_ie);
+	handshake_state_set_authenticator_ie(hs, ap_wpa_ie);
 	eapol_start(sm);
 
 	__eapol_set_tx_packet_func(verify_step2);
@@ -2443,11 +2443,11 @@ static void eapol_sm_test_wpa_ptk_gtk_2(const void *data)
 	handshake_state_set_authenticator_address(hs, ap_address);
 	handshake_state_set_supplicant_address(hs, sta_address);
 
-	r = handshake_state_set_supplicant_wpa(hs,
+	r = handshake_state_set_supplicant_ie(hs,
 				eapol_key_data_20 + EAPOL_FRAME_LEN(16));
 	assert(r);
 
-	handshake_state_set_authenticator_wpa(hs, ap_wpa_ie);
+	handshake_state_set_authenticator_ie(hs, ap_wpa_ie);
 	eapol_start(sm);
 
 	__eapol_set_tx_packet_func(verify_step2);
@@ -2558,11 +2558,11 @@ static void eapol_sm_wpa2_retransmit_test(const void *data)
 	handshake_state_set_authenticator_address(hs, ap_address);
 	handshake_state_set_supplicant_address(hs, sta_address);
 
-	r = handshake_state_set_supplicant_rsn(hs,
+	r = handshake_state_set_supplicant_ie(hs,
 				eapol_key_data_8 + EAPOL_FRAME_LEN(16));
 	assert(r);
 
-	handshake_state_set_authenticator_rsn(hs, ap_rsne);
+	handshake_state_set_authenticator_ie(hs, ap_rsne);
 	eapol_start(sm);
 
 	ptk_step1 = eapol_key_validate(eapol_key_data_7,
@@ -2916,11 +2916,11 @@ static void eapol_sm_test_tls(struct eapol_8021x_tls_test_state *s,
 	handshake_state_set_event_func(hs, verify_handshake_successful, NULL);
 	__eapol_set_tx_user_data(s);
 
-	r = handshake_state_set_supplicant_wpa(hs,
+	r = handshake_state_set_supplicant_ie(hs,
 				eapol_key_data_14 + EAPOL_FRAME_LEN(16));
 	assert(r);
 
-	handshake_state_set_authenticator_wpa(hs, ap_wpa_ie);
+	handshake_state_set_authenticator_ie(hs, ap_wpa_ie);
 
 	settings = l_settings_new();
 	l_settings_load_from_data(settings, config, strlen(config));
@@ -3293,11 +3293,11 @@ static void eapol_sm_test_eap_nak(const void *data)
 	handshake_state_set_event_func(hs, test_handshake_event, NULL);
 	__eapol_set_tx_user_data(&s);
 
-	r = handshake_state_set_supplicant_wpa(hs,
+	r = handshake_state_set_supplicant_ie(hs,
 				eapol_key_data_20 + EAPOL_FRAME_LEN(16));
 	assert(r);
 
-	handshake_state_set_authenticator_wpa(hs, ap_wpa_ie);
+	handshake_state_set_authenticator_ie(hs, ap_wpa_ie);
 
 	settings = l_settings_new();
 	l_settings_load_from_data(settings, eapol_8021x_config,
@@ -3390,8 +3390,8 @@ static void eapol_ft_handshake_test(const void *data)
 	handshake_state_set_supplicant_address(hs, spa);
 	handshake_state_set_ssid(hs, (void *) ssid, strlen(ssid));
 
-	handshake_state_set_supplicant_rsn(hs, own_rsne);
-	handshake_state_set_authenticator_rsn(hs, ap_rsne);
+	handshake_state_set_supplicant_ie(hs, own_rsne);
+	handshake_state_set_authenticator_ie(hs, ap_rsne);
 	handshake_state_set_mde(hs, mde);
 	handshake_state_set_fte(hs, fte);
 	handshake_state_set_kh_ids(hs, r0khid, strlen((void *) r0khid), r1khid);
diff --git a/unit/test-p2p.c b/unit/test-p2p.c
new file mode 100644
index 00000000..6638b5d9
--- /dev/null
+++ b/unit/test-p2p.c
@@ -0,0 +1,1178 @@
+/*
+ *
+ *  Wireless daemon for Linux
+ *
+ *  Copyright (C) 2019  Intel Corporation. All rights reserved.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <ell/ell.h>
+
+#include "src/p2putil.h"
+#include "src/ie.h"
+
+static const uint8_t p2p_attrs1[] = {
+	0x02, 0x02, 0x00, 0x25, 0x00, 0x0d, 0x1d, 0x00, 0x00, 0x28, 0xf8, 0xed,
+	0x26, 0x57, 0x11, 0x08, 0x00, 0x01, 0x00, 0x50, 0xf2, 0x04, 0x00, 0x01,
+	0x00, 0x10, 0x11, 0x00, 0x08, 0x74, 0x65, 0x73, 0x74, 0x64, 0x65, 0x76,
+	0x31, 0x0f, 0x15, 0x00, 0x2a, 0xfe, 0xcd, 0x01, 0xbe, 0xa0, 0x44, 0x49,
+	0x52, 0x45, 0x43, 0x54, 0x2d, 0x5a, 0x75, 0x2d, 0x41, 0x6e, 0x64, 0x72,
+	0x65,
+};
+
+static void p2p_test_iter_sanity_check(const void *data)
+{
+	struct p2p_attr_iter iter;
+
+	p2p_attr_iter_init(&iter, p2p_attrs1, sizeof(p2p_attrs1));
+
+	assert(p2p_attr_iter_next(&iter));
+	assert(p2p_attr_iter_get_type(&iter) == P2P_ATTR_P2P_CAPABILITY);
+	assert(p2p_attr_iter_get_length(&iter) == 2);
+
+	assert(p2p_attr_iter_next(&iter));
+	assert(p2p_attr_iter_get_type(&iter) == P2P_ATTR_P2P_DEVICE_INFO);
+	assert(p2p_attr_iter_get_length(&iter) == 29);
+
+	assert(p2p_attr_iter_next(&iter));
+	assert(p2p_attr_iter_get_type(&iter) == P2P_ATTR_P2P_GROUP_ID);
+	assert(p2p_attr_iter_get_length(&iter) == 21);
+
+	assert(!p2p_attr_iter_next(&iter));
+}
+
+typedef bool (*test_queue_cmp_func)(const void *data1, const void *data2);
+
+static bool test_queue_cmp(struct l_queue *q1, struct l_queue *q2,
+				test_queue_cmp_func func)
+{
+	const struct l_queue_entry *entry1 = l_queue_get_entries(q1);
+	const struct l_queue_entry *entry2 = l_queue_get_entries(q2);
+
+	while (entry1 && entry2) {
+		if (!func(entry1->data, entry2->data))
+			return false;
+
+		entry1 = entry1->next;
+		entry2 = entry2->next;
+	}
+
+	return !entry1 && !entry2;
+}
+
+static bool p2p_noa_desc_cmp(const void *data1, const void *data2)
+{
+	const struct p2p_notice_of_absence_desc *desc1 = data1;
+	const struct p2p_notice_of_absence_desc *desc2 = data2;
+
+	if (desc1->count_type != desc2->count_type)
+		return false;
+	if (desc1->duration != desc2->duration)
+		return false;
+	if (desc1->interval != desc2->interval)
+		return false;
+	if (desc1->start_time != desc2->start_time)
+		return false;
+
+	return true;
+}
+
+/*
+ * The attributes in a P2P IE are not explicitly required to be ordered
+ * in the same way they're listed in each frame's format specification in
+ * Wi-Fi P2P Technical Specification v1.7 and in fact some consumer devices
+ * switch some attributes' order in their probe responses.  This compares
+ * the contents of two sets of P2P IEs ignoring attribute order and payload
+ * segmentation into individual P2P IEs.
+ * TODO: Might also want to validate the WSC IEs written by the p2putil.c
+ * builder functions.
+ */
+static bool p2p_payload_cmd(const uint8_t *ies1, size_t ies1_len,
+				const uint8_t *ies2, size_t ies2_len)
+{
+	uint8_t *payload1, *payload2;
+	ssize_t payload1_len, payload2_len;
+	struct p2p_attr_iter iter1, iter2;
+	const uint8_t *attr1_start[P2P_ATTR_PERSISTENT_GROUP_INFO + 1];
+	int i;
+	bool r = false;
+
+	if (!ies1 || !ies2)
+		return false;
+
+	payload1 = ie_tlv_extract_p2p_payload(ies1, ies1_len, &payload1_len);
+	payload2 = ie_tlv_extract_p2p_payload(ies2, ies2_len, &payload2_len);
+
+	if (payload1_len < 0 || payload2_len < 0)
+		return false;
+
+	p2p_attr_iter_init(&iter1, payload1, payload1_len);
+	p2p_attr_iter_init(&iter2, payload2, payload2_len);
+
+	memset(attr1_start, 0, sizeof(attr1_start));
+
+	while (p2p_attr_iter_next(&iter1)) {
+		enum p2p_attr type = p2p_attr_iter_get_type(&iter1);
+		const uint8_t *start = p2p_attr_iter_get_data(&iter1) - 3;
+
+		if (type >= L_ARRAY_SIZE(attr1_start))
+			goto done;	/* Unknown attribute */
+
+		if (attr1_start[type])
+			goto done;	/* Duplicate attribute type in @ies1 */
+
+		attr1_start[type] = start;
+	}
+
+	while (p2p_attr_iter_next(&iter2)) {
+		enum p2p_attr type = p2p_attr_iter_get_type(&iter2);
+		const uint8_t *start = p2p_attr_iter_get_data(&iter2) - 3;
+		size_t len;
+
+		if ((int) type >= (int) L_ARRAY_SIZE(attr1_start))
+			goto done;	/* Unknown attribute */
+
+		if (!attr1_start[type])
+			goto done;	/* Not in @ies1 or dupe in @ies2 */
+
+		len = p2p_attr_iter_get_length(&iter2) + 3;
+
+		/*
+		 * It's safe to memcmp len bytes because the length is also
+		 * encoded in the first 3 bytes of both buffers.
+		 */
+		if (memcmp(start, attr1_start[type], len))
+			goto done;	/* Contents or lengths differ */
+
+		attr1_start[type] = NULL;
+	}
+
+	for (i = 0; i < (int) L_ARRAY_SIZE(attr1_start); i++)
+		if (attr1_start[i])
+			goto done;	/* @ies1 attribute was not in @ies2 */
+
+	r = true;
+
+done:
+	l_free(payload1);
+	l_free(payload2);
+	return r;
+}
+
+static const uint8_t p2p_beacon_ies_1[] = {
+	0xdd, 0x12, 0x50, 0x6f, 0x9a, 0x09, 0x02, 0x02, 0x00, 0x05, 0xab, 0x03,
+	0x06, 0x00, 0x2a, 0xfe, 0xcd, 0x01, 0xbe, 0xa0, 0xdd, 0x4e, 0x00, 0x50,
+	0xf2, 0x04, 0x10, 0x4a, 0x00, 0x01, 0x10, 0x10, 0x44, 0x00, 0x01, 0x02,
+	0x10, 0x41, 0x00, 0x01, 0x01, 0x10, 0x12, 0x00, 0x02, 0x00, 0x04, 0x10,
+	0x53, 0x00, 0x02, 0x43, 0x88, 0x10, 0x49, 0x00, 0x0e, 0x00, 0x37, 0x2a,
+	0x00, 0x01, 0x20, 0x01, 0x06, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10,
+	0x11, 0x00, 0x0d, 0x4c, 0x45, 0x58, 0x36, 0x32, 0x36, 0x2d, 0x50, 0x64,
+	0x61, 0x4e, 0x65, 0x74, 0x10, 0x54, 0x00, 0x08, 0x00, 0x08, 0x00, 0x50,
+	0xf2, 0x04, 0x00, 0x02, 0xdd, 0x16, 0x50, 0x6f, 0x9a, 0x09, 0x0c, 0x0f,
+	0x00, 0xe1, 0x00, 0x01, 0xb0, 0xb3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x7c, 0x45, 0x8f, 0x0c,
+};
+
+struct p2p_beacon_data {
+	const uint8_t *ies;
+	size_t ies_len;
+	ssize_t payload_len;
+	struct p2p_beacon data;
+	const struct p2p_notice_of_absence_desc *noa_descs;
+};
+
+static const struct p2p_beacon_data p2p_beacon_data_1 = {
+	.ies = p2p_beacon_ies_1,
+	.ies_len = L_ARRAY_SIZE(p2p_beacon_ies_1),
+	.payload_len = 32,
+	.data = {
+		.capability = {
+			.device_caps = P2P_DEVICE_CAP_SVC_DISCOVERY |
+				P2P_DEVICE_CAP_CONCURRENT_OP,
+			.group_caps = P2P_GROUP_CAP_GO |
+				P2P_GROUP_CAP_PERSISTENT_GROUP |
+				P2P_GROUP_CAP_INTRA_BSS_DISTRIBUTION |
+				P2P_GROUP_CAP_PERSISTENT_RECONNECT |
+				P2P_GROUP_CAP_IP_ALLOCATION,
+		},
+		.device_addr = { 0x2a, 0xfe, 0xcd, 0x01, 0xbe, 0xa0 },
+		.notice_of_absence = {
+			.index = 225,
+			.opp_ps = false,
+			.ct_window = 0,
+		},
+	},
+	.noa_descs = (const struct p2p_notice_of_absence_desc []) {
+		[0] = {
+			.count_type = 1,
+			.duration = 46000,
+			.interval = 0,
+			.start_time = 210716028,
+		},
+		[1] = {}
+	},
+};
+
+static void p2p_test_parse_beacon(const void *data)
+{
+	const struct p2p_beacon_data *test = data;
+	struct p2p_beacon attrs1, attrs2;
+	const struct p2p_notice_of_absence_desc *desc = test->noa_descs;
+	uint8_t *payload;
+	ssize_t payload_len;
+
+	payload = ie_tlv_extract_p2p_payload(test->ies, test->ies_len,
+						&payload_len);
+	l_free(payload);
+	assert(payload_len == test->payload_len);
+
+	memcpy(&attrs2, &test->data, sizeof(attrs2));
+
+	if (desc)
+		attrs2.notice_of_absence.descriptors = l_queue_new();
+
+	while (desc && desc->start_time) {
+		l_queue_push_tail(attrs2.notice_of_absence.descriptors,
+					l_memdup(desc, sizeof(*desc)));
+		desc++;
+	}
+
+	assert(p2p_parse_beacon(test->ies, test->ies_len, &attrs1) == 0);
+
+	assert(attrs1.capability.device_caps == attrs2.capability.device_caps);
+	assert(attrs1.capability.group_caps == attrs2.capability.group_caps);
+
+	assert(!memcmp(attrs1.device_addr, attrs2.device_addr, 6));
+
+	assert(attrs1.notice_of_absence.index ==
+		attrs2.notice_of_absence.index);
+	assert(attrs1.notice_of_absence.opp_ps ==
+		attrs2.notice_of_absence.opp_ps);
+	assert(attrs1.notice_of_absence.ct_window ==
+		attrs2.notice_of_absence.ct_window);
+	assert(test_queue_cmp(attrs1.notice_of_absence.descriptors,
+				attrs2.notice_of_absence.descriptors,
+				p2p_noa_desc_cmp));
+
+	p2p_free_beacon(&attrs1);
+	p2p_free_beacon(&attrs2);
+}
+
+static void p2p_test_build_beacon(const void *data)
+{
+	const struct p2p_beacon_data *test = data;
+	struct p2p_beacon attrs2;
+	const struct p2p_notice_of_absence_desc *desc = test->noa_descs;
+	uint8_t *ies;
+	size_t ies_len;
+
+	memcpy(&attrs2, &test->data, sizeof(attrs2));
+
+	if (desc)
+		attrs2.notice_of_absence.descriptors = l_queue_new();
+
+	while (desc && desc->start_time) {
+		l_queue_push_tail(attrs2.notice_of_absence.descriptors,
+					l_memdup(desc, sizeof(*desc)));
+		desc++;
+	}
+
+	ies = p2p_build_beacon(&attrs2, &ies_len);
+	p2p_free_beacon(&attrs2);
+
+	assert(p2p_payload_cmd(ies, ies_len, test->ies, test->ies_len));
+	l_free(ies);
+}
+
+static const uint8_t p2p_probe_req_ies_1[] = {
+	0xdd, 0x73, 0x00, 0x50, 0xf2, 0x04, 0x10, 0x4a, 0x00, 0x01, 0x10, 0x10,
+	0x3a, 0x00, 0x01, 0x01, 0x10, 0x08, 0x00, 0x02, 0x31, 0x48, 0x10, 0x47,
+	0x00, 0x10, 0x9a, 0xdd, 0x77, 0x82, 0xcb, 0xa6, 0x5e, 0x2d, 0xac, 0xd9,
+	0xc0, 0x54, 0x34, 0xd0, 0xd7, 0x29, 0x10, 0x54, 0x00, 0x08, 0x00, 0x01,
+	0x00, 0x50, 0xf2, 0x04, 0x00, 0x01, 0x10, 0x3c, 0x00, 0x01, 0x03, 0x10,
+	0x02, 0x00, 0x02, 0x00, 0x00, 0x10, 0x09, 0x00, 0x02, 0x00, 0x00, 0x10,
+	0x12, 0x00, 0x02, 0x00, 0x00, 0x10, 0x21, 0x00, 0x01, 0x20, 0x10, 0x23,
+	0x00, 0x01, 0x20, 0x10, 0x24, 0x00, 0x01, 0x20, 0x10, 0x11, 0x00, 0x08,
+	0x74, 0x65, 0x73, 0x74, 0x64, 0x65, 0x76, 0x31, 0x10, 0x49, 0x00, 0x09,
+	0x00, 0x37, 0x2a, 0x00, 0x01, 0x20, 0x03, 0x01, 0x01, 0xdd, 0x11, 0x50,
+	0x6f, 0x9a, 0x09, 0x02, 0x02, 0x00, 0x25, 0x00, 0x06, 0x05, 0x00, 0x58,
+	0x58, 0x04, 0x51, 0x01,
+};
+
+struct p2p_probe_req_data {
+	const uint8_t *ies;
+	size_t ies_len;
+	ssize_t payload_len;
+	struct p2p_probe_req data;
+};
+
+static const struct p2p_probe_req_data p2p_probe_req_data_1 = {
+	.ies = p2p_probe_req_ies_1,
+	.ies_len = L_ARRAY_SIZE(p2p_probe_req_ies_1),
+	.payload_len = 13,
+	.data = {
+		.capability = {
+			.device_caps = P2P_DEVICE_CAP_SVC_DISCOVERY |
+				P2P_DEVICE_CAP_CONCURRENT_OP |
+				P2P_DEVICE_CAP_INVITATION_PROCEDURE,
+			.group_caps = 0,
+		},
+		.listen_channel = {
+			.country = "XX\x04",
+			.oper_class = 81,
+			.channel_num = 1,
+		},
+	},
+};
+
+static void p2p_test_parse_probe_req(const void *data)
+{
+	const struct p2p_probe_req_data *test = data;
+	uint8_t *payload;
+	ssize_t payload_len;
+	struct p2p_probe_req attrs;
+
+	payload = ie_tlv_extract_p2p_payload(test->ies, test->ies_len,
+						&payload_len);
+	l_free(payload);
+	assert(payload_len == test->payload_len);
+
+	assert(p2p_parse_probe_req(test->ies, test->ies_len, &attrs) == 0);
+
+	assert(attrs.capability.device_caps ==
+		test->data.capability.device_caps);
+	assert(attrs.capability.group_caps == test->data.capability.group_caps);
+
+	assert(!memcmp(attrs.device_addr, test->data.device_addr, 6));
+
+	assert(!memcmp(attrs.listen_channel.country,
+			test->data.listen_channel.country, 3));
+	assert(attrs.listen_channel.oper_class ==
+		test->data.listen_channel.oper_class);
+	assert(attrs.listen_channel.channel_num ==
+		test->data.listen_channel.channel_num);
+
+	assert(attrs.listen_availability.avail_period_ms ==
+		test->data.listen_availability.avail_period_ms);
+	assert(attrs.listen_availability.avail_interval_ms ==
+		test->data.listen_availability.avail_interval_ms);
+
+	assert(!memcmp(attrs.device_info.device_addr,
+			test->data.device_info.device_addr, 6));
+	assert(attrs.device_info.wsc_config_methods ==
+		test->data.device_info.wsc_config_methods);
+	assert(attrs.device_info.primary_device_type.category ==
+		test->data.device_info.primary_device_type.category);
+	assert(!memcmp(attrs.device_info.primary_device_type.oui,
+			test->data.device_info.primary_device_type.oui, 3));
+	assert(attrs.device_info.primary_device_type.oui_type ==
+		test->data.device_info.primary_device_type.oui_type);
+	assert(attrs.device_info.primary_device_type.subcategory ==
+		test->data.device_info.primary_device_type.subcategory);
+	assert(l_queue_length(attrs.device_info.secondary_device_types) ==
+		l_queue_length(test->data.device_info.secondary_device_types));
+	assert(!strcmp(attrs.device_info.device_name,
+			test->data.device_info.device_name));
+
+	assert(!memcmp(attrs.operating_channel.country,
+			test->data.operating_channel.country, 3));
+	assert(attrs.operating_channel.oper_class ==
+		test->data.operating_channel.oper_class);
+	assert(attrs.operating_channel.channel_num ==
+		test->data.operating_channel.channel_num);
+
+	assert(l_queue_length(attrs.service_hashes) ==
+		l_queue_length(test->data.service_hashes));
+
+	p2p_free_probe_req(&attrs);
+}
+
+static void p2p_test_build_probe_req(const void *data)
+{
+	const struct p2p_probe_req_data *test = data;
+	uint8_t *ies;
+	size_t ies_len;
+
+	ies = p2p_build_probe_req(&test->data, &ies_len);
+
+	assert(p2p_payload_cmd(ies, ies_len, test->ies, test->ies_len));
+	l_free(ies);
+}
+
+/* Notice of Absence and Device Info in the wrong order */
+static const uint8_t p2p_probe_resp_ies_1[] = {
+	0xdd, 0xa2, 0x00, 0x50, 0xf2, 0x04, 0x10, 0x4a, 0x00, 0x01, 0x10, 0x10,
+	0x44, 0x00, 0x01, 0x02, 0x10, 0x41, 0x00, 0x01, 0x01, 0x10, 0x12, 0x00,
+	0x02, 0x00, 0x04, 0x10, 0x53, 0x00, 0x02, 0x43, 0x88, 0x10, 0x3b, 0x00,
+	0x01, 0x03, 0x10, 0x47, 0x00, 0x10, 0xb1, 0x7d, 0x6f, 0xc9, 0x4f, 0xd1,
+	0x5a, 0x6f, 0xb6, 0x50, 0x53, 0x11, 0x0b, 0x2a, 0xb5, 0x25, 0x10, 0x21,
+	0x00, 0x0d, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x54, 0x65, 0x6b, 0x20, 0x49,
+	0x6e, 0x63, 0x2e, 0x10, 0x23, 0x00, 0x12, 0x4d, 0x54, 0x4b, 0x20, 0x57,
+	0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x20, 0x4d, 0x6f, 0x64, 0x65,
+	0x6c, 0x10, 0x24, 0x00, 0x03, 0x31, 0x2e, 0x30, 0x10, 0x42, 0x00, 0x03,
+	0x32, 0x2e, 0x30, 0x10, 0x54, 0x00, 0x08, 0x00, 0x08, 0x00, 0x50, 0xf2,
+	0x04, 0x00, 0x02, 0x10, 0x11, 0x00, 0x0d, 0x4c, 0x45, 0x58, 0x36, 0x32,
+	0x36, 0x2d, 0x50, 0x64, 0x61, 0x4e, 0x65, 0x74, 0x10, 0x08, 0x00, 0x02,
+	0x41, 0x08, 0x10, 0x49, 0x00, 0x0e, 0x00, 0x37, 0x2a, 0x00, 0x01, 0x20,
+	0x01, 0x06, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 0x27, 0x50, 0x6f,
+	0x9a, 0x09, 0x02, 0x02, 0x00, 0x05, 0xab, 0x0d, 0x1b, 0x00, 0x2a, 0xfe,
+	0xcd, 0x01, 0xbe, 0xa0, 0x01, 0x88, 0x00, 0x08, 0x00, 0x50, 0xf2, 0x04,
+	0x00, 0x02, 0x00, 0x10, 0x11, 0x00, 0x06, 0x4d, 0x6f, 0x62, 0x69, 0x6c,
+	0x65, 0xdd, 0x16, 0x50, 0x6f, 0x9a, 0x09, 0x0c, 0x0f, 0x00, 0xe1, 0x00,
+	0x01, 0xb0, 0xb3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x45, 0x8f,
+	0x0c,
+};
+
+struct p2p_probe_resp_data {
+	const uint8_t *ies;
+	size_t ies_len;
+	ssize_t payload_len;
+	struct p2p_probe_resp data;
+	const struct p2p_notice_of_absence_desc *noa_descs;
+};
+
+static const struct p2p_probe_resp_data p2p_probe_resp_data_1 = {
+	.ies = p2p_probe_resp_ies_1,
+	.ies_len = L_ARRAY_SIZE(p2p_probe_resp_ies_1),
+	.payload_len = 53,
+	.data = {
+		.capability = {
+			.device_caps = P2P_DEVICE_CAP_SVC_DISCOVERY |
+				P2P_DEVICE_CAP_CONCURRENT_OP,
+			.group_caps = P2P_GROUP_CAP_GO |
+				P2P_GROUP_CAP_PERSISTENT_GROUP |
+				P2P_GROUP_CAP_INTRA_BSS_DISTRIBUTION |
+				P2P_GROUP_CAP_PERSISTENT_RECONNECT |
+				P2P_GROUP_CAP_IP_ALLOCATION,
+		},
+		.notice_of_absence = {
+			.index = 225,
+			.opp_ps = false,
+			.ct_window = 0,
+		},
+		.device_info = {
+			.device_addr = { 0x2a, 0xfe, 0xcd, 0x01, 0xbe, 0xa0 },
+			.wsc_config_methods = WSC_CONFIGURATION_METHOD_DISPLAY |
+				WSC_CONFIGURATION_METHOD_PUSH_BUTTON |
+				WSC_CONFIGURATION_METHOD_KEYPAD,
+			.primary_device_type = {
+				.category = 8,
+				.oui = { 0x00, 0x50, 0xf2 },
+				.oui_type = 0x04,
+				.subcategory = 2,
+			},
+			.device_name = "Mobile",
+		},
+	},
+	.noa_descs = (const struct p2p_notice_of_absence_desc []) {
+		[0] = {
+			.count_type = 1,
+			.duration = 46000,
+			.interval = 0,
+			.start_time = 210716028,
+		},
+		[1] = {}
+	},
+};
+
+static const uint8_t p2p_probe_resp_ies_2[] = {
+	0xdd, 0x3e, 0x50, 0x6f, 0x9a, 0x09, 0x02, 0x02, 0x00, 0x05, 0x01, 0x0d,
+	0x32, 0x00, 0xa2, 0x8c, 0xfd, 0xb9, 0x05, 0xef, 0x5a, 0x88, 0x00, 0x03,
+	0x00, 0x50, 0xf2, 0x04, 0x00, 0x01, 0x00, 0x10, 0x11, 0x00, 0x1d, 0x44,
+	0x49, 0x52, 0x45, 0x43, 0x54, 0x2d, 0x45, 0x46, 0x2d, 0x48, 0x50, 0x20,
+	0x45, 0x4e, 0x56, 0x59, 0x20, 0x34, 0x35, 0x32, 0x30, 0x20, 0x73, 0x65,
+	0x72, 0x69, 0x65, 0x73, 0xdd, 0xc1, 0x00, 0x50, 0xf2, 0x04, 0x10, 0x4a,
+	0x00, 0x01, 0x10, 0x10, 0x44, 0x00, 0x01, 0x02, 0x10, 0x57, 0x00, 0x01,
+	0x01, 0x10, 0x41, 0x00, 0x01, 0x00, 0x10, 0x3b, 0x00, 0x01, 0x03, 0x10,
+	0x47, 0x00, 0x10, 0x1c, 0x85, 0x2a, 0x4d, 0xb8, 0x00, 0x1f, 0x08, 0xab,
+	0xcd, 0xa0, 0x8c, 0xfd, 0xb9, 0x05, 0xef, 0x10, 0x21, 0x00, 0x02, 0x48,
+	0x50, 0x10, 0x23, 0x00, 0x11, 0x45, 0x4e, 0x56, 0x59, 0x20, 0x34, 0x35,
+	0x32, 0x30, 0x20, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x00, 0x10, 0x24,
+	0x00, 0x05, 0x34, 0x35, 0x32, 0x37, 0x00, 0x10, 0x42, 0x00, 0x10, 0x54,
+	0x48, 0x36, 0x35, 0x4f, 0x33, 0x48, 0x31, 0x58, 0x59, 0x30, 0x36, 0x36,
+	0x30, 0x00, 0x00, 0x10, 0x54, 0x00, 0x08, 0x00, 0x03, 0x00, 0x50, 0xf2,
+	0x04, 0x00, 0x05, 0x10, 0x11, 0x00, 0x1d, 0x44, 0x49, 0x52, 0x45, 0x43,
+	0x54, 0x2d, 0x45, 0x46, 0x2d, 0x48, 0x50, 0x20, 0x45, 0x4e, 0x56, 0x59,
+	0x20, 0x34, 0x35, 0x32, 0x30, 0x20, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73,
+	0x10, 0x08, 0x00, 0x02, 0x00, 0x00, 0x10, 0x49, 0x00, 0x06, 0x00, 0x37,
+	0x2a, 0x00, 0x01, 0x20, 0x10, 0x49, 0x00, 0x17, 0x00, 0x01, 0x37, 0x10,
+	0x06, 0x00, 0x10, 0x1c, 0x85, 0x2a, 0x4d, 0xb8, 0x00, 0x1f, 0x08, 0xab,
+	0xcd, 0xa0, 0x8c, 0xfd, 0xb9, 0x05, 0xef,
+};
+
+static const struct p2p_probe_resp_data p2p_probe_resp_data_2 = {
+	.ies = p2p_probe_resp_ies_2,
+	.ies_len = L_ARRAY_SIZE(p2p_probe_resp_ies_2),
+	.payload_len = 58,
+	.data = {
+		.capability = {
+			.device_caps = P2P_DEVICE_CAP_SVC_DISCOVERY |
+				P2P_DEVICE_CAP_CONCURRENT_OP,
+			.group_caps = P2P_GROUP_CAP_GO,
+		},
+		.device_info = {
+			.device_addr = { 0xa2, 0x8c, 0xfd, 0xb9, 0x05, 0xef },
+			.wsc_config_methods =
+				WSC_CONFIGURATION_METHOD_VIRTUAL_PUSH_BUTTON |
+				0x0800 | WSC_CONFIGURATION_METHOD_P2P |
+				WSC_CONFIGURATION_METHOD_PHYSICAL_DISPLAY_PIN,
+			.primary_device_type = {
+				.category = 3,
+				.oui = { 0x00, 0x50, 0xf2 },
+				.oui_type = 0x04,
+				.subcategory = 1,
+			},
+			.device_name = "DIRECT-EF-HP ENVY 4520 series",
+		},
+	},
+};
+
+static void p2p_test_parse_probe_resp(const void *data)
+{
+	const struct p2p_probe_resp_data *test = data;
+	struct p2p_probe_resp attrs1, attrs2;
+	const struct p2p_notice_of_absence_desc *desc = test->noa_descs;
+	uint8_t *payload;
+	ssize_t payload_len;
+
+	payload = ie_tlv_extract_p2p_payload(test->ies, test->ies_len,
+						&payload_len);
+	l_free(payload);
+	assert(payload_len == test->payload_len);
+
+	assert(p2p_parse_probe_resp(test->ies, test->ies_len, &attrs1) == 0);
+
+	memcpy(&attrs2, &test->data, sizeof(attrs2));
+
+	if (desc)
+		attrs2.notice_of_absence.descriptors = l_queue_new();
+
+	while (desc && desc->start_time) {
+		l_queue_push_tail(attrs2.notice_of_absence.descriptors,
+					l_memdup(desc, sizeof(*desc)));
+		desc++;
+	}
+
+	assert(attrs1.capability.device_caps == attrs2.capability.device_caps);
+	assert(attrs1.capability.group_caps == attrs2.capability.group_caps);
+
+	assert(attrs1.listen_availability.avail_period_ms ==
+		attrs2.listen_availability.avail_period_ms);
+	assert(attrs1.listen_availability.avail_interval_ms ==
+		attrs2.listen_availability.avail_interval_ms);
+
+	assert(attrs1.notice_of_absence.index ==
+		attrs2.notice_of_absence.index);
+	assert(attrs1.notice_of_absence.opp_ps ==
+		attrs2.notice_of_absence.opp_ps);
+	assert(attrs1.notice_of_absence.ct_window ==
+		attrs2.notice_of_absence.ct_window);
+	assert(test_queue_cmp(attrs1.notice_of_absence.descriptors,
+				attrs2.notice_of_absence.descriptors,
+				p2p_noa_desc_cmp));
+
+	assert(!memcmp(attrs1.device_info.device_addr,
+			attrs2.device_info.device_addr, 6));
+	assert(attrs1.device_info.wsc_config_methods ==
+		attrs2.device_info.wsc_config_methods);
+	assert(attrs1.device_info.primary_device_type.category ==
+		attrs2.device_info.primary_device_type.category);
+	assert(!memcmp(attrs1.device_info.primary_device_type.oui,
+			attrs2.device_info.primary_device_type.oui, 3));
+	assert(attrs1.device_info.primary_device_type.oui_type ==
+		attrs2.device_info.primary_device_type.oui_type);
+	assert(attrs1.device_info.primary_device_type.subcategory ==
+		attrs2.device_info.primary_device_type.subcategory);
+	assert(l_queue_length(attrs1.device_info.secondary_device_types) ==
+		l_queue_length(attrs2.device_info.secondary_device_types));
+	assert(!strcmp(attrs1.device_info.device_name,
+			attrs2.device_info.device_name));
+
+	assert(l_queue_length(attrs1.group_clients) ==
+		l_queue_length(attrs2.group_clients));
+
+	assert(l_queue_length(attrs1.advertised_svcs) ==
+		l_queue_length(attrs2.advertised_svcs));
+
+	p2p_free_probe_resp(&attrs1);
+	p2p_free_probe_resp(&attrs2);
+}
+
+static void p2p_test_build_probe_resp(const void *data)
+{
+	const struct p2p_probe_resp_data *test = data;
+	struct p2p_probe_resp attrs2;
+	const struct p2p_notice_of_absence_desc *desc = test->noa_descs;
+	uint8_t *ies;
+	size_t ies_len;
+
+	memcpy(&attrs2, &test->data, sizeof(attrs2));
+
+	if (desc)
+		attrs2.notice_of_absence.descriptors = l_queue_new();
+
+	while (desc && desc->start_time) {
+		l_queue_push_tail(attrs2.notice_of_absence.descriptors,
+					l_memdup(desc, sizeof(*desc)));
+		desc++;
+	}
+
+	ies = p2p_build_probe_resp(&attrs2, &ies_len);
+	p2p_free_probe_resp(&attrs2);
+
+	assert(p2p_payload_cmd(ies, ies_len, test->ies, test->ies_len));
+	l_free(ies);
+}
+
+static const uint8_t p2p_association_req_ies_1[] = {
+	0xdd, 0x18, 0x00, 0x50, 0xf2, 0x04, 0x10, 0x4a, 0x00, 0x01, 0x10, 0x10,
+	0x3a, 0x00, 0x01, 0x01, 0x10, 0x49, 0x00, 0x06, 0x00, 0x37, 0x2a, 0x00,
+	0x01, 0x20, 0xdd, 0x29, 0x50, 0x6f, 0x9a, 0x09, 0x02, 0x02, 0x00, 0x27,
+	0x00, 0x0d, 0x1d, 0x00, 0x00, 0x28, 0xf8, 0xed, 0x26, 0x57, 0x11, 0x08,
+	0x00, 0x01, 0x00, 0x50, 0xf2, 0x04, 0x00, 0x01, 0x00, 0x10, 0x11, 0x00,
+	0x08, 0x74, 0x65, 0x73, 0x74, 0x64, 0x65, 0x76, 0x31,
+};
+
+struct p2p_association_req_data {
+	const uint8_t *ies;
+	size_t ies_len;
+	ssize_t payload_len;
+	struct p2p_association_req data;
+};
+
+static const struct p2p_association_req_data p2p_association_req_data_1 = {
+	.ies = p2p_association_req_ies_1,
+	.ies_len = L_ARRAY_SIZE(p2p_association_req_ies_1),
+	.payload_len = 37,
+	.data = {
+		.capability = {
+			.device_caps = P2P_DEVICE_CAP_SVC_DISCOVERY |
+				P2P_DEVICE_CAP_CLIENT_DISCOVERABILITY |
+				P2P_DEVICE_CAP_CONCURRENT_OP |
+				P2P_DEVICE_CAP_INVITATION_PROCEDURE,
+			.group_caps = 0,
+		},
+		.device_info = {
+			.device_addr = { 0x00, 0x28, 0xf8, 0xed, 0x26, 0x57 },
+			.wsc_config_methods = WSC_CONFIGURATION_METHOD_DISPLAY |
+				WSC_CONFIGURATION_METHOD_KEYPAD |
+				WSC_CONFIGURATION_METHOD_P2P,
+			.primary_device_type = {
+				.category = 1,
+				.oui = { 0x00, 0x50, 0xf2 },
+				.oui_type = 0x04,
+				.subcategory = 1,
+			},
+			.device_name = "testdev1",
+		},
+	},
+};
+
+static void p2p_test_parse_association_req(const void *data)
+{
+	const struct p2p_association_req_data *test = data;
+	struct p2p_association_req attrs1, attrs2;
+	uint8_t *payload;
+	ssize_t payload_len;
+
+	payload = ie_tlv_extract_p2p_payload(test->ies, test->ies_len,
+						&payload_len);
+	l_free(payload);
+	assert(payload_len == test->payload_len);
+
+	assert(p2p_parse_association_req(test->ies, test->ies_len, &attrs1) ==
+		0);
+
+	memcpy(&attrs2, &test->data, sizeof(attrs2));
+
+	assert(attrs1.capability.device_caps == attrs2.capability.device_caps);
+	assert(attrs1.capability.group_caps == attrs2.capability.group_caps);
+
+	assert(attrs1.listen_availability.avail_period_ms ==
+		attrs2.listen_availability.avail_period_ms);
+	assert(attrs1.listen_availability.avail_interval_ms ==
+		attrs2.listen_availability.avail_interval_ms);
+
+	assert(!memcmp(attrs1.device_info.device_addr,
+			attrs2.device_info.device_addr, 6));
+	assert(attrs1.device_info.wsc_config_methods ==
+		attrs2.device_info.wsc_config_methods);
+	assert(attrs1.device_info.primary_device_type.category ==
+		attrs2.device_info.primary_device_type.category);
+	assert(!memcmp(attrs1.device_info.primary_device_type.oui,
+			attrs2.device_info.primary_device_type.oui, 3));
+	assert(attrs1.device_info.primary_device_type.oui_type ==
+		attrs2.device_info.primary_device_type.oui_type);
+	assert(attrs1.device_info.primary_device_type.subcategory ==
+		attrs2.device_info.primary_device_type.subcategory);
+	assert(l_queue_length(attrs1.device_info.secondary_device_types) ==
+		l_queue_length(attrs2.device_info.secondary_device_types));
+	assert(!strcmp(attrs1.device_info.device_name,
+			attrs2.device_info.device_name));
+
+	assert(!memcmp(attrs1.interface.device_addr,
+			attrs2.interface.device_addr, 6));
+	assert(l_queue_length(attrs1.interface.interface_addrs) ==
+		l_queue_length(attrs2.interface.interface_addrs));
+
+	p2p_free_association_req(&attrs1);
+	p2p_free_association_req(&attrs2);
+}
+
+static void p2p_test_build_association_req(const void *data)
+{
+	const struct p2p_association_req_data *test = data;
+	uint8_t *ies;
+	size_t ies_len;
+
+	ies = p2p_build_association_req(&test->data, &ies_len);
+
+	assert(p2p_payload_cmd(ies, ies_len, test->ies, test->ies_len));
+	l_free(ies);
+}
+
+/* Obligatory P2P IE empty here */
+static const uint8_t p2p_association_resp_ies_1[] = {
+	0x01, 0x08, 0x8c, 0x12, 0x98, 0x24, 0xb0, 0x48, 0x60, 0x6c, 0x2d, 0x1a,
+	0x73, 0x11, 0x03, 0xff, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x3d, 0x16, 0x64, 0x05, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xdd, 0x04, 0x50, 0x6f, 0x9a, 0x09, 0x7f, 0x08, 0x01, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xbf, 0x0c, 0x30, 0x71, 0x90, 0x03,
+	0xfe, 0xff, 0x00, 0x00, 0xfe, 0xff, 0x00, 0x00, 0xc0, 0x05, 0x00, 0x00,
+	0x00, 0xfe, 0xff, 0xdd, 0x18, 0x00, 0x50, 0xf2, 0x02, 0x01, 0x01, 0x80,
+	0x01, 0x03, 0xa4, 0x00, 0x00, 0x27, 0xa4, 0x00, 0x00, 0x42, 0x43, 0x5e,
+	0x00, 0x62, 0x32, 0x2f, 0x00, 0xdd, 0x07, 0x00, 0x0c, 0xe7, 0x08, 0x00,
+	0x00, 0x00,
+};
+
+struct p2p_association_resp_data {
+	const uint8_t *ies;
+	size_t ies_len;
+	ssize_t payload_len;
+	struct p2p_association_resp data;
+};
+
+static const struct p2p_association_resp_data p2p_association_resp_data_1 = {
+	.ies = p2p_association_resp_ies_1,
+	.ies_len = L_ARRAY_SIZE(p2p_association_resp_ies_1),
+	.payload_len = 0,
+	.data = {},
+};
+
+static void p2p_test_parse_association_resp(const void *data)
+{
+	const struct p2p_association_resp_data *test = data;
+	struct p2p_association_resp attrs1, attrs2;
+	uint8_t *payload;
+	ssize_t payload_len;
+
+	payload = ie_tlv_extract_p2p_payload(test->ies, test->ies_len,
+						&payload_len);
+	l_free(payload);
+	assert(payload_len == test->payload_len);
+
+	assert(p2p_parse_association_resp(test->ies, test->ies_len, &attrs1) ==
+		0);
+
+	memcpy(&attrs2, &test->data, sizeof(attrs2));
+
+	assert(attrs1.status == attrs2.status);
+
+	assert(attrs1.listen_availability.avail_period_ms ==
+		attrs2.listen_availability.avail_period_ms);
+	assert(attrs1.listen_availability.avail_interval_ms ==
+		attrs2.listen_availability.avail_interval_ms);
+
+	p2p_free_association_resp(&attrs1);
+	p2p_free_association_resp(&attrs2);
+}
+
+static void p2p_test_build_association_resp(const void *data)
+{
+	const struct p2p_association_resp_data *test = data;
+	uint8_t *ies;
+	size_t ies_len;
+
+	ies = p2p_build_association_resp(&test->data, &ies_len);
+
+	assert(p2p_payload_cmd(ies, ies_len, test->ies, test->ies_len));
+	l_free(ies);
+}
+
+static const uint8_t p2p_provision_disc_req_1[] = {
+	0x04, 0x09, 0x50, 0x6f, 0x9a, 0x09, 0x07, 0x01, 0xdd, 0x41, 0x50, 0x6f,
+	0x9a, 0x09, 0x02, 0x02, 0x00, 0x25, 0x00, 0x0d, 0x1d, 0x00, 0x00, 0x28,
+	0xf8, 0xed, 0x26, 0x57, 0x11, 0x08, 0x00, 0x01, 0x00, 0x50, 0xf2, 0x04,
+	0x00, 0x01, 0x00, 0x10, 0x11, 0x00, 0x08, 0x74, 0x65, 0x73, 0x74, 0x64,
+	0x65, 0x76, 0x31, 0x0f, 0x15, 0x00, 0x2a, 0xfe, 0xcd, 0x01, 0xbe, 0xa0,
+	0x44, 0x49, 0x52, 0x45, 0x43, 0x54, 0x2d, 0x5a, 0x75, 0x2d, 0x54, 0x65,
+	0x73, 0x74, 0x31, 0xdd, 0x0a, 0x00, 0x50, 0xf2, 0x04, 0x10, 0x08, 0x00,
+	0x02, 0x00, 0x80,
+};
+
+struct p2p_provision_disc_req_data {
+	const uint8_t *frame;
+	size_t frame_len;
+	ssize_t payload_len;
+	struct p2p_provision_discovery_req data;
+};
+
+static const struct p2p_provision_disc_req_data p2p_provision_disc_req_data_1 =
+{
+	.frame = p2p_provision_disc_req_1,
+	.frame_len = L_ARRAY_SIZE(p2p_provision_disc_req_1),
+	.payload_len = 61,
+	.data = {
+		.dialog_token = 1,
+		.capability = {
+			.device_caps = P2P_DEVICE_CAP_SVC_DISCOVERY |
+				P2P_DEVICE_CAP_CONCURRENT_OP |
+				P2P_DEVICE_CAP_INVITATION_PROCEDURE,
+			.group_caps = 0,
+		},
+		.device_info = {
+			.device_addr = { 0x00, 0x28, 0xf8, 0xed, 0x26, 0x57 },
+			.wsc_config_methods = WSC_CONFIGURATION_METHOD_DISPLAY |
+				WSC_CONFIGURATION_METHOD_KEYPAD |
+				WSC_CONFIGURATION_METHOD_P2P,
+			.primary_device_type = {
+				.category = 1,
+				.oui = { 0x00, 0x50, 0xf2 },
+				.oui_type = 0x04,
+				.subcategory = 1,
+			},
+			.device_name = "testdev1",
+		},
+		.group_id = {
+			.device_addr = { 0x2a, 0xfe, 0xcd, 0x01, 0xbe, 0xa0 },
+			.ssid = "DIRECT-Zu-Test1",
+		},
+		.status = -1,
+		.wsc_config_method = WSC_CONFIGURATION_METHOD_PUSH_BUTTON,
+	},
+};
+
+static void p2p_test_parse_provision_disc_req(const void *data)
+{
+	const struct p2p_provision_disc_req_data *test = data;
+	struct p2p_provision_discovery_req attrs1, attrs2;
+	uint8_t *payload;
+	ssize_t payload_len;
+
+	payload = ie_tlv_extract_p2p_payload(test->frame + 8,
+						test->frame_len - 8,
+						&payload_len);
+	l_free(payload);
+	assert(payload_len == test->payload_len);
+
+	assert(p2p_parse_provision_disc_req(test->frame + 7,
+						test->frame_len - 7,
+						&attrs1) == 0);
+
+	memcpy(&attrs2, &test->data, sizeof(attrs2));
+
+	assert(attrs1.dialog_token == attrs2.dialog_token);
+
+	assert(attrs1.capability.device_caps == attrs2.capability.device_caps);
+	assert(attrs1.capability.group_caps == attrs2.capability.group_caps);
+
+	assert(!memcmp(attrs1.device_info.device_addr,
+			attrs2.device_info.device_addr, 6));
+	assert(attrs1.device_info.wsc_config_methods ==
+		attrs2.device_info.wsc_config_methods);
+	assert(attrs1.device_info.primary_device_type.category ==
+		attrs2.device_info.primary_device_type.category);
+	assert(!memcmp(attrs1.device_info.primary_device_type.oui,
+			attrs2.device_info.primary_device_type.oui, 3));
+	assert(attrs1.device_info.primary_device_type.oui_type ==
+		attrs2.device_info.primary_device_type.oui_type);
+	assert(attrs1.device_info.primary_device_type.subcategory ==
+		attrs2.device_info.primary_device_type.subcategory);
+	assert(l_queue_length(attrs1.device_info.secondary_device_types) ==
+		l_queue_length(attrs2.device_info.secondary_device_types));
+	assert(!strcmp(attrs1.device_info.device_name,
+			attrs2.device_info.device_name));
+
+	assert(!memcmp(attrs1.group_id.device_addr,
+			attrs2.group_id.device_addr, 6));
+	assert(!strcmp(attrs1.group_id.ssid, attrs2.group_id.ssid));
+
+	assert(!memcmp(attrs1.intended_interface_addr,
+			attrs2.intended_interface_addr, 6));
+
+	assert(attrs1.status == attrs2.status);
+
+	assert(!memcmp(attrs1.operating_channel.country,
+			attrs2.operating_channel.country, 3));
+	assert(attrs1.operating_channel.oper_class ==
+		attrs2.operating_channel.oper_class);
+	assert(attrs1.operating_channel.channel_num ==
+		attrs2.operating_channel.channel_num);
+
+	assert(!memcmp(attrs1.channel_list.country,
+			attrs2.channel_list.country, 3));
+	assert(l_queue_length(attrs1.channel_list.channel_entries) ==
+		l_queue_length(attrs2.channel_list.channel_entries));
+
+	assert(attrs1.session_info.data_len == attrs2.session_info.data_len);
+	assert(!attrs1.session_info.data_len ||
+		!memcmp(attrs1.session_info.data, attrs2.session_info.data,
+			attrs1.session_info.data_len));
+
+	assert(attrs1.connection_capability == attrs2.connection_capability);
+
+	assert(attrs1.advertisement_id.advertisement_id ==
+		attrs2.advertisement_id.advertisement_id);
+	assert(!memcmp(attrs1.advertisement_id.service_mac_addr,
+			attrs2.advertisement_id.service_mac_addr, 6));
+
+	assert(attrs1.config_timeout.go_config_timeout ==
+		attrs2.config_timeout.go_config_timeout);
+	assert(attrs1.config_timeout.client_config_timeout ==
+		attrs2.config_timeout.client_config_timeout);
+
+	assert(!memcmp(attrs1.listen_channel.country,
+			attrs2.listen_channel.country, 3));
+	assert(attrs1.listen_channel.oper_class ==
+		attrs2.listen_channel.oper_class);
+	assert(attrs1.listen_channel.channel_num ==
+		attrs2.listen_channel.channel_num);
+
+	assert(attrs1.session_id.session_id == attrs2.session_id.session_id);
+	assert(!memcmp(attrs1.session_id.session_mac_addr,
+			attrs2.session_id.session_mac_addr, 6));
+
+	assert(attrs1.transport_protocol == attrs2.transport_protocol);
+
+	assert(!memcmp(attrs1.persistent_group_info.device_addr,
+			attrs2.persistent_group_info.device_addr, 6));
+	assert(!strcmp(attrs1.persistent_group_info.ssid,
+			attrs2.persistent_group_info.ssid));
+
+	assert(attrs1.wsc_config_method == attrs2.wsc_config_method);
+
+	p2p_free_provision_disc_req(&attrs1);
+	p2p_free_provision_disc_req(&attrs2);
+}
+
+static void p2p_test_build_provision_disc_req(const void *data)
+{
+	const struct p2p_provision_disc_req_data *test = data;
+	uint8_t *frame;
+	size_t frame_len;
+
+	frame = p2p_build_provision_disc_req(&test->data, &frame_len);
+
+	assert(!memcmp(frame, test->frame, 8));
+	assert(p2p_payload_cmd(frame + 8, frame_len - 8,
+				test->frame + 8, test->frame_len - 8));
+	l_free(frame);
+}
+
+/* The optional P2P IE not present here */
+static const uint8_t p2p_provision_disc_resp_1[] = {
+	0x04, 0x09, 0x50, 0x6f, 0x9a, 0x09, 0x08, 0x01, 0xdd, 0x0a, 0x00, 0x50,
+	0xf2, 0x04, 0x10, 0x08, 0x00, 0x02, 0x00, 0x80, 0xdd, 0x0d, 0x50, 0x6f,
+	0x9a, 0x0a, 0x00, 0x00, 0x06, 0x00, 0x11, 0x00, 0x00, 0x00, 0x32,
+};
+
+struct p2p_provision_disc_resp_data {
+	const uint8_t *frame;
+	size_t frame_len;
+	ssize_t payload_len;
+	struct p2p_provision_discovery_resp data;
+};
+
+static const struct p2p_provision_disc_resp_data
+		p2p_provision_disc_resp_data_1 = {
+	.frame = p2p_provision_disc_resp_1,
+	.frame_len = L_ARRAY_SIZE(p2p_provision_disc_resp_1),
+	.payload_len = -ENOENT,
+	.data = {
+		.dialog_token = 1,
+		.status = -1,
+		.wsc_config_method = WSC_CONFIGURATION_METHOD_PUSH_BUTTON,
+	},
+};
+
+static void p2p_test_parse_provision_disc_resp(const void *data)
+{
+	const struct p2p_provision_disc_resp_data *test = data;
+	struct p2p_provision_discovery_resp attrs1, attrs2;
+	uint8_t *payload;
+	ssize_t payload_len;
+
+	payload = ie_tlv_extract_p2p_payload(test->frame + 8,
+						test->frame_len - 8,
+						&payload_len);
+	if (payload_len >= 0)
+		l_free(payload);
+
+	assert(payload_len == test->payload_len);
+
+	assert(p2p_parse_provision_disc_resp(test->frame + 7,
+						test->frame_len - 7,
+						&attrs1) == 0);
+
+	memcpy(&attrs2, &test->data, sizeof(attrs2));
+
+	assert(attrs1.dialog_token == attrs2.dialog_token);
+
+	assert(attrs1.status == attrs2.status);
+
+	assert(attrs1.capability.device_caps == attrs2.capability.device_caps);
+	assert(attrs1.capability.group_caps == attrs2.capability.group_caps);
+
+	assert(!memcmp(attrs1.device_info.device_addr,
+			attrs2.device_info.device_addr, 6));
+	assert(attrs1.device_info.wsc_config_methods ==
+		attrs2.device_info.wsc_config_methods);
+	assert(attrs1.device_info.primary_device_type.category ==
+		attrs2.device_info.primary_device_type.category);
+	assert(!memcmp(attrs1.device_info.primary_device_type.oui,
+			attrs2.device_info.primary_device_type.oui, 3));
+	assert(attrs1.device_info.primary_device_type.oui_type ==
+		attrs2.device_info.primary_device_type.oui_type);
+	assert(attrs1.device_info.primary_device_type.subcategory ==
+		attrs2.device_info.primary_device_type.subcategory);
+	assert(l_queue_length(attrs1.device_info.secondary_device_types) ==
+		l_queue_length(attrs2.device_info.secondary_device_types));
+	assert(!strcmp(attrs1.device_info.device_name,
+			attrs2.device_info.device_name));
+
+	assert(!memcmp(attrs1.group_id.device_addr,
+			attrs2.group_id.device_addr, 6));
+	assert(!strcmp(attrs1.group_id.ssid, attrs2.group_id.ssid));
+
+	assert(!memcmp(attrs1.intended_interface_addr,
+			attrs2.intended_interface_addr, 6));
+
+	assert(!memcmp(attrs1.operating_channel.country,
+			attrs2.operating_channel.country, 3));
+	assert(attrs1.operating_channel.oper_class ==
+		attrs2.operating_channel.oper_class);
+	assert(attrs1.operating_channel.channel_num ==
+		attrs2.operating_channel.channel_num);
+
+	assert(!memcmp(attrs1.channel_list.country,
+			attrs2.channel_list.country, 3));
+	assert(l_queue_length(attrs1.channel_list.channel_entries) ==
+		l_queue_length(attrs2.channel_list.channel_entries));
+
+	assert(attrs1.connection_capability == attrs2.connection_capability);
+
+	assert(attrs1.advertisement_id.advertisement_id ==
+		attrs2.advertisement_id.advertisement_id);
+	assert(!memcmp(attrs1.advertisement_id.service_mac_addr,
+			attrs2.advertisement_id.service_mac_addr, 6));
+
+	assert(attrs1.config_timeout.go_config_timeout ==
+		attrs2.config_timeout.go_config_timeout);
+	assert(attrs1.config_timeout.client_config_timeout ==
+		attrs2.config_timeout.client_config_timeout);
+
+	assert(attrs1.session_id.session_id == attrs2.session_id.session_id);
+	assert(!memcmp(attrs1.session_id.session_mac_addr,
+			attrs2.session_id.session_mac_addr, 6));
+
+	assert(attrs1.transport_protocol == attrs2.transport_protocol);
+
+	assert(!memcmp(attrs1.persistent_group_info.device_addr,
+			attrs2.persistent_group_info.device_addr, 6));
+	assert(!strcmp(attrs1.persistent_group_info.ssid,
+			attrs2.persistent_group_info.ssid));
+
+	assert(attrs1.session_info.data_len == attrs2.session_info.data_len);
+	assert(!attrs1.session_info.data_len ||
+		!memcmp(attrs1.session_info.data, attrs2.session_info.data,
+			attrs1.session_info.data_len));
+
+	assert(attrs1.wsc_config_method == attrs2.wsc_config_method);
+
+	p2p_free_provision_disc_resp(&attrs1);
+	p2p_free_provision_disc_resp(&attrs2);
+}
+
+int main(int argc, char *argv[])
+{
+	l_test_init(&argc, &argv);
+
+	l_test_add("/p2p/iter/sanity-check", p2p_test_iter_sanity_check, NULL);
+
+	l_test_add("/p2p/parse/Beacon IEs 1", p2p_test_parse_beacon,
+			&p2p_beacon_data_1);
+
+	l_test_add("/p2p/build/Beacon IEs 1", p2p_test_build_beacon,
+			&p2p_beacon_data_1);
+
+	l_test_add("/p2p/parse/Probe Request IEs 1", p2p_test_parse_probe_req,
+			&p2p_probe_req_data_1);
+
+	l_test_add("/p2p/build/Probe Request IEs 1", p2p_test_build_probe_req,
+			&p2p_probe_req_data_1);
+
+	l_test_add("/p2p/parse/Probe Response IEs 1", p2p_test_parse_probe_resp,
+			&p2p_probe_resp_data_1);
+	l_test_add("/p2p/parse/Probe Response IEs 2", p2p_test_parse_probe_resp,
+			&p2p_probe_resp_data_2);
+
+	l_test_add("/p2p/build/Probe Response IEs 1", p2p_test_build_probe_resp,
+			&p2p_probe_resp_data_1);
+	l_test_add("/p2p/build/Probe Response IEs 2", p2p_test_build_probe_resp,
+			&p2p_probe_resp_data_2);
+
+	l_test_add("/p2p/parse/Association Request IEs 1",
+			p2p_test_parse_association_req,
+			&p2p_association_req_data_1);
+
+	l_test_add("/p2p/build/Association Request IEs 1",
+			p2p_test_build_association_req,
+			&p2p_association_req_data_1);
+
+	l_test_add("/p2p/parse/Association Response IEs 1",
+			p2p_test_parse_association_resp,
+			&p2p_association_resp_data_1);
+
+	l_test_add("/p2p/build/Association Response IEs 1",
+			p2p_test_build_association_resp,
+			&p2p_association_resp_data_1);
+
+	l_test_add("/p2p/parse/Provision Discovery Request 1",
+			p2p_test_parse_provision_disc_req,
+			&p2p_provision_disc_req_data_1);
+
+	l_test_add("/p2p/build/Provision Discovery Request 1",
+			p2p_test_build_provision_disc_req,
+			&p2p_provision_disc_req_data_1);
+
+	l_test_add("/p2p/parse/Provision Discovery Response 1",
+			p2p_test_parse_provision_disc_resp,
+			&p2p_provision_disc_resp_data_1);
+
+	return l_test_run();
+}
