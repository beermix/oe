commit 5bd36e05f86ed94c009005fccb7e765b514420de
Author: Lukas Rusak <lorusak@gmail.com>
Date:   Thu Mar 2 09:12:25 2017 -0800

    remove kdbus

diff --git a/Makefile.am b/Makefile.am
index d6863ba..d2e33de 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -12,8 +12,6 @@ ELL_CURRENT = 0
 ELL_REVISION = 0
 ELL_AGE = 0
 
-linux_headers = linux/kdbus.h
-
 pkginclude_HEADERS = ell/ell.h \
 			ell/util.h \
 			ell/test.h \
@@ -71,7 +69,6 @@ ell_libell_la_SOURCES = $(linux_headers) \
 			ell/genl.c \
 			ell/dbus-private.h \
 			ell/dbus.c \
-			ell/dbus-kernel.c \
 			ell/dbus-message.c \
 			ell/dbus-util.c \
 			ell/dbus-service.c \
@@ -135,8 +132,7 @@ unit_tests = unit/test-unit \
 			unit/test-uuid \
 			unit/test-key
 
-dbus_tests = unit/test-kdbus \
-			unit/test-dbus \
+dbus_tests = unit/test-dbus \
 			unit/test-dbus-util \
 			unit/test-dbus-message \
 			unit/test-dbus-message-fds \
@@ -180,8 +176,6 @@ unit_test_genl_LDADD = ell/libell-private.la
 
 unit_test_genl_msg_LDADD = ell/libell-private.la
 
-unit_test_kdbus_LDADD = ell/libell-private.la
-
 unit_test_dbus_LDADD = ell/libell-private.la
 
 unit_test_dbus_message_LDADD = ell/libell-private.la
diff --git a/README b/README
index c1ac931..eaff57c 100644
--- a/README
+++ b/README
@@ -44,15 +44,6 @@ Kernel configuration checklist:
 
 	CONFIG_KEY_DH_OPERATIONS=y
 
-For kernel D-Bus (kdbus) support, the appropriate kernel module is required
-and must be loaded. The development repositories can be found here:
-
-	https://github.com/gregkh/kdbus
-	https://code.google.com/p/d-bus/
-
-If /dev/kdbus/control device node is present, kernel D-Bus support can be
-used.
-
 Information
 ===========
 
diff --git a/TODO b/TODO
index 8ffa455..27bc35f 100644
--- a/TODO
+++ b/TODO
@@ -23,12 +23,8 @@ DBus API
   mechanisms specified in the DBus specification.  Whenever a given signal
   matches one of the filters, the relevant callback function should be called.
 
-  For KDBus this implies calculating and installing proper bloom filters.  For
-  DBus classic this implies managing a set of appropriate filters with the DBus
-  daemon as specified in the DBus specification.
-
-  Note that certain filtering mechanisms which are possible with DBus classic
-  are likely not possible with KDBus.
+  For DBus classic this implies managing a set of appropriate filters with the 
+  DBus daemon as specified in the DBus specification.
 
   Priority: Medium
   Complexity: C4
diff --git a/ell/dbus-kernel.c b/ell/dbus-kernel.c
deleted file mode 100644
index 4d7cae3..0000000
--- a/ell/dbus-kernel.c
+++ /dev/null
@@ -1,971 +0,0 @@
-/*
- *
- *  Embedded Linux library
- *
- *  Copyright (C) 2011-2014  Intel Corporation. All rights reserved.
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#define _GNU_SOURCE
-#include <stdio.h>
-#include <stdlib.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <string.h>
-#include <alloca.h>
-#include <errno.h>
-#include <sys/mman.h>
-#include <sys/ioctl.h>
-#include <time.h>
-
-#include "linux/kdbus.h"
-
-#include "private.h"
-#include "dbus.h"
-#include "dbus-private.h"
-#include "siphash-private.h"
-
-#define KDBUS_ITEM_HEADER_SIZE offsetof(struct kdbus_item, data)
-#define KDBUS_POOL_SIZE (16*1024*1024)
-
-#define KDBUS_ITEM_FOREACH(item, head, first)				\
-	for (item = head->first;					\
-		(void *)(item) < (void *)(head) + (head)->size;		\
-		item = KDBUS_ITEM_NEXT(item))				\
-
-#define DEFAULT_BLOOM_SIZE (512 / 8)
-#define DEFAULT_BLOOM_N_HASH (8)
-
-#define HASH_KEY(v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15) \
-        { 0x##v0, 0x##v1, 0x##v2, 0x##v3, 0x##v4, 0x##v5, 0x##v6, 0x##v7, \
-	0x##v8, 0x##v9, 0x##v10, 0x##v11, 0x##v12, 0x##v13, 0x##v14, 0x##v15 }
-
-#define KDBUS_ITEM_SIZE(actual) \
-	align_len(actual + offsetof(struct kdbus_item, data), 8)
-
-static inline struct kdbus_item *KDBUS_ITEM_NEXT(struct kdbus_item *item)
-{
-	size_t aligned = align_len(item->size, 8);
-	void *start = item;
-
-	return start + aligned;
-}
-
-static inline unsigned int __u64_log2(uint64_t n)
-{
-	if (n == 0)
-		return 0;
-
-	return __builtin_clzll(n) ^ 63U;
-}
-
-static inline void set_bit(uint64_t filter[], size_t b)
-{
-	filter[b >> 6] |= 1ULL << (b & 63);
-}
-
-static const uint8_t hash_keys[][16] = {
-	HASH_KEY(b9,66,0b,f0,46,70,47,c1,88,75,c4,9c,54,b9,bd,15),
-	HASH_KEY(aa,a1,54,a2,e0,71,4b,39,bf,e1,dd,2e,9f,c5,4a,3b),
-	HASH_KEY(63,fd,ae,be,cd,82,48,12,a1,6e,41,26,cb,fa,a0,c8),
-	HASH_KEY(23,be,45,29,32,d2,46,2d,82,03,52,28,fe,37,17,f5),
-	HASH_KEY(56,3b,bf,ee,5a,4f,43,39,af,aa,94,08,df,f0,fc,10),
-	HASH_KEY(31,80,c8,73,c7,ea,46,d3,aa,25,75,0f,9e,4c,09,29),
-	HASH_KEY(7d,f7,18,4b,7b,a4,44,d5,85,3c,06,e0,65,53,96,6d),
-	HASH_KEY(f2,77,e9,6f,93,b5,4e,71,9a,0c,34,88,39,25,bf,35),
-};
-
-static void bloom_update(uint64_t filter[], size_t size, uint8_t num_hash,
-				const void *data, size_t data_size)
-{
-	uint8_t hashed[8];
-	uint64_t n_bits;
-	unsigned int index_size;
-	unsigned int i;
-	unsigned int hash_index;
-	unsigned int unused_bytes = 0;
-
-	if (unlikely(num_hash == 0))
-		return;
-
-	if (unlikely(size == 0))
-		return;
-
-	n_bits = size * 8;
-	index_size = (__u64_log2(n_bits) + 7) / 8;
-
-	if (unlikely(index_size > sizeof(uint32_t)))
-		return;
-
-	for (i = 0, hash_index = 0; i < num_hash; i++) {
-		uint32_t index = 0;
-		unsigned int j;
-
-		for (j = 0; j < index_size; j++) {
-			if (unused_bytes == 0) {
-				_siphash24(hashed, data, data_size,
-						hash_keys[hash_index++]);
-				unused_bytes = 8;
-			}
-
-			index = index << 8;
-			index |= hashed[8 - unused_bytes];
-			unused_bytes -= 1;
-		}
-
-		index &= n_bits - 1;
-		set_bit(filter, index);
-	}
-}
-
-void _dbus_kernel_bloom_add(uint64_t filter[], size_t size, uint8_t num_hash,
-				const char *prefix, const char *str)
-{
-	char *buf;
-	size_t len;
-
-	len = strlen(prefix) + 1 + strlen(str) + 1;
-	buf = alloca(len);
-
-	sprintf(buf, "%s:%s", prefix, str);
-
-	bloom_update(filter, size, num_hash, buf, len - 1);
-}
-
-void _dbus_kernel_bloom_add_parents(uint64_t filter[], size_t size,
-					uint8_t num_hash, const char *prefix,
-					const char *str, const char sep)
-{
-	char *buf;
-	size_t len;
-	int start;
-
-	len = strlen(prefix) + 1 + strlen(str) + 1;
-	buf = alloca(len);
-
-	sprintf(buf, "%s:%n%s", prefix, &start, str);
-
-	while (true) {
-		char *s = strrchr(buf + start, sep);
-
-		if (!s)
-			break;
-
-		if (s == buf + start)
-			break;
-
-		*s = '\0';
-		bloom_update(filter, size, num_hash, buf, s - buf);
-	}
-}
-
-int _dbus_kernel_create_bus(const char *name)
-{
-	struct {
-		struct kdbus_cmd head;
-		/* bloom size item */
-		uint64_t bloom_size;
-		uint64_t bloom_type;
-		struct kdbus_bloom_parameter bloom_param;
-		/* name item */
-		uint64_t name_size;
-		uint64_t name_type;
-		char name_param[64];
-	} bus_make;
-	int fd;
-
-	fd = open("/dev/kdbus/control", O_RDWR | O_CLOEXEC);
-	if (fd < 0)
-		return -1;
-
-	memset(&bus_make, 0, sizeof(bus_make));
-	/* bloom size item */
-	bus_make.bloom_size = KDBUS_ITEM_HEADER_SIZE +
-					sizeof(bus_make.bloom_param);
-	bus_make.bloom_type = KDBUS_ITEM_BLOOM_PARAMETER;
-	bus_make.bloom_param.size = DEFAULT_BLOOM_SIZE;
-	bus_make.bloom_param.n_hash = DEFAULT_BLOOM_N_HASH;
-	/* name item */
-	snprintf(bus_make.name_param, sizeof(bus_make.name_param), "%s", name);
-	bus_make.name_size = KDBUS_ITEM_HEADER_SIZE +
-				strlen(bus_make.name_param) + 1;
-	bus_make.name_type = KDBUS_ITEM_MAKE_NAME;
-	/* bus make head */
-	bus_make.head.size = align_len(sizeof(bus_make.head) +
-					bus_make.bloom_size +
-					bus_make.name_size, 8);
-	bus_make.head.flags = KDBUS_MAKE_ACCESS_WORLD;
-
-	if (ioctl(fd, KDBUS_CMD_BUS_MAKE, &bus_make) < 0) {
-		close(fd);
-		return -1;
-        }
-
-	return fd;
-}
-
-void _dbus_kernel_unmap_pool(void *pool)
-{
-	munmap(pool, KDBUS_POOL_SIZE);
-}
-
-int _dbus_kernel_hello(int fd, const char *connection_name,
-			size_t *bloom_size, uint8_t *bloom_n_hash,
-			uint64_t *id, void **pool, char **guid)
-{
-	size_t len = strlen(connection_name);
-	size_t size;
-	struct kdbus_cmd_hello *hello;
-	struct kdbus_item *item;
-	int ret;
-	struct kdbus_cmd_free cmd_free;
-
-	size = align_len(sizeof(struct kdbus_cmd_hello), 8);
-	size += KDBUS_ITEM_SIZE(len + 1);
-
-	hello = alloca(size);
-	memset(hello, 0, size);
-
-	hello->size = size;
-	hello->flags |= KDBUS_HELLO_ACCEPT_FD;
-	hello->pool_size = KDBUS_POOL_SIZE;
-
-	item = hello->items;
-	item->size = KDBUS_ITEM_HEADER_SIZE + len + 1;
-	item->type = KDBUS_ITEM_CONN_DESCRIPTION;
-	strcpy(item->str, connection_name);
-
-	ret = ioctl(fd, KDBUS_CMD_HELLO, hello);
-	if (ret < 0) {
-		ret = -errno;
-		goto done;
-	}
-
-        /* Check for incompatible flags (upper 32 bits) */
-        if (hello->bus_flags > 0xFFFFFFFFULL ||
-			hello->flags > 0xFFFFFFFFULL) {
-		ret = -ENOTSUP;
-		goto done;
-	}
-
-	*pool = mmap(NULL, KDBUS_POOL_SIZE, PROT_READ, MAP_SHARED, fd, 0);
-	if (*pool == MAP_FAILED) {
-		*pool = NULL;
-		ret = -errno;
-		goto done;
-	}
-
-	*bloom_size = DEFAULT_BLOOM_SIZE;
-	*bloom_n_hash = DEFAULT_BLOOM_N_HASH;
-
-	KDBUS_ITEM_FOREACH(item, hello, items) {
-		switch (item->type) {
-		case KDBUS_ITEM_BLOOM_PARAMETER:
-			*bloom_size = item->bloom_parameter.size;
-			*bloom_n_hash = item->bloom_parameter.n_hash;
-			break;
-		}
-	}
-
-	*id = hello->id;
-	*guid = l_strdup_printf("%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx"
-				"%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx"
-				"%02hhx%02hhx",
-				hello->id128[0], hello->id128[1],
-				hello->id128[2], hello->id128[3],
-				hello->id128[4], hello->id128[5],
-				hello->id128[6], hello->id128[7],
-				hello->id128[8], hello->id128[9],
-				hello->id128[10], hello->id128[11],
-				hello->id128[12], hello->id128[13],
-				hello->id128[14], hello->id128[15]);
-
-done:
-	memset(&cmd_free, 0, sizeof(cmd_free));
-	cmd_free.size = sizeof(cmd_free);
-	cmd_free.offset = hello->offset;
-
-	ioctl(fd, KDBUS_CMD_FREE, &cmd_free);
-
-	return ret;
-}
-
-int _dbus_kernel_send(int fd, size_t bloom_size, uint8_t bloom_n_hash,
-			struct l_dbus_message *message)
-{
-	size_t kmsg_size;
-	bool unique;
-	uint64_t uninitialized_var(id);
-	const char *dest;
-	size_t dest_len;
-	struct kdbus_item *item;
-	void *header;
-	size_t header_size;
-	void *footer;
-	size_t footer_size;
-	int ret;
-	struct kdbus_cmd_send cmd;
-	uint32_t num_fds;
-	int *fds;
-	L_AUTO_FREE_VAR(struct kdbus_msg *, kmsg);
-
-	dest = l_dbus_message_get_destination(message);
-	if (dest)
-		unique = _dbus_parse_unique_name(dest, &id);
-	else
-		unique = false;
-
-	dest_len = dest ? strlen(dest) : 0;
-
-	kmsg_size = sizeof(struct kdbus_msg);
-
-	/* Reserve space for header + body */
-	kmsg_size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_vec));
-	kmsg_size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_vec));
-
-	/* Reserve space for bloom filter */
-	if (_dbus_message_get_type(message) == DBUS_MESSAGE_TYPE_SIGNAL)
-		kmsg_size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_bloom_filter) +
-						bloom_size);
-
-	/* Reserve space for well-known destination header */
-	if (dest && !unique)
-		kmsg_size += KDBUS_ITEM_SIZE(dest_len + 1);
-
-	/* Reserve space for fds */
-	fds = _dbus_message_get_fds(message, &num_fds);
-	if (num_fds)
-		kmsg_size += KDBUS_ITEM_SIZE(num_fds * sizeof(int));
-
-	kmsg = aligned_alloc(8, kmsg_size);
-	if (!kmsg)
-		return -ENOMEM;
-
-	memset(kmsg, 0, kmsg_size);
-	item = kmsg->items;
-
-	kmsg->payload_type = KDBUS_PAYLOAD_DBUS;
-	kmsg->priority = 0;
-	kmsg->cookie = _dbus_message_get_serial(message);
-
-	if (l_dbus_message_get_no_autostart(message))
-		kmsg->flags |= KDBUS_MSG_NO_AUTO_START;
-
-	if (!l_dbus_message_get_no_reply(message))
-		kmsg->flags |= KDBUS_MSG_EXPECT_REPLY;
-
-	if (!unique && dest) {
-		kmsg->dst_id = KDBUS_DST_ID_NAME;
-		item->size = KDBUS_ITEM_HEADER_SIZE + dest_len + 1;
-		item->type = KDBUS_ITEM_DST_NAME;
-		strcpy(item->str, dest);
-		item = KDBUS_ITEM_NEXT(item);
-	} else if (!unique && !dest)
-		kmsg->dst_id = KDBUS_DST_ID_BROADCAST;
-	else
-		kmsg->dst_id = id;
-
-	switch(_dbus_message_get_type(message)) {
-	case DBUS_MESSAGE_TYPE_METHOD_RETURN:
-	case DBUS_MESSAGE_TYPE_ERROR:
-	{
-		uint32_t reply_cookie = _dbus_message_get_reply_serial(message);
-
-		if (reply_cookie == 0)
-			return -EINVAL;
-
-		kmsg->cookie_reply = reply_cookie;
-		break;
-	}
-	case DBUS_MESSAGE_TYPE_METHOD_CALL:
-		if (!l_dbus_message_get_no_reply(message)) {
-			struct timespec now;
-
-			clock_gettime(CLOCK_MONOTONIC_COARSE, &now);
-
-			kmsg->timeout_ns =
-				now.tv_sec * 1000000000ULL + now.tv_nsec +
-				30000 * 1000000ULL;
-		}
-
-		break;
-	case DBUS_MESSAGE_TYPE_SIGNAL:
-		kmsg->flags |= KDBUS_MSG_SIGNAL;
-
-		item->size = KDBUS_ITEM_HEADER_SIZE +
-				sizeof(struct kdbus_bloom_filter) + bloom_size;
-		item->type = KDBUS_ITEM_BLOOM_FILTER;
-
-		item->bloom_filter.generation = 0;
-		_dbus_kernel_calculate_bloom(message,
-					(uint64_t *) item->bloom_filter.data,
-					bloom_size, bloom_n_hash);
-
-		item = KDBUS_ITEM_NEXT(item);
-		break;
-	}
-
-	header = _dbus_message_get_header(message, &header_size);
-	item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(struct kdbus_vec);
-	item->type = KDBUS_ITEM_PAYLOAD_VEC;
-	item->vec.address = (uintptr_t) header;
-	item->vec.size = header_size;
-	item = KDBUS_ITEM_NEXT(item);
-
-	footer = _dbus_message_get_footer(message, &footer_size);
-
-	item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(struct kdbus_vec);
-	item->type = KDBUS_ITEM_PAYLOAD_VEC;
-	item->vec.address = (uintptr_t) footer;
-	item->vec.size = footer_size;
-	item = KDBUS_ITEM_NEXT(item);
-
-	if (num_fds) {
-		item->size = KDBUS_ITEM_HEADER_SIZE + num_fds * sizeof(int);
-		item->type = KDBUS_ITEM_FDS;
-		memcpy(item->fds, fds, num_fds * sizeof(int));
-		item = KDBUS_ITEM_NEXT(item);
-	}
-
-	kmsg->size = (void *)item - (void *)kmsg;
-
-	memset(&cmd, 0, sizeof(cmd));
-	cmd.size = sizeof(cmd);
-	cmd.msg_address = (uintptr_t) kmsg;
-
-	ret = ioctl(fd, KDBUS_CMD_SEND, &cmd);
-	if (ret < 0)
-		return -errno;
-
-	return 0;
-}
-
-static void collect_body_parts(struct kdbus_msg *kmsg, size_t size, void **data)
-{
-	struct kdbus_item *item;
-	size_t offset = 0;
-
-	*data = l_malloc(size);
-
-	KDBUS_ITEM_FOREACH(item, kmsg, items) {
-		switch (item->type) {
-		case KDBUS_ITEM_PAYLOAD_OFF:
-			memcpy(*data + offset, (void *) kmsg + item->vec.offset,
-				item->vec.size);
-
-			offset += item->vec.size;
-
-			break;
-		}
-	}
-}
-
-static int _dbus_kernel_make_message(struct kdbus_msg *kmsg,
-				struct l_dbus_message **out_message)
-{
-	struct kdbus_item *item;
-	void *data = 0;
-	size_t size = 0;
-	struct dbus_header *hdr;
-	const char *destination = 0;
-	char unique_bus_name[128];
-	uint32_t num_fds = 0;
-	int *fds = NULL;
-	unsigned int i;
-
-	KDBUS_ITEM_FOREACH(item, kmsg, items) {
-		switch (item->type) {
-		case KDBUS_ITEM_PAYLOAD_OFF:
-			if (!size) {
-				if (item->vec.size < sizeof(struct dbus_header))
-					return -EBADMSG;
-
-				hdr = (void *)kmsg + item->vec.offset;
-			}
-
-			size += item->vec.size;
-
-			break;
-		case KDBUS_ITEM_PAYLOAD_MEMFD:
-			if (!size)
-				return -EBADMSG;
-
-			return -ENOTSUP;
-		case KDBUS_ITEM_FDS:
-			if (fds || item->size <= KDBUS_ITEM_HEADER_SIZE)
-				return -EBADMSG;
-
-			num_fds = (item->size - KDBUS_ITEM_HEADER_SIZE) /
-				sizeof(int);
-			fds = item->fds;
-
-			/* Set FD_CLOEXEC on all file descriptors */
-			for (i = 0; i < num_fds; i++) {
-				long flags;
-
-				if (fds[i] == -1)
-					continue;
-
-				flags = fcntl(fds[i], F_GETFD, NULL);
-				if (flags < 0 || (flags & FD_CLOEXEC))
-					continue;
-
-				fcntl(fds[i], F_SETFD, flags | FD_CLOEXEC);
-			}
-
-			break;
-		case KDBUS_ITEM_DST_NAME:
-			if (!_dbus_valid_bus_name(item->str))
-				return -EBADMSG;
-
-			destination = item->str;
-			break;
-		}
-	}
-
-	if (!size)
-		return -EBADMSG;
-
-	if (hdr->endian != DBUS_NATIVE_ENDIAN)
-		return -EPROTOTYPE;
-
-	if (hdr->version != 2)
-		return -EPROTO;
-
-	collect_body_parts(kmsg, size, &data);
-
-	*out_message = dbus_message_from_blob(data, size, fds, num_fds);
-
-	l_free(data);
-
-	if (!*out_message)
-		return -EBADMSG;
-
-	if (kmsg->src_id != KDBUS_SRC_ID_KERNEL) {
-		sprintf(unique_bus_name, ":1.%llu", kmsg->src_id);
-		_dbus_message_set_sender(*out_message, unique_bus_name);
-	} else
-		_dbus_message_set_sender(*out_message, "org.freedesktop.DBus");
-
-	switch (kmsg->dst_id) {
-	case KDBUS_DST_ID_NAME:
-		break;
-	case KDBUS_DST_ID_BROADCAST:
-		break;
-	default:
-		sprintf(unique_bus_name, ":1.%llu", kmsg->dst_id);
-		_dbus_message_set_destination(*out_message, unique_bus_name);
-	}
-
-	if (destination)
-		_dbus_message_set_destination(*out_message, destination);
-
-	return 0;
-}
-
-int _dbus_kernel_recv(int fd, void *kdbus_pool,
-			l_dbus_message_func_t message_func,
-			_dbus_name_owner_change_func_t name_owner_change_func,
-			void *user_data)
-{
-	struct kdbus_cmd_recv recv_cmd;
-	struct kdbus_cmd_free cmd_free;
-	struct kdbus_msg *msg;
-	struct l_dbus_message *dbus_msg;
-	struct kdbus_item *item;
-	int r;
-	size_t min_size;
-	const char *error;
-	char unique_bus_name[128];
-
-	memset(&recv_cmd, 0, sizeof(recv_cmd));
-
-	recv_cmd.size = sizeof(recv_cmd);
-
-	r = ioctl(fd, KDBUS_CMD_RECV, &recv_cmd);
-	if (r < 0)
-		return -errno;
-
-	msg = (struct kdbus_msg *)(kdbus_pool + recv_cmd.msg.offset);
-
-	switch (msg->payload_type) {
-	case KDBUS_PAYLOAD_DBUS:
-		r = _dbus_kernel_make_message(msg, &dbus_msg);
-		if (!r)
-			message_func(dbus_msg, user_data);
-		break;
-	case KDBUS_PAYLOAD_KERNEL:
-		if (msg->size < sizeof(*msg) + KDBUS_ITEM_HEADER_SIZE) {
-			r = -EPROTONOSUPPORT;
-			break;
-		}
-
-		item = msg->items;
-
-		switch (item->type) {
-		case KDBUS_ITEM_NAME_ADD:
-		case KDBUS_ITEM_NAME_CHANGE:
-		case KDBUS_ITEM_NAME_REMOVE:
-			min_size = KDBUS_ITEM_SIZE(sizeof(item->name_change));
-			if (msg->size < sizeof(*msg) + min_size ||
-					item->size < min_size) {
-				r = -EPROTONOSUPPORT;
-				break;
-			}
-
-			name_owner_change_func(item->name_change.name,
-						item->name_change.old_id.id,
-						item->name_change.new_id.id,
-						user_data);
-			break;
-
-		case KDBUS_ITEM_ID_ADD:
-		case KDBUS_ITEM_ID_REMOVE:
-			min_size = KDBUS_ITEM_SIZE(sizeof(item->id_change));
-			if (msg->size < sizeof(*msg) + min_size ||
-					item->size < min_size) {
-				r = -EPROTONOSUPPORT;
-				break;
-			}
-
-			sprintf(unique_bus_name, ":1.%llu", item->id_change.id);
-
-			if (item->type == KDBUS_ITEM_ID_ADD)
-				name_owner_change_func(unique_bus_name,
-							0, item->id_change.id,
-							user_data);
-			else
-				name_owner_change_func(unique_bus_name,
-							item->id_change.id, 0,
-							user_data);
-			break;
-
-		case KDBUS_ITEM_REPLY_TIMEOUT:
-		case KDBUS_ITEM_REPLY_DEAD:
-			if (item->type == KDBUS_ITEM_REPLY_TIMEOUT)
-				error = "Did not receive a reply.";
-			else
-				error = "Message recipient disconnected from "
-					"message bus without replying.";
-
-			dbus_msg = _dbus_message_new_error(
-					2, msg->cookie_reply, NULL,
-					"org.freedesktop.DBus.Error.NoReply",
-					error);
-			if (dbus_msg)
-				message_func(dbus_msg, user_data);
-
-			break;
-
-		default:
-			break;
-		}
-
-		break;
-	default:
-		r = -EPROTONOSUPPORT;
-		break;
-	}
-
-	memset(&cmd_free, 0, sizeof(cmd_free));
-	cmd_free.size = sizeof(cmd_free);
-	cmd_free.offset = recv_cmd.msg.offset;
-
-	ioctl(fd, KDBUS_CMD_FREE, &cmd_free);
-
-	return r;
-}
-
-int _dbus_kernel_name_acquire(int fd, const char *name, bool allow_replacement,
-				bool replace_existing, bool queue, bool *queued)
-{
-	struct {
-		struct kdbus_cmd head;
-		char param[64];
-	} cmd_name;
-	struct kdbus_item *item;
-	size_t nlen;
-
-	if (!name)
-		return false;
-
-	nlen = strlen(name) + 1;
-	if (KDBUS_ITEM_SIZE(nlen) > sizeof(cmd_name.param))
-		return false;
-
-	memset(&cmd_name, 0, sizeof(cmd_name));
-
-	cmd_name.head.size = sizeof(cmd_name.head) + KDBUS_ITEM_SIZE(nlen);
-
-	item = cmd_name.head.items;
-	item->size = KDBUS_ITEM_HEADER_SIZE + nlen;
-	item->type = KDBUS_ITEM_NAME;
-	strcpy(item->str, name);
-
-	if (replace_existing)
-		cmd_name.head.flags |= KDBUS_NAME_REPLACE_EXISTING;
-
-	if (allow_replacement)
-		cmd_name.head.flags |= KDBUS_NAME_ALLOW_REPLACEMENT;
-
-	if (queue)
-		cmd_name.head.flags |= KDBUS_NAME_QUEUE;
-
-	if (ioctl(fd, KDBUS_CMD_NAME_ACQUIRE, &cmd_name) < 0)
-		return -errno;
-
-	if (queued)
-		*queued = !!(cmd_name.head.flags & KDBUS_NAME_IN_QUEUE);
-
-	return 0;
-}
-
-int _dbus_kernel_add_match(int fd, uint64_t bloom_size, uint64_t bloom_n_hash,
-				const struct _dbus_filter_condition *rule,
-				int rule_len, unsigned int id)
-{
-	struct kdbus_item *bloom, *item;
-	struct kdbus_cmd_match *cmd;
-	size_t cmd_size;
-	const char *prefix;
-	char argstr[8];
-	int r, i;
-	uint64_t sender_id;
-
-	cmd_size = sizeof(struct kdbus_cmd_match);
-	cmd_size += KDBUS_ITEM_SIZE(bloom_size);
-
-	for (i = 0; i < rule_len; i++) {
-		switch (rule[i].type) {
-		case L_DBUS_MATCH_SENDER:
-			if (_dbus_parse_unique_name(rule->value, NULL))
-				cmd_size += KDBUS_ITEM_SIZE(sizeof(item->id));
-			else
-				cmd_size += KDBUS_ITEM_SIZE(
-						strlen(rule[i].value) + 1);
-			break;
-		default:
-			break;
-		}
-	}
-
-	cmd = alloca(cmd_size);
-	memset(cmd, 0, cmd_size);
-	cmd->size = cmd_size;
-	cmd->cookie = id;
-	item = cmd->items;
-
-	bloom = item;
-	bloom->size = KDBUS_ITEM_HEADER_SIZE + bloom_size;
-	bloom->type = KDBUS_ITEM_BLOOM_MASK;
-
-	for (; rule_len; rule++, rule_len--) {
-		switch ((int) rule->type) {
-		case L_DBUS_MATCH_SENDER:
-			item = KDBUS_ITEM_NEXT(item);
-
-			if (_dbus_parse_unique_name(rule->value, &sender_id)) {
-				item->size = KDBUS_ITEM_HEADER_SIZE +
-					strlen(rule->value) + 1;
-				item->type = KDBUS_ITEM_ID;
-				item->id = id;
-			} else {
-				item->size = KDBUS_ITEM_HEADER_SIZE +
-					strlen(rule->value) + 1;
-				item->type = KDBUS_ITEM_NAME;
-				strcpy(item->str, rule->value);
-			}
-
-			continue;
-		case L_DBUS_MATCH_TYPE:
-			prefix = "message-type";
-			break;
-		case L_DBUS_MATCH_PATH:
-			prefix = "path";
-			break;
-		case L_DBUS_MATCH_INTERFACE:
-			prefix = "interface";
-			break;
-		case L_DBUS_MATCH_MEMBER:
-			prefix = "member";
-			break;
-		case L_DBUS_MATCH_ARG0...(L_DBUS_MATCH_ARG0 + 63):
-			prefix = argstr;
-			snprintf(argstr, sizeof(argstr), "arg%i",
-					rule->type - L_DBUS_MATCH_ARG0);
-			break;
-		default:
-			return -ENOTSUP;
-		}
-
-		_dbus_kernel_bloom_add((uint64_t *) bloom->data64, bloom_size,
-					bloom_n_hash, prefix, rule->value);
-	}
-
-	r = ioctl(fd, KDBUS_CMD_MATCH_ADD, cmd);
-	if (r < 0)
-		return -errno;
-
-	return 0;
-}
-
-int _dbus_kernel_remove_match(int fd, unsigned int id)
-{
-	struct kdbus_cmd_match cmd;
-	int r;
-
-	memset(&cmd, 0, sizeof(cmd));
-	cmd.size = sizeof(cmd);
-	cmd.cookie = id;
-
-	r = ioctl(fd, KDBUS_CMD_MATCH_REMOVE, &cmd);
-	if (r < 0)
-		return -errno;
-
-	return 0;
-}
-
-int _dbus_kernel_enable_name_owner_notify(int fd)
-{
-	struct {
-		struct kdbus_cmd_match cmd;
-		uint8_t param[KDBUS_ITEM_SIZE(
-				sizeof(struct kdbus_notify_name_change)) +
-				KDBUS_ITEM_SIZE(
-				sizeof(struct kdbus_notify_id_change))];
-	} cmd_match;
-	struct kdbus_item *item;
-	int r;
-
-	memset(&cmd_match, 0, sizeof(cmd_match));
-	item = cmd_match.cmd.items;
-	item->type = KDBUS_ITEM_NAME_ADD;
-	item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(item->name_change);
-	item->name_change.old_id.id = KDBUS_MATCH_ID_ANY;
-	item->name_change.new_id.id = KDBUS_MATCH_ID_ANY;
-	cmd_match.cmd.size = sizeof(cmd_match.cmd) + item->size;
-
-	r = ioctl(fd, KDBUS_CMD_MATCH_ADD, &cmd_match);
-	if (r < 0)
-		return -errno;
-
-	memset(&cmd_match, 0, sizeof(cmd_match));
-	item = cmd_match.cmd.items;
-	item->type = KDBUS_ITEM_NAME_CHANGE;
-	item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(item->name_change);
-	item->name_change.old_id.id = KDBUS_MATCH_ID_ANY;
-	item->name_change.new_id.id = KDBUS_MATCH_ID_ANY;
-	cmd_match.cmd.size = sizeof(cmd_match.cmd) + item->size;
-
-	r = ioctl(fd, KDBUS_CMD_MATCH_ADD, &cmd_match);
-	if (r < 0)
-		return -errno;
-
-	memset(&cmd_match, 0, sizeof(cmd_match));
-	item = cmd_match.cmd.items;
-	item->type = KDBUS_ITEM_NAME_REMOVE;
-	item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(item->name_change);
-	item->name_change.old_id.id = KDBUS_MATCH_ID_ANY;
-	item->name_change.new_id.id = KDBUS_MATCH_ID_ANY;
-	cmd_match.cmd.size = sizeof(cmd_match.cmd) + item->size;
-
-	r = ioctl(fd, KDBUS_CMD_MATCH_ADD, &cmd_match);
-	if (r < 0)
-		return -errno;
-
-	memset(&cmd_match, 0, sizeof(cmd_match));
-	item = cmd_match.cmd.items;
-	item->type = KDBUS_ITEM_ID_ADD;
-	item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(item->id_change);
-	item->id_change.id = KDBUS_MATCH_ID_ANY;
-	cmd_match.cmd.size = sizeof(cmd_match.cmd) + item->size;
-
-	r = ioctl(fd, KDBUS_CMD_MATCH_ADD, &cmd_match);
-	if (r < 0)
-		return -errno;
-
-	memset(&cmd_match, 0, sizeof(cmd_match));
-	item = cmd_match.cmd.items;
-	item->type = KDBUS_ITEM_ID_REMOVE;
-	item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(item->id_change);
-	item->id_change.id = KDBUS_MATCH_ID_ANY;
-	cmd_match.cmd.size = sizeof(cmd_match.cmd) + item->size;
-
-	r = ioctl(fd, KDBUS_CMD_MATCH_ADD, &cmd_match);
-	if (r < 0)
-		return -errno;
-
-	return 0;
-}
-
-uint64_t _dbus_kernel_get_name_owner(int fd, void *kdbus_pool,
-					const char *name)
-{
-	struct kdbus_cmd_list cmd;
-	struct kdbus_cmd_free cmd_free;
-	struct kdbus_info *entry, *end;
-	struct kdbus_item *item;
-	const char *entry_name;
-	uint64_t owner_id = 0;
-	bool is_unique;
-	uint64_t uninitialized_var(id);
-
-	is_unique = _dbus_parse_unique_name(name, &id);
-
-	memset(&cmd, 0, sizeof(cmd));
-	cmd.size = sizeof(cmd);
-	cmd.flags = is_unique ? KDBUS_LIST_UNIQUE : KDBUS_LIST_NAMES;
-
-	if (ioctl(fd, KDBUS_CMD_LIST, &cmd) < 0)
-		return 0;
-
-	entry = kdbus_pool + cmd.offset;
-	end = (void *) entry + cmd.list_size;
-
-	for (; entry < end; entry = (void *) entry + entry->size) {
-		entry_name = NULL;
-
-		KDBUS_ITEM_FOREACH(item, entry, items) {
-			if (item->type == KDBUS_ITEM_OWNED_NAME) {
-				entry_name = item->name.name;
-				break;
-			}
-		}
-
-		if (entry_name && !strcmp(entry_name, name)) {
-			owner_id = entry->id;
-			break;
-		}
-
-		if (is_unique && id == entry->id) {
-			owner_id = id;
-			break;
-		}
-	}
-
-	memset(&cmd_free, 0, sizeof(cmd_free));
-	cmd_free.size = sizeof(cmd_free);
-	cmd_free.offset = cmd.offset;
-
-	ioctl(fd, KDBUS_CMD_FREE, &cmd_free);
-
-	return owner_id;
-}
diff --git a/ell/dbus-message.c b/ell/dbus-message.c
index ef5dd22..afd845a 100644
--- a/ell/dbus-message.c
+++ b/ell/dbus-message.c
@@ -73,8 +73,6 @@ struct l_dbus_message {
 	uint32_t num_fds;
 
 	bool sealed : 1;
-	bool kdbus_sender : 1;
-	bool kdbus_destination : 1;
 	bool signature_free : 1;
 };
 
@@ -137,9 +135,7 @@ void _dbus_message_set_serial(struct l_dbus_message *msg, uint32_t serial)
 {
 	struct dbus_header *hdr = msg->header;
 
-	if (_dbus_message_is_gvariant(msg))
-		hdr->kdbus.cookie = serial;
-	else
+	if (!_dbus_message_is_gvariant(msg))
 		hdr->dbus1.serial = serial;
 }
 
@@ -147,9 +143,7 @@ uint32_t _dbus_message_get_serial(struct l_dbus_message *msg)
 {
 	struct dbus_header *hdr = msg->header;
 
-	if (_dbus_message_is_gvariant(msg))
-		return hdr->kdbus.cookie;
-	else
+	if (!_dbus_message_is_gvariant(msg))
 		return hdr->dbus1.serial;
 }
 
@@ -430,12 +424,6 @@ LIB_EXPORT void l_dbus_message_unref(struct l_dbus_message *message)
 		l_free(message->sender);
 	}
 
-	if (message->kdbus_sender)
-		l_free(message->sender);
-
-	if (message->kdbus_destination)
-		l_free(message->destination);
-
 	if (message->signature_free)
 		l_free(message->signature);
 
@@ -689,10 +677,6 @@ static bool valid_header(const struct dbus_header *hdr)
 	if (hdr->version == 1) {
 		if (hdr->dbus1.serial == 0)
 			return false;
-	} else {
-		/* We don't support 64-bit GVariant cookies */
-		if (hdr->kdbus.cookie == 0 || (hdr->kdbus.cookie >> 32))
-			return false;
 	}
 
 	return true;
@@ -1619,7 +1603,6 @@ void _dbus_message_set_sender(struct l_dbus_message *message,
 	l_free(message->sender);
 
 	message->sender = l_strdup(sender);
-	message->kdbus_sender = true;
 }
 
 void _dbus_message_set_destination(struct l_dbus_message *message,
@@ -1631,112 +1614,6 @@ void _dbus_message_set_destination(struct l_dbus_message *message,
 	l_free(message->destination);
 
 	message->destination = l_strdup(destination);
-	message->kdbus_destination = true;
-}
-
-bool _dbus_kernel_calculate_bloom(struct l_dbus_message *message,
-					uint64_t filter[], size_t f_size,
-					uint8_t num_hash)
-{
-	const char *attr;
-	const char *signature;
-	void *body;
-	size_t body_size;
-	struct l_dbus_message_iter iter;
-	uint8_t argn;
-	char buf[256];
-	bool (*get_basic)(struct l_dbus_message_iter *, char, void *);
-
-	/* The string "interface:" suffixed by the interface name */
-	attr = l_dbus_message_get_interface(message);
-	if (attr)
-		_dbus_kernel_bloom_add(filter, f_size, num_hash,
-					"interface", attr);
-
-	/* The string "member:" suffixed by the member name */
-	attr = l_dbus_message_get_member(message);
-	if (attr)
-		_dbus_kernel_bloom_add(filter, f_size, num_hash,
-					"member", attr);
-
-	/*
-	 * The string "path:" suffixed by the path name
-	 *
-	 * The string "path-slash-prefix:" suffixed with the path name, and
-	 * also all prefixes of the path name (cut off at "/"), also prefixed
-	 * with "path-slash-prefix"
-	 */
-	attr = l_dbus_message_get_path(message);
-	if (attr) {
-		_dbus_kernel_bloom_add(filter, f_size, num_hash, "path", attr);
-		_dbus_kernel_bloom_add(filter, f_size, num_hash,
-					"path-slash-prefix", attr);
-		_dbus_kernel_bloom_add_parents(filter, f_size, num_hash,
-						"path-slash-prefix", attr, '/');
-	}
-
-	/*
-	 * The string "message-type:" suffixed with the strings "signal",
-	 * "method_call", "error" or "method_return" for the respective
-	 * message type of the message.
-	 */
-	_dbus_kernel_bloom_add(filter, f_size, num_hash, "message-type",
-				_dbus_message_get_type_as_string(message));
-
-	signature = l_dbus_message_get_signature(message);
-	if (!signature)
-		return true;
-
-	body = _dbus_message_get_body(message, &body_size);
-
-	if (_dbus_message_is_gvariant(message)) {
-		if (!_gvariant_iter_init(&iter, message, signature, NULL,
-						body, body_size))
-			return false;
-
-		get_basic = _gvariant_iter_next_entry_basic;
-	} else {
-		_dbus1_iter_init(&iter, message, signature, NULL,
-					body, body_size);
-
-		get_basic = _dbus1_iter_next_entry_basic;
-	}
-
-	argn = 0;
-
-	/*
-	 * systemd-master/src/libsystemd/sd-bus/PORTING-DBUS1:
-	 *
-	 * "If the first argument of the message is a string,
-	 * "arg0-slash-prefix" suffixed with the first argument, and also
-	 * all prefixes of the argument (cut off at "/"), also prefixed
-	 * with "arg0-slash-prefix".
-	 *
-	 * Similar for all further arguments that are strings up to 63,
-	 * for the arguments and their "dot" and "slash" prefixes. On the
-	 * first argument that is not a string, addition to the bloom
-	 * filter should be stopped however."
-	 */
-	while (*signature == 's' || *signature == 'o' || *signature == 'g') {
-		if (!get_basic(&iter, *signature, &attr))
-			return false;
-
-		sprintf(buf, "arg%hhu", argn);
-		_dbus_kernel_bloom_add(filter, f_size, num_hash, buf, attr);
-
-		sprintf(buf, "arg%hhu-slash-prefix", argn);
-		_dbus_kernel_bloom_add_parents(filter, f_size, num_hash, buf,
-						attr, '/');
-
-		sprintf(buf, "arg%hhu-dot-prefix", argn);
-		_dbus_kernel_bloom_add_parents(filter, f_size, num_hash, buf,
-						attr, '.');
-
-		argn += 1;
-		signature += 1;
-	}
-
-	return true;
 }
 
 LIB_EXPORT struct l_dbus_message_builder *l_dbus_message_builder_new(
diff --git a/ell/dbus-private.h b/ell/dbus-private.h
index a4118c6..441e668 100644
--- a/ell/dbus-private.h
+++ b/ell/dbus-private.h
@@ -56,11 +56,6 @@ struct dbus_header {
 			uint32_t serial;
 			uint32_t field_length;
 		} __attribute__ ((packed)) dbus1;
-
-		struct {
-			uint32_t reserved1;
-			uint64_t cookie;
-		} __attribute__ ((packed)) kdbus;
 	};
 } __attribute__ ((packed));
 #define DBUS_HEADER_SIZE 16
@@ -234,46 +229,11 @@ bool _dbus_object_tree_property_changed(struct l_dbus *dbus,
 					const char *interface_name,
 					const char *property_name);
 
-void _dbus_kernel_bloom_add(uint64_t filter[], size_t size, uint8_t num_hash,
-				const char *prefix, const char *str);
-void _dbus_kernel_bloom_add_parents(uint64_t filter[], size_t size,
-					uint8_t num_hash, const char *prefix,
-					const char *str, const char sep);
-
-int _dbus_kernel_create_bus(const char *name);
-
-bool _dbus_kernel_calculate_bloom(struct l_dbus_message *message,
-					uint64_t filter[], size_t f_size,
-					uint8_t num_hash);
-
-int _dbus_kernel_hello(int fd, const char *connection_name,
-			size_t *bloom_size, uint8_t *bloom_n_hash,
-			uint64_t *id, void **pool, char **guid);
-void _dbus_kernel_unmap_pool(void *pool);
-
 typedef void (*_dbus_name_owner_change_func_t)(const char *name,
 						uint64_t old_owner,
 						uint64_t new_owner,
 						void *user_data);
 
-int _dbus_kernel_send(int fd, size_t bloom_size, uint8_t n_bloom_hash,
-			struct l_dbus_message *message);
-int _dbus_kernel_recv(int fd, void *kdbus_pool,
-			l_dbus_message_func_t message_func,
-			_dbus_name_owner_change_func_t name_owner_change_func,
-			void *user_data);
-
-int _dbus_kernel_name_acquire(int fd, const char *name, bool allow_replacement,
-				bool replace_existing, bool queue,
-				bool *queued);
-int _dbus_kernel_add_match(int fd, uint64_t bloom_size, uint64_t bloom_n_hash,
-				const struct _dbus_filter_condition *rule,
-				int rule_len, unsigned int id);
-int _dbus_kernel_remove_match(int fd, unsigned int it);
-int _dbus_kernel_enable_name_owner_notify(int fd);
-uint64_t _dbus_kernel_get_name_owner(int fd, void *kdbus_pool,
-					const char *name);
-
 uint8_t _dbus_get_version(struct l_dbus *dbus);
 int _dbus_get_fd(struct l_dbus *dbus);
 struct _dbus_object_tree *_dbus_get_tree(struct l_dbus *dbus);
diff --git a/ell/dbus.c b/ell/dbus.c
index ddc51aa..db69c0d 100644
--- a/ell/dbus.c
+++ b/ell/dbus.c
@@ -101,14 +101,6 @@ struct l_dbus {
 	const struct l_dbus_ops *driver;
 };
 
-struct l_dbus_kdbus {
-	struct l_dbus super;
-	uint8_t bloom_n_hash;		/* Number of hash indexes to use */
-	size_t bloom_size;		/* Size of the filter in bytes */
-	uint64_t kdbus_id;		/* Unique id */
-	void *kdbus_pool;		/* KDBus Memory pool */
-};
-
 struct l_dbus_classic {
 	struct l_dbus super;
 	void *auth_command;
@@ -1154,257 +1146,6 @@ static struct l_dbus *setup_unix(char *params)
 	return setup_dbus1(fd, guid);
 }
 
-static void kdbus_ready(void *user_data)
-{
-	struct l_dbus *dbus = user_data;
-
-	bus_ready(dbus);
-}
-
-static void kdbus_free(struct l_dbus *dbus)
-{
-	struct l_dbus_kdbus *kdbus =
-		container_of(dbus, struct l_dbus_kdbus, super);
-
-	if (kdbus->kdbus_pool)
-		_dbus_kernel_unmap_pool(kdbus->kdbus_pool);
-
-	l_free(kdbus);
-}
-
-static bool kdbus_send_message(struct l_dbus *dbus,
-					struct l_dbus_message *message)
-{
-	struct l_dbus_kdbus *kdbus =
-			container_of(dbus, struct l_dbus_kdbus, super);
-	int fd = l_io_get_fd(dbus->io);
-	int r;
-
-	r = _dbus_kernel_send(fd, kdbus->bloom_size,
-				kdbus->bloom_n_hash, message);
-	if (r < 0) {
-		l_util_debug(dbus->debug_handler,
-				dbus->debug_data, strerror(-r));
-		return false;
-	}
-
-	return true;
-}
-
-struct kdbus_message_recv_data {
-	struct l_dbus_message *message;
-	struct l_dbus *dbus;
-};
-
-static void kdbus_message_func(struct l_dbus_message *message, void *user_data)
-{
-	struct kdbus_message_recv_data *recv_data = user_data;
-
-	recv_data->message = message;
-
-	l_util_debug(recv_data->dbus->debug_handler,
-			recv_data->dbus->debug_data, "Read KDBUS Message");
-}
-
-static void kdbus_name_owner_change_func(const char *name, uint64_t old_owner,
-						uint64_t new_owner,
-						void *user_data)
-{
-	struct kdbus_message_recv_data *recv_data = user_data;
-	char owner[32];
-
-	l_util_debug(recv_data->dbus->debug_handler,
-			recv_data->dbus->debug_data,
-			"Read KDBUS Name Owner Change notification");
-
-	if (new_owner)
-		snprintf(owner, sizeof(owner), ":1.%" PRIu64, new_owner);
-	else
-		owner[0] = '\0';
-
-	_dbus_name_cache_notify(recv_data->dbus->name_cache, name, owner);
-}
-
-static struct l_dbus_message *kdbus_recv_message(struct l_dbus *dbus)
-{
-	struct l_dbus_kdbus *kdbus =
-			container_of(dbus, struct l_dbus_kdbus, super);
-	int fd = l_io_get_fd(dbus->io);
-	struct kdbus_message_recv_data recv_data = { NULL, dbus };
-	int r;
-
-	r = _dbus_kernel_recv(fd, kdbus->kdbus_pool, kdbus_message_func,
-				kdbus_name_owner_change_func, &recv_data);
-	if (r < 0) {
-		l_util_debug(dbus->debug_handler,
-				dbus->debug_data, strerror(-r));
-		return NULL;
-	}
-
-	return recv_data.message;
-}
-
-static bool kdbus_add_match(struct l_dbus *dbus, unsigned int id,
-				const struct _dbus_filter_condition *rule,
-				int rule_len)
-{
-	struct l_dbus_kdbus *kdbus =
-		container_of(dbus, struct l_dbus_kdbus, super);
-	int fd = l_io_get_fd(dbus->io);
-	int r;
-
-	r = _dbus_kernel_add_match(fd, kdbus->bloom_size, kdbus->bloom_n_hash,
-					rule, rule_len, id);
-	if (r < 0)
-		l_util_debug(dbus->debug_handler,
-				dbus->debug_data, strerror(-r));
-
-	return !r;
-}
-
-static bool kdbus_remove_match(struct l_dbus *dbus, unsigned int id)
-{
-	int fd = l_io_get_fd(dbus->io);
-	int r;
-
-	r = _dbus_kernel_remove_match(fd, id);
-	if (r < 0)
-		l_util_debug(dbus->debug_handler,
-				dbus->debug_data, strerror(-r));
-
-	return !r;
-}
-
-static bool kdbus_get_name_owner(struct l_dbus *dbus, const char *name)
-{
-	struct l_dbus_kdbus *kdbus =
-		container_of(dbus, struct l_dbus_kdbus, super);
-	int fd = l_io_get_fd(dbus->io);
-	uint64_t owner_id;
-	char owner[32];
-	int r;
-
-	owner_id = _dbus_kernel_get_name_owner(fd, kdbus->kdbus_pool, name);
-
-	if (owner_id)
-		snprintf(owner, sizeof(owner), ":1.%" PRIu64, owner_id);
-	else
-		owner[0] = '\0';
-
-	_dbus_name_cache_notify(dbus->name_cache, name, owner);
-
-	if (!dbus->name_notify_enabled) {
-		r = _dbus_kernel_enable_name_owner_notify(fd);
-		if (r < 0)
-			l_util_debug(dbus->debug_handler,
-					dbus->debug_data, strerror(-r));
-
-		dbus->name_notify_enabled = true;
-	}
-
-	return true;
-}
-
-static uint32_t kdbus_name_acquire(struct l_dbus *dbus, const char *name,
-					bool allow_replacement,
-					bool replace_existing, bool queue,
-					l_dbus_name_acquire_func_t callback,
-					void *user_data)
-{
-	int fd = l_io_get_fd(dbus->io);
-	bool queued = false;
-	bool result;
-	int r;
-
-	r = _dbus_kernel_name_acquire(fd, name, allow_replacement,
-					replace_existing, queue, &queued);
-
-	result = r >= 0 || r == -EALREADY;
-
-	if (!result)
-		l_util_debug(dbus->debug_handler,
-				dbus->debug_data, strerror(-r));
-
-	if (callback)
-		callback(dbus, result, queued, user_data);
-
-	return 0;
-}
-
-static const struct l_dbus_ops kdbus_ops = {
-	.version  = 2,
-	.free = kdbus_free,
-	.send_message = kdbus_send_message,
-	.recv_message = kdbus_recv_message,
-	.name_ops = {
-		.get_name_owner = kdbus_get_name_owner,
-	},
-	.filter_ops = {
-		.add_match = kdbus_add_match,
-		.remove_match = kdbus_remove_match,
-	},
-	.name_acquire = kdbus_name_acquire,
-};
-
-static struct l_dbus *setup_kdbus(int fd)
-{
-	struct l_dbus *dbus;
-	struct l_dbus_kdbus *kdbus;
-
-	kdbus = l_new(struct l_dbus_kdbus, 1);
-	dbus = &kdbus->super;
-	dbus->driver = &kdbus_ops;
-
-	if (_dbus_kernel_hello(fd, "ell-connection",
-				&kdbus->bloom_size, &kdbus->bloom_n_hash,
-				&kdbus->kdbus_id, &kdbus->kdbus_pool,
-				&dbus->guid) < 0) {
-		l_free(dbus);
-		close(fd);
-		return NULL;
-	}
-
-	dbus_init(dbus, fd);
-
-	dbus->unique_name = l_strdup_printf(":1.%llu", kdbus->kdbus_id);
-
-	l_idle_oneshot(kdbus_ready, dbus, NULL);
-
-	return dbus;
-}
-
-static struct l_dbus *setup_kernel(char *params)
-{
-	char *path = NULL;
-	int fd;
-
-	while (params) {
-		char *key = strsep(&params, ",");
-		char *value;
-
-		if (!key)
-			break;
-
-		value = strchr(key, '=');
-		if (!value)
-			continue;
-
-		*value++ = '\0';
-
-		if (!strcmp(key, "path"))
-			path = value;
-	}
-
-	if (!path)
-		return NULL;
-
-	fd = open(path, O_RDWR | O_CLOEXEC);
-	if (fd < 0)
-		return NULL;
-
-	return setup_kdbus(fd);
-}
-
 static struct l_dbus *setup_address(const char *address)
 {
 	struct l_dbus *dbus = NULL;
@@ -1423,11 +1164,7 @@ static struct l_dbus *setup_address(const char *address)
 		if (params)
 			*params++ = '\0';
 
-		if (!strcmp(transport, "kernel")) {
-			/* Function will modify params string */
-			dbus = setup_kernel(params);
-			break;
-		} else if (!strcmp(transport, "unix")) {
+		if (!strcmp(transport, "unix")) {
 			/* Function will modify params string */
 			dbus = setup_unix(params);
 			break;
diff --git a/linux/kdbus.h b/linux/kdbus.h
deleted file mode 100644
index 4fc44cb..0000000
--- a/linux/kdbus.h
+++ /dev/null
@@ -1,984 +0,0 @@
-/*
- * kdbus is free software; you can redistribute it and/or modify it under
- * the terms of the GNU Lesser General Public License as published by the
- * Free Software Foundation; either version 2.1 of the License, or (at
- * your option) any later version.
- */
-
-#ifndef _UAPI_KDBUS_H_
-#define _UAPI_KDBUS_H_
-
-#include <linux/ioctl.h>
-#include <linux/types.h>
-
-#define KDBUS_IOCTL_MAGIC		0x95
-#define KDBUS_SRC_ID_KERNEL		(0)
-#define KDBUS_DST_ID_NAME		(0)
-#define KDBUS_MATCH_ID_ANY		(~0ULL)
-#define KDBUS_DST_ID_BROADCAST		(~0ULL)
-#define KDBUS_FLAG_NEGOTIATE		(1ULL << 63)
-
-/**
- * struct kdbus_notify_id_change - name registry change message
- * @id:			New or former owner of the name
- * @flags:		flags field from KDBUS_HELLO_*
- *
- * Sent from kernel to userspace when the owner or activator of
- * a well-known name changes.
- *
- * Attached to:
- *   KDBUS_ITEM_ID_ADD
- *   KDBUS_ITEM_ID_REMOVE
- */
-struct kdbus_notify_id_change {
-	__u64 id;
-	__u64 flags;
-} __attribute__((__aligned__(8)));
-
-/**
- * struct kdbus_notify_name_change - name registry change message
- * @old_id:		ID and flags of former owner of a name
- * @new_id:		ID and flags of new owner of a name
- * @name:		Well-known name
- *
- * Sent from kernel to userspace when the owner or activator of
- * a well-known name changes.
- *
- * Attached to:
- *   KDBUS_ITEM_NAME_ADD
- *   KDBUS_ITEM_NAME_REMOVE
- *   KDBUS_ITEM_NAME_CHANGE
- */
-struct kdbus_notify_name_change {
-	struct kdbus_notify_id_change old_id;
-	struct kdbus_notify_id_change new_id;
-	char name[0];
-} __attribute__((__aligned__(8)));
-
-/**
- * struct kdbus_creds - process credentials
- * @uid:		User ID
- * @euid:		Effective UID
- * @suid:		Saved UID
- * @fsuid:		Filesystem UID
- * @gid:		Group ID
- * @egid:		Effective GID
- * @sgid:		Saved GID
- * @fsgid:		Filesystem GID
- *
- * Attached to:
- *   KDBUS_ITEM_CREDS
- */
-struct kdbus_creds {
-	__u64 uid;
-	__u64 euid;
-	__u64 suid;
-	__u64 fsuid;
-	__u64 gid;
-	__u64 egid;
-	__u64 sgid;
-	__u64 fsgid;
-} __attribute__((__aligned__(8)));
-
-/**
- * struct kdbus_pids - process identifiers
- * @pid:		Process ID
- * @tid:		Thread ID
- * @ppid:		Parent process ID
- *
- * The PID and TID of a process.
- *
- * Attached to:
- *   KDBUS_ITEM_PIDS
- */
-struct kdbus_pids {
-	__u64 pid;
-	__u64 tid;
-	__u64 ppid;
-} __attribute__((__aligned__(8)));
-
-/**
- * struct kdbus_caps - process capabilities
- * @last_cap:	Highest currently known capability bit
- * @caps:	Variable number of 32-bit capabilities flags
- *
- * Contains a variable number of 32-bit capabilities flags.
- *
- * Attached to:
- *   KDBUS_ITEM_CAPS
- */
-struct kdbus_caps {
-	__u32 last_cap;
-	__u32 caps[0];
-} __attribute__((__aligned__(8)));
-
-/**
- * struct kdbus_audit - audit information
- * @sessionid:		The audit session ID
- * @loginuid:		The audit login uid
- *
- * Attached to:
- *   KDBUS_ITEM_AUDIT
- */
-struct kdbus_audit {
-	__u32 sessionid;
-	__u32 loginuid;
-} __attribute__((__aligned__(8)));
-
-/**
- * struct kdbus_timestamp
- * @seqnum:		Global per-domain message sequence number
- * @monotonic_ns:	Monotonic timestamp, in nanoseconds
- * @realtime_ns:	Realtime timestamp, in nanoseconds
- *
- * Attached to:
- *   KDBUS_ITEM_TIMESTAMP
- */
-struct kdbus_timestamp {
-	__u64 seqnum;
-	__u64 monotonic_ns;
-	__u64 realtime_ns;
-} __attribute__((__aligned__(8)));
-
-/**
- * struct kdbus_vec - I/O vector for kdbus payload items
- * @size:		The size of the vector
- * @address:		Memory address of data buffer
- * @offset:		Offset in the in-message payload memory,
- *			relative to the message head
- *
- * Attached to:
- *   KDBUS_ITEM_PAYLOAD_VEC, KDBUS_ITEM_PAYLOAD_OFF
- */
-struct kdbus_vec {
-	__u64 size;
-	union {
-		__u64 address;
-		__u64 offset;
-	};
-} __attribute__((__aligned__(8)));
-
-/**
- * struct kdbus_bloom_parameter - bus-wide bloom parameters
- * @size:		Size of the bit field in bytes (m / 8)
- * @n_hash:		Number of hash functions used (k)
- */
-struct kdbus_bloom_parameter {
-	__u64 size;
-	__u64 n_hash;
-} __attribute__((__aligned__(8)));
-
-/**
- * struct kdbus_bloom_filter - bloom filter containing n elements
- * @generation:		Generation of the element set in the filter
- * @data:		Bit field, multiple of 8 bytes
- */
-struct kdbus_bloom_filter {
-	__u64 generation;
-	__u64 data[0];
-} __attribute__((__aligned__(8)));
-
-/**
- * struct kdbus_memfd - a kdbus memfd
- * @start:		The offset into the memfd where the segment starts
- * @size:		The size of the memfd segment
- * @fd:			The file descriptor number
- * @__pad:		Padding to ensure proper alignment and size
- *
- * Attached to:
- *   KDBUS_ITEM_PAYLOAD_MEMFD
- */
-struct kdbus_memfd {
-	__u64 start;
-	__u64 size;
-	int fd;
-	__u32 __pad;
-} __attribute__((__aligned__(8)));
-
-/**
- * struct kdbus_name - a registered well-known name with its flags
- * @flags:		Flags from KDBUS_NAME_*
- * @name:		Well-known name
- *
- * Attached to:
- *   KDBUS_ITEM_OWNED_NAME
- */
-struct kdbus_name {
-	__u64 flags;
-	char name[0];
-} __attribute__((__aligned__(8)));
-
-/**
- * enum kdbus_policy_access_type - permissions of a policy record
- * @_KDBUS_POLICY_ACCESS_NULL:	Uninitialized/invalid
- * @KDBUS_POLICY_ACCESS_USER:	Grant access to a uid
- * @KDBUS_POLICY_ACCESS_GROUP:	Grant access to gid
- * @KDBUS_POLICY_ACCESS_WORLD:	World-accessible
- */
-enum kdbus_policy_access_type {
-	_KDBUS_POLICY_ACCESS_NULL,
-	KDBUS_POLICY_ACCESS_USER,
-	KDBUS_POLICY_ACCESS_GROUP,
-	KDBUS_POLICY_ACCESS_WORLD,
-};
-
-/**
- * enum kdbus_policy_access_flags - mode flags
- * @KDBUS_POLICY_OWN:		Allow to own a well-known name
- *				Implies KDBUS_POLICY_TALK and KDBUS_POLICY_SEE
- * @KDBUS_POLICY_TALK:		Allow communication to a well-known name
- *				Implies KDBUS_POLICY_SEE
- * @KDBUS_POLICY_SEE:		Allow to see a well-known name
- */
-enum kdbus_policy_type {
-	KDBUS_POLICY_SEE	= 0,
-	KDBUS_POLICY_TALK,
-	KDBUS_POLICY_OWN,
-};
-
-/**
- * struct kdbus_policy_access - policy access item
- * @type:		One of KDBUS_POLICY_ACCESS_* types
- * @access:		Access to grant
- * @id:			For KDBUS_POLICY_ACCESS_USER, the uid
- *			For KDBUS_POLICY_ACCESS_GROUP, the gid
- */
-struct kdbus_policy_access {
-	__u64 type;	/* USER, GROUP, WORLD */
-	__u64 access;	/* OWN, TALK, SEE */
-	__u64 id;	/* uid, gid, 0 */
-} __attribute__((__aligned__(8)));
-
-/**
- * enum kdbus_attach_flags - flags for metadata attachments
- * @KDBUS_ATTACH_TIMESTAMP:		Timestamp
- * @KDBUS_ATTACH_CREDS:			Credentials
- * @KDBUS_ATTACH_PIDS:			PIDs
- * @KDBUS_ATTACH_AUXGROUPS:		Auxiliary groups
- * @KDBUS_ATTACH_NAMES:			Well-known names
- * @KDBUS_ATTACH_TID_COMM:		The "comm" process identifier of the TID
- * @KDBUS_ATTACH_PID_COMM:		The "comm" process identifier of the PID
- * @KDBUS_ATTACH_EXE:			The path of the executable
- * @KDBUS_ATTACH_CMDLINE:		The process command line
- * @KDBUS_ATTACH_CGROUP:		The croup membership
- * @KDBUS_ATTACH_CAPS:			The process capabilities
- * @KDBUS_ATTACH_SECLABEL:		The security label
- * @KDBUS_ATTACH_AUDIT:			The audit IDs
- * @KDBUS_ATTACH_CONN_DESCRIPTION:	The human-readable connection name
- * @_KDBUS_ATTACH_ALL:			All of the above
- * @_KDBUS_ATTACH_ANY:			Wildcard match to enable any kind of
- *					metatdata.
- */
-enum kdbus_attach_flags {
-	KDBUS_ATTACH_TIMESTAMP		=  1ULL <<  0,
-	KDBUS_ATTACH_CREDS		=  1ULL <<  1,
-	KDBUS_ATTACH_PIDS		=  1ULL <<  2,
-	KDBUS_ATTACH_AUXGROUPS		=  1ULL <<  3,
-	KDBUS_ATTACH_NAMES		=  1ULL <<  4,
-	KDBUS_ATTACH_TID_COMM		=  1ULL <<  5,
-	KDBUS_ATTACH_PID_COMM		=  1ULL <<  6,
-	KDBUS_ATTACH_EXE		=  1ULL <<  7,
-	KDBUS_ATTACH_CMDLINE		=  1ULL <<  8,
-	KDBUS_ATTACH_CGROUP		=  1ULL <<  9,
-	KDBUS_ATTACH_CAPS		=  1ULL << 10,
-	KDBUS_ATTACH_SECLABEL		=  1ULL << 11,
-	KDBUS_ATTACH_AUDIT		=  1ULL << 12,
-	KDBUS_ATTACH_CONN_DESCRIPTION	=  1ULL << 13,
-	_KDBUS_ATTACH_ALL		=  (1ULL << 14) - 1,
-	_KDBUS_ATTACH_ANY		=  ~0ULL
-};
-
-/**
- * enum kdbus_item_type - item types to chain data in a list
- * @_KDBUS_ITEM_NULL:			Uninitialized/invalid
- * @_KDBUS_ITEM_USER_BASE:		Start of user items
- * @KDBUS_ITEM_NEGOTIATE:		Negotiate supported items
- * @KDBUS_ITEM_PAYLOAD_VEC:		Vector to data
- * @KDBUS_ITEM_PAYLOAD_OFF:		Data at returned offset to message head
- * @KDBUS_ITEM_PAYLOAD_MEMFD:		Data as sealed memfd
- * @KDBUS_ITEM_FDS:			Attached file descriptors
- * @KDBUS_ITEM_CANCEL_FD:		FD used to cancel a synchronous
- *					operation by writing to it from
- *					userspace
- * @KDBUS_ITEM_BLOOM_PARAMETER:		Bus-wide bloom parameters, used with
- *					KDBUS_CMD_BUS_MAKE, carries a
- *					struct kdbus_bloom_parameter
- * @KDBUS_ITEM_BLOOM_FILTER:		Bloom filter carried with a message,
- *					used to match against a bloom mask of a
- *					connection, carries a struct
- *					kdbus_bloom_filter
- * @KDBUS_ITEM_BLOOM_MASK:		Bloom mask used to match against a
- *					message'sbloom filter
- * @KDBUS_ITEM_DST_NAME:		Destination's well-known name
- * @KDBUS_ITEM_MAKE_NAME:		Name of domain, bus, endpoint
- * @KDBUS_ITEM_ATTACH_FLAGS_SEND:	Attach-flags, used for updating which
- *					metadata a connection opts in to send
- * @KDBUS_ITEM_ATTACH_FLAGS_RECV:	Attach-flags, used for updating which
- *					metadata a connection requests to
- *					receive for each reeceived message
- * @KDBUS_ITEM_ID:			Connection ID
- * @KDBUS_ITEM_NAME:			Well-know name with flags
- * @_KDBUS_ITEM_ATTACH_BASE:		Start of metadata attach items
- * @KDBUS_ITEM_TIMESTAMP:		Timestamp
- * @KDBUS_ITEM_CREDS:			Process credentials
- * @KDBUS_ITEM_PIDS:			Process identifiers
- * @KDBUS_ITEM_AUXGROUPS:		Auxiliary process groups
- * @KDBUS_ITEM_OWNED_NAME:		A name owned by the associated
- *					connection
- * @KDBUS_ITEM_TID_COMM:		Thread ID "comm" identifier
- *					(Don't trust this, see below.)
- * @KDBUS_ITEM_PID_COMM:		Process ID "comm" identifier
- *					(Don't trust this, see below.)
- * @KDBUS_ITEM_EXE:			The path of the executable
- *					(Don't trust this, see below.)
- * @KDBUS_ITEM_CMDLINE:			The process command line
- *					(Don't trust this, see below.)
- * @KDBUS_ITEM_CGROUP:			The croup membership
- * @KDBUS_ITEM_CAPS:			The process capabilities
- * @KDBUS_ITEM_SECLABEL:		The security label
- * @KDBUS_ITEM_AUDIT:			The audit IDs
- * @KDBUS_ITEM_CONN_DESCRIPTION:	The connection's human-readable name
- *					(debugging)
- * @_KDBUS_ITEM_POLICY_BASE:		Start of policy items
- * @KDBUS_ITEM_POLICY_ACCESS:		Policy access block
- * @_KDBUS_ITEM_KERNEL_BASE:		Start of kernel-generated message items
- * @KDBUS_ITEM_NAME_ADD:		Notification in kdbus_notify_name_change
- * @KDBUS_ITEM_NAME_REMOVE:		Notification in kdbus_notify_name_change
- * @KDBUS_ITEM_NAME_CHANGE:		Notification in kdbus_notify_name_change
- * @KDBUS_ITEM_ID_ADD:			Notification in kdbus_notify_id_change
- * @KDBUS_ITEM_ID_REMOVE:		Notification in kdbus_notify_id_change
- * @KDBUS_ITEM_REPLY_TIMEOUT:		Timeout has been reached
- * @KDBUS_ITEM_REPLY_DEAD:		Destination died
- *
- * N.B: The process and thread COMM fields, as well as the CMDLINE and
- * EXE fields may be altered by unprivileged processes und should
- * hence *not* used for security decisions. Peers should make use of
- * these items only for informational purposes, such as generating log
- * records.
- */
-enum kdbus_item_type {
-	_KDBUS_ITEM_NULL,
-	_KDBUS_ITEM_USER_BASE,
-	KDBUS_ITEM_NEGOTIATE	= _KDBUS_ITEM_USER_BASE,
-	KDBUS_ITEM_PAYLOAD_VEC,
-	KDBUS_ITEM_PAYLOAD_OFF,
-	KDBUS_ITEM_PAYLOAD_MEMFD,
-	KDBUS_ITEM_FDS,
-	KDBUS_ITEM_CANCEL_FD,
-	KDBUS_ITEM_BLOOM_PARAMETER,
-	KDBUS_ITEM_BLOOM_FILTER,
-	KDBUS_ITEM_BLOOM_MASK,
-	KDBUS_ITEM_DST_NAME,
-	KDBUS_ITEM_MAKE_NAME,
-	KDBUS_ITEM_ATTACH_FLAGS_SEND,
-	KDBUS_ITEM_ATTACH_FLAGS_RECV,
-	KDBUS_ITEM_ID,
-	KDBUS_ITEM_NAME,
-	KDBUS_ITEM_DST_ID,
-
-	/* keep these item types in sync with KDBUS_ATTACH_* flags */
-	_KDBUS_ITEM_ATTACH_BASE	= 0x1000,
-	KDBUS_ITEM_TIMESTAMP	= _KDBUS_ITEM_ATTACH_BASE,
-	KDBUS_ITEM_CREDS,
-	KDBUS_ITEM_PIDS,
-	KDBUS_ITEM_AUXGROUPS,
-	KDBUS_ITEM_OWNED_NAME,
-	KDBUS_ITEM_TID_COMM,
-	KDBUS_ITEM_PID_COMM,
-	KDBUS_ITEM_EXE,
-	KDBUS_ITEM_CMDLINE,
-	KDBUS_ITEM_CGROUP,
-	KDBUS_ITEM_CAPS,
-	KDBUS_ITEM_SECLABEL,
-	KDBUS_ITEM_AUDIT,
-	KDBUS_ITEM_CONN_DESCRIPTION,
-
-	_KDBUS_ITEM_POLICY_BASE	= 0x2000,
-	KDBUS_ITEM_POLICY_ACCESS = _KDBUS_ITEM_POLICY_BASE,
-
-	_KDBUS_ITEM_KERNEL_BASE	= 0x8000,
-	KDBUS_ITEM_NAME_ADD	= _KDBUS_ITEM_KERNEL_BASE,
-	KDBUS_ITEM_NAME_REMOVE,
-	KDBUS_ITEM_NAME_CHANGE,
-	KDBUS_ITEM_ID_ADD,
-	KDBUS_ITEM_ID_REMOVE,
-	KDBUS_ITEM_REPLY_TIMEOUT,
-	KDBUS_ITEM_REPLY_DEAD,
-};
-
-/**
- * struct kdbus_item - chain of data blocks
- * @size:		Overall data record size
- * @type:		Kdbus_item type of data
- * @data:		Generic bytes
- * @data32:		Generic 32 bit array
- * @data64:		Generic 64 bit array
- * @str:		Generic string
- * @id:			Connection ID
- * @vec:		KDBUS_ITEM_PAYLOAD_VEC
- * @creds:		KDBUS_ITEM_CREDS
- * @audit:		KDBUS_ITEM_AUDIT
- * @timestamp:		KDBUS_ITEM_TIMESTAMP
- * @name:		KDBUS_ITEM_NAME
- * @bloom_parameter:	KDBUS_ITEM_BLOOM_PARAMETER
- * @bloom_filter:	KDBUS_ITEM_BLOOM_FILTER
- * @memfd:		KDBUS_ITEM_PAYLOAD_MEMFD
- * @name_change:	KDBUS_ITEM_NAME_ADD
- *			KDBUS_ITEM_NAME_REMOVE
- *			KDBUS_ITEM_NAME_CHANGE
- * @id_change:		KDBUS_ITEM_ID_ADD
- *			KDBUS_ITEM_ID_REMOVE
- * @policy:		KDBUS_ITEM_POLICY_ACCESS
- */
-struct kdbus_item {
-	__u64 size;
-	__u64 type;
-	union {
-		__u8 data[0];
-		__u32 data32[0];
-		__u64 data64[0];
-		char str[0];
-
-		__u64 id;
-		struct kdbus_vec vec;
-		struct kdbus_creds creds;
-		struct kdbus_pids pids;
-		struct kdbus_audit audit;
-		struct kdbus_caps caps;
-		struct kdbus_timestamp timestamp;
-		struct kdbus_name name;
-		struct kdbus_bloom_parameter bloom_parameter;
-		struct kdbus_bloom_filter bloom_filter;
-		struct kdbus_memfd memfd;
-		int fds[0];
-		struct kdbus_notify_name_change name_change;
-		struct kdbus_notify_id_change id_change;
-		struct kdbus_policy_access policy_access;
-	};
-} __attribute__((__aligned__(8)));
-
-/**
- * enum kdbus_msg_flags - type of message
- * @KDBUS_MSG_EXPECT_REPLY:	Expect a reply message, used for
- *				method calls. The userspace-supplied
- *				cookie identifies the message and the
- *				respective reply carries the cookie
- *				in cookie_reply
- * @KDBUS_MSG_NO_AUTO_START:	Do not start a service if the addressed
- *				name is not currently active. This flag is
- *				not looked at by the kernel but only
- *				serves as hint for userspace implementations.
- * @KDBUS_MSG_SIGNAL:		Treat this message as signal
- */
-enum kdbus_msg_flags {
-	KDBUS_MSG_EXPECT_REPLY	= 1ULL << 0,
-	KDBUS_MSG_NO_AUTO_START	= 1ULL << 1,
-	KDBUS_MSG_SIGNAL	= 1ULL << 2,
-};
-
-/**
- * enum kdbus_payload_type - type of payload carried by message
- * @KDBUS_PAYLOAD_KERNEL:	Kernel-generated simple message
- * @KDBUS_PAYLOAD_DBUS:		D-Bus marshalling "DBusDBus"
- *
- * Any payload-type is accepted. Common types will get added here once
- * established.
- */
-enum kdbus_payload_type {
-	KDBUS_PAYLOAD_KERNEL,
-	KDBUS_PAYLOAD_DBUS	= 0x4442757344427573ULL,
-};
-
-/**
- * struct kdbus_msg - the representation of a kdbus message
- * @size:		Total size of the message
- * @flags:		Message flags (KDBUS_MSG_*), userspace → kernel
- * @priority:		Message queue priority value
- * @dst_id:		64-bit ID of the destination connection
- * @src_id:		64-bit ID of the source connection
- * @payload_type:	Payload type (KDBUS_PAYLOAD_*)
- * @cookie:		Userspace-supplied cookie, for the connection
- *			to identify its messages
- * @timeout_ns:		The time to wait for a message reply from the peer.
- *			If there is no reply, and the send command is
- *			executed asynchronously, a kernel-generated message
- *			with an attached KDBUS_ITEM_REPLY_TIMEOUT item
- *			is sent to @src_id. For synchronously executed send
- *			command, the value denotes the maximum time the call
- *			blocks to wait for a reply. The timeout is expected in
- *			nanoseconds and as absolute CLOCK_MONOTONIC value.
- * @cookie_reply:	A reply to the requesting message with the same
- *			cookie. The requesting connection can match its
- *			request and the reply with this value
- * @items:		A list of kdbus_items containing the message payload
- */
-struct kdbus_msg {
-	__u64 size;
-	__u64 flags;
-	__s64 priority;
-	__u64 dst_id;
-	__u64 src_id;
-	__u64 payload_type;
-	__u64 cookie;
-	union {
-		__u64 timeout_ns;
-		__u64 cookie_reply;
-	};
-	struct kdbus_item items[0];
-} __attribute__((__aligned__(8)));
-
-/**
- * struct kdbus_msg_info - returned message container
- * @offset:		Offset of kdbus_msg slice in pool
- * @msg_size:		Copy of the kdbus_msg.size field
- * @return_flags:	Command return flags, kernel → userspace
- */
-struct kdbus_msg_info {
-	__u64 offset;
-	__u64 msg_size;
-	__u64 return_flags;
-} __attribute__((__aligned__(8)));
-
-/**
- * enum kdbus_send_flags - flags for sending messages
- * @KDBUS_SEND_SYNC_REPLY:	Wait for destination connection to
- *				reply to this message. The
- *				KDBUS_CMD_SEND ioctl() will block
- *				until the reply is received, and
- *				reply in struct kdbus_cmd_send will
- *				yield the offset in the sender's pool
- *				where the reply can be found.
- *				This flag is only valid if
- *				@KDBUS_MSG_EXPECT_REPLY is set as well.
- */
-enum kdbus_send_flags {
-	KDBUS_SEND_SYNC_REPLY		= 1ULL << 0,
-};
-
-/**
- * struct kdbus_cmd_send - send message
- * @size:		Overall size of this structure
- * @flags:		Flags to change send behavior (KDBUS_SEND_*)
- * @return_flags:	Command return flags, kernel → userspace
- * @msg_address:	Storage address of the kdbus_msg to send
- * @reply:		Storage for message reply if KDBUS_SEND_SYNC_REPLY
- *			was given
- * @items:		Additional items for this command
- */
-struct kdbus_cmd_send {
-	__u64 size;
-	__u64 flags;
-	__u64 return_flags;
-	__u64 msg_address;
-	struct kdbus_msg_info reply;
-	struct kdbus_item items[0];
-} __attribute__((__aligned__(8)));
-
-/**
- * enum kdbus_recv_flags - flags for de-queuing messages
- * @KDBUS_RECV_PEEK:		Return the next queued message without
- *				actually de-queuing it, and without installing
- *				any file descriptors or other resources. It is
- *				usually used to determine the activating
- *				connection of a bus name.
- * @KDBUS_RECV_DROP:		Drop and free the next queued message and all
- *				its resources without actually receiving it.
- * @KDBUS_RECV_USE_PRIORITY:	Only de-queue messages with the specified or
- *				higher priority (lowest values); if not set,
- *				the priority value is ignored.
- */
-enum kdbus_recv_flags {
-	KDBUS_RECV_PEEK		= 1ULL <<  0,
-	KDBUS_RECV_DROP		= 1ULL <<  1,
-	KDBUS_RECV_USE_PRIORITY	= 1ULL <<  2,
-};
-
-/**
- * enum kdbus_recv_return_flags - return flags for message receive commands
- * @KDBUS_RECV_RETURN_INCOMPLETE_FDS:	One or more file descriptors could not
- *					be installed. These descriptors in
- *					KDBUS_ITEM_FDS will carry the value -1.
- * @KDBUS_RECV_RETURN_DROPPED_MSGS:	There have been dropped messages since
- *					the last time a message was received.
- *					The 'dropped_msgs' counter contains the
- *					number of messages dropped pool
- *					overflows or other missed broadcasts.
- */
-enum kdbus_recv_return_flags {
-	KDBUS_RECV_RETURN_INCOMPLETE_FDS	= 1ULL <<  0,
-	KDBUS_RECV_RETURN_DROPPED_MSGS		= 1ULL <<  1,
-};
-
-/**
- * struct kdbus_cmd_recv - struct to de-queue a buffered message
- * @size:		Overall size of this object
- * @flags:		KDBUS_RECV_* flags, userspace → kernel
- * @return_flags:	Command return flags, kernel → userspace
- * @priority:		Minimum priority of the messages to de-queue. Lowest
- *			values have the highest priority.
- * @dropped_msgs:	In case there were any dropped messages since the last
- *			time a message was received, this will be set to the
- *			number of lost messages and
- *			KDBUS_RECV_RETURN_DROPPED_MSGS will be set in
- *			'return_flags'. This can only happen if the ioctl
- *			returns 0 or EAGAIN.
- * @msg:		Return storage for received message.
- * @items:		Additional items for this command.
- *
- * This struct is used with the KDBUS_CMD_RECV ioctl.
- */
-struct kdbus_cmd_recv {
-	__u64 size;
-	__u64 flags;
-	__u64 return_flags;
-	__s64 priority;
-	__u64 dropped_msgs;
-	struct kdbus_msg_info msg;
-	struct kdbus_item items[0];
-} __attribute__((__aligned__(8)));
-
-/**
- * struct kdbus_cmd_free - struct to free a slice of memory in the pool
- * @size:		Overall size of this structure
- * @flags:		Flags for the free command, userspace → kernel
- * @return_flags:	Command return flags, kernel → userspace
- * @offset:		The offset of the memory slice, as returned by other
- *			ioctls
- * @items:		Additional items to modify the behavior
- *
- * This struct is used with the KDBUS_CMD_FREE ioctl.
- */
-struct kdbus_cmd_free {
-	__u64 size;
-	__u64 flags;
-	__u64 return_flags;
-	__u64 offset;
-	struct kdbus_item items[0];
-} __attribute__((__aligned__(8)));
-
-/**
- * enum kdbus_hello_flags - flags for struct kdbus_cmd_hello
- * @KDBUS_HELLO_ACCEPT_FD:	The connection allows the reception of
- *				any passed file descriptors
- * @KDBUS_HELLO_ACTIVATOR:	Special-purpose connection which registers
- *				a well-know name for a process to be started
- *				when traffic arrives
- * @KDBUS_HELLO_POLICY_HOLDER:	Special-purpose connection which registers
- *				policy entries for a name. The provided name
- *				is not activated and not registered with the
- *				name database, it only allows unprivileged
- *				connections to acquire a name, talk or discover
- *				a service
- * @KDBUS_HELLO_MONITOR:	Special-purpose connection to monitor
- *				bus traffic
- */
-enum kdbus_hello_flags {
-	KDBUS_HELLO_ACCEPT_FD		=  1ULL <<  0,
-	KDBUS_HELLO_ACTIVATOR		=  1ULL <<  1,
-	KDBUS_HELLO_POLICY_HOLDER	=  1ULL <<  2,
-	KDBUS_HELLO_MONITOR		=  1ULL <<  3,
-};
-
-/**
- * struct kdbus_cmd_hello - struct to say hello to kdbus
- * @size:		The total size of the structure
- * @flags:		Connection flags (KDBUS_HELLO_*), userspace → kernel
- * @return_flags:	Command return flags, kernel → userspace
- * @attach_flags_send:	Mask of metadata to attach to each message sent
- *			off by this connection (KDBUS_ATTACH_*)
- * @attach_flags_recv:	Mask of metadata to attach to each message receieved
- *			by the new connection (KDBUS_ATTACH_*)
- * @bus_flags:		The flags field copied verbatim from the original
- *			KDBUS_CMD_BUS_MAKE ioctl. It's intended to be useful
- *			to do negotiation of features of the payload that is
- *			transferred (kernel → userspace)
- * @id:			The ID of this connection (kernel → userspace)
- * @pool_size:		Size of the connection's buffer where the received
- *			messages are placed
- * @offset:		Pool offset where items are returned to report
- *			additional information about the bus and the newly
- *			created connection.
- * @items_size:		Size of buffer returned in the pool slice at @offset.
- * @id128:		Unique 128-bit ID of the bus (kernel → userspace)
- * @items:		A list of items
- *
- * This struct is used with the KDBUS_CMD_HELLO ioctl.
- */
-struct kdbus_cmd_hello {
-	__u64 size;
-	__u64 flags;
-	__u64 return_flags;
-	__u64 attach_flags_send;
-	__u64 attach_flags_recv;
-	__u64 bus_flags;
-	__u64 id;
-	__u64 pool_size;
-	__u64 offset;
-	__u64 items_size;
-	__u8 id128[16];
-	struct kdbus_item items[0];
-} __attribute__((__aligned__(8)));
-
-/**
- * struct kdbus_info - connection information
- * @size:		total size of the struct
- * @id:			64bit object ID
- * @flags:		object creation flags
- * @items:		list of items
- *
- * Note that the user is responsible for freeing the allocated memory with
- * the KDBUS_CMD_FREE ioctl.
- */
-struct kdbus_info {
-	__u64 size;
-	__u64 id;
-	__u64 flags;
-	struct kdbus_item items[0];
-} __attribute__((__aligned__(8)));
-
-/**
- * enum kdbus_list_flags - what to include into the returned list
- * @KDBUS_LIST_UNIQUE:		active connections
- * @KDBUS_LIST_ACTIVATORS:	activator connections
- * @KDBUS_LIST_NAMES:		known well-known names
- * @KDBUS_LIST_QUEUED:		queued-up names
- */
-enum kdbus_list_flags {
-	KDBUS_LIST_UNIQUE		= 1ULL <<  0,
-	KDBUS_LIST_NAMES		= 1ULL <<  1,
-	KDBUS_LIST_ACTIVATORS		= 1ULL <<  2,
-	KDBUS_LIST_QUEUED		= 1ULL <<  3,
-};
-
-/**
- * struct kdbus_cmd_list - list connections
- * @size:		overall size of this object
- * @flags:		flags for the query (KDBUS_LIST_*), userspace → kernel
- * @return_flags:	command return flags, kernel → userspace
- * @offset:		Offset in the caller's pool buffer where an array of
- *			kdbus_info objects is stored.
- *			The user must use KDBUS_CMD_FREE to free the
- *			allocated memory.
- * @list_size:		size of returned list in bytes
- * @items:		Items for the command. Reserved for future use.
- *
- * This structure is used with the KDBUS_CMD_LIST ioctl.
- */
-struct kdbus_cmd_list {
-	__u64 size;
-	__u64 flags;
-	__u64 return_flags;
-	__u64 offset;
-	__u64 list_size;
-	struct kdbus_item items[0];
-} __attribute__((__aligned__(8)));
-
-/**
- * struct kdbus_cmd_info - struct used for KDBUS_CMD_CONN_INFO ioctl
- * @size:		The total size of the struct
- * @flags:		Flags for this ioctl, userspace → kernel
- * @return_flags:	Command return flags, kernel → userspace
- * @id:			The 64-bit ID of the connection. If set to zero, passing
- *			@name is required. kdbus will look up the name to
- *			determine the ID in this case.
- * @attach_flags:	Set of attach flags to specify the set of information
- *			to receive, userspace → kernel
- * @offset:		Returned offset in the caller's pool buffer where the
- *			kdbus_info struct result is stored. The user must
- *			use KDBUS_CMD_FREE to free the allocated memory.
- * @info_size:		Output buffer to report size of data at @offset.
- * @items:		The optional item list, containing the
- *			well-known name to look up as a KDBUS_ITEM_NAME.
- *			Only needed in case @id is zero.
- *
- * On success, the KDBUS_CMD_CONN_INFO ioctl will return 0 and @offset will
- * tell the user the offset in the connection pool buffer at which to find the
- * result in a struct kdbus_info.
- */
-struct kdbus_cmd_info {
-	__u64 size;
-	__u64 flags;
-	__u64 return_flags;
-	__u64 id;
-	__u64 attach_flags;
-	__u64 offset;
-	__u64 info_size;
-	struct kdbus_item items[0];
-} __attribute__((__aligned__(8)));
-
-/**
- * enum kdbus_cmd_match_flags - flags to control the KDBUS_CMD_MATCH_ADD ioctl
- * @KDBUS_MATCH_REPLACE:	If entries with the supplied cookie already
- *				exists, remove them before installing the new
- *				matches.
- */
-enum kdbus_cmd_match_flags {
-	KDBUS_MATCH_REPLACE	= 1ULL <<  0,
-};
-
-/**
- * struct kdbus_cmd_match - struct to add or remove matches
- * @size:		The total size of the struct
- * @flags:		Flags for match command (KDBUS_MATCH_*),
- *			userspace → kernel
- * @return_flags:	Command return flags, kernel → userspace
- * @cookie:		Userspace supplied cookie. When removing, the cookie
- *			identifies the match to remove
- * @items:		A list of items for additional information
- *
- * This structure is used with the KDBUS_CMD_MATCH_ADD and
- * KDBUS_CMD_MATCH_REMOVE ioctl.
- */
-struct kdbus_cmd_match {
-	__u64 size;
-	__u64 flags;
-	__u64 return_flags;
-	__u64 cookie;
-	struct kdbus_item items[0];
-} __attribute__((__aligned__(8)));
-
-/**
- * enum kdbus_make_flags - Flags for KDBUS_CMD_{BUS,ENDPOINT}_MAKE
- * @KDBUS_MAKE_ACCESS_GROUP:	Make the bus or endpoint node group-accessible
- * @KDBUS_MAKE_ACCESS_WORLD:	Make the bus or endpoint node world-accessible
- */
-enum kdbus_make_flags {
-	KDBUS_MAKE_ACCESS_GROUP		= 1ULL <<  0,
-	KDBUS_MAKE_ACCESS_WORLD		= 1ULL <<  1,
-};
-
-/**
- * enum kdbus_name_flags - flags for KDBUS_CMD_NAME_ACQUIRE
- * @KDBUS_NAME_REPLACE_EXISTING:	Try to replace name of other connections
- * @KDBUS_NAME_ALLOW_REPLACEMENT:	Allow the replacement of the name
- * @KDBUS_NAME_QUEUE:			Name should be queued if busy
- * @KDBUS_NAME_IN_QUEUE:		Name is queued
- * @KDBUS_NAME_ACTIVATOR:		Name is owned by a activator connection
- * @KDBUS_NAME_PRIMARY:			Primary owner of the name
- * @KDBUS_NAME_ACQUIRED:		Name was acquired/queued _now_
- */
-enum kdbus_name_flags {
-	KDBUS_NAME_REPLACE_EXISTING	= 1ULL <<  0,
-	KDBUS_NAME_ALLOW_REPLACEMENT	= 1ULL <<  1,
-	KDBUS_NAME_QUEUE		= 1ULL <<  2,
-	KDBUS_NAME_IN_QUEUE		= 1ULL <<  3,
-	KDBUS_NAME_ACTIVATOR		= 1ULL <<  4,
-	KDBUS_NAME_PRIMARY		= 1ULL <<  5,
-	KDBUS_NAME_ACQUIRED		= 1ULL <<  6,
-};
-
-/**
- * struct kdbus_cmd - generic ioctl payload
- * @size:		Overall size of this structure
- * @flags:		Flags for this ioctl, userspace → kernel
- * @return_flags:	Ioctl return flags, kernel → userspace
- * @items:		Additional items to modify the behavior
- *
- * This is a generic ioctl payload object. It's used by all ioctls that only
- * take flags and items as input.
- */
-struct kdbus_cmd {
-	__u64 size;
-	__u64 flags;
-	__u64 return_flags;
-	struct kdbus_item items[0];
-} __attribute__((__aligned__(8)));
-
-/**
- * Ioctl API
- *
- * KDBUS_CMD_BUS_MAKE:		After opening the "control" node, this command
- *				creates a new bus with the specified
- *				name. The bus is immediately shut down and
- *				cleaned up when the opened file descriptor is
- *				closed.
- *
- * KDBUS_CMD_ENDPOINT_MAKE:	Creates a new named special endpoint to talk to
- *				the bus. Such endpoints usually carry a more
- *				restrictive policy and grant restricted access
- *				to specific applications.
- * KDBUS_CMD_ENDPOINT_UPDATE:	Update the properties of a custom enpoint. Used
- *				to update the policy.
- *
- * KDBUS_CMD_HELLO:		By opening the bus node, a connection is
- *				created. After a HELLO the opened connection
- *				becomes an active peer on the bus.
- * KDBUS_CMD_UPDATE:		Update the properties of a connection. Used to
- *				update the metadata subscription mask and
- *				policy.
- * KDBUS_CMD_BYEBYE:		Disconnect a connection. If there are no
- *				messages queued up in the connection's pool,
- *				the call succeeds, and the handle is rendered
- *				unusable. Otherwise, -EBUSY is returned without
- *				any further side-effects.
- * KDBUS_CMD_FREE:		Release the allocated memory in the receiver's
- *				pool.
- * KDBUS_CMD_CONN_INFO:		Retrieve credentials and properties of the
- *				initial creator of the connection. The data was
- *				stored at registration time and does not
- *				necessarily represent the connected process or
- *				the actual state of the process.
- * KDBUS_CMD_BUS_CREATOR_INFO:	Retrieve information of the creator of the bus
- *				a connection is attached to.
- *
- * KDBUS_CMD_SEND:		Send a message and pass data from userspace to
- *				the kernel.
- * KDBUS_CMD_RECV:		Receive a message from the kernel which is
- *				placed in the receiver's pool.
- *
- * KDBUS_CMD_NAME_ACQUIRE:	Request a well-known bus name to associate with
- *				the connection. Well-known names are used to
- *				address a peer on the bus.
- * KDBUS_CMD_NAME_RELEASE:	Release a well-known name the connection
- *				currently owns.
- * KDBUS_CMD_LIST:		Retrieve the list of all currently registered
- *				well-known and unique names.
- *
- * KDBUS_CMD_MATCH_ADD:		Install a match which broadcast messages should
- *				be delivered to the connection.
- * KDBUS_CMD_MATCH_REMOVE:	Remove a current match for broadcast messages.
- */
-enum kdbus_ioctl_type {
-	/* bus owner (00-0f) */
-	KDBUS_CMD_BUS_MAKE =		_IOW(KDBUS_IOCTL_MAGIC, 0x00,
-					     struct kdbus_cmd),
-
-	/* endpoint owner (10-1f) */
-	KDBUS_CMD_ENDPOINT_MAKE =	_IOW(KDBUS_IOCTL_MAGIC, 0x10,
-					     struct kdbus_cmd),
-	KDBUS_CMD_ENDPOINT_UPDATE =	_IOW(KDBUS_IOCTL_MAGIC, 0x11,
-					     struct kdbus_cmd),
-
-	/* connection owner (80-ff) */
-	KDBUS_CMD_HELLO =		_IOWR(KDBUS_IOCTL_MAGIC, 0x80,
-					      struct kdbus_cmd_hello),
-	KDBUS_CMD_UPDATE =		_IOW(KDBUS_IOCTL_MAGIC, 0x81,
-					     struct kdbus_cmd),
-	KDBUS_CMD_BYEBYE =		_IOW(KDBUS_IOCTL_MAGIC, 0x82,
-					     struct kdbus_cmd),
-	KDBUS_CMD_FREE =		_IOW(KDBUS_IOCTL_MAGIC, 0x83,
-					     struct kdbus_cmd_free),
-	KDBUS_CMD_CONN_INFO =		_IOR(KDBUS_IOCTL_MAGIC, 0x84,
-					     struct kdbus_cmd_info),
-	KDBUS_CMD_BUS_CREATOR_INFO =	_IOR(KDBUS_IOCTL_MAGIC, 0x85,
-					     struct kdbus_cmd_info),
-	KDBUS_CMD_LIST =		_IOR(KDBUS_IOCTL_MAGIC, 0x86,
-					     struct kdbus_cmd_list),
-
-	KDBUS_CMD_SEND =		_IOW(KDBUS_IOCTL_MAGIC, 0x90,
-					     struct kdbus_cmd_send),
-	KDBUS_CMD_RECV =		_IOR(KDBUS_IOCTL_MAGIC, 0x91,
-					     struct kdbus_cmd_recv),
-
-	KDBUS_CMD_NAME_ACQUIRE =	_IOW(KDBUS_IOCTL_MAGIC, 0xa0,
-					     struct kdbus_cmd),
-	KDBUS_CMD_NAME_RELEASE =	_IOW(KDBUS_IOCTL_MAGIC, 0xa1,
-					     struct kdbus_cmd),
-
-	KDBUS_CMD_MATCH_ADD =		_IOW(KDBUS_IOCTL_MAGIC, 0xb0,
-					     struct kdbus_cmd_match),
-	KDBUS_CMD_MATCH_REMOVE =	_IOW(KDBUS_IOCTL_MAGIC, 0xb1,
-					     struct kdbus_cmd_match),
-};
-
-#endif /* _UAPI_KDBUS_H_ */
diff --git a/unit/test-dbus-message-fds.c b/unit/test-dbus-message-fds.c
index c93f093..9039bb5 100644
--- a/unit/test-dbus-message-fds.c
+++ b/unit/test-dbus-message-fds.c
@@ -39,8 +39,6 @@
 
 static pid_t dbus_daemon_pid = -1;
 
-static int kdbus_fd = -1;
-
 static char bus_address[128];
 
 static bool start_dbus_daemon(void)
@@ -80,24 +78,6 @@ static bool start_dbus_daemon(void)
 	return true;
 }
 
-static bool create_kdbus(void)
-{
-	char bus_name[64];
-
-	snprintf(bus_name, sizeof(bus_name), "%u-ell-test", getuid());
-
-	kdbus_fd = _dbus_kernel_create_bus(bus_name);
-	if (kdbus_fd < 0) {
-		l_warn("kdbus not available");
-		return false;
-	}
-
-	snprintf(bus_address, sizeof(bus_address),
-				"kernel:path=/dev/kdbus/%s/bus", bus_name);
-
-	return true;
-}
-
 static void signal_handler(struct l_signal *signal, uint32_t signo,
 							void *user_data)
 {
@@ -364,17 +344,12 @@ int main(int argc, char *argv[])
 	if (!success)
 		goto done;
 
-	if (!create_kdbus())
-		goto done;
-
 	dbus = l_dbus_new(bus_address);
 
 	test_run();
 
 	l_dbus_destroy(dbus);
 
-	close(kdbus_fd);
-
 done:
 	l_signal_remove(signal);
 
diff --git a/unit/test-dbus-message.c b/unit/test-dbus-message.c
index 0c14a7b..d1ff1ef 100644
--- a/unit/test-dbus-message.c
+++ b/unit/test-dbus-message.c
@@ -2505,34 +2505,6 @@ static void check_complex_5(const void *data)
 	l_dbus_message_unref(msg);
 }
 
-static uint64_t bloom_1[] = {
-	0x8000001100001000, 0x0010304080000001, 0x0000800810000411,
-	0x0040002100000081, 0x0120004008030080, 0x8400020801000008,
-	0x0002000000008010, 0x0010000100000008,
-};
-
-static void check_bloom_1(const void *data)
-{
-	struct l_dbus_message *msg;
-	bool result;
-	uint64_t filter[8];
-	int i;
-
-	memset(filter, 0, sizeof(filter));
-
-	msg = _dbus_message_new_signal(2, "/test",
-					"org.test", "PropertyChanged");
-	result = l_dbus_message_set_arguments(msg, "");
-	assert(result);
-
-	_dbus_kernel_calculate_bloom(msg, filter, 64, 8);
-
-	for (i = 0; i < 8; i++)
-		assert(bloom_1[i] == filter[i]);
-
-	l_dbus_message_unref(msg);
-}
-
 static void builder_rewind(const void *data)
 {
 	struct l_dbus_message *msg = build_message(data);
@@ -2789,8 +2761,6 @@ int main(int argc, char *argv[])
 	l_test_add("Complex 4", check_complex_4, &message_data_complex_4);
 	l_test_add("Complex 5", check_complex_5, &message_data_complex_5);
 
-	l_test_add("Bloom 1", check_bloom_1, NULL);
-
 	l_test_add("Message Builder Complex 3", builder_complex_3,
 						&message_data_complex_3);
 
diff --git a/unit/test-dbus-properties.c b/unit/test-dbus-properties.c
index a184deb..0ba05fd 100644
--- a/unit/test-dbus-properties.c
+++ b/unit/test-dbus-properties.c
@@ -36,8 +36,6 @@
 
 static pid_t dbus_daemon_pid = -1;
 
-static int kdbus_fd = -1;
-
 static char bus_address[128];
 
 static bool start_dbus_daemon(void)
@@ -77,24 +75,6 @@ static bool start_dbus_daemon(void)
 	return true;
 }
 
-static bool create_kdbus(void)
-{
-	char bus_name[64];
-
-	snprintf(bus_name, sizeof(bus_name), "%u-ell-test", getuid());
-
-	kdbus_fd = _dbus_kernel_create_bus(bus_name);
-	if (kdbus_fd < 0) {
-		l_warn("kdbus not available");
-		return false;
-	}
-
-	snprintf(bus_address, sizeof(bus_address),
-				"kernel:path=/dev/kdbus/%s/bus", bus_name);
-
-	return true;
-}
-
 static void signal_handler(struct l_signal *signal, uint32_t signo,
 							void *user_data)
 {
@@ -1030,17 +1010,12 @@ int main(int argc, char *argv[])
 	if (!success)
 		goto done;
 
-	if (!create_kdbus())
-		goto done;
-
 	dbus = l_dbus_new(bus_address);
 
 	test_run();
 
 	l_dbus_destroy(dbus);
 
-	close(kdbus_fd);
-
 done:
 	l_signal_remove(signal);
 
diff --git a/unit/test-kdbus.c b/unit/test-kdbus.c
deleted file mode 100644
index ad4a754..0000000
--- a/unit/test-kdbus.c
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- *
- *  Embedded Linux library
- *
- *  Copyright (C) 2011-2014  Intel Corporation. All rights reserved.
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <assert.h>
-
-#include <ell/ell.h>
-#include "ell/dbus-private.h"
-
-static void do_debug(const char *str, void *user_data)
-{
-	const char *prefix = user_data;
-
-	l_info("%s%s", prefix, str);
-}
-
-static void signal_handler(struct l_signal *signal, uint32_t signo,
-							void *user_data)
-{
-	switch (signo) {
-	case SIGINT:
-	case SIGTERM:
-		l_info("Terminate");
-		l_main_quit();
-		break;
-	}
-}
-
-static void signal_message(struct l_dbus_message *message, void *user_data)
-{
-	const char *path, *interface, *member, *destination, *sender;
-
-	path = l_dbus_message_get_path(message);
-	destination = l_dbus_message_get_destination(message);
-
-	l_info("path=%s destination=%s", path, destination);
-
-	interface = l_dbus_message_get_interface(message);
-	member = l_dbus_message_get_member(message);
-
-	l_info("interface=%s member=%s", interface, member);
-
-	sender = l_dbus_message_get_sender(message);
-
-	l_info("sender=%s", sender);
-}
-
-static struct l_dbus_message *test_method_call(struct l_dbus *dbus,
-						struct l_dbus_message *message,
-						void *user_data)
-{
-	struct l_dbus_message *reply;
-
-	l_info("Method Call");
-
-	reply = l_dbus_message_new_method_return(message);
-	l_dbus_message_set_arguments(reply, "");
-
-	return reply;
-}
-
-static void client_ready_callback(void *user_data)
-{
-	struct l_dbus *dbus = user_data;
-
-	l_info("client ready");
-
-	l_dbus_method_call(dbus, "org.test",
-				"/test",
-				"org.test", "TestMethod",
-				NULL,
-				NULL, NULL, NULL);
-}
-
-static void service_name_acquire_callback(struct l_dbus *dbus, bool success,
-						bool queued, void *user_data)
-{
-	if (!success)
-		l_info("Failed to acquire name");
-}
-
-static void service_ready_callback(void *user_data)
-{
-	struct l_dbus *dbus = user_data;
-	struct l_dbus_message *message;
-
-	l_dbus_name_acquire(dbus, "org.test", false, false, false,
-				service_name_acquire_callback, NULL);
-
-	l_info("service ready");
-
-	message = l_dbus_message_new_signal(dbus, "/test",
-					"org.test", "TestSignal");
-	l_dbus_message_set_arguments(message, "");
-	l_dbus_send(dbus, message);
-}
-
-static void setup_test_interface(struct l_dbus_interface *interface)
-{
-	l_dbus_interface_method(interface, "TestMethod", 0,
-				test_method_call, "", "");
-}
-
-int main(int argc, char *argv[])
-{
-	struct l_dbus *service;
-	struct l_dbus *client;
-	char bus_name[16];
-	char bus_address[64];
-	int bus_fd;
-	struct l_signal *signal;
-	sigset_t mask;
-
-	if (!l_main_init())
-		return -1;
-
-	sigemptyset(&mask);
-	sigaddset(&mask, SIGINT);
-	sigaddset(&mask, SIGTERM);
-
-	signal = l_signal_create(&mask, signal_handler, NULL, NULL);
-
-	l_log_set_stderr();
-
-	snprintf(bus_name, sizeof(bus_name), "%u-ell-test", getuid());
-
-	bus_fd = _dbus_kernel_create_bus(bus_name);
-	if (bus_fd < 0) {
-		l_warn("kdbus not available");
-		return EXIT_SUCCESS;
-	}
-
-	snprintf(bus_address, sizeof(bus_address),
-				"kernel:path=/dev/kdbus/%s/bus", bus_name);
-
-	service = l_dbus_new(bus_address);
-	assert(service);
-
-	l_dbus_set_debug(service, do_debug, "[SERVICE] ", NULL);
-	l_dbus_set_ready_handler(service, service_ready_callback,
-					service, NULL);
-
-	if (!l_dbus_register_interface(service, "org.test",
-					setup_test_interface, NULL, false)) {
-		l_info("Unable to register interface");
-		goto error;
-	}
-
-	if (!l_dbus_object_add_interface(service, "/test", "org.test", NULL)) {
-		l_info("Unable to instantiate interface");
-		goto error;
-	}
-
-	client = l_dbus_new(bus_address);
-	assert(client);
-
-	l_dbus_set_debug(client, do_debug, "[CLIENT] ", NULL);
-	l_dbus_set_ready_handler(client, client_ready_callback, client, NULL);
-	l_dbus_add_signal_watch(client, "org.test", NULL, NULL, NULL,
-				L_DBUS_MATCH_NONE, signal_message, NULL);
-
-	l_main_run();
-
-	l_dbus_destroy(client);
-error:
-	l_dbus_destroy(service);
-
-	close(bus_fd);
-
-	l_signal_remove(signal);
-
-	l_main_exit();
-
-	return EXIT_SUCCESS;
-}
