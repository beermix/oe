# DP: Fix PR go/79037, proposed golang patch.

--- a/gcc/go/gofrontend/types.cc.orig	2016-02-03 07:54:41.000000000 +0100
+++ b/gcc/go/gofrontend/types.cc	2017-01-20 17:54:46.460409688 +0100
@@ -2175,11 +2175,25 @@
       is_common = true;
     }
 
+  // The current garbage collector requires that the GC symbol be
+  // aligned to at least a four byte boundary.  See the use of PRECISE
+  // and LOOP in libgo/runtime/mgc0.c.
+  int64_t align;
+  if (!sym_init->type()->backend_type_align(gogo, &align))
+    go_assert(saw_errors());
+  if (align < 4)
+    align = 4;
+  else
+    {
+      // Use default alignment.
+      align = 0;
+    }
+
   // Since we are building the GC symbol in this package, we must create the
   // variable before converting the initializer to its backend representation
   // because the initializer may refer to the GC symbol for this type.
   this->gc_symbol_var_ =
-    gogo->backend()->implicit_variable(sym_name, sym_btype, false, true, is_common, 0);
+    gogo->backend()->implicit_variable(sym_name, sym_btype, false, true, is_common, align);
   if (phash != NULL)
     *phash = this->gc_symbol_var_;
 
--- a/libgo/runtime/go-unsafe-pointer.c.orig	2015-10-29 19:14:50.000000000 +0100
+++ b/libgo/runtime/go-unsafe-pointer.c	2017-01-20 17:57:12.227392567 +0100
@@ -36,7 +36,8 @@
   sizeof REFLECTION - 1
 };
 
-const uintptr unsafe_Pointer_gc[] = {sizeof(void*), GC_APTR, 0, GC_END};
+const uintptr unsafe_Pointer_gc[] __attribute__((aligned(4))) =
+  {sizeof(void*), GC_APTR, 0, GC_END};
 
 const struct __go_type_descriptor unsafe_Pointer =
 {
--- a/libgo/runtime/parfor.c.orig	2015-10-31 01:59:47.000000000 +0100
+++ b/libgo/runtime/parfor.c	2017-01-20 17:58:47.154729980 +0100
@@ -10,7 +10,7 @@
 struct ParForThread
 {
 	// the thread's iteration space [32lsb, 32msb)
-	uint64 pos;
+	uint64 pos __attribute__((aligned(8)));
 	// stats
 	uint64 nsteal;
 	uint64 nstealcnt;
--- a/libgo/runtime/runtime.h.orig	2016-02-12 23:10:09.000000000 +0100
+++ b/libgo/runtime/runtime.h	2017-01-21 00:58:07.386595035 +0100
@@ -431,7 +431,7 @@
 					// otherwise parfor may return while other threads are still working
 	ParForThread *thr;		// array of thread descriptors
 	// stats
-	uint64 nsteal;
+	uint64 nsteal  __attribute__((aligned(8))); // force alignment for m68k
 	uint64 nstealcnt;
 	uint64 nprocyield;
 	uint64 nosyield;
