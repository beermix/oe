From 7887dfdadcd47922bd21569d5e1753192baa2828 Mon Sep 17 00:00:00 2001
From: Con Kolivas <kernel@kolivas.org>
Date: Mon, 20 Feb 2017 13:32:58 +1100
Subject: [PATCH 11/24] Don't use hrtimer overlay when pm_freezing since some
 drivers still don't correctly use freezable timeouts.

---
 kernel/time/hrtimer.c |    2 +-
 kernel/time/timer.c   |    9 +++++----
 2 files changed, 6 insertions(+), 5 deletions(-)

Index: linux-4.11-ck2/kernel/time/hrtimer.c
===================================================================
--- linux-4.11-ck2.orig/kernel/time/hrtimer.c	2017-05-26 19:04:58.664235233 +1000
+++ linux-4.11-ck2/kernel/time/hrtimer.c	2017-05-26 19:04:58.664235233 +1000
@@ -1792,7 +1792,7 @@ long __sched schedule_msec_hrtimeout(lon
 	 * (yet) better than Hz, as would occur during startup, use regular
 	 * timers.
 	 */
-	if (jiffs > 4 || hrtimer_resolution >= NSEC_PER_SEC / HZ)
+	if (jiffs > 4 || hrtimer_resolution >= NSEC_PER_SEC / HZ || pm_freezing)
 		return schedule_timeout(jiffs);
 
 	delta = (timeout % 1000) * NSEC_PER_MSEC;
Index: linux-4.11-ck2/kernel/time/timer.c
===================================================================
--- linux-4.11-ck2.orig/kernel/time/timer.c	2017-05-26 19:04:58.664235233 +1000
+++ linux-4.11-ck2/kernel/time/timer.c	2017-05-26 19:04:58.664235233 +1000
@@ -44,6 +44,7 @@
 #include <linux/sched/debug.h>
 #include <linux/slab.h>
 #include <linux/compat.h>
+#include <linux/freezer.h>
 
 #include <linux/uaccess.h>
 #include <asm/unistd.h>
@@ -1859,12 +1860,12 @@ void msleep(unsigned int msecs)
 	 * Use high resolution timers where the resolution of tick based
 	 * timers is inadequate.
 	 */
-	if (jiffs < 5 && hrtimer_resolution < NSEC_PER_SEC / HZ) {
+	if (jiffs < 5 && hrtimer_resolution < NSEC_PER_SEC / HZ && !pm_freezing) {
 		while (msecs)
 			msecs = schedule_msec_hrtimeout_uninterruptible(msecs);
 		return;
 	}
-	timeout = msecs_to_jiffies(msecs) + 1;
+	timeout = jiffs + 1;
 
 	while (timeout)
 		timeout = schedule_timeout_uninterruptible(timeout);
@@ -1881,12 +1882,12 @@ unsigned long msleep_interruptible(unsig
 	int jiffs = msecs_to_jiffies(msecs);
 	unsigned long timeout;
 
-	if (jiffs < 5 && hrtimer_resolution < NSEC_PER_SEC / HZ) {
+	if (jiffs < 5 && hrtimer_resolution < NSEC_PER_SEC / HZ && !pm_freezing) {
 		while (msecs && !signal_pending(current))
 			msecs = schedule_msec_hrtimeout_interruptible(msecs);
 		return msecs;
 	}
-	timeout = msecs_to_jiffies(msecs) + 1;
+	timeout = jiffs + 1;
 
 	while (timeout && !signal_pending(current))
 		timeout = schedule_timeout_interruptible(timeout);
