From e5e1d3f320f8f3f7c25aec79d3121927514757e1 Mon Sep 17 00:00:00 2001
From: Icarus Sparry <icarus.w.sparry@intel.com>
Date: Sun, 25 Feb 2018 14:10:28 -0800
Subject: [PATCH 1/2] driver

---
 kernel/trace/sysdig/CMakeLists.txt         |   80 +
 kernel/trace/sysdig/Makefile               |    2 +
 kernel/trace/sysdig/Makefile.in            |   15 +
 kernel/trace/sysdig/dkms.conf.in           |    5 +
 kernel/trace/sysdig/driver_config.h        |    7 +
 kernel/trace/sysdig/driver_config.h.in     |    7 +
 kernel/trace/sysdig/dynamic_params_table.c |   29 +
 kernel/trace/sysdig/event_table.c          |  321 ++
 kernel/trace/sysdig/flags_table.c          |  436 +++
 kernel/trace/sysdig/main.c                 | 2535 +++++++++++++
 kernel/trace/sysdig/ppm.h                  |  142 +
 kernel/trace/sysdig/ppm_compat_unistd_32.h |  401 ++
 kernel/trace/sysdig/ppm_cputime.c          |  347 ++
 kernel/trace/sysdig/ppm_events.c           | 1508 ++++++++
 kernel/trace/sysdig/ppm_events.h           |  167 +
 kernel/trace/sysdig/ppm_events_public.h    | 1396 +++++++
 kernel/trace/sysdig/ppm_fillers.c          | 5648 ++++++++++++++++++++++++++++
 kernel/trace/sysdig/ppm_ringbuffer.h       |   42 +
 kernel/trace/sysdig/ppm_syscall.h          |  229 ++
 kernel/trace/sysdig/syscall_table.c        | 1623 ++++++++
 20 files changed, 14940 insertions(+)
 create mode 100644 kernel/trace/sysdig/CMakeLists.txt
 create mode 100644 kernel/trace/sysdig/Makefile
 create mode 100644 kernel/trace/sysdig/Makefile.in
 create mode 100644 kernel/trace/sysdig/dkms.conf.in
 create mode 100644 kernel/trace/sysdig/driver_config.h
 create mode 100644 kernel/trace/sysdig/driver_config.h.in
 create mode 100644 kernel/trace/sysdig/dynamic_params_table.c
 create mode 100644 kernel/trace/sysdig/event_table.c
 create mode 100644 kernel/trace/sysdig/flags_table.c
 create mode 100644 kernel/trace/sysdig/main.c
 create mode 100644 kernel/trace/sysdig/ppm.h
 create mode 100644 kernel/trace/sysdig/ppm_compat_unistd_32.h
 create mode 100644 kernel/trace/sysdig/ppm_cputime.c
 create mode 100644 kernel/trace/sysdig/ppm_events.c
 create mode 100644 kernel/trace/sysdig/ppm_events.h
 create mode 100644 kernel/trace/sysdig/ppm_events_public.h
 create mode 100644 kernel/trace/sysdig/ppm_fillers.c
 create mode 100644 kernel/trace/sysdig/ppm_ringbuffer.h
 create mode 100644 kernel/trace/sysdig/ppm_syscall.h
 create mode 100644 kernel/trace/sysdig/syscall_table.c

diff --git a/kernel/trace/sysdig/CMakeLists.txt b/kernel/trace/sysdig/CMakeLists.txt
new file mode 100644
index 0000000..7050121
--- /dev/null
+++ b/kernel/trace/sysdig/CMakeLists.txt
@@ -0,0 +1,80 @@
+option(BUILD_DRIVER "Build the driver on Linux" ON)
+option(ENABLE_DKMS "Enable DKMS on Linux" ON)
+
+configure_file(dkms.conf.in dkms.conf)
+configure_file(Makefile.in Makefile.dkms)
+configure_file(driver_config.h.in driver_config.h)
+configure_file(driver_config.h.in "${CMAKE_CURRENT_SOURCE_DIR}/driver_config.h")
+
+set(CLEAN_FILES
+	"${CMAKE_CURRENT_SOURCE_DIR}/Makefile"
+	"${CMAKE_CURRENT_SOURCE_DIR}/driver_config.h")
+
+set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES "${CLEAN_FILES}")
+
+add_custom_target(configure_driver ALL
+	COMMAND "${CMAKE_COMMAND}" -E copy_if_different ${CMAKE_CURRENT_BINARY_DIR}/driver_config.h driver_config.h
+	WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
+	VERBATIM)
+
+# make can be self-referenced as $(MAKE) only from Makefiles but this
+# triggers syntax errors with other generators such as Ninja
+if(${CMAKE_GENERATOR} STREQUAL "Unix Makefiles")
+	set(MAKE_COMMAND "$(MAKE)")
+else()
+	set(MAKE_COMMAND "make")
+endif()
+
+# This if/else is needed because you currently cannot manipulate dependencies
+# of built-in targets like "all" in CMake:
+# http://public.kitware.com/Bug/view.php?id=8438
+if(BUILD_DRIVER)
+	add_custom_target(driver ALL
+		COMMAND "${CMAKE_COMMAND}" -E copy_if_different ${CMAKE_CURRENT_BINARY_DIR}/Makefile.dkms Makefile
+		COMMAND ${MAKE_COMMAND}
+		COMMAND "${CMAKE_COMMAND}" -E copy_if_different ${PROBE_NAME}.ko "${CMAKE_CURRENT_BINARY_DIR}"
+		DEPENDS configure_driver
+		WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
+		VERBATIM)
+else()
+	add_custom_target(driver
+		COMMAND "${CMAKE_COMMAND}" -E copy_if_different ${CMAKE_CURRENT_BINARY_DIR}/Makefile.dkms Makefile
+		COMMAND ${MAKE_COMMAND}
+		COMMAND "${CMAKE_COMMAND}" -E copy_if_different ${PROBE_NAME}.ko "${CMAKE_CURRENT_BINARY_DIR}"
+		DEPENDS configure_driver
+		WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
+		VERBATIM)
+endif()
+
+add_custom_target(install_driver
+	COMMAND ${MAKE_COMMAND} install
+	DEPENDS driver
+	WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
+	VERBATIM)
+
+if(ENABLE_DKMS)
+	install(FILES ${CMAKE_CURRENT_BINARY_DIR}/Makefile.dkms
+		RENAME Makefile
+		DESTINATION "src/${PACKAGE_NAME}-${PROBE_VERSION}"
+		COMPONENT agent)
+
+	install(FILES
+		${CMAKE_CURRENT_BINARY_DIR}/dkms.conf
+		dynamic_params_table.c
+		driver_config.h
+		event_table.c
+		flags_table.c
+		main.c
+		ppm.h
+		ppm_events.c
+		ppm_events.h
+		ppm_events_public.h
+		ppm_fillers.c
+		ppm_ringbuffer.h
+		ppm_syscall.h
+		syscall_table.c
+		ppm_cputime.c
+		ppm_compat_unistd_32.h
+		DESTINATION "src/${PACKAGE_NAME}-${PROBE_VERSION}"
+		COMPONENT agent)
+endif()
diff --git a/kernel/trace/sysdig/Makefile b/kernel/trace/sysdig/Makefile
new file mode 100644
index 0000000..3abebb1
--- /dev/null
+++ b/kernel/trace/sysdig/Makefile
@@ -0,0 +1,2 @@
+sysdig-probe-y += main.o dynamic_params_table.o flags_table.o ppm_events.o ppm_fillers.o event_table.o syscall_table.o ppm_cputime.o
+obj-m += sysdig-probe.o
diff --git a/kernel/trace/sysdig/Makefile.in b/kernel/trace/sysdig/Makefile.in
new file mode 100644
index 0000000..bb0ecba
--- /dev/null
+++ b/kernel/trace/sysdig/Makefile.in
@@ -0,0 +1,15 @@
+@PROBE_NAME@-y += main.o dynamic_params_table.o flags_table.o ppm_events.o ppm_fillers.o event_table.o syscall_table.o ppm_cputime.o
+obj-m += @PROBE_NAME@.o
+ccflags-y := @KBUILD_FLAGS@
+
+KERNELDIR 		?= /lib/modules/$(shell uname -r)/build
+
+TOP := $(shell pwd)
+all:
+	$(MAKE) -C $(KERNELDIR) M=$(TOP) modules
+
+clean:
+	$(MAKE) -C $(KERNELDIR) M=$(TOP) clean
+
+install: all
+	$(MAKE) -C $(KERNELDIR) M=$(TOP) modules_install
diff --git a/kernel/trace/sysdig/dkms.conf.in b/kernel/trace/sysdig/dkms.conf.in
new file mode 100644
index 0000000..afa8ee7
--- /dev/null
+++ b/kernel/trace/sysdig/dkms.conf.in
@@ -0,0 +1,5 @@
+PACKAGE_NAME="@PACKAGE_NAME@"
+PACKAGE_VERSION="@PROBE_VERSION@"
+BUILT_MODULE_NAME[0]="@PROBE_NAME@"
+DEST_MODULE_LOCATION[0]="/kernel/extra"
+AUTOINSTALL="yes"
diff --git a/kernel/trace/sysdig/driver_config.h b/kernel/trace/sysdig/driver_config.h
new file mode 100644
index 0000000..accb5b9
--- /dev/null
+++ b/kernel/trace/sysdig/driver_config.h
@@ -0,0 +1,7 @@
+#pragma once
+
+#define PROBE_VERSION "0.1.1dev"
+
+#define PROBE_NAME "sysdig-probe"
+
+#define PROBE_DEVICE_NAME "sysdig"
diff --git a/kernel/trace/sysdig/driver_config.h.in b/kernel/trace/sysdig/driver_config.h.in
new file mode 100644
index 0000000..92ed113
--- /dev/null
+++ b/kernel/trace/sysdig/driver_config.h.in
@@ -0,0 +1,7 @@
+#pragma once
+
+#define PROBE_VERSION "${PROBE_VERSION}"
+
+#define PROBE_NAME "${PROBE_NAME}"
+
+#define PROBE_DEVICE_NAME "${PROBE_DEVICE_NAME}"
diff --git a/kernel/trace/sysdig/dynamic_params_table.c b/kernel/trace/sysdig/dynamic_params_table.c
new file mode 100644
index 0000000..1d8b599
--- /dev/null
+++ b/kernel/trace/sysdig/dynamic_params_table.c
@@ -0,0 +1,29 @@
+/*
+Copyright (C) 2013-2014 Draios inc.
+
+This file is part of sysdig.
+
+sysdig is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License version 2 as
+published by the Free Software Foundation.
+
+sysdig is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with sysdig.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "ppm_events_public.h"
+
+const struct ppm_param_info ptrace_dynamic_param[PPM_PTRACE_IDX_MAX] = {
+	[PPM_PTRACE_IDX_UINT64] = {{0}, PT_UINT64, PF_HEX},
+	[PPM_PTRACE_IDX_SIGTYPE] = {{0}, PT_SIGTYPE, PF_DEC},
+};
+
+const struct ppm_param_info bpf_dynamic_param[PPM_BPF_IDX_MAX] = {
+	[PPM_BPF_IDX_FD] = {{0}, PT_FD, PF_DEC},
+	[PPM_BPF_IDX_RES] = {{0}, PT_ERRNO, PF_DEC},
+};
diff --git a/kernel/trace/sysdig/event_table.c b/kernel/trace/sysdig/event_table.c
new file mode 100644
index 0000000..c963d41
--- /dev/null
+++ b/kernel/trace/sysdig/event_table.c
@@ -0,0 +1,321 @@
+/*
+Copyright (C) 2013-2014 Draios inc.
+
+This file is part of sysdig.
+
+sysdig is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License version 2 as
+published by the Free Software Foundation.
+
+sysdig is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with sysdig.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "ppm_events_public.h"
+#include "ppm.h"
+
+const struct ppm_event_info g_event_info[PPM_EVENT_MAX] = {
+	/* PPME_GENERIC_E */{"syscall", EC_OTHER, EF_NONE, 2, {{"ID", PT_SYSCALLID, PF_DEC}, {"nativeID", PT_UINT16, PF_DEC} } },
+	/* PPME_GENERIC_X */{"syscall", EC_OTHER, EF_NONE, 1, {{"ID", PT_SYSCALLID, PF_DEC} } },
+	/* PPME_SYSCALL_OPEN_E */{"open", EC_FILE, EF_CREATES_FD | EF_MODIFIES_STATE, 0},
+	/* PPME_SYSCALL_OPEN_X */{"open", EC_FILE, EF_CREATES_FD | EF_MODIFIES_STATE, 4, {{"fd", PT_FD, PF_DEC}, {"name", PT_FSPATH, PF_NA}, {"flags", PT_FLAGS32, PF_HEX, file_flags}, {"mode", PT_UINT32, PF_OCT} } },
+	/* PPME_SYSCALL_CLOSE_E */{"close", EC_IO_OTHER, EF_DESTROYS_FD | EF_USES_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 1, {{"fd", PT_FD, PF_DEC} } },
+	/* PPME_SYSCALL_CLOSE_X */{"close", EC_IO_OTHER, EF_DESTROYS_FD | EF_USES_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_READ_E */{"read", EC_IO_READ, EF_USES_FD | EF_READS_FROM_FD | EF_DROP_FALCO, 2, {{"fd", PT_FD, PF_DEC}, {"size", PT_UINT32, PF_DEC} } },
+	/* PPME_SYSCALL_READ_X */{"read", EC_IO_READ, EF_USES_FD | EF_READS_FROM_FD | EF_DROP_FALCO, 2, {{"res", PT_ERRNO, PF_DEC}, {"data", PT_BYTEBUF, PF_NA} } },
+	/* PPME_SYSCALL_WRITE_E */{"write", EC_IO_WRITE, EF_USES_FD | EF_WRITES_TO_FD | EF_DROP_FALCO, 2, {{"fd", PT_FD, PF_DEC}, {"size", PT_UINT32, PF_DEC} } },
+	/* PPME_SYSCALL_WRITE_X */{"write", EC_IO_WRITE, EF_USES_FD | EF_WRITES_TO_FD | EF_DROP_FALCO, 2, {{"res", PT_ERRNO, PF_DEC}, {"data", PT_BYTEBUF, PF_NA} } },
+	/* PPME_SYSCALL_BRK_1_E */{"brk", EC_MEMORY, EF_OLD_VERSION, 1, {{"size", PT_UINT32, PF_DEC} } },
+	/* PPME_SYSCALL_BRK_1_X */{"brk", EC_MEMORY, EF_OLD_VERSION, 1, {{"res", PT_UINT64, PF_HEX} } },
+	/* PPME_SYSCALL_EXECVE_8_E */{"execve", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 0},
+	/* PPME_SYSCALL_EXECVE_8_X */{"execve", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 8, {{"res", PT_ERRNO, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_UINT64, PF_DEC} } },
+	/* PPME_CLONE_11_E */{"clone", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 0},
+	/* PPME_CLONE_11_X */{"clone", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 11, {{"res", PT_PID, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_INT64, PF_DEC}, {"flags", PT_FLAGS32, PF_HEX, clone_flags}, {"uid", PT_UINT32, PF_DEC}, {"gid", PT_UINT32, PF_DEC} } },
+	/* PPME_PROCEXIT_E */{"procexit", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 0},
+	/* PPME_NA1 */{"NA1", EC_PROCESS, EF_UNUSED, 0},
+	/* PPME_SOCKET_SOCKET_E */{"socket", EC_NET, EF_CREATES_FD | EF_MODIFIES_STATE, 3, {{"domain", PT_FLAGS32, PF_DEC, socket_families}, {"type", PT_UINT32, PF_DEC}, {"proto", PT_UINT32, PF_DEC} } },
+	/* PPME_SOCKET_SOCKET_X */{"socket", EC_NET, EF_CREATES_FD | EF_MODIFIES_STATE, 1, {{"fd", PT_FD, PF_DEC} } },
+	/* PPME_SOCKET_BIND_E */{"bind", EC_NET, EF_USES_FD | EF_MODIFIES_STATE, 1, {{"fd", PT_FD, PF_DEC} } },
+	/* PPME_SOCKET_BIND_X */{"bind", EC_NET, EF_USES_FD | EF_MODIFIES_STATE, 2, {{"res", PT_ERRNO, PF_DEC}, {"addr", PT_SOCKADDR, PF_NA} } },
+	/* PPME_SOCKET_CONNECT_E */{"connect", EC_NET, EF_USES_FD | EF_MODIFIES_STATE, 1, {{"fd", PT_FD, PF_DEC} } },
+	/* PPME_SOCKET_CONNECT_X */{"connect", EC_NET, EF_USES_FD | EF_MODIFIES_STATE, 2, {{"res", PT_ERRNO, PF_DEC}, {"tuple", PT_SOCKTUPLE, PF_NA} } },
+	/* PPME_SOCKET_LISTEN_E */{"listen", EC_NET, EF_USES_FD, 2, {{"fd", PT_FD, PF_DEC}, {"backlog", PT_UINT32, PF_DEC} } },
+	/* PPME_SOCKET_LISTEN_X */{"listen", EC_NET, EF_USES_FD, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SOCKET_ACCEPT_E */{"accept", EC_NET, EF_CREATES_FD | EF_MODIFIES_STATE | EF_OLD_VERSION, 0},
+	/* PPME_SOCKET_ACCEPT_X */{"accept", EC_NET, EF_CREATES_FD | EF_MODIFIES_STATE | EF_OLD_VERSION, 3, {{"fd", PT_FD, PF_DEC}, {"tuple", PT_SOCKTUPLE, PF_NA}, {"queuepct", PT_UINT8, PF_DEC} } },
+	/* PPME_SYSCALL_SEND_E */{"send", EC_IO_WRITE, EF_USES_FD | EF_WRITES_TO_FD | EF_DROP_FALCO, 2, {{"fd", PT_FD, PF_DEC}, {"size", PT_UINT32, PF_DEC} } },
+	/* PPME_SYSCALL_SEND_X */{"send", EC_IO_WRITE, EF_USES_FD | EF_WRITES_TO_FD | EF_DROP_FALCO, 2, {{"res", PT_ERRNO, PF_DEC}, {"data", PT_BYTEBUF, PF_NA} } },
+	/* PPME_SOCKET_SENDTO_E */{"sendto", EC_IO_WRITE, EF_USES_FD | EF_WRITES_TO_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 3, {{"fd", PT_FD, PF_DEC}, {"size", PT_UINT32, PF_DEC}, {"tuple", PT_SOCKTUPLE, PF_NA} } },
+	/* PPME_SOCKET_SENDTO_X */{"sendto", EC_IO_WRITE, EF_USES_FD | EF_WRITES_TO_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 2, {{"res", PT_ERRNO, PF_DEC}, {"data", PT_BYTEBUF, PF_NA} } },
+	/* PPME_SOCKET_RECV_E */{"recv", EC_IO_READ, EF_USES_FD | EF_READS_FROM_FD | EF_DROP_FALCO, 2, {{"fd", PT_FD, PF_DEC}, {"size", PT_UINT32, PF_DEC} } },
+	/* PPME_SOCKET_RECV_X */{"recv", EC_IO_READ, EF_USES_FD | EF_READS_FROM_FD | EF_DROP_FALCO, 2, {{"res", PT_ERRNO, PF_DEC}, {"data", PT_BYTEBUF, PF_NA} } },
+	/* PPME_SOCKET_RECVFROM_E */{"recvfrom", EC_IO_READ, EF_USES_FD | EF_READS_FROM_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 2, {{"fd", PT_FD, PF_DEC}, {"size", PT_UINT32, PF_DEC} } },
+	/* PPME_SOCKET_RECVFROM_X */{"recvfrom", EC_IO_READ, EF_USES_FD | EF_READS_FROM_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 3, {{"res", PT_ERRNO, PF_DEC}, {"data", PT_BYTEBUF, PF_NA}, {"tuple", PT_SOCKTUPLE, PF_NA} } },
+	/* PPME_SOCKET_SHUTDOWN_E */{"shutdown", EC_NET, EF_USES_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 2, {{"fd", PT_FD, PF_DEC}, {"how", PT_FLAGS8, PF_HEX, shutdown_how} } },
+	/* PPME_SOCKET_SHUTDOWN_X */{"shutdown", EC_NET, EF_USES_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SOCKET_GETSOCKNAME_E */{"getsockname", EC_NET, EF_NONE, 0},
+	/* PPME_SOCKET_GETSOCKNAME_X */{"getsockname", EC_NET, EF_NONE, 0},
+	/* PPME_SOCKET_GETPEERNAME_E */{"getpeername", EC_NET, EF_NONE, 0},
+	/* PPME_SOCKET_GETPEERNAME_X */{"getpeername", EC_NET, EF_NONE, 0},
+	/* PPME_SOCKET_SOCKETPAIR_E */{"socketpair", EC_IPC, EF_CREATES_FD | EF_MODIFIES_STATE, 3, {{"domain", PT_FLAGS32, PF_DEC, socket_families}, {"type", PT_UINT32, PF_DEC}, {"proto", PT_UINT32, PF_DEC} } },
+	/* PPME_SOCKET_SOECKETPAIR_X */{"socketpair", EC_IPC, EF_CREATES_FD | EF_MODIFIES_STATE, 5, {{"res", PT_ERRNO, PF_DEC}, {"fd1", PT_FD, PF_DEC}, {"fd2", PT_FD, PF_DEC}, {"source", PT_UINT64, PF_HEX}, {"peer", PT_UINT64, PF_HEX} } },
+	/* PPME_SOCKET_SETSOCKOPT_E */{"setsockopt", EC_NET, EF_NONE, 0},
+	/* PPME_SOCKET_SETSOCKOPT_X */{"setsockopt", EC_NET, EF_NONE, 0},
+	/* PPME_SOCKET_GETSOCKOPT_E */{"getsockopt", EC_NET, EF_NONE, 0},
+	/* PPME_SOCKET_GETSOCKOPT_X */{"getsockopt", EC_NET, EF_NONE, 0},
+	/* PPME_SOCKET_SENDMSG_E */{"sendmsg", EC_IO_WRITE, EF_USES_FD | EF_WRITES_TO_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 3, {{"fd", PT_FD, PF_DEC}, {"size", PT_UINT32, PF_DEC}, {"tuple", PT_SOCKTUPLE, PF_NA} } },
+	/* PPME_SOCKET_SENDMSG_X */{"sendmsg", EC_IO_WRITE, EF_USES_FD | EF_WRITES_TO_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 2, {{"res", PT_ERRNO, PF_DEC}, {"data", PT_BYTEBUF, PF_NA} } },
+	/* PPME_SOCKET_SENDMMSG_E */{"sendmmsg", EC_IO_WRITE, EF_DROP_FALCO, 0},
+	/* PPME_SOCKET_SENDMMSG_X */{"sendmmsg", EC_IO_WRITE, EF_DROP_FALCO, 0},
+	/* PPME_SOCKET_RECVMSG_E */{"recvmsg", EC_IO_READ, EF_USES_FD | EF_READS_FROM_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 1, {{"fd", PT_FD, PF_DEC} } },
+	/* PPME_SOCKET_RECVMSG_X */{"recvmsg", EC_IO_READ, EF_USES_FD | EF_READS_FROM_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 4, {{"res", PT_ERRNO, PF_DEC}, {"size", PT_UINT32, PF_DEC}, {"data", PT_BYTEBUF, PF_NA}, {"tuple", PT_SOCKTUPLE, PF_NA} } },
+	/* PPME_SOCKET_RECVMMSG_E */{"recvmmsg", EC_IO_READ, EF_DROP_FALCO, 0},
+	/* PPME_SOCKET_RECVMMSG_X */{"recvmmsg", EC_IO_READ, EF_DROP_FALCO, 0},
+	/* PPME_SOCKET_ACCEPT4_E */{"accept", EC_NET, EF_CREATES_FD | EF_MODIFIES_STATE | EF_OLD_VERSION, 1, {{"flags", PT_INT32, PF_HEX} } },
+	/* PPME_SOCKET_ACCEPT4_X */{"accept", EC_NET, EF_CREATES_FD | EF_MODIFIES_STATE | EF_OLD_VERSION, 3, {{"fd", PT_FD, PF_DEC}, {"tuple", PT_SOCKTUPLE, PF_NA}, {"queuepct", PT_UINT8, PF_DEC} } },
+	/* PPME_SYSCALL_CREAT_E */{"creat", EC_FILE, EF_CREATES_FD | EF_MODIFIES_STATE, 0},
+	/* PPME_SYSCALL_CREAT_X */{"creat", EC_FILE, EF_CREATES_FD | EF_MODIFIES_STATE, 3, {{"fd", PT_FD, PF_DEC}, {"name", PT_FSPATH, PF_NA}, {"mode", PT_UINT32, PF_HEX} } },
+	/* PPME_SOCKET_PIPE_E */{"pipe", EC_IPC, EF_CREATES_FD | EF_MODIFIES_STATE, 0},
+	/* PPME_SOCKET_PIPE_X */{"pipe", EC_IPC, EF_CREATES_FD | EF_MODIFIES_STATE, 4, {{"res", PT_ERRNO, PF_DEC}, {"fd1", PT_FD, PF_DEC}, {"fd2", PT_FD, PF_DEC}, {"ino", PT_UINT64, PF_DEC} } },
+	/* PPME_SYSCALL_EVENTFD_E */{"eventfd", EC_IPC, EF_CREATES_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 2, {{"initval", PT_UINT64, PF_DEC}, {"flags", PT_FLAGS32, PF_HEX} } },
+	/* PPME_SYSCALL_EVENTFD_X */{"eventfd", EC_IPC, EF_CREATES_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 1, {{"res", PT_FD, PF_DEC} } },
+	/* PPME_SYSCALL_FUTEX_E */{"futex", EC_IPC, EF_DROP_FALCO, 3, {{"addr", PT_UINT64, PF_HEX}, {"op", PT_FLAGS16, PF_HEX, futex_operations}, {"val", PT_UINT64, PF_DEC} } },
+	/* PPME_SYSCALL_FUTEX_X */{"futex", EC_IPC, EF_DROP_FALCO, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_STAT_E */{"stat", EC_FILE, EF_DROP_FALCO, 0},
+	/* PPME_SYSCALL_STAT_X */{"stat", EC_FILE, EF_DROP_FALCO, 2, {{"res", PT_ERRNO, PF_DEC}, {"path", PT_FSPATH, PF_NA} } },
+	/* PPME_SYSCALL_LSTAT_E */{"lstat", EC_FILE, EF_DROP_FALCO, 0},
+	/* PPME_SYSCALL_LSTAT_X */{"lstat", EC_FILE, EF_DROP_FALCO, 2, {{"res", PT_ERRNO, PF_DEC}, {"path", PT_FSPATH, PF_NA} } },
+	/* PPME_SYSCALL_FSTAT_E */{"fstat", EC_FILE, EF_USES_FD | EF_DROP_FALCO, 1, {{"fd", PT_FD, PF_NA} } },
+	/* PPME_SYSCALL_FSTAT_X */{"fstat", EC_FILE, EF_USES_FD | EF_DROP_FALCO, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_STAT64_E */{"stat64", EC_FILE, EF_DROP_FALCO, 0},
+	/* PPME_SYSCALL_STAT64_X */{"stat64", EC_FILE, EF_DROP_FALCO, 2, {{"res", PT_ERRNO, PF_DEC}, {"path", PT_FSPATH, PF_NA} } },
+	/* PPME_SYSCALL_LSTAT64_E */{"lstat64", EC_FILE, EF_DROP_FALCO, 0},
+	/* PPME_SYSCALL_LSTAT64_X */{"lstat64", EC_FILE, EF_DROP_FALCO, 2, {{"res", PT_ERRNO, PF_DEC}, {"path", PT_FSPATH, PF_NA} } },
+	/* PPME_SYSCALL_FSTAT64_E */{"fstat64", EC_FILE, EF_USES_FD | EF_DROP_FALCO, 1, {{"fd", PT_FD, PF_NA} } },
+	/* PPME_SYSCALL_FSTAT64_X */{"fstat64", EC_FILE, EF_USES_FD | EF_DROP_FALCO, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_EPOLLWAIT_E */{"epoll_wait", EC_WAIT, EF_WAITS | EF_DROP_FALCO, 1, {{"maxevents", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_EPOLLWAIT_X */{"epoll_wait", EC_WAIT, EF_WAITS | EF_DROP_FALCO, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_POLL_E */{"poll", EC_WAIT, EF_WAITS | EF_DROP_FALCO, 2, {{"fds", PT_FDLIST, PF_DEC}, {"timeout", PT_INT64, PF_DEC} } },
+	/* PPME_SYSCALL_POLL_X */{"poll", EC_WAIT, EF_WAITS | EF_DROP_FALCO, 2, {{"res", PT_ERRNO, PF_DEC}, {"fds", PT_FDLIST, PF_DEC} } },
+	/* PPME_SYSCALL_SELECT_E */{"select", EC_WAIT, EF_WAITS | EF_DROP_FALCO, 0},
+	/* PPME_SYSCALL_SELECT_X */{"select", EC_WAIT, EF_WAITS | EF_DROP_FALCO, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_NEWSELECT_E */{"select", EC_WAIT, EF_WAITS | EF_DROP_FALCO, 0},
+	/* PPME_SYSCALL_NEWSELECT_X */{"select", EC_WAIT, EF_WAITS | EF_DROP_FALCO, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_LSEEK_E */{"lseek", EC_FILE, EF_USES_FD | EF_DROP_FALCO, 3, {{"fd", PT_FD, PF_DEC}, {"offset", PT_UINT64, PF_DEC}, {"whence", PT_FLAGS8, PF_DEC, lseek_whence} } },
+	/* PPME_SYSCALL_LSEEK_X */{"lseek", EC_FILE, EF_USES_FD | EF_DROP_FALCO, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_LLSEEK_E */{"llseek", EC_FILE, EF_USES_FD | EF_DROP_FALCO, 3, {{"fd", PT_FD, PF_DEC}, {"offset", PT_UINT64, PF_DEC}, {"whence", PT_FLAGS8, PF_DEC, lseek_whence} } },
+	/* PPME_SYSCALL_LLSEEK_X */{"llseek", EC_FILE, EF_USES_FD | EF_DROP_FALCO, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_IOCTL_2_E */{"ioctl", EC_IO_OTHER, EF_USES_FD | EF_OLD_VERSION, 2, {{"fd", PT_FD, PF_DEC}, {"request", PT_UINT64, PF_HEX} } },
+	/* PPME_SYSCALL_IOCTL_2_X */{"ioctl", EC_IO_OTHER, EF_USES_FD | EF_OLD_VERSION, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_GETCWD_E */{"getcwd", EC_FILE, EF_NONE, 0},
+	/* Note: path is PT_CHARBUF and not PT_FSPATH because we assume it's abosulte and will never need resolution */
+	/* PPME_SYSCALL_GETCWD_X */{"getcwd", EC_FILE, EF_NONE, 2, {{"res", PT_ERRNO, PF_DEC}, {"path", PT_CHARBUF, PF_NA} } },
+	/* Note: path is PT_CHARBUF and not PT_FSPATH because we don't want it to be resolved, since the event handler already changes it */
+	/* PPME_SYSCALL_CHDIR_E */{"chdir", EC_FILE, EF_MODIFIES_STATE, 0},
+	/* PPME_SYSCALL_CHDIR_X */{"chdir", EC_FILE, EF_MODIFIES_STATE, 2, {{"res", PT_ERRNO, PF_DEC}, {"path", PT_CHARBUF, PF_NA} } },
+	/* PPME_SYSCALL_FCHDIR_E */{"fchdir", EC_FILE, EF_USES_FD | EF_MODIFIES_STATE, 1, {{"fd", PT_FD, PF_NA} } },
+	/* PPME_SYSCALL_FCHDIR_X */{"fchdir", EC_FILE, EF_USES_FD | EF_MODIFIES_STATE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_MKDIR_E */{"mkdir", EC_FILE, EF_NONE, 2, {{"path", PT_FSPATH, PF_NA}, {"mode", PT_UINT32, PF_HEX} } },
+	/* PPME_SYSCALL_MKDIR_X */{"mkdir", EC_FILE, EF_NONE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_RMDIR_E */{"rmdir", EC_FILE, EF_NONE, 1, {{"path", PT_FSPATH, PF_NA} } },
+	/* PPME_SYSCALL_RMDIR_X */{"rmdir", EC_FILE, EF_NONE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_OPENAT_E */{"openat", EC_FILE, EF_CREATES_FD | EF_MODIFIES_STATE, 4, {{"dirfd", PT_FD, PF_DEC}, {"name", PT_CHARBUF, PF_NA}, {"flags", PT_FLAGS32, PF_HEX, file_flags}, {"mode", PT_UINT32, PF_OCT} } },
+	/* PPME_SYSCALL_OPENAT_X */{"openat", EC_FILE, EF_CREATES_FD | EF_MODIFIES_STATE, 1, {{"fd", PT_FD, PF_DEC} } },
+	/* PPME_SYSCALL_LINK_E */{"link", EC_FILE, EF_NONE, 2, {{"oldpath", PT_FSPATH, PF_NA}, {"newpath", PT_FSPATH, PF_NA} } },
+	/* PPME_SYSCALL_LINK_X */{"link", EC_FILE, EF_NONE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_LINKAT_E */{"linkat", EC_FILE, EF_NONE, 4, {{"olddir", PT_FD, PF_DEC}, {"oldpath", PT_CHARBUF, PF_NA}, {"newdir", PT_FD, PF_DEC}, {"newpath", PT_CHARBUF, PF_NA} } },
+	/* PPME_SYSCALL_LINKAT_X */{"linkat", EC_FILE, EF_NONE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_UNLINK_E */{"unlink", EC_FILE, EF_NONE, 1, {{"path", PT_FSPATH, PF_NA} } },
+	/* PPME_SYSCALL_UNLINK_X */{"unlink", EC_FILE, EF_NONE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_UNLINKAT_E */{"unlinkat", EC_FILE, EF_NONE, 2, {{"dirfd", PT_FD, PF_DEC}, {"name", PT_CHARBUF, PF_NA} } },
+	/* PPME_SYSCALL_UNLINKAT_X */{"unlinkat", EC_FILE, EF_NONE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_PREAD_E */{"pread", EC_IO_READ, EF_USES_FD | EF_READS_FROM_FD, 3, {{"fd", PT_FD, PF_DEC}, {"size", PT_UINT32, PF_DEC}, {"pos", PT_UINT64, PF_DEC} } },
+	/* PPME_SYSCALL_PREAD_X */{"pread", EC_IO_READ, EF_USES_FD | EF_READS_FROM_FD, 2, {{"res", PT_ERRNO, PF_DEC}, {"data", PT_BYTEBUF, PF_NA} } },
+	/* PPME_SYSCALL_PWRITE_E */{"pwrite", EC_IO_WRITE, EF_USES_FD | EF_WRITES_TO_FD, 3, {{"fd", PT_FD, PF_DEC}, {"size", PT_UINT32, PF_DEC}, {"pos", PT_UINT64, PF_DEC} } },
+	/* PPME_SYSCALL_PWRITE_X */{"pwrite", EC_IO_WRITE, EF_USES_FD | EF_WRITES_TO_FD, 2, {{"res", PT_ERRNO, PF_DEC}, {"data", PT_BYTEBUF, PF_NA} } },
+	/* PPME_SYSCALL_READV_E */{"readv", EC_IO_READ, EF_USES_FD | EF_READS_FROM_FD | EF_DROP_FALCO, 1, {{"fd", PT_FD, PF_DEC} } },
+	/* PPME_SYSCALL_READV_X */{"readv", EC_IO_READ, EF_USES_FD | EF_READS_FROM_FD | EF_DROP_FALCO, 3, {{"res", PT_ERRNO, PF_DEC}, {"size", PT_UINT32, PF_DEC}, {"data", PT_BYTEBUF, PF_NA} } },
+	/* PPME_SYSCALL_WRITEV_E */{"writev", EC_IO_WRITE, EF_USES_FD | EF_WRITES_TO_FD | EF_DROP_FALCO, 2, {{"fd", PT_FD, PF_DEC}, {"size", PT_UINT32, PF_DEC} } },
+	/* PPME_SYSCALL_WRITEV_X */{"writev", EC_IO_WRITE, EF_USES_FD | EF_WRITES_TO_FD | EF_DROP_FALCO, 2, {{"res", PT_ERRNO, PF_DEC}, {"data", PT_BYTEBUF, PF_NA} } },
+	/* PPME_SYSCALL_PREADV_E */{"preadv", EC_IO_READ, EF_USES_FD | EF_READS_FROM_FD | EF_DROP_FALCO, 2, {{"fd", PT_FD, PF_DEC}, {"pos", PT_UINT64, PF_DEC} } },
+	/* PPME_SYSCALL_PREADV_X */{"preadv", EC_IO_READ, EF_USES_FD | EF_READS_FROM_FD | EF_DROP_FALCO, 3, {{"res", PT_ERRNO, PF_DEC}, {"size", PT_UINT32, PF_DEC}, {"data", PT_BYTEBUF, PF_NA} } },
+	/* PPME_SYSCALL_PWRITEV_E */{"pwritev", EC_IO_WRITE, EF_USES_FD | EF_WRITES_TO_FD | EF_DROP_FALCO, 3, {{"fd", PT_FD, PF_DEC}, {"size", PT_UINT32, PF_DEC}, {"pos", PT_UINT64, PF_DEC} } },
+	/* PPME_SYSCALL_PWRITEV_X */{"pwritev", EC_IO_WRITE, EF_USES_FD | EF_WRITES_TO_FD | EF_DROP_FALCO, 2, {{"res", PT_ERRNO, PF_DEC}, {"data", PT_BYTEBUF, PF_NA} } },
+	/* PPME_SYSCALL_DUP_E */{"dup", EC_IO_OTHER, EF_CREATES_FD | EF_USES_FD | EF_MODIFIES_STATE, 1, {{"fd", PT_FD, PF_DEC} } },
+	/* PPME_SYSCALL_DUP_X */{"dup", EC_IO_OTHER, EF_CREATES_FD | EF_USES_FD | EF_MODIFIES_STATE, 1, {{"res", PT_FD, PF_DEC} } },
+	/* PPME_SYSCALL_SIGNALFD_E */{"signalfd", EC_SIGNAL, EF_CREATES_FD | EF_MODIFIES_STATE, 3, {{"fd", PT_FD, PF_DEC}, {"mask", PT_UINT32, PF_HEX}, {"flags", PT_FLAGS8, PF_HEX} } },
+	/* PPME_SYSCALL_SIGNALFD_X */{"signalfd", EC_SIGNAL, EF_CREATES_FD | EF_MODIFIES_STATE, 1, {{"res", PT_FD, PF_DEC} } },
+	/* PPME_SYSCALL_KILL_E */{"kill", EC_SIGNAL, EF_NONE, 2, {{"pid", PT_PID, PF_DEC}, {"sig", PT_SIGTYPE, PF_DEC} } },
+	/* PPME_SYSCALL_KILL_X */{"kill", EC_SIGNAL, EF_NONE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_TKILL_E */{"tkill", EC_SIGNAL, EF_NONE, 2, {{"tid", PT_PID, PF_DEC}, {"sig", PT_SIGTYPE, PF_DEC} } },
+	/* PPME_SYSCALL_TKILL_X */{"tkill", EC_SIGNAL, EF_NONE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_TGKILL_E */{"tgkill", EC_SIGNAL, EF_NONE, 3, {{"pid", PT_PID, PF_DEC}, {"tid", PT_PID, PF_DEC}, {"sig", PT_SIGTYPE, PF_DEC} } },
+	/* PPME_SYSCALL_TGKILL_X */{"tgkill", EC_SIGNAL, EF_NONE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_NANOSLEEP_E */{"nanosleep", EC_SLEEP, EF_WAITS | EF_DROP_FALCO, 1, {{"interval", PT_RELTIME, PF_DEC} } },
+	/* PPME_SYSCALL_NANOSLEEP_X */{"nanosleep", EC_SLEEP, EF_WAITS | EF_DROP_FALCO, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_TIMERFD_CREATE_E */{"timerfd_create", EC_TIME, EF_CREATES_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 2, {{"clockid", PT_UINT8, PF_DEC}, {"flags", PT_FLAGS8, PF_HEX} } },
+	/* PPME_SYSCALL_TIMERFD_CREATE_X */{"timerfd_create", EC_TIME, EF_CREATES_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 1, {{"res", PT_FD, PF_DEC} } },
+	/* PPME_SYSCALL_INOTIFY_INIT_E */{"inotify_init", EC_IPC, EF_CREATES_FD | EF_MODIFIES_STATE, 1, {{"flags", PT_FLAGS8, PF_HEX} } },
+	/* PPME_SYSCALL_INOTIFY_INIT_X */{"inotify_init", EC_IPC, EF_CREATES_FD | EF_MODIFIES_STATE, 1, {{"res", PT_FD, PF_DEC} } },
+	/* PPME_SYSCALL_GETRLIMIT_E */{"getrlimit", EC_PROCESS, EF_NONE, 1, {{"resource", PT_FLAGS8, PF_DEC, rlimit_resources} } },
+	/* PPME_SYSCALL_GETRLIMIT_X */{"getrlimit", EC_PROCESS, EF_NONE, 3, {{"res", PT_ERRNO, PF_DEC}, {"cur", PT_INT64, PF_DEC}, {"max", PT_INT64, PF_DEC} } },
+	/* PPME_SYSCALL_SETRLIMIT_E */{"setrlimit", EC_PROCESS, EF_NONE, 1, {{"resource", PT_FLAGS8, PF_DEC, rlimit_resources} } },
+	/* PPME_SYSCALL_SETRLIMIT_X */{"setrlimit", EC_PROCESS, EF_NONE, 3, {{"res", PT_ERRNO, PF_DEC}, {"cur", PT_INT64, PF_DEC}, {"max", PT_INT64, PF_DEC} } },
+	/* PPME_SYSCALL_PRLIMIT_E */{"prlimit", EC_PROCESS, EF_NONE, 2, {{"pid", PT_PID, PF_DEC}, {"resource", PT_FLAGS8, PF_DEC, rlimit_resources} } },
+	/* PPME_SYSCALL_PRLIMIT_X */{"prlimit", EC_PROCESS, EF_NONE, 5, {{"res", PT_ERRNO, PF_DEC}, {"newcur", PT_INT64, PF_DEC}, {"newmax", PT_INT64, PF_DEC}, {"oldcur", PT_INT64, PF_DEC}, {"oldmax", PT_INT64, PF_DEC} } },
+	/* PPME_SCHEDSWITCH_1_E */{"switch", EC_SCHEDULER, EF_SKIPPARSERESET | EF_OLD_VERSION | EF_DROP_FALCO, 1, {{"next", PT_PID, PF_DEC} } },
+	/* PPME_SCHEDSWITCH_1_X */{"NA2", EC_SCHEDULER, EF_SKIPPARSERESET | EF_UNUSED | EF_OLD_VERSION, 0},
+	/* PPME_DROP_E */{"drop", EC_INTERNAL, EF_SKIPPARSERESET, 1, {{"ratio", PT_UINT32, PF_DEC} } },
+	/* PPME_DROP_X */{"drop", EC_INTERNAL, EF_SKIPPARSERESET, 1, {{"ratio", PT_UINT32, PF_DEC} } },
+	/* PPME_SYSCALL_FCNTL_E */{"fcntl", EC_IO_OTHER, EF_USES_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 2, {{"fd", PT_FD, PF_DEC}, {"cmd", PT_FLAGS8, PF_DEC, fcntl_commands} } },
+	/* PPME_SYSCALL_FCNTL_X */{"fcntl", EC_IO_OTHER, EF_USES_FD | EF_MODIFIES_STATE | EF_DROP_FALCO, 1, {{"res", PT_FD, PF_DEC} } },
+	/* PPME_SCHEDSWITCH_6_E */{"switch", EC_SCHEDULER, EF_DROP_FALCO , 6, {{"next", PT_PID, PF_DEC}, {"pgft_maj", PT_UINT64, PF_DEC}, {"pgft_min", PT_UINT64, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC} } },
+	/* PPME_SCHEDSWITCH_6_X */{"NA2", EC_SCHEDULER, EF_UNUSED, 0},
+	/* PPME_SYSCALL_EXECVE_13_E */{"execve", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 0},
+	/* PPME_SYSCALL_EXECVE_13_X */{"execve", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 13, {{"res", PT_ERRNO, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_UINT64, PF_DEC}, {"pgft_maj", PT_UINT64, PF_DEC}, {"pgft_min", PT_UINT64, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC} } },
+	/* PPME_CLONE_16_E */{"clone", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 0},
+	/* PPME_CLONE_16_X */{"clone", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 16, {{"res", PT_PID, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_INT64, PF_DEC}, {"pgft_maj", PT_UINT64, PF_DEC}, {"pgft_min", PT_UINT64, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC}, {"flags", PT_FLAGS32, PF_HEX, clone_flags}, {"uid", PT_UINT32, PF_DEC}, {"gid", PT_UINT32, PF_DEC} } },
+	/* PPME_SYSCALL_BRK_4_E */{"brk", EC_MEMORY, EF_NONE, 1, {{"addr", PT_UINT64, PF_HEX} } },
+	/* PPME_SYSCALL_BRK_4_X */{"brk", EC_MEMORY, EF_NONE, 4, {{"res", PT_UINT64, PF_HEX}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC} } },
+	/* PPME_SYSCALL_MMAP_E */{"mmap", EC_MEMORY, EF_DROP_FALCO, 6, {{"addr", PT_UINT64, PF_HEX}, {"length", PT_UINT64, PF_DEC}, {"prot", PT_FLAGS32, PF_HEX, prot_flags}, {"flags", PT_FLAGS32, PF_HEX, mmap_flags}, {"fd", PT_FD, PF_DEC}, {"offset", PT_UINT64, PF_DEC} } },
+	/* PPME_SYSCALL_MMAP_X */{"mmap", EC_MEMORY, EF_DROP_FALCO, 4, {{"res", PT_UINT64, PF_HEX}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC} } },
+	/* PPME_SYSCALL_MMAP2_E */{"mmap2", EC_MEMORY, EF_DROP_FALCO, 6, {{"addr", PT_UINT64, PF_HEX}, {"length", PT_UINT64, PF_DEC}, {"prot", PT_FLAGS32, PF_HEX, prot_flags}, {"flags", PT_FLAGS32, PF_HEX, mmap_flags}, {"fd", PT_FD, PF_DEC}, {"pgoffset", PT_UINT64, PF_DEC} } },
+	/* PPME_SYSCALL_MMAP2_X */{"mmap2", EC_MEMORY, EF_DROP_FALCO, 4, {{"res", PT_UINT64, PF_HEX}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC} } },
+	/* PPME_SYSCALL_MUNMAP_E */{"munmap", EC_MEMORY, EF_DROP_FALCO, 2, {{"addr", PT_UINT64, PF_HEX}, {"length", PT_UINT64, PF_DEC} } },
+	/* PPME_SYSCALL_MUNMAP_X */{"munmap", EC_MEMORY, EF_DROP_FALCO, 4, {{"res", PT_ERRNO, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC} } },
+	/* PPME_SYSCALL_SPLICE_E */{"splice", EC_IO_OTHER, EF_USES_FD, 4, {{"fd_in", PT_FD, PF_DEC}, {"fd_out", PT_FD, PF_DEC}, {"size", PT_UINT64, PF_DEC}, {"flags", PT_FLAGS32, PF_HEX, splice_flags} } },
+	/* PPME_SYSCALL_SPLICE_X */{"splice", EC_IO_OTHER, EF_USES_FD, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_PTRACE_E */{"ptrace", EC_PROCESS, EF_NONE, 2, {{"request", PT_FLAGS16, PF_DEC, ptrace_requests}, {"pid", PT_PID, PF_DEC} } },
+	/* PPME_SYSCALL_PTRACE_X */{"ptrace", EC_PROCESS, EF_NONE, 3, {{"res", PT_ERRNO, PF_DEC}, {"addr", PT_DYN, PF_HEX, ptrace_dynamic_param, PPM_PTRACE_IDX_MAX}, {"data", PT_DYN, PF_HEX, ptrace_dynamic_param, PPM_PTRACE_IDX_MAX} } },
+	/* PPME_SYSCALL_IOCTL_3_E */{"ioctl", EC_IO_OTHER, EF_USES_FD, 3, {{"fd", PT_FD, PF_DEC}, {"request", PT_UINT64, PF_HEX}, {"argument", PT_UINT64, PF_HEX} } },
+	/* PPME_SYSCALL_IOCTL_3_X */{"ioctl", EC_IO_OTHER, EF_USES_FD, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_EXECVE_14_E */{"execve", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 0},
+	/* PPME_SYSCALL_EXECVE_14_X */{"execve", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 14, {{"res", PT_ERRNO, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_UINT64, PF_DEC}, {"pgft_maj", PT_UINT64, PF_DEC}, {"pgft_min", PT_UINT64, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC}, {"env", PT_BYTEBUF, PF_NA} } },
+	/* PPME_SYSCALL_RENAME_E */{"rename", EC_FILE, EF_NONE, 0 },
+	/* PPME_SYSCALL_RENAME_X */{"rename", EC_FILE, EF_NONE, 3, {{"res", PT_ERRNO, PF_DEC}, {"oldpath", PT_FSPATH, PF_NA}, {"newpath", PT_FSPATH, PF_NA} } },
+	/* PPME_SYSCALL_RENAMEAT_E */{"renameat", EC_FILE, EF_NONE, 0 },
+	/* PPME_SYSCALL_RENAMEAT_X */{"renameat", EC_FILE, EF_NONE, 5, {{"res", PT_ERRNO, PF_DEC}, {"olddirfd", PT_FD, PF_DEC}, {"oldpath", PT_CHARBUF, PF_NA}, {"newdirfd", PT_FD, PF_DEC}, {"newpath", PT_CHARBUF, PF_NA} } },
+	/* PPME_SYSCALL_SYMLINK_E */{"symlink", EC_FILE, EF_NONE, 0 },
+	/* PPME_SYSCALL_SYMLINK_X */{"symlink", EC_FILE, EF_NONE, 3, {{"res", PT_ERRNO, PF_DEC}, {"target", PT_CHARBUF, PF_NA}, {"linkpath", PT_FSPATH, PF_NA} } },
+	/* PPME_SYSCALL_SYMLINKAT_E */{"symlinkat", EC_FILE, EF_NONE, 0 },
+	/* PPME_SYSCALL_SYMLINKAT_X */{"symlinkat", EC_FILE, EF_NONE, 4, {{"res", PT_ERRNO, PF_DEC}, {"target", PT_CHARBUF, PF_NA}, {"linkdirfd", PT_FD, PF_DEC}, {"linkpath", PT_CHARBUF, PF_NA} } },
+	/* PPME_SYSCALL_FORK_E */{"fork", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 0},
+	/* PPME_SYSCALL_FORK_X */{"fork", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 16, {{"res", PT_PID, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_INT64, PF_DEC}, {"pgft_maj", PT_UINT64, PF_DEC}, {"pgft_min", PT_UINT64, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC}, {"flags", PT_FLAGS32, PF_HEX, clone_flags}, {"uid", PT_UINT32, PF_DEC}, {"gid", PT_UINT32, PF_DEC} } },
+	/* PPME_SYSCALL_VFORK_E */{"vfork", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 0},
+	/* PPME_SYSCALL_VFORK_X */{"vfork", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 16, {{"res", PT_PID, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_INT64, PF_DEC}, {"pgft_maj", PT_UINT64, PF_DEC}, {"pgft_min", PT_UINT64, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC}, {"flags", PT_FLAGS32, PF_HEX, clone_flags}, {"uid", PT_UINT32, PF_DEC}, {"gid", PT_UINT32, PF_DEC} } },
+	/* PPME_PROCEXIT_1_E */{"procexit", EC_PROCESS, EF_MODIFIES_STATE, 1, {{"status", PT_ERRNO, PF_DEC} } },
+	/* PPME_NA1 */{"NA1", EC_PROCESS, EF_UNUSED, 0},
+	/* PPME_SYSCALL_SENDFILE_E */{"sendfile", EC_IO_WRITE, EF_USES_FD | EF_DROP_FALCO, 4, {{"out_fd", PT_FD, PF_DEC}, {"in_fd", PT_FD, PF_DEC}, {"offset", PT_UINT64, PF_DEC}, {"size", PT_UINT64, PF_DEC} } },
+	/* PPME_SYSCALL_SENDFILE_X */{"sendfile", EC_IO_WRITE, EF_USES_FD | EF_DROP_FALCO, 2, {{"res", PT_ERRNO, PF_DEC}, {"offset", PT_UINT64, PF_DEC} } },
+	/* PPME_SYSCALL_QUOTACTL_E */{"quotactl", EC_USER, EF_NONE, 4, {{"cmd", PT_FLAGS16, PF_DEC, quotactl_cmds }, {"type", PT_FLAGS8, PF_DEC, quotactl_types}, {"id", PT_UINT32, PF_DEC}, {"quota_fmt", PT_FLAGS8, PF_DEC, quotactl_quota_fmts } } },
+	/* PPME_SYSCALL_QUOTACTL_X */{"quotactl", EC_USER, EF_NONE, 14, {{"res", PT_ERRNO, PF_DEC}, {"special", PT_CHARBUF, PF_NA }, {"quotafilepath", PT_CHARBUF, PF_NA}, {"dqb_bhardlimit", PT_UINT64, PF_DEC }, {"dqb_bsoftlimit", PT_UINT64, PF_DEC }, {"dqb_curspace", PT_UINT64, PF_DEC }, {"dqb_ihardlimit", PT_UINT64, PF_DEC }, {"dqb_isoftlimit", PT_UINT64, PF_DEC }, {"dqb_btime", PT_RELTIME, PF_DEC }, {"dqb_itime", PT_RELTIME, PF_DEC }, {"dqi_bgrace", PT_RELTIME, PF_DEC }, {"dqi_igrace", PT_RELTIME, PF_DEC }, {"dqi_flags", PT_FLAGS8, PF_DEC, quotactl_dqi_flags }, {"quota_fmt_out", PT_FLAGS8, PF_DEC, quotactl_quota_fmts } } },
+	/* PPME_SYSCALL_SETRESUID_E */ {"setresuid", EC_USER, EF_MODIFIES_STATE, 3, {{"ruid", PT_UID, PF_DEC }, {"euid", PT_UID, PF_DEC }, {"suid", PT_UID, PF_DEC } } },
+	/* PPME_SYSCALL_SETRESUID_X */ {"setresuid", EC_USER, EF_MODIFIES_STATE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_SETRESGID_E */ {"setresgid", EC_USER, EF_MODIFIES_STATE, 3, {{"rgid", PT_GID, PF_DEC }, {"egid", PT_GID, PF_DEC }, {"sgid", PT_GID, PF_DEC } } },
+	/* PPME_SYSCALL_SETRESGID_X */ {"setresgid", EC_USER, EF_MODIFIES_STATE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSDIGEVENT_E */{"sysdigevent", EC_INTERNAL, EF_SKIPPARSERESET, 2, {{"event_type", PT_UINT32, PF_DEC}, {"event_data", PT_UINT64, PF_DEC} } },
+	/* PPME_NA1 */{"sysdigevent", EC_INTERNAL, EF_UNUSED, 0},
+	/* PPME_SYSCALL_SETUID_E */ {"setuid", EC_USER, EF_MODIFIES_STATE, 1, {{"uid", PT_UID, PF_DEC} } },
+	/* PPME_SYSCALL_SETUID_X */ {"setuid", EC_USER, EF_MODIFIES_STATE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_SETGID_E */ {"setgid", EC_USER, EF_MODIFIES_STATE, 1, {{"gid", PT_GID, PF_DEC} } },
+	/* PPME_SYSCALL_SETGID_X */ {"setgid", EC_USER, EF_MODIFIES_STATE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_GETUID_E */ {"getuid", EC_USER, EF_NONE, 0},
+	/* PPME_SYSCALL_GETUID_X */ {"getuid", EC_USER, EF_NONE, 1, {{"uid", PT_UID, PF_DEC} } },
+	/* PPME_SYSCALL_GETEUID_E */ {"geteuid", EC_USER, EF_NONE, 0 },
+	/* PPME_SYSCALL_GETEUID_X */ {"geteuid", EC_USER, EF_NONE, 1, {{"euid", PT_UID, PF_DEC} } },
+	/* PPME_SYSCALL_GETGID_E */ {"getgid", EC_USER, EF_NONE, 0},
+	/* PPME_SYSCALL_GETGID_X */ {"getgid", EC_USER, EF_NONE, 1, {{"gid", PT_GID, PF_DEC} } },
+	/* PPME_SYSCALL_GETEGID_E */ {"getegid", EC_USER, EF_NONE, 0 },
+	/* PPME_SYSCALL_GETEGID_X */ {"getegid", EC_USER, EF_NONE, 1, {{"egid", PT_GID, PF_DEC} } },
+	/* PPME_SYSCALL_GETRESUID_E */ {"getresuid", EC_USER, EF_NONE, 0 },
+	/* PPME_SYSCALL_GETRESUID_X */ {"getresuid", EC_USER, EF_NONE, 4, {{"res", PT_ERRNO, PF_DEC}, {"ruid", PT_UID, PF_DEC }, {"euid", PT_UID, PF_DEC }, {"suid", PT_UID, PF_DEC } } },
+	/* PPME_SYSCALL_GETRESGID_E */ {"getresgid", EC_USER, EF_NONE, 0 },
+	/* PPME_SYSCALL_GETRESGID_X */ {"getresgid", EC_USER, EF_NONE, 4, {{"res", PT_ERRNO, PF_DEC}, {"rgid", PT_GID, PF_DEC }, {"egid", PT_GID, PF_DEC }, {"sgid", PT_GID, PF_DEC } } },
+	/* PPME_SYSCALL_EXECVE_15_E */{"execve", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 0},
+	/* PPME_SYSCALL_EXECVE_15_X */{"execve", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 15, {{"res", PT_ERRNO, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_UINT64, PF_DEC}, {"pgft_maj", PT_UINT64, PF_DEC}, {"pgft_min", PT_UINT64, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC}, {"comm", PT_CHARBUF, PF_NA}, {"env", PT_BYTEBUF, PF_NA} } },
+	/* PPME_CLONE_17_E */{"clone", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 0},
+	/* PPME_CLONE_17_X */{"clone", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 17, {{"res", PT_PID, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_INT64, PF_DEC}, {"pgft_maj", PT_UINT64, PF_DEC}, {"pgft_min", PT_UINT64, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC}, {"comm", PT_CHARBUF, PF_NA}, {"flags", PT_FLAGS32, PF_HEX, clone_flags}, {"uid", PT_UINT32, PF_DEC}, {"gid", PT_UINT32, PF_DEC} } },
+	/* PPME_SYSCALL_FORK_17_E */{"fork", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 0},
+	/* PPME_SYSCALL_FORK_17_X */{"fork", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 17, {{"res", PT_PID, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_INT64, PF_DEC}, {"pgft_maj", PT_UINT64, PF_DEC}, {"pgft_min", PT_UINT64, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC}, {"comm", PT_CHARBUF, PF_NA}, {"flags", PT_FLAGS32, PF_HEX, clone_flags}, {"uid", PT_UINT32, PF_DEC}, {"gid", PT_UINT32, PF_DEC} } },
+	/* PPME_SYSCALL_VFORK_17_E */{"vfork", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 0},
+	/* PPME_SYSCALL_VFORK_17_X */{"vfork", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 17, {{"res", PT_PID, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_INT64, PF_DEC}, {"pgft_maj", PT_UINT64, PF_DEC}, {"pgft_min", PT_UINT64, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC}, {"comm", PT_CHARBUF, PF_NA}, {"flags", PT_FLAGS32, PF_HEX, clone_flags}, {"uid", PT_UINT32, PF_DEC}, {"gid", PT_UINT32, PF_DEC} } },
+	/* PPME_CLONE_20_E */{"clone", EC_PROCESS, EF_MODIFIES_STATE, 0},
+	/* PPME_CLONE_20_X */{"clone", EC_PROCESS, EF_MODIFIES_STATE, 20, {{"res", PT_PID, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_INT64, PF_DEC}, {"pgft_maj", PT_UINT64, PF_DEC}, {"pgft_min", PT_UINT64, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC}, {"comm", PT_CHARBUF, PF_NA}, {"cgroups", PT_BYTEBUF, PF_NA}, {"flags", PT_FLAGS32, PF_HEX, clone_flags}, {"uid", PT_UINT32, PF_DEC}, {"gid", PT_UINT32, PF_DEC}, {"vtid", PT_PID, PF_DEC}, {"vpid", PT_PID, PF_DEC} } },
+	/* PPME_SYSCALL_FORK_20_E */{"fork", EC_PROCESS, EF_MODIFIES_STATE, 0},
+	/* PPME_SYSCALL_FORK_20_X */{"fork", EC_PROCESS, EF_MODIFIES_STATE, 20, {{"res", PT_PID, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_INT64, PF_DEC}, {"pgft_maj", PT_UINT64, PF_DEC}, {"pgft_min", PT_UINT64, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC}, {"comm", PT_CHARBUF, PF_NA}, {"cgroups", PT_BYTEBUF, PF_NA}, {"flags", PT_FLAGS32, PF_HEX, clone_flags}, {"uid", PT_UINT32, PF_DEC}, {"gid", PT_UINT32, PF_DEC}, {"vtid", PT_PID, PF_DEC}, {"vpid", PT_PID, PF_DEC} } },
+	/* PPME_SYSCALL_VFORK_20_E */{"vfork", EC_PROCESS, EF_MODIFIES_STATE, 0},
+	/* PPME_SYSCALL_VFORK_20_X */{"vfork", EC_PROCESS, EF_MODIFIES_STATE, 20, {{"res", PT_PID, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_INT64, PF_DEC}, {"pgft_maj", PT_UINT64, PF_DEC}, {"pgft_min", PT_UINT64, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC}, {"comm", PT_CHARBUF, PF_NA}, {"cgroups", PT_BYTEBUF, PF_NA}, {"flags", PT_FLAGS32, PF_HEX, clone_flags}, {"uid", PT_UINT32, PF_DEC}, {"gid", PT_UINT32, PF_DEC}, {"vtid", PT_PID, PF_DEC}, {"vpid", PT_PID, PF_DEC} } },
+	/* PPME_CONTAINER_E */{"container", EC_INTERNAL, EF_SKIPPARSERESET | EF_MODIFIES_STATE, 4, {{"id", PT_CHARBUF, PF_NA}, {"type", PT_UINT32, PF_DEC}, {"name", PT_CHARBUF, PF_NA}, {"image", PT_CHARBUF, PF_NA} } },
+	/* PPME_CONTAINER_X */{"container", EC_INTERNAL, EF_UNUSED, 0},
+	/* PPME_SYSCALL_EXECVE_16_E */{"execve", EC_PROCESS, EF_MODIFIES_STATE, 0},
+	/* PPME_SYSCALL_EXECVE_16_X */{"execve", EC_PROCESS, EF_MODIFIES_STATE, 16, {{"res", PT_ERRNO, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_UINT64, PF_DEC}, {"pgft_maj", PT_UINT64, PF_DEC}, {"pgft_min", PT_UINT64, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC}, {"comm", PT_CHARBUF, PF_NA}, {"cgroups", PT_BYTEBUF, PF_NA}, {"env", PT_BYTEBUF, PF_NA} } },
+	/* PPME_SIGNALDELIVER_E */ {"signaldeliver", EC_SIGNAL, EF_NONE, 3, {{"spid", PT_PID, PF_DEC}, {"dpid", PT_PID, PF_DEC}, {"sig", PT_SIGTYPE, PF_DEC} } },
+	/* PPME_SIGNALDELIVER_X */ {"signaldeliver", EC_SIGNAL, EF_UNUSED, 0 },
+	/* PPME_PROCINFO_E */{"procinfo", EC_INTERNAL, EF_SKIPPARSERESET | EF_DROP_FALCO, 2, {{"cpu_usr", PT_UINT64, PF_DEC}, {"cpu_sys", PT_UINT64, PF_DEC} } },
+	/* PPME_PROCINFO_X */{"NA2", EC_INTERNAL, EF_UNUSED, 0},
+	/* PPME_SYSCALL_GETDENTS_E */{"getdents", EC_FILE, EF_USES_FD | EF_DROP_FALCO, 1, {{"fd", PT_FD, PF_NA} } },
+	/* PPME_SYSCALL_GETDENTS_X */{"getdents", EC_FILE, EF_USES_FD | EF_DROP_FALCO, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_GETDENTS64_E */{"getdents64", EC_FILE, EF_USES_FD | EF_DROP_FALCO, 1, {{"fd", PT_FD, PF_NA} } },
+	/* PPME_SYSCALL_GETDENTS64_X */{"getdents64", EC_FILE, EF_USES_FD | EF_DROP_FALCO, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_SETNS_E */ {"setns", EC_PROCESS, EF_USES_FD, 2, {{"fd", PT_FD, PF_NA}, {"nstype", PT_FLAGS32, PF_HEX, clone_flags} } },
+	/* PPME_SYSCALL_SETNS_X */ {"setns", EC_PROCESS, EF_USES_FD, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_FLOCK_E */ {"flock", EC_FILE, EF_USES_FD, 2, {{"fd", PT_FD, PF_NA}, {"operation", PT_FLAGS32, PF_HEX, flock_flags} } },
+	/* PPME_SYSCALL_FLOCK_X */ {"flock", EC_FILE, EF_USES_FD, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_CPU_HOTPLUG_E */ {"cpu_hotplug", EC_SYSTEM, EF_SKIPPARSERESET, 2, {{"cpu", PT_UINT32, PF_DEC}, {"action", PT_UINT32, PF_DEC} } },
+	/* PPME_CPU_HOTPLUG_X */{"NA2", EC_SYSTEM, EF_UNUSED, 0},
+	/* PPME_SOCKET_ACCEPT_5_E */{"accept", EC_NET, EF_CREATES_FD | EF_MODIFIES_STATE, 0},
+	/* PPME_SOCKET_ACCEPT_5_X */{"accept", EC_NET, EF_CREATES_FD | EF_MODIFIES_STATE, 5, {{"fd", PT_FD, PF_DEC}, {"tuple", PT_SOCKTUPLE, PF_NA}, {"queuepct", PT_UINT8, PF_DEC}, {"queuelen", PT_UINT32, PF_DEC}, {"queuemax", PT_UINT32, PF_DEC} } },
+	/* PPME_SOCKET_ACCEPT4_5_E */{"accept", EC_NET, EF_CREATES_FD | EF_MODIFIES_STATE, 1, {{"flags", PT_INT32, PF_HEX} } },
+	/* PPME_SOCKET_ACCEPT4_5_X */{"accept", EC_NET, EF_CREATES_FD | EF_MODIFIES_STATE, 5, {{"fd", PT_FD, PF_DEC}, {"tuple", PT_SOCKTUPLE, PF_NA}, {"queuepct", PT_UINT8, PF_DEC}, {"queuelen", PT_UINT32, PF_DEC}, {"queuemax", PT_UINT32, PF_DEC} } },
+	/* PPME_SYSCALL_SEMOP_E */ {"semop", EC_PROCESS, EF_NONE, 1, {{"semid", PT_INT32, PF_DEC} } },
+	/* PPME_SYSCALL_SEMOP_X */ {"semop", EC_PROCESS, EF_NONE, 8, {{"res", PT_ERRNO, PF_DEC}, {"nsops", PT_UINT32, PF_DEC}, {"sem_num_0", PT_UINT16, PF_DEC}, {"sem_op_0", PT_INT16, PF_DEC}, {"sem_flg_0", PT_FLAGS16, PF_HEX, semop_flags}, {"sem_num_1", PT_UINT16, PF_DEC}, {"sem_op_1", PT_INT16, PF_DEC}, {"sem_flg_1", PT_FLAGS16, PF_HEX, semop_flags} } },
+	/* PPME_SYSCALL_SEMCTL_E */{"semctl", EC_PROCESS, EF_NONE, 4, {{"semid", PT_INT32, PF_DEC}, {"semnum", PT_INT32, PF_DEC}, {"cmd", PT_FLAGS16, PF_HEX, semctl_commands}, {"val", PT_INT32, PF_DEC} } },
+	/* PPME_SYSCALL_SEMCTL_X */{"semctl", EC_PROCESS, EF_NONE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_PPOLL_E */{"ppoll", EC_WAIT, EF_WAITS | EF_DROP_FALCO, 3, {{"fds", PT_FDLIST, PF_DEC}, {"timeout", PT_RELTIME, PF_DEC}, {"sigmask", PT_SIGSET, PF_DEC} } },
+	/* PPME_SYSCALL_PPOLL_X */{"ppoll", EC_WAIT, EF_WAITS | EF_DROP_FALCO, 2, {{"res", PT_ERRNO, PF_DEC}, {"fds", PT_FDLIST, PF_DEC} } },
+	/* PPME_SYSCALL_MOUNT_E */{"mount", EC_FILE, EF_MODIFIES_STATE, 1, {{"flags", PT_FLAGS32, PF_HEX, mount_flags} } },
+	/* PPME_SYSCALL_MOUNT_X */{"mount", EC_FILE, EF_MODIFIES_STATE, 4, {{"res", PT_ERRNO, PF_DEC}, {"dev", PT_CHARBUF, PF_NA}, {"dir", PT_FSPATH, PF_NA}, {"type", PT_CHARBUF, PF_NA} } },
+	/* PPME_SYSCALL_UMOUNT_E */{"umount", EC_FILE, EF_MODIFIES_STATE, 1, {{"flags", PT_FLAGS32, PF_HEX, umount_flags} } },
+	/* PPME_SYSCALL_UMOUNT_X */{"umount", EC_FILE, EF_MODIFIES_STATE, 2, {{"res", PT_ERRNO, PF_DEC}, {"name", PT_FSPATH, PF_NA} } },
+	/* PPME_K8S_E */{"k8s", EC_INTERNAL, EF_SKIPPARSERESET | EF_MODIFIES_STATE, 1, {{"json", PT_CHARBUF, PF_NA} } },
+	/* PPME_K8S_X */{"NA3", EC_SYSTEM, EF_UNUSED, 0},
+	/* PPME_SYSCALL_SEMGET_E */{"semget", EC_PROCESS, EF_NONE, 3, {{"key", PT_INT32, PF_HEX}, {"nsems", PT_INT32, PF_DEC}, {"semflg", PT_FLAGS32, PF_HEX, semget_flags} } },
+	/* PPME_SYSCALL_SEMGET_X */{"semget", EC_PROCESS, EF_NONE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_SYSCALL_ACCESS_E */{"access", EC_FILE, EF_NONE, 1, {{"mode", PT_FLAGS32, PF_HEX, access_flags} } },
+	/* PPME_SYSCALL_ACCESS_X */{"access", EC_FILE, EF_NONE, 2, {{"res", PT_ERRNO, PF_DEC}, {"name", PT_FSPATH, PF_NA} } },
+	/* PPME_SYSCALL_CHROOT_E */{"chroot", EC_PROCESS, EF_MODIFIES_STATE, 0},
+	/* PPME_SYSCALL_CHROOT_X */{"chroot", EC_PROCESS, EF_MODIFIES_STATE, 2, {{"res", PT_ERRNO, PF_DEC}, {"path", PT_FSPATH, PF_NA} } },
+	/* PPME_TRACER_E */{"tracer", EC_OTHER, EF_NONE, 3, {{"id", PT_INT64, PF_DEC}, {"tags", PT_CHARBUFARRAY, PF_NA}, {"args", PT_CHARBUF_PAIR_ARRAY, PF_NA} } },
+	/* PPME_TRACER_X */{ "tracer", EC_OTHER, EF_NONE, 3, { { "id", PT_INT64, PF_DEC }, { "tags", PT_CHARBUFARRAY, PF_NA }, { "args", PT_CHARBUF_PAIR_ARRAY, PF_NA } } },
+	/* PPME_MESOS_E */{"mesos", EC_INTERNAL, EF_SKIPPARSERESET | EF_MODIFIES_STATE, 1, {{"json", PT_CHARBUF, PF_NA} } },
+	/* PPME_MESOS_X */{"NA4", EC_SYSTEM, EF_UNUSED, 0},
+	/* PPME_CONTAINER_JSON_E */{"container", EC_INTERNAL, EF_SKIPPARSERESET | EF_MODIFIES_STATE, 1, {{"json", PT_CHARBUF, PF_NA} } },
+	/* PPME_CONTAINER_JSON_X */{"container", EC_INTERNAL, EF_UNUSED, 0},
+	/* PPME_SYSCALL_SETSID_E */{"setsid", EC_PROCESS, EF_MODIFIES_STATE, 0},
+	/* PPME_SYSCALL_SETSID_X */{"setsid", EC_PROCESS, EF_MODIFIES_STATE, 1, {{"res", PT_PID, PF_DEC} } },
+	/* PPME_SYSCALL_MKDIR_2_E */{"mkdir", EC_FILE, EF_NONE, 1, {{"mode", PT_UINT32, PF_HEX} } },
+	/* PPME_SYSCALL_MKDIR_2_X */{"mkdir", EC_FILE, EF_NONE, 2, {{"res", PT_ERRNO, PF_DEC}, {"path", PT_FSPATH, PF_NA} } },
+	/* PPME_SYSCALL_RMDIR_2_E */{"rmdir", EC_FILE, EF_NONE, 0},
+	/* PPME_SYSCALL_RMDIR_2_X */{"rmdir", EC_FILE, EF_NONE, 2, {{"res", PT_ERRNO, PF_DEC}, {"path", PT_FSPATH, PF_NA} } },
+	/* PPME_NOTIFICATION_E */{"notification", EC_OTHER, EF_SKIPPARSERESET, 2, {{"id", PT_CHARBUF, PF_DEC}, {"desc", PT_CHARBUF, PF_NA}, } },
+	/* PPME_NOTIFICATION_X */{"NA4", EC_SYSTEM, EF_UNUSED, 0},
+	/* PPME_SYSCALL_EXECVE_17_E */{"execve", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 0},
+	/* PPME_SYSCALL_EXECVE_17_X */{"execve", EC_PROCESS, EF_MODIFIES_STATE | EF_OLD_VERSION, 17, {{"res", PT_ERRNO, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_UINT64, PF_DEC}, {"pgft_maj", PT_UINT64, PF_DEC}, {"pgft_min", PT_UINT64, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC}, {"comm", PT_CHARBUF, PF_NA}, {"cgroups", PT_BYTEBUF, PF_NA}, {"env", PT_BYTEBUF, PF_NA}, {"tty", PT_INT32, PF_DEC} } },
+	/* PPME_SYSCALL_UNSHARE_E */ {"unshare", EC_PROCESS, EF_NONE, 1, {{"flags", PT_FLAGS32, PF_HEX, clone_flags} } },
+	/* PPME_SYSCALL_UNSHARE_X */ {"unshare", EC_PROCESS, EF_NONE, 1, {{"res", PT_ERRNO, PF_DEC} } },
+	/* PPME_INFRASTRUCTURE_EVENT_E */{"infra", EC_INTERNAL, EF_SKIPPARSERESET, 4, {{"source", PT_CHARBUF, PF_DEC}, {"name", PT_CHARBUF, PF_NA}, {"description", PT_CHARBUF, PF_NA}, {"scope", PT_CHARBUF, PF_NA} } },
+	/* PPME_INFRASTRUCTURE_EVENT_X */{"NA4", EC_SYSTEM, EF_UNUSED, 0},
+	/* PPME_SYSCALL_EXECVE_18_E */{"execve", EC_PROCESS, EF_MODIFIES_STATE, 1, {{"filename", PT_FSPATH, PF_NA}} },
+	/* PPME_SYSCALL_EXECVE_18_X */{"execve", EC_PROCESS, EF_MODIFIES_STATE, 17, {{"res", PT_ERRNO, PF_DEC}, {"exe", PT_CHARBUF, PF_NA}, {"args", PT_BYTEBUF, PF_NA}, {"tid", PT_PID, PF_DEC}, {"pid", PT_PID, PF_DEC}, {"ptid", PT_PID, PF_DEC}, {"cwd", PT_CHARBUF, PF_NA}, {"fdlimit", PT_UINT64, PF_DEC}, {"pgft_maj", PT_UINT64, PF_DEC}, {"pgft_min", PT_UINT64, PF_DEC}, {"vm_size", PT_UINT32, PF_DEC}, {"vm_rss", PT_UINT32, PF_DEC}, {"vm_swap", PT_UINT32, PF_DEC}, {"comm", PT_CHARBUF, PF_NA}, {"cgroups", PT_BYTEBUF, PF_NA}, {"env", PT_BYTEBUF, PF_NA}, {"tty", PT_INT32, PF_DEC} } },
+	/* PPME_PAGE_FAULT_E */ {"page_fault", EC_OTHER, EF_SKIPPARSERESET | EF_DROP_FALCO, 3, {{"addr", PT_UINT64, PF_HEX}, {"ip", PT_UINT64, PF_HEX}, {"error", PT_FLAGS32, PF_HEX, pf_flags} } },
+	/* PPME_PAGE_FAULT_X */ {"NA5", EC_OTHER, EF_UNUSED, 0},
+	/* PPME_SYSCALL_BPF_E */{"bpf", EC_OTHER, EF_CREATES_FD, 1, {{"cmd", PT_INT64, PF_DEC} } },
+	/* PPME_SYSCALL_BPF_X */{"bpf", EC_OTHER, EF_CREATES_FD, 1, {{"res", PT_DYN, PF_DEC, bpf_dynamic_param, PPM_BPF_IDX_MAX} }},
+	/* PPME_SYSCALL_SECCOMP_E */{"seccomp", EC_OTHER, EF_NONE, 1, {{"op", PT_UINT64, PF_DEC}, {"flags", PT_UINT64, PF_HEX} } },
+	/* PPME_SYSCALL_SECCOMP_X */{"seccomp", EC_OTHER, EF_NONE, 1, {{"res", PT_ERRNO, PF_DEC} } }
+};
diff --git a/kernel/trace/sysdig/flags_table.c b/kernel/trace/sysdig/flags_table.c
new file mode 100644
index 0000000..46eb794
--- /dev/null
+++ b/kernel/trace/sysdig/flags_table.c
@@ -0,0 +1,436 @@
+/*
+Copyright (C) 2013-2014 Draios inc.
+
+This file is part of sysdig.
+
+sysdig is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License version 2 as
+published by the Free Software Foundation.
+
+sysdig is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with sysdig.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "ppm_events_public.h"
+
+const struct ppm_name_value socket_families[] = {
+	{"AF_NFC", PPM_AF_NFC},
+	{"AF_ALG", PPM_AF_ALG},
+	{"AF_CAIF", PPM_AF_CAIF},
+	{"AF_IEEE802154", PPM_AF_IEEE802154},
+	{"AF_PHONET", PPM_AF_PHONET},
+	{"AF_ISDN", PPM_AF_ISDN},
+	{"AF_RXRPC", PPM_AF_RXRPC},
+	{"AF_IUCV", PPM_AF_IUCV},
+	{"AF_BLUETOOTH", PPM_AF_BLUETOOTH},
+	{"AF_TIPC", PPM_AF_TIPC},
+	{"AF_CAN", PPM_AF_CAN},
+	{"AF_LLC", PPM_AF_LLC},
+	{"AF_WANPIPE", PPM_AF_WANPIPE},
+	{"AF_PPPOX", PPM_AF_PPPOX},
+	{"AF_IRDA", PPM_AF_IRDA},
+	{"AF_SNA", PPM_AF_SNA},
+	{"AF_RDS", PPM_AF_RDS},
+	{"AF_ATMSVC", PPM_AF_ATMSVC},
+	{"AF_ECONET", PPM_AF_ECONET},
+	{"AF_ASH", PPM_AF_ASH},
+	{"AF_PACKET", PPM_AF_PACKET},
+	{"AF_ROUTE", PPM_AF_ROUTE},
+	{"AF_NETLINK", PPM_AF_NETLINK},
+	{"AF_KEY", PPM_AF_KEY},
+	{"AF_SECURITY", PPM_AF_SECURITY},
+	{"AF_NETBEUI", PPM_AF_NETBEUI},
+	{"AF_DECnet", PPM_AF_DECnet},
+	{"AF_ROSE", PPM_AF_ROSE},
+	{"AF_INET6", PPM_AF_INET6},
+	{"AF_X25", PPM_AF_X25},
+	{"AF_ATMPVC", PPM_AF_ATMPVC},
+	{"AF_BRIDGE", PPM_AF_BRIDGE},
+	{"AF_NETROM", PPM_AF_NETROM},
+	{"AF_APPLETALK", PPM_AF_APPLETALK},
+	{"AF_IPX", PPM_AF_IPX},
+	{"AF_AX25", PPM_AF_AX25},
+	{"AF_INET", PPM_AF_INET},
+	{"AF_LOCAL", PPM_AF_LOCAL},
+	{"AF_UNIX", PPM_AF_UNIX},
+	{"AF_UNSPEC", PPM_AF_UNSPEC},
+	{ },
+};
+
+const struct ppm_name_value file_flags[] = {
+	{"O_LARGEFILE", PPM_O_LARGEFILE},
+	{"O_DIRECTORY", PPM_O_DIRECTORY},
+	{"O_DIRECT", PPM_O_DIRECT},
+	{"O_TRUNC", PPM_O_TRUNC},
+	{"O_SYNC", PPM_O_SYNC},
+	{"O_NONBLOCK", PPM_O_NONBLOCK},
+	{"O_EXCL", PPM_O_EXCL},
+	{"O_DSYNC", PPM_O_DSYNC},
+	{"O_APPEND", PPM_O_APPEND},
+	{"O_CREAT", PPM_O_CREAT},
+	{"O_RDWR", PPM_O_RDWR},
+	{"O_WRONLY", PPM_O_WRONLY},
+	{"O_RDONLY", PPM_O_RDONLY},
+	{"O_CLOEXEC", PPM_O_CLOEXEC},
+	{"O_NONE", PPM_O_NONE},
+	{ },
+};
+
+const struct ppm_name_value flock_flags[] = {
+	{"LOCK_SH", PPM_LOCK_SH},
+	{"LOCK_EX", PPM_LOCK_EX},
+	{"LOCK_NB", PPM_LOCK_NB},
+	{"LOCK_UN", PPM_LOCK_UN},
+	{"LOCK_NONE", PPM_LOCK_NONE},
+	{ },
+};
+
+const struct ppm_name_value clone_flags[] = {
+	{"CLONE_FILES", PPM_CL_CLONE_FILES},
+	{"CLONE_FS", PPM_CL_CLONE_FS},
+	{"CLONE_IO", PPM_CL_CLONE_IO},
+	{"CLONE_NEWIPC", PPM_CL_CLONE_NEWIPC},
+	{"CLONE_NEWNET", PPM_CL_CLONE_NEWNET},
+	{"CLONE_NEWNS", PPM_CL_CLONE_NEWNS},
+	{"CLONE_NEWPID", PPM_CL_CLONE_NEWPID},
+	{"CLONE_NEWUTS", PPM_CL_CLONE_NEWUTS},
+	{"CLONE_PARENT", PPM_CL_CLONE_PARENT},
+	{"CLONE_PARENT_SETTID", PPM_CL_CLONE_PARENT_SETTID},
+	{"CLONE_PTRACE", PPM_CL_CLONE_PTRACE},
+	{"CLONE_SIGHAND", PPM_CL_CLONE_SIGHAND},
+	{"CLONE_SYSVSEM", PPM_CL_CLONE_SYSVSEM},
+	{"CLONE_THREAD", PPM_CL_CLONE_THREAD},
+	{"CLONE_UNTRACED", PPM_CL_CLONE_UNTRACED},
+	{"CLONE_VM", PPM_CL_CLONE_VM},
+	{"CLONE_INVERTED", PPM_CL_CLONE_INVERTED},
+	{"NAME_CHANGED", PPM_CL_NAME_CHANGED},
+	{"CLOSED", PPM_CL_CLOSED},
+	{"CLONE_NEWUSER", PPM_CL_CLONE_NEWUSER},
+	{"CLONE_CHILD_CLEARTID", PPM_CL_CLONE_CHILD_CLEARTID},
+	{"CLONE_CHILD_SETTID", PPM_CL_CLONE_CHILD_SETTID},
+	{"CLONE_SETTLS", PPM_CL_CLONE_SETTLS},
+	{"CLONE_STOPPED", PPM_CL_CLONE_STOPPED},
+	{"CLONE_VFORK", PPM_CL_CLONE_VFORK},
+	{"CLONE_NEWCGROUP", PPM_CL_CLONE_NEWCGROUP},
+	{ },
+};
+
+const struct ppm_name_value futex_operations[] = {
+	{"FUTEX_CLOCK_REALTIME", PPM_FU_FUTEX_CLOCK_REALTIME},
+	{"FUTEX_PRIVATE_FLAG", PPM_FU_FUTEX_PRIVATE_FLAG},
+	{"FUTEX_CMP_REQUEUE_PI", PPM_FU_FUTEX_CMP_REQUEUE_PI},
+	{"FUTEX_WAIT_REQUEUE_PI", PPM_FU_FUTEX_WAIT_REQUEUE_PI},
+	{"FUTEX_WAKE_BITSET", PPM_FU_FUTEX_WAKE_BITSET},
+	{"FUTEX_WAIT_BITSET", PPM_FU_FUTEX_WAIT_BITSET},
+	{"FUTEX_TRYLOCK_PI", PPM_FU_FUTEX_TRYLOCK_PI},
+	{"FUTEX_UNLOCK_PI", PPM_FU_FUTEX_UNLOCK_PI},
+	{"FUTEX_LOCK_PI", PPM_FU_FUTEX_LOCK_PI},
+	{"FUTEX_WAKE_OP", PPM_FU_FUTEX_WAKE_OP},
+	{"FUTEX_CMP_REQUEUE", PPM_FU_FUTEX_CMP_REQUEUE},
+	{"FUTEX_REQUEUE", PPM_FU_FUTEX_REQUEUE},
+	{"FUTEX_FD", PPM_FU_FUTEX_FD},
+	{"FUTEX_WAKE", PPM_FU_FUTEX_WAKE},
+	{"FUTEX_WAIT", PPM_FU_FUTEX_WAIT},
+	{ },
+};
+
+const struct ppm_name_value poll_flags[] = {
+	{"POLLIN", PPM_POLLIN},
+	{"POLLPRI", PPM_POLLPRI},
+	{"POLLOUT", PPM_POLLOUT},
+	{"POLLRDHUP", PPM_POLLRDHUP},
+	{"POLLERR", PPM_POLLERR},
+	{"POLLHUP", PPM_POLLHUP},
+	{"POLLNVAL", PPM_POLLNVAL},
+	{"POLLRDNORM", PPM_POLLRDNORM},
+	{"POLLRDBAND", PPM_POLLRDBAND},
+	{"POLLWRNORM", PPM_POLLWRNORM},
+	{"POLLWRBAND", PPM_POLLWRBAND},
+	{ },
+};
+
+/* http://lxr.free-electrons.com/source/include/uapi/linux/fs.h?v=4.2#L65 */
+const struct ppm_name_value mount_flags[] = {
+	{"RDONLY", PPM_MS_RDONLY},
+	{"NOSUID", PPM_MS_NOSUID},
+	{"NODEV", PPM_MS_NODEV},
+	{"NOEXEC", PPM_MS_NOEXEC},
+	{"SYNCHRONOUS", PPM_MS_SYNCHRONOUS},
+	{"REMOUNT", PPM_MS_REMOUNT},
+	{"MANDLOCK", PPM_MS_MANDLOCK},
+	{"DIRSYNC", PPM_MS_DIRSYNC},
+	{"NOATIME", PPM_MS_NOATIME},
+	{"NODIRATIME", PPM_MS_NODIRATIME},
+	{"BIND", PPM_MS_BIND},
+	{"MOVE", PPM_MS_MOVE},
+	{"REC", PPM_MS_REC},
+	{"SILENT", PPM_MS_SILENT},
+	{"POSIXACL", PPM_MS_POSIXACL},
+	{"UNBINDABLE", PPM_MS_UNBINDABLE},
+	{"PRIVATE", PPM_MS_PRIVATE},
+	{"SLAVE", PPM_MS_SLAVE},
+	{"SHARED", PPM_MS_SHARED},
+	{"RELATIME", PPM_MS_RELATIME},
+	{"KERNMOUNT", PPM_MS_KERNMOUNT},
+	{"I_VERSION", PPM_MS_I_VERSION},
+	{"STRICTATIME", PPM_MS_STRICTATIME},
+	{"LAZYTIME", PPM_MS_LAZYTIME},
+	{"NOSEC", PPM_MS_NOSEC},
+	{"BORN", PPM_MS_BORN},
+	{"ACTIVE", PPM_MS_ACTIVE},
+	{"NOUSER", PPM_MS_NOUSER},
+	{ },
+};
+
+/* http://lxr.free-electrons.com/source/include/linux/fs.h?v=4.2#L1251 */
+const struct ppm_name_value umount_flags[] = {
+	{"FORCE", PPM_MNT_FORCE},
+	{"DETACH", PPM_MNT_DETACH},
+	{"EXPIRE", PPM_MNT_EXPIRE},
+	{"NOFOLLOW", PPM_UMOUNT_NOFOLLOW},
+	{ },
+};
+
+const struct ppm_name_value lseek_whence[] = {
+	{"SEEK_END", PPM_SEEK_END},
+	{"SEEK_CUR", PPM_SEEK_CUR},
+	{"SEEK_SET", PPM_SEEK_SET},
+	{ },
+};
+
+const struct ppm_name_value shutdown_how[] = {
+	{"SHUT_RDWR", PPM_SHUT_RDWR},
+	{"SHUT_WR", PPM_SHUT_WR},
+	{"SHUT_RD", PPM_SHUT_RD},
+	{ },
+};
+
+const struct ppm_name_value rlimit_resources[] = {
+	{"RLIMIT_UNKNOWN", PPM_RLIMIT_UNKNOWN},
+	{"RLIMIT_RTTIME", PPM_RLIMIT_RTTIME},
+	{"RLIMIT_RTPRIO", PPM_RLIMIT_RTPRIO},
+	{"RLIMIT_NICE", PPM_RLIMIT_NICE},
+	{"RLIMIT_MSGQUEUE", PPM_RLIMIT_MSGQUEUE},
+	{"RLIMIT_SIGPENDING", PPM_RLIMIT_SIGPENDING},
+	{"RLIMIT_LOCKS", PPM_RLIMIT_LOCKS},
+	{"RLIMIT_AS", PPM_RLIMIT_AS},
+	{"RLIMIT_MEMLOCK", PPM_RLIMIT_MEMLOCK},
+	{"RLIMIT_NOFILE", PPM_RLIMIT_NOFILE},
+	{"RLIMIT_NPROC", PPM_RLIMIT_NPROC},
+	{"RLIMIT_RSS", PPM_RLIMIT_RSS},
+	{"RLIMIT_CORE", PPM_RLIMIT_CORE},
+	{"RLIMIT_STACK", PPM_RLIMIT_STACK},
+	{"RLIMIT_DATA", PPM_RLIMIT_DATA},
+	{"RLIMIT_FSIZE", PPM_RLIMIT_FSIZE},
+	{"RLIMIT_CPU", PPM_RLIMIT_CPU},
+	{ },
+};
+
+const struct ppm_name_value fcntl_commands[] = {
+	{"F_GETPIPE_SZ", PPM_FCNTL_F_GETPIPE_SZ},
+	{"F_SETPIPE_SZ", PPM_FCNTL_F_SETPIPE_SZ},
+	{"F_NOTIFY", PPM_FCNTL_F_NOTIFY},
+	{"F_DUPFD_CLOEXEC", PPM_FCNTL_F_DUPFD_CLOEXEC},
+	{"F_CANCELLK", PPM_FCNTL_F_CANCELLK},
+	{"F_GETLEASE", PPM_FCNTL_F_GETLEASE},
+	{"F_SETLEASE", PPM_FCNTL_F_SETLEASE},
+	{"F_GETOWN_EX", PPM_FCNTL_F_GETOWN_EX},
+	{"F_SETOWN_EX", PPM_FCNTL_F_SETOWN_EX},
+#ifndef CONFIG_64BIT
+	{"F_SETLKW64", PPM_FCNTL_F_SETLKW64},
+	{"F_SETLK64", PPM_FCNTL_F_SETLK64},
+	{"F_GETLK64", PPM_FCNTL_F_GETLK64},
+#endif
+	{"F_GETSIG", PPM_FCNTL_F_GETSIG},
+	{"F_SETSIG", PPM_FCNTL_F_SETSIG},
+	{"F_GETOWN", PPM_FCNTL_F_GETOWN},
+	{"F_SETOWN", PPM_FCNTL_F_SETOWN},
+	{"F_SETLKW", PPM_FCNTL_F_SETLKW},
+	{"F_SETLK", PPM_FCNTL_F_SETLK},
+	{"F_GETLK", PPM_FCNTL_F_GETLK},
+	{"F_SETFL", PPM_FCNTL_F_SETFL},
+	{"F_GETFL", PPM_FCNTL_F_GETFL},
+	{"F_SETFD", PPM_FCNTL_F_SETFD},
+	{"F_GETFD", PPM_FCNTL_F_GETFD},
+	{"F_DUPFD", PPM_FCNTL_F_DUPFD},
+	{"F_OFD_GETLK", PPM_FCNTL_F_OFD_GETLK},
+	{"F_OFD_SETLK", PPM_FCNTL_F_OFD_SETLK},
+	{"F_OFD_SETLKW", PPM_FCNTL_F_OFD_SETLKW},
+	{"UNKNOWN", PPM_FCNTL_UNKNOWN},
+	{ },
+};
+
+const struct ppm_name_value ptrace_requests[] = {
+	{"PTRACE_SINGLEBLOCK", PPM_PTRACE_SINGLEBLOCK},
+	{"PTRACE_SYSEMU_SINGLESTEP", PPM_PTRACE_SYSEMU_SINGLESTEP},
+	{"PTRACE_SYSEMU", PPM_PTRACE_SYSEMU},
+	{"PTRACE_ARCH_PRCTL", PPM_PTRACE_ARCH_PRCTL},
+	{"PTRACE_SET_THREAD_AREA", PPM_PTRACE_SET_THREAD_AREA},
+	{"PTRACE_GET_THREAD_AREA", PPM_PTRACE_GET_THREAD_AREA},
+	{"PTRACE_OLDSETOPTIONS", PPM_PTRACE_OLDSETOPTIONS},
+	{"PTRACE_SETFPXREGS", PPM_PTRACE_SETFPXREGS},
+	{"PTRACE_GETFPXREGS", PPM_PTRACE_GETFPXREGS},
+	{"PTRACE_SETFPREGS", PPM_PTRACE_SETFPREGS},
+	{"PTRACE_GETFPREGS", PPM_PTRACE_GETFPREGS},
+	{"PTRACE_SETREGS", PPM_PTRACE_SETREGS},
+	{"PTRACE_GETREGS", PPM_PTRACE_GETREGS},
+	{"PTRACE_SETSIGMASK", PPM_PTRACE_SETSIGMASK},
+	{"PTRACE_GETSIGMASK", PPM_PTRACE_GETSIGMASK},
+	{"PTRACE_PEEKSIGINFO", PPM_PTRACE_PEEKSIGINFO},
+	{"PTRACE_LISTEN", PPM_PTRACE_LISTEN},
+	{"PTRACE_INTERRUPT", PPM_PTRACE_INTERRUPT},
+	{"PTRACE_SEIZE", PPM_PTRACE_SEIZE},
+	{"PTRACE_SETREGSET", PPM_PTRACE_SETREGSET},
+	{"PTRACE_GETREGSET", PPM_PTRACE_GETREGSET},
+	{"PTRACE_SETSIGINFO", PPM_PTRACE_SETSIGINFO},
+	{"PTRACE_GETSIGINFO", PPM_PTRACE_GETSIGINFO},
+	{"PTRACE_GETEVENTMSG", PPM_PTRACE_GETEVENTMSG},
+	{"PTRACE_SETOPTIONS", PPM_PTRACE_SETOPTIONS},
+	{"PTRACE_SYSCALL", PPM_PTRACE_SYSCALL},
+	{"PTRACE_DETACH", PPM_PTRACE_DETACH},
+	{"PTRACE_ATTACH", PPM_PTRACE_ATTACH},
+	{"PTRACE_SINGLESTEP", PPM_PTRACE_SINGLESTEP},
+	{"PTRACE_KILL", PPM_PTRACE_KILL},
+	{"PTRACE_CONT", PPM_PTRACE_CONT},
+	{"PTRACE_POKEUSR", PPM_PTRACE_POKEUSR},
+	{"PTRACE_POKEDATA", PPM_PTRACE_POKEDATA},
+	{"PTRACE_POKETEXT", PPM_PTRACE_POKETEXT},
+	{"PTRACE_PEEKUSR", PPM_PTRACE_PEEKUSR},
+	{"PTRACE_PEEKDATA", PPM_PTRACE_PEEKDATA},
+	{"PTRACE_PEEKTEXT", PPM_PTRACE_PEEKTEXT},
+	{"PTRACE_TRACEME", PPM_PTRACE_TRACEME},
+	{"PTRACE_UNKNOWN", PPM_PTRACE_UNKNOWN},
+	{ },
+};
+
+const struct ppm_name_value prot_flags[] = {
+	{"PROT_READ", PPM_PROT_READ},
+	{"PROT_WRITE", PPM_PROT_WRITE},
+	{"PROT_EXEC", PPM_PROT_EXEC},
+	{"PROT_SEM", PPM_PROT_SEM},
+	{"PROT_GROWSDOWN", PPM_PROT_GROWSDOWN},
+	{"PROT_GROWSUP", PPM_PROT_GROWSUP},
+	{"PROT_SAO", PPM_PROT_SAO},
+	{"PROT_NONE", PPM_PROT_NONE},
+	{ },
+};
+
+const struct ppm_name_value mmap_flags[] = {
+	{"MAP_SHARED", PPM_MAP_SHARED},
+	{"MAP_PRIVATE", PPM_MAP_PRIVATE},
+	{"MAP_FIXED", PPM_MAP_FIXED},
+	{"MAP_ANONYMOUS", PPM_MAP_ANONYMOUS},
+	{"MAP_32BIT", PPM_MAP_32BIT},
+	{"MAP_RENAME", PPM_MAP_RENAME},
+	{"MAP_NORESERVE", PPM_MAP_NORESERVE},
+	{"MAP_POPULATE", PPM_MAP_POPULATE},
+	{"MAP_NONBLOCK", PPM_MAP_NONBLOCK},
+	{"MAP_GROWSDOWN", PPM_MAP_GROWSDOWN},
+	{"MAP_DENYWRITE", PPM_MAP_DENYWRITE},
+	{"MAP_EXECUTABLE", PPM_MAP_EXECUTABLE},
+	{"MAP_INHERIT", PPM_MAP_INHERIT},
+	{"MAP_FILE", PPM_MAP_FILE},
+	{"MAP_LOCKED", PPM_MAP_LOCKED},
+	{ },
+};
+
+const struct ppm_name_value splice_flags[] = {
+	{"SPLICE_F_MOVE", PPM_SPLICE_F_MOVE},
+	{"SPLICE_F_NONBLOCK", PPM_SPLICE_F_NONBLOCK},
+	{"SPLICE_F_MORE", PPM_SPLICE_F_MORE},
+	{"SPLICE_F_GIFT", PPM_SPLICE_F_GIFT},
+	{ },
+};
+
+const struct ppm_name_value quotactl_dqi_flags[] = {
+	{"DQF_NONE", PPM_DQF_NONE},
+	{"V1_DQF_RSQUASH", PPM_V1_DQF_RSQUASH},
+	{ }
+};
+
+const struct ppm_name_value quotactl_cmds[] = {
+	{"Q_QUOTAON", PPM_Q_QUOTAON},
+	{"Q_QUOTAOFF", PPM_Q_QUOTAOFF},
+	{"Q_GETFMT", PPM_Q_GETFMT},
+	{"Q_GETINFO", PPM_Q_GETINFO},
+	{"Q_SETINFO", PPM_Q_SETINFO},
+	{"Q_GETQUOTA", PPM_Q_GETQUOTA},
+	{"Q_SETQUOTA", PPM_Q_SETQUOTA},
+	{"Q_SYNC", PPM_Q_SYNC},
+	{"Q_XQUOTAON", PPM_Q_XQUOTAON},
+	{"Q_XQUOTAOFF", PPM_Q_XQUOTAOFF},
+	{"Q_XGETQUOTA", PPM_Q_XGETQUOTA},
+	{"Q_XSETQLIM", PPM_Q_XSETQLIM},
+	{"Q_XGETQSTAT", PPM_Q_XGETQSTAT},
+	{"Q_XQUOTARM", PPM_Q_XQUOTARM},
+	{"Q_XQUOTASYNC", PPM_Q_XQUOTASYNC},
+	{ },
+};
+
+const struct ppm_name_value quotactl_types[] = {
+	{"USRQUOTA", PPM_USRQUOTA},
+	{"GRPQUOTA", PPM_GRPQUOTA},
+	{ },
+};
+
+const struct ppm_name_value quotactl_quota_fmts[] = {
+	{"QFMT_NOT_USED", PPM_QFMT_NOT_USED},
+	{"QFMT_VFS_OLD", PPM_QFMT_VFS_OLD},
+	{"QFMT_VFS_V0", PPM_QFMT_VFS_V0},
+	{"QFMT_VFS_V1", PPM_QFMT_VFS_V1},
+	{ }
+};
+
+const struct ppm_name_value semop_flags[] = {
+	{"IPC_NOWAIT", PPM_IPC_NOWAIT},
+	{"SEM_UNDO", PPM_SEM_UNDO},
+	{ },
+};
+
+const struct ppm_name_value semget_flags[] = {
+	{"IPC_EXCL", PPM_IPC_EXCL},
+	{"IPC_CREAT", PPM_IPC_CREAT},
+	{ },
+};
+
+const struct ppm_name_value semctl_commands[] = {
+	{"IPC_STAT", PPM_IPC_STAT},
+	{"IPC_SET", PPM_IPC_SET},
+	{"IPC_RMID", PPM_IPC_RMID},
+	{"IPC_INFO", PPM_IPC_INFO},
+	{"SEM_INFO", PPM_SEM_INFO},
+	{"SEM_STAT", PPM_SEM_STAT},
+	{"GETALL", PPM_GETALL},
+	{"GETNCNT", PPM_GETNCNT},
+	{"GETPID", PPM_GETPID},
+	{"GETVAL", PPM_GETVAL},
+	{"GETZCNT", PPM_GETZCNT},
+	{"SETALL", PPM_SETALL},
+	{"SETVAL", PPM_SETVAL},
+	{ },
+};
+
+const struct ppm_name_value access_flags[] = {
+	{"F_OK", PPM_F_OK},
+	{"R_OK", PPM_R_OK},
+	{"W_OK", PPM_W_OK},
+	{"X_OK", PPM_X_OK},
+	{ },
+};
+
+const struct ppm_name_value pf_flags[] = {
+	{"PROTECTION_VIOLATION", PPM_PF_PROTECTION_VIOLATION},
+	{"PAGE_NOT_PRESENT", PPM_PF_PAGE_NOT_PRESENT},
+	{"WRITE_ACCESS", PPM_PF_WRITE_ACCESS},
+	{"READ_ACCESS", PPM_PF_READ_ACCESS},
+	{"USER_FAULT", PPM_PF_USER_FAULT},
+	{"SUPERVISOR_FAULT", PPM_PF_SUPERVISOR_FAULT},
+	{"RESERVED_PAGE", PPM_PF_RESERVED_PAGE},
+	{"INSTRUCTION_FETCH", PPM_PF_INSTRUCTION_FETCH},
+	{ },
+};
diff --git a/kernel/trace/sysdig/main.c b/kernel/trace/sysdig/main.c
new file mode 100644
index 0000000..07f3054
--- /dev/null
+++ b/kernel/trace/sysdig/main.c
@@ -0,0 +1,2535 @@
+/*
+Copyright (C) 2013-2014 Draios inc.
+
+This file is part of sysdig.
+
+sysdig is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License version 2 as
+published by the Free Software Foundation.
+
+sysdig is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with sysdig.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#define pr_fmt(fmt)	KBUILD_MODNAME ": " fmt
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 20)
+#include <linux/kobject.h>
+#include <trace/sched.h>
+#include "ppm_syscall.h"
+#include <trace/syscall.h>
+#else
+#include <asm/syscall.h>
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
+#include <asm/atomic.h>
+#else
+#include <linux/atomic.h>
+#endif
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/kdev_t.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 11, 0))
+#include <linux/sched.h>
+#else
+#include <linux/sched/signal.h>
+#include <linux/sched/cputime.h>
+#endif
+#include <linux/vmalloc.h>
+#include <linux/wait.h>
+#include <linux/tracepoint.h>
+#include <linux/cpu.h>
+#include <linux/jiffies.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#include <linux/file.h>
+#else
+#include <linux/fdtable.h>
+#endif
+#include <net/sock.h>
+#include <asm/asm-offsets.h>	/* For NR_syscalls */
+#include <asm/unistd.h>
+
+#include "driver_config.h"
+#include "ppm_ringbuffer.h"
+#include "ppm_events_public.h"
+#include "ppm_events.h"
+#include "ppm.h"
+#if defined(CONFIG_IA32_EMULATION) && !defined(__NR_ia32_socketcall)
+#include "ppm_compat_unistd_32.h"
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("sysdig inc");
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35))
+    #define TRACEPOINT_PROBE_REGISTER(p1, p2) tracepoint_probe_register(p1, p2)
+    #define TRACEPOINT_PROBE_UNREGISTER(p1, p2) tracepoint_probe_unregister(p1, p2)
+    #define TRACEPOINT_PROBE(probe, args...) static void probe(args)
+#else
+    #define TRACEPOINT_PROBE_REGISTER(p1, p2) tracepoint_probe_register(p1, p2, NULL)
+    #define TRACEPOINT_PROBE_UNREGISTER(p1, p2) tracepoint_probe_unregister(p1, p2, NULL)
+    #define TRACEPOINT_PROBE(probe, args...) static void probe(void *__data, args)
+#endif
+
+struct ppm_device {
+	dev_t dev;
+	struct cdev cdev;
+	wait_queue_head_t read_queue;
+};
+
+struct event_data_t {
+	enum ppm_capture_category category;
+	int socketcall_syscall;
+	bool compat;
+
+	union {
+		struct {
+			struct pt_regs *regs;
+			long id;
+			const enum ppm_syscall_code *cur_g_syscall_code_routing_table;
+		} syscall_data;
+
+		struct {
+			struct task_struct *sched_prev;
+			struct task_struct *sched_next;
+		} context_data;
+
+		struct {
+			int sig;
+			struct siginfo *info;
+			struct k_sigaction *ka;
+		} signal_data;
+
+		struct fault_data_t fault_data;
+	} event_info;
+};
+
+/*
+ * FORWARD DECLARATIONS
+ */
+static int ppm_open(struct inode *inode, struct file *filp);
+static int ppm_release(struct inode *inode, struct file *filp);
+static long ppm_ioctl(struct file *f, unsigned int cmd, unsigned long arg);
+static int ppm_mmap(struct file *filp, struct vm_area_struct *vma);
+static int record_event_consumer(struct ppm_consumer_t *consumer,
+	enum ppm_event_type event_type,
+	enum syscall_flags drop_flags,
+	struct timespec *ts,
+	struct event_data_t *event_datap);
+static void record_event_all_consumers(enum ppm_event_type event_type,
+	enum syscall_flags drop_flags,
+	struct event_data_t *event_datap);
+static int init_ring_buffer(struct ppm_ring_buffer_context *ring);
+static void free_ring_buffer(struct ppm_ring_buffer_context *ring);
+static void reset_ring_buffer(struct ppm_ring_buffer_context *ring);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0))
+void ppm_task_cputime_adjusted(struct task_struct *p, cputime_t *ut, cputime_t *st);
+#endif
+
+#ifndef CONFIG_HAVE_SYSCALL_TRACEPOINTS
+ #error The kernel must have HAVE_SYSCALL_TRACEPOINTS in order for sysdig to be useful
+#endif
+
+TRACEPOINT_PROBE(syscall_enter_probe, struct pt_regs *regs, long id);
+TRACEPOINT_PROBE(syscall_exit_probe, struct pt_regs *regs, long ret);
+TRACEPOINT_PROBE(syscall_procexit_probe, struct task_struct *p);
+#ifdef CAPTURE_CONTEXT_SWITCHES
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35))
+TRACEPOINT_PROBE(sched_switch_probe, struct rq *rq, struct task_struct *prev, struct task_struct *next);
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0))
+TRACEPOINT_PROBE(sched_switch_probe, struct task_struct *prev, struct task_struct *next);
+#else
+TRACEPOINT_PROBE(sched_switch_probe, bool preempt, struct task_struct *prev, struct task_struct *next);
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)) */
+#endif /* CAPTURE_CONTEXT_SWITCHES */
+
+#ifdef CAPTURE_SIGNAL_DELIVERIES
+TRACEPOINT_PROBE(signal_deliver_probe, int sig, struct siginfo *info, struct k_sigaction *ka);
+#endif
+
+#ifdef CAPTURE_PAGE_FAULTS
+TRACEPOINT_PROBE(page_fault_probe, unsigned long address, struct pt_regs *regs, unsigned long error_code);
+#endif
+
+DECLARE_BITMAP(g_events_mask, PPM_EVENT_MAX);
+static struct ppm_device *g_ppm_devs;
+static struct class *g_ppm_class;
+static unsigned int g_ppm_numdevs;
+static int g_ppm_major;
+bool g_tracers_enabled = false;
+bool g_simple_mode_enabled = false;
+static DEFINE_PER_CPU(long, g_n_tracepoint_hit);
+static const struct file_operations g_ppm_fops = {
+	.open = ppm_open,
+	.release = ppm_release,
+	.mmap = ppm_mmap,
+	.unlocked_ioctl = ppm_ioctl,
+	.owner = THIS_MODULE,
+};
+
+/*
+ * GLOBALS
+ */
+LIST_HEAD(g_consumer_list);
+static DEFINE_MUTEX(g_consumer_mutex);
+static bool g_tracepoint_registered;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+static struct tracepoint *tp_sys_enter;
+static struct tracepoint *tp_sys_exit;
+#endif
+
+static struct tracepoint *tp_sched_process_exit;
+#ifdef CAPTURE_CONTEXT_SWITCHES
+static struct tracepoint *tp_sched_switch;
+#endif
+#ifdef CAPTURE_SIGNAL_DELIVERIES
+static struct tracepoint *tp_signal_deliver;
+#endif
+#ifdef CAPTURE_PAGE_FAULTS
+// Even in kernels that can support page fault tracepoints, tracepoints may be
+// disabled so check if g_fault_tracepoint_disabled is set.
+static struct tracepoint *tp_page_fault_user;
+static struct tracepoint *tp_page_fault_kernel;
+static bool g_fault_tracepoint_registered;
+static bool g_fault_tracepoint_disabled;
+#endif
+
+#ifdef _DEBUG
+static bool verbose = 1;
+#else
+static bool verbose = 0;
+#endif
+
+static unsigned int max_consumers = 5;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
+static enum cpuhp_state hp_state = 0;
+#endif
+
+#define vpr_info(fmt, ...)					\
+do {								\
+	if (verbose)						\
+		pr_info(fmt, ##__VA_ARGS__);			\
+} while (0)
+
+/* compat tracepoint functions */
+static int compat_register_trace(void *func, const char *probename, struct tracepoint *tp)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0))
+	return TRACEPOINT_PROBE_REGISTER(probename, func);
+#else
+	return tracepoint_probe_register(tp, func, NULL);
+#endif
+}
+
+static void compat_unregister_trace(void *func, const char *probename, struct tracepoint *tp)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0))
+	TRACEPOINT_PROBE_UNREGISTER(probename, func);
+#else
+	tracepoint_probe_unregister(tp, func, NULL);
+#endif
+}
+
+static struct ppm_consumer_t *ppm_find_consumer(struct task_struct *consumer_id)
+{
+	struct ppm_consumer_t *el = NULL;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(el, &g_consumer_list, node) {
+		if (el->consumer_id == consumer_id) {
+			rcu_read_unlock();
+			return el;
+		}
+	}
+	rcu_read_unlock();
+
+	return NULL;
+}
+
+static void check_remove_consumer(struct ppm_consumer_t *consumer, int remove_from_list)
+{
+	int cpu;
+	int open_rings = 0;
+
+	for_each_possible_cpu(cpu) {
+		struct ppm_ring_buffer_context *ring = per_cpu_ptr(consumer->ring_buffers, cpu);
+
+		if (ring && ring->open)
+			++open_rings;
+	}
+
+	if (open_rings == 0) {
+		pr_info("deallocating consumer %p\n", consumer->consumer_id);
+
+		if (remove_from_list) {
+			list_del_rcu(&consumer->node);
+			synchronize_rcu();
+		}
+
+		for_each_possible_cpu(cpu) {
+			struct ppm_ring_buffer_context *ring = per_cpu_ptr(consumer->ring_buffers, cpu);
+			free_ring_buffer(ring);
+		}
+
+		free_percpu(consumer->ring_buffers);
+
+		vfree(consumer);
+	}
+}
+
+/*
+ * user I/O functions
+ */
+static int ppm_open(struct inode *inode, struct file *filp)
+{
+	int ret;
+	int in_list = false;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+	int ring_no = iminor(filp->f_path.dentry->d_inode);
+#else
+	int ring_no = iminor(filp->f_dentry->d_inode);
+#endif
+	struct task_struct *consumer_id = current;
+	struct ppm_consumer_t *consumer = NULL;
+	struct ppm_ring_buffer_context *ring = NULL;
+
+	/*
+	 * Tricky: to identify a consumer, attach the thread id
+	 * to the newly open file descriptor
+	 */
+	filp->private_data = consumer_id;
+
+	mutex_lock(&g_consumer_mutex);
+
+	consumer = ppm_find_consumer(consumer_id);
+	if (!consumer) {
+		unsigned int cpu;
+		unsigned int num_consumers = 0;
+		struct ppm_consumer_t *el = NULL;
+
+		rcu_read_lock();
+		list_for_each_entry_rcu(el, &g_consumer_list, node) {
+			++num_consumers;
+		}
+		rcu_read_unlock();
+
+		if (num_consumers >= max_consumers) {
+			pr_err("maximum number of consumers reached\n");
+			ret = -EBUSY;
+			goto cleanup_open;
+		}
+
+		pr_info("adding new consumer %p\n", consumer_id);
+
+		consumer = vmalloc(sizeof(struct ppm_consumer_t));
+		if (!consumer) {
+			pr_err("can't allocate consumer\n");
+			ret = -ENOMEM;
+			goto cleanup_open;
+		}
+
+		consumer->consumer_id = consumer_id;
+
+		/*
+		 * Initialize the ring buffers array
+		 */
+		consumer->ring_buffers = alloc_percpu(struct ppm_ring_buffer_context);
+		if (consumer->ring_buffers == NULL) {
+			pr_err("can't allocate the ring buffer array\n");
+
+			vfree(consumer);
+
+			ret = -ENOMEM;
+			goto cleanup_open;
+		}
+
+		/*
+		 * Note, we have two loops here because the first one makes sure that ALL of the
+		 * rings are properly initialized to null, since the second one could be interrupted
+		 * and cause issues in the cleanup phase.
+		 * This might not be necessary, because alloc_percpu memsets the allocated entries to
+		 * 0, but better be extra safe.
+		 */
+		for_each_possible_cpu(cpu) {
+			ring = per_cpu_ptr(consumer->ring_buffers, cpu);
+
+			ring->cpu_online = false;
+			ring->str_storage = NULL;
+			ring->buffer = NULL;
+			ring->info = NULL;
+		}
+
+		/*
+		 * If a cpu is offline when the consumer is first created, we
+		 * will never get events for that cpu even if it later comes
+		 * online via hotplug. We could allocate these rings on-demand
+		 * later in this function if needed for hotplug, but that
+		 * requires the consumer to know to call open again, and sysdig
+		 * doesn't support that.
+		 */
+		for_each_online_cpu(cpu) {
+			ring = per_cpu_ptr(consumer->ring_buffers, cpu);
+
+			pr_info("initializing ring buffer for CPU %u\n", cpu);
+
+			if (!init_ring_buffer(ring)) {
+				pr_err("can't initialize the ring buffer for CPU %u\n", cpu);
+				ret = -ENOMEM;
+				goto err_init_ring_buffer;
+			}
+
+			ring->cpu_online = true;
+		}
+
+		list_add_rcu(&consumer->node, &g_consumer_list);
+		in_list = true;
+	} else {
+		vpr_info("found already existent consumer %p\n", consumer_id);
+	}
+
+	ring = per_cpu_ptr(consumer->ring_buffers, ring_no);
+
+	/*
+	 * Check if the CPU pointed by this device is online. If it isn't stop here and
+	 * return ENODEV. The cpu could be online while buffer is NULL if there's a cpu
+	 * online hotplug callback between the first open on this consumer and the open
+	 * for this particular device.
+	 */
+	if (ring->cpu_online == false || ring->buffer == NULL) {
+		ret = -ENODEV;
+		goto cleanup_open;
+	}
+
+	if (ring->open) {
+		pr_err("invalid operation: attempting to open device %d multiple times for consumer %p\n", ring_no, consumer->consumer_id);
+		ret = -EBUSY;
+		goto cleanup_open;
+	}
+
+	vpr_info("opening ring %d, consumer %p\n", ring_no, consumer->consumer_id);
+
+	/*
+	 * ring->preempt_count is not reset to 0 on purpose, to prevent a race condition:
+	 * if the same device is quickly closed and then reopened, record_event() might still be executing
+	 * (with ring->preempt_count to 1) while ppm_open() resets ring->preempt_count to 0.
+	 * When record_event() will exit, it will decrease
+	 * ring->preempt_count which will become < 0, leading to the complete loss of all the events for that CPU.
+	 */
+	consumer->dropping_mode = 0;
+	consumer->snaplen = RW_SNAPLEN;
+	consumer->sampling_ratio = 1;
+	consumer->sampling_interval = 0;
+	consumer->is_dropping = 0;
+	consumer->do_dynamic_snaplen = false;
+	consumer->need_to_insert_drop_e = 0;
+	consumer->need_to_insert_drop_x = 0;
+	bitmap_fill(g_events_mask, PPM_EVENT_MAX); /* Enable all syscall to be passed to userspace */
+	reset_ring_buffer(ring);
+	ring->open = true;
+
+	if (!g_tracepoint_registered) {
+		pr_info("starting capture\n");
+		/*
+		 * Enable the tracepoints
+		 */
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+		ret = compat_register_trace(syscall_exit_probe, "sys_exit", tp_sys_exit);
+#else
+		ret = register_trace_syscall_exit(syscall_exit_probe);
+#endif
+		if (ret) {
+			pr_err("can't create the sys_exit tracepoint\n");
+			goto err_sys_exit;
+		}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+		ret = compat_register_trace(syscall_enter_probe, "sys_enter", tp_sys_enter);
+#else
+		ret = register_trace_syscall_enter(syscall_enter_probe);
+#endif
+		if (ret) {
+			pr_err("can't create the sys_enter tracepoint\n");
+			goto err_sys_enter;
+		}
+
+		ret = compat_register_trace(syscall_procexit_probe, "sched_process_exit", tp_sched_process_exit);
+		if (ret) {
+			pr_err("can't create the sched_process_exit tracepoint\n");
+			goto err_sched_procexit;
+		}
+
+#ifdef CAPTURE_CONTEXT_SWITCHES
+		ret = compat_register_trace(sched_switch_probe, "sched_switch", tp_sched_switch);
+		if (ret) {
+			pr_err("can't create the sched_switch tracepoint\n");
+			goto err_sched_switch;
+		}
+#endif
+
+#ifdef CAPTURE_SIGNAL_DELIVERIES
+		ret = compat_register_trace(signal_deliver_probe, "signal_deliver", tp_signal_deliver);
+		if (ret) {
+			pr_err("can't create the signal_deliver tracepoint\n");
+			goto err_signal_deliver;
+		}
+#endif
+		g_tracepoint_registered = true;
+	}
+
+	ret = 0;
+
+	goto cleanup_open;
+
+#ifdef CAPTURE_SIGNAL_DELIVERIES
+err_signal_deliver:
+	compat_unregister_trace(sched_switch_probe, "sched_switch", tp_sched_switch);
+#endif
+err_sched_switch:
+	compat_unregister_trace(syscall_procexit_probe, "sched_process_exit", tp_sched_process_exit);
+err_sched_procexit:
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+	compat_unregister_trace(syscall_enter_probe, "sys_enter", tp_sys_enter);
+#else
+	unregister_trace_syscall_enter(syscall_enter_probe);
+#endif
+err_sys_enter:
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+	compat_unregister_trace(syscall_exit_probe, "sys_exit", tp_sys_exit);
+#else
+	unregister_trace_syscall_exit(syscall_exit_probe);
+#endif
+err_sys_exit:
+	ring->open = false;
+err_init_ring_buffer:
+	check_remove_consumer(consumer, in_list);
+cleanup_open:
+	mutex_unlock(&g_consumer_mutex);
+
+	return ret;
+}
+
+static int ppm_release(struct inode *inode, struct file *filp)
+{
+	int cpu;
+	int ret;
+	struct ppm_ring_buffer_context *ring;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+	int ring_no = iminor(filp->f_path.dentry->d_inode);
+#else
+	int ring_no = iminor(filp->f_dentry->d_inode);
+#endif
+	struct task_struct *consumer_id = filp->private_data;
+	struct ppm_consumer_t *consumer = NULL;
+
+	mutex_lock(&g_consumer_mutex);
+
+	consumer = ppm_find_consumer(consumer_id);
+	if (!consumer) {
+		pr_err("release: unknown consumer %p\n", consumer_id);
+		ret = -EBUSY;
+		goto cleanup_release;
+	}
+
+	ring = per_cpu_ptr(consumer->ring_buffers, ring_no);
+	if (!ring) {
+		ASSERT(false);
+		ret = -ENODEV;
+		goto cleanup_release;
+	}
+
+	if (!ring->open) {
+		pr_err("attempting to close unopened device %d for consumer %p\n", ring_no, consumer_id);
+		ret = -EBUSY;
+		goto cleanup_release;
+	}
+
+	ring->capture_enabled = false;
+
+	vpr_info("closing ring %d, consumer:%p evt:%llu, dr_buf:%llu, dr_pf:%llu, pr:%llu, cs:%llu\n",
+	       ring_no,
+	       consumer_id,
+	       ring->info->n_evts,
+	       ring->info->n_drops_buffer,
+	       ring->info->n_drops_pf,
+	       ring->info->n_preemptions,
+	       ring->info->n_context_switches);
+
+	ring->open = false;
+
+	check_remove_consumer(consumer, true);
+
+	/*
+	 * The last closed device stops event collection
+	 */
+	if (list_empty(&g_consumer_list)) {
+		if (g_tracepoint_registered) {
+			pr_info("no more consumers, stopping capture\n");
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+			compat_unregister_trace(syscall_exit_probe, "sys_exit", tp_sys_exit);
+			compat_unregister_trace(syscall_enter_probe, "sys_enter", tp_sys_enter);
+#else
+			unregister_trace_syscall_exit(syscall_exit_probe);
+			unregister_trace_syscall_enter(syscall_enter_probe);
+#endif
+			compat_unregister_trace(syscall_procexit_probe, "sched_process_exit", tp_sched_process_exit);
+
+#ifdef CAPTURE_CONTEXT_SWITCHES
+			compat_unregister_trace(sched_switch_probe, "sched_switch", tp_sched_switch);
+#endif
+#ifdef CAPTURE_SIGNAL_DELIVERIES
+			compat_unregister_trace(signal_deliver_probe, "signal_deliver", tp_signal_deliver);
+#endif
+#ifdef CAPTURE_PAGE_FAULTS
+			if (g_fault_tracepoint_registered) {
+				compat_unregister_trace(page_fault_probe, "page_fault_user", tp_page_fault_user);
+				compat_unregister_trace(page_fault_probe, "page_fault_kernel", tp_page_fault_kernel);
+
+				g_fault_tracepoint_registered = false;
+			}
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+			tracepoint_synchronize_unregister();
+#endif
+			g_tracepoint_registered = false;
+
+			/*
+			 * While we're here, disable simple mode if it's active
+			 */
+			g_simple_mode_enabled = false;
+
+			/*
+			 * Reset tracepoint counter
+			 */
+			for_each_possible_cpu(cpu) {
+				per_cpu(g_n_tracepoint_hit, cpu) = 0;
+			}
+		} else {
+			ASSERT(false);
+		}
+	}
+
+	ret = 0;
+
+cleanup_release:
+	mutex_unlock(&g_consumer_mutex);
+
+	return ret;
+}
+
+static long ppm_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int cpu;
+	int ret;
+	struct task_struct *consumer_id = filp->private_data;
+	struct ppm_consumer_t *consumer = NULL;
+
+	if (cmd == PPM_IOCTL_GET_PROCLIST) {
+		struct ppm_proclist_info *proclist_info = NULL;
+		struct task_struct *p, *t;
+		u64 nentries = 0;
+		struct ppm_proclist_info pli;
+		u32 memsize;
+
+		if (copy_from_user(&pli, (void *)arg, sizeof(pli))) {
+			ret = -EINVAL;
+			goto cleanup_ioctl_nolock;
+		}
+
+		vpr_info("PPM_IOCTL_GET_PROCLIST, size=%d\n", (int)pli.max_entries);
+
+		memsize = sizeof(struct ppm_proclist_info) + sizeof(struct ppm_proc_info) * pli.max_entries;
+		proclist_info = vmalloc(memsize);
+		if (!proclist_info) {
+			ret = -EINVAL;
+			goto cleanup_ioctl_nolock;
+		}
+
+		proclist_info->max_entries = pli.max_entries;
+
+		rcu_read_lock();
+
+#ifdef for_each_process_thread
+		for_each_process_thread(p, t) {
+#else
+#ifdef for_each_process_all
+		for_each_process_all(p) {
+#else
+		for_each_process(p) {
+#endif
+			t = p;
+			do {
+				task_lock(p);
+#endif
+				if (nentries < pli.max_entries) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 11, 0))
+					cputime_t utime, stime;
+#else
+					u64 utime, stime;
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+					task_cputime_adjusted(t, &utime, &stime);
+#else
+					ppm_task_cputime_adjusted(t, &utime, &stime);
+#endif
+					proclist_info->entries[nentries].pid = t->pid;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 11, 0))
+					proclist_info->entries[nentries].utime = cputime_to_clock_t(utime);
+					proclist_info->entries[nentries].stime = cputime_to_clock_t(stime);
+#else
+					proclist_info->entries[nentries].utime = nsec_to_clock_t(utime);
+					proclist_info->entries[nentries].stime = nsec_to_clock_t(stime);
+#endif
+				}
+
+				nentries++;
+#ifdef for_each_process_thread
+		}
+#else
+				task_unlock(p);
+#ifdef while_each_thread_all
+			} while_each_thread_all(p, t);
+		}
+#else
+			} while_each_thread(p, t);
+		}
+#endif
+#endif
+
+		rcu_read_unlock();
+
+		proclist_info->n_entries = nentries;
+
+		if (nentries >= pli.max_entries) {
+			vpr_info("PPM_IOCTL_GET_PROCLIST: not enough space (%d avail, %d required)\n",
+				(int)pli.max_entries,
+				(int)nentries);
+
+			if (copy_to_user((void *)arg, proclist_info, sizeof(struct ppm_proclist_info))) {
+				ret = -EINVAL;
+				goto cleanup_ioctl_procinfo;
+			}
+
+			ret = -ENOSPC;
+			goto cleanup_ioctl_procinfo;
+		} else {
+			memsize = sizeof(struct ppm_proclist_info) + sizeof(struct ppm_proc_info) * nentries;
+
+			if (copy_to_user((void *)arg, proclist_info, memsize)) {
+				ret = -EINVAL;
+				goto cleanup_ioctl_procinfo;
+			}
+		}
+
+		ret = 0;
+cleanup_ioctl_procinfo:
+		vfree((void *)proclist_info);
+		goto cleanup_ioctl_nolock;
+	}
+
+	if (cmd == PPM_IOCTL_GET_N_TRACEPOINT_HIT) {
+		long __user *counters = (long __user *) arg;
+
+		for_each_possible_cpu(cpu) {
+			if (put_user(per_cpu(g_n_tracepoint_hit, cpu), &counters[cpu])) {
+				ret = -EINVAL;
+				goto cleanup_ioctl_nolock;
+			}
+		}
+		ret = 0;
+		goto cleanup_ioctl_nolock;
+	}
+
+	mutex_lock(&g_consumer_mutex);
+
+	consumer = ppm_find_consumer(consumer_id);
+	if (!consumer) {
+		pr_err("ioctl: unknown consumer %p\n", consumer_id);
+		ret = -EBUSY;
+		goto cleanup_ioctl;
+	}
+
+	switch (cmd) {
+	case PPM_IOCTL_DISABLE_CAPTURE:
+	{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+		int ring_no = iminor(filp->f_path.dentry->d_inode);
+#else
+		int ring_no = iminor(filp->f_dentry->d_inode);
+#endif
+		struct ppm_ring_buffer_context *ring = per_cpu_ptr(consumer->ring_buffers, ring_no);
+
+		if (!ring) {
+			ASSERT(false);
+			ret = -ENODEV;
+			goto cleanup_ioctl;
+		}
+
+		ring->capture_enabled = false;
+
+		vpr_info("PPM_IOCTL_DISABLE_CAPTURE for ring %d, consumer %p\n", ring_no, consumer_id);
+
+		ret = 0;
+		goto cleanup_ioctl;
+	}
+	case PPM_IOCTL_ENABLE_CAPTURE:
+	{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+		int ring_no = iminor(filp->f_path.dentry->d_inode);
+#else
+		int ring_no = iminor(filp->f_dentry->d_inode);
+#endif
+		struct ppm_ring_buffer_context *ring = per_cpu_ptr(consumer->ring_buffers, ring_no);
+
+		if (!ring) {
+			ASSERT(false);
+			ret = -ENODEV;
+			goto cleanup_ioctl;
+		}
+
+		ring->capture_enabled = true;
+
+		vpr_info("PPM_IOCTL_ENABLE_CAPTURE for ring %d, consumer %p\n", ring_no, consumer_id);
+
+		ret = 0;
+		goto cleanup_ioctl;
+	}
+	case PPM_IOCTL_DISABLE_DROPPING_MODE:
+	{
+		struct event_data_t event_data;
+		struct timespec ts;
+
+		vpr_info("PPM_IOCTL_DISABLE_DROPPING_MODE, consumer %p\n", consumer_id);
+
+		consumer->dropping_mode = 0;
+		consumer->sampling_interval = 1000000000;
+		consumer->sampling_ratio = 1;
+
+		/*
+		 * Push an event into the ring buffer so that the user can know that dropping
+		 * mode has been disabled
+		 */
+		getnstimeofday(&ts);
+		event_data.category = PPMC_CONTEXT_SWITCH;
+		event_data.event_info.context_data.sched_prev = (void *)DEI_DISABLE_DROPPING;
+		event_data.event_info.context_data.sched_next = (void *)0;
+
+		record_event_consumer(consumer, PPME_SYSDIGEVENT_E, UF_NEVER_DROP, &ts, &event_data);
+
+		ret = 0;
+		goto cleanup_ioctl;
+	}
+	case PPM_IOCTL_ENABLE_DROPPING_MODE:
+	{
+		u32 new_sampling_ratio;
+
+		consumer->dropping_mode = 1;
+		vpr_info("PPM_IOCTL_ENABLE_DROPPING_MODE, consumer %p\n", consumer_id);
+
+		new_sampling_ratio = (u32)arg;
+
+		if (new_sampling_ratio != 1 &&
+			new_sampling_ratio != 2 &&
+			new_sampling_ratio != 4 &&
+			new_sampling_ratio != 8 &&
+			new_sampling_ratio != 16 &&
+			new_sampling_ratio != 32 &&
+			new_sampling_ratio != 64 &&
+			new_sampling_ratio != 128) {
+			pr_err("invalid sampling ratio %u\n", new_sampling_ratio);
+			ret = -EINVAL;
+			goto cleanup_ioctl;
+		}
+
+		consumer->sampling_interval = 1000000000 / new_sampling_ratio;
+		consumer->sampling_ratio = new_sampling_ratio;
+
+		vpr_info("new sampling ratio: %d\n", new_sampling_ratio);
+
+		ret = 0;
+		goto cleanup_ioctl;
+	}
+	case PPM_IOCTL_SET_SNAPLEN:
+	{
+		u32 new_snaplen;
+
+		vpr_info("PPM_IOCTL_SET_SNAPLEN, consumer %p\n", consumer_id);
+		new_snaplen = (u32)arg;
+
+		if (new_snaplen > RW_MAX_SNAPLEN) {
+			pr_err("invalid snaplen %u\n", new_snaplen);
+			ret = -EINVAL;
+			goto cleanup_ioctl;
+		}
+
+		consumer->snaplen = new_snaplen;
+
+		vpr_info("new snaplen: %d\n", consumer->snaplen);
+
+		ret = 0;
+		goto cleanup_ioctl;
+	}
+	case PPM_IOCTL_MASK_ZERO_EVENTS:
+	{
+		vpr_info("PPM_IOCTL_MASK_ZERO_EVENTS, consumer %p\n", consumer_id);
+
+		bitmap_zero(g_events_mask, PPM_EVENT_MAX);
+
+		/* Used for dropping events so they must stay on */
+		set_bit(PPME_DROP_E, g_events_mask);
+		set_bit(PPME_DROP_X, g_events_mask);
+
+		ret = 0;
+		goto cleanup_ioctl;
+	}
+	case PPM_IOCTL_MASK_SET_EVENT:
+	{
+		u32 syscall_to_set = (u32)arg;
+
+		vpr_info("PPM_IOCTL_MASK_SET_EVENT (%u), consumer %p\n", syscall_to_set, consumer_id);
+
+		if (syscall_to_set > PPM_EVENT_MAX) {
+			pr_err("invalid syscall %u\n", syscall_to_set);
+			ret = -EINVAL;
+			goto cleanup_ioctl;
+		}
+
+		set_bit(syscall_to_set, g_events_mask);
+
+		ret = 0;
+		goto cleanup_ioctl;
+	}
+	case PPM_IOCTL_MASK_UNSET_EVENT:
+	{
+		u32 syscall_to_unset = (u32)arg;
+
+		vpr_info("PPM_IOCTL_MASK_UNSET_EVENT (%u), consumer %p\n", syscall_to_unset, consumer_id);
+
+		if (syscall_to_unset > NR_syscalls) {
+			pr_err("invalid syscall %u\n", syscall_to_unset);
+			ret = -EINVAL;
+			goto cleanup_ioctl;
+		}
+
+		clear_bit(syscall_to_unset, g_events_mask);
+
+		ret = 0;
+		goto cleanup_ioctl;
+	}
+	case PPM_IOCTL_DISABLE_DYNAMIC_SNAPLEN:
+	{
+		consumer->do_dynamic_snaplen = false;
+
+		ret = 0;
+		goto cleanup_ioctl;
+	}
+	case PPM_IOCTL_ENABLE_DYNAMIC_SNAPLEN:
+	{
+		consumer->do_dynamic_snaplen = true;
+
+		ret = 0;
+		goto cleanup_ioctl;
+	}
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+	case PPM_IOCTL_GET_VTID:
+	case PPM_IOCTL_GET_VPID:
+	{
+		pid_t vid;
+		struct pid *pid;
+		struct task_struct *task;
+		struct pid_namespace *ns;
+
+		rcu_read_lock();
+		pid = find_pid_ns(arg, &init_pid_ns);
+		if (!pid) {
+			rcu_read_unlock();
+			ret = -EINVAL;
+			goto cleanup_ioctl;
+		}
+
+		task = pid_task(pid, PIDTYPE_PID);
+		if (!task) {
+			rcu_read_unlock();
+			ret = -EINVAL;
+			goto cleanup_ioctl;
+		}
+
+		ns = ns_of_pid(pid);
+		if (!pid) {
+			rcu_read_unlock();
+			ret = -EINVAL;
+			goto cleanup_ioctl;
+		}
+
+		if (cmd == PPM_IOCTL_GET_VTID)
+			vid = task_pid_nr_ns(task, ns);
+		else
+			vid = task_tgid_nr_ns(task, ns);
+
+		rcu_read_unlock();
+		ret = vid;
+		goto cleanup_ioctl;
+	}
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+	case PPM_IOCTL_GET_CURRENT_TID:
+		ret = task_pid_nr(current);
+		goto cleanup_ioctl;
+	case PPM_IOCTL_GET_CURRENT_PID:
+		ret = task_tgid_nr(current);
+		goto cleanup_ioctl;
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20) */
+#ifdef CAPTURE_SIGNAL_DELIVERIES
+	case PPM_IOCTL_DISABLE_SIGNAL_DELIVER:
+	{
+		vpr_info("PPM_IOCTL_DISABLE_SIGNAL_DELIVER\n");
+		if (g_tracepoint_registered)
+			compat_unregister_trace(signal_deliver_probe, "signal_deliver", tp_signal_deliver);
+		ret = 0;
+		goto cleanup_ioctl;
+	}
+	case PPM_IOCTL_ENABLE_SIGNAL_DELIVER:
+	{
+		vpr_info("PPM_IOCTL_ENABLE_SIGNAL_DELIVER\n");
+		if (g_tracepoint_registered)
+			compat_register_trace(signal_deliver_probe, "signal_deliver", tp_signal_deliver);
+		ret = 0;
+		goto cleanup_ioctl;
+	}
+#endif
+	case PPM_IOCTL_SET_TRACERS_CAPTURE:
+	{
+		vpr_info("PPM_IOCTL_SET_TRACERS_CAPTURE, consumer %p\n", consumer_id);
+		g_tracers_enabled = true;
+		ret = 0;
+		goto cleanup_ioctl;
+	}
+	case PPM_IOCTL_SET_SIMPLE_MODE:
+	{
+		vpr_info("PPM_IOCTL_SET_SIMPLE_MODE, consumer %p\n", consumer_id);
+		g_simple_mode_enabled = true;
+		ret = 0;
+		goto cleanup_ioctl;
+	}
+	case PPM_IOCTL_ENABLE_PAGE_FAULTS:
+	{
+		vpr_info("PPM_IOCTL_ENABLE_PAGE_FAULTS\n");
+#ifdef CAPTURE_PAGE_FAULTS
+		ASSERT(g_tracepoint_registered);
+
+		if (g_fault_tracepoint_disabled) {
+			pr_err("kernel page fault tracepoints are disabled\n");
+			ret = -EPERM;
+			goto cleanup_ioctl;
+		}
+
+		if (!g_fault_tracepoint_registered) {
+			ret = compat_register_trace(page_fault_probe, "page_fault_user", tp_page_fault_user);
+			if (ret) {
+				pr_err("can't create the page_fault_user tracepoint\n");
+				ret = -EINVAL;
+				goto cleanup_ioctl;
+			}
+
+			ret = compat_register_trace(page_fault_probe, "page_fault_kernel", tp_page_fault_kernel);
+			if (ret) {
+				pr_err("can't create the page_fault_kernel tracepoint\n");
+				ret = -EINVAL;
+				goto err_page_fault_kernel;
+			}
+
+			g_fault_tracepoint_registered = true;
+		}
+
+		ret = 0;
+		goto cleanup_ioctl;
+#else
+		pr_err("kernel doesn't support page fault tracepoints\n");
+		ret = -EINVAL;
+		goto cleanup_ioctl;
+#endif
+	}
+	default:
+		ret = -ENOTTY;
+		goto cleanup_ioctl;
+	}
+
+#ifdef CAPTURE_PAGE_FAULTS
+err_page_fault_kernel:
+	compat_unregister_trace(page_fault_probe, "page_fault_user", tp_page_fault_user);
+#endif
+cleanup_ioctl:
+	mutex_unlock(&g_consumer_mutex);
+cleanup_ioctl_nolock:
+	return ret;
+}
+
+static int ppm_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	int ret;
+	struct task_struct *consumer_id = filp->private_data;
+	struct ppm_consumer_t *consumer = NULL;
+
+	mutex_lock(&g_consumer_mutex);
+
+	consumer = ppm_find_consumer(consumer_id);
+	if (!consumer) {
+		pr_err("mmap: unknown consumer %p\n", consumer_id);
+		ret = -EIO;
+		goto cleanup_mmap;
+	}
+
+	if (vma->vm_pgoff == 0) {
+		long length = vma->vm_end - vma->vm_start;
+		unsigned long useraddr = vma->vm_start;
+		unsigned long pfn;
+		char *vmalloc_area_ptr;
+		char *orig_vmalloc_area_ptr;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+		int ring_no = iminor(filp->f_path.dentry->d_inode);
+#else
+		int ring_no = iminor(filp->f_dentry->d_inode);
+#endif
+		struct ppm_ring_buffer_context *ring;
+
+		vpr_info("mmap for consumer %p, CPU %d, start=%lu len=%ld page_size=%lu\n",
+			   consumer_id,
+		       ring_no,
+		       useraddr,
+		       length,
+		       PAGE_SIZE);
+
+		/*
+		 * Enforce ring buffer size
+		 */
+		if (RING_BUF_SIZE < 2 * PAGE_SIZE) {
+			pr_err("Ring buffer size too small (%ld bytes, must be at least %ld bytes\n",
+			       (long)RING_BUF_SIZE,
+			       (long)PAGE_SIZE);
+			ret = -EIO;
+			goto cleanup_mmap;
+		}
+
+		if (RING_BUF_SIZE / PAGE_SIZE * PAGE_SIZE != RING_BUF_SIZE) {
+			pr_err("Ring buffer size is not a multiple of the page size\n");
+			ret = -EIO;
+			goto cleanup_mmap;
+		}
+
+		/*
+		 * Retrieve the ring structure for this CPU
+		 */
+		ring = per_cpu_ptr(consumer->ring_buffers, ring_no);
+		if (!ring) {
+			ASSERT(false);
+			ret = -ENODEV;
+			goto cleanup_mmap;
+		}
+
+		if (length <= PAGE_SIZE) {
+			/*
+			 * When the size requested by the user is smaller than a page, we assume
+			 * she's mapping the ring info structure
+			 */
+			vpr_info("mapping the ring info\n");
+
+			vmalloc_area_ptr = (char *)ring->info;
+			orig_vmalloc_area_ptr = vmalloc_area_ptr;
+
+			pfn = vmalloc_to_pfn(vmalloc_area_ptr);
+
+			ret = remap_pfn_range(vma, useraddr, pfn,
+					      PAGE_SIZE, PAGE_SHARED);
+			if (ret < 0) {
+				pr_err("remap_pfn_range failed (1)\n");
+				goto cleanup_mmap;
+			}
+
+			ret = 0;
+			goto cleanup_mmap;
+		} else if (length == RING_BUF_SIZE * 2) {
+			long mlength;
+
+			/*
+			 * When the size requested by the user equals the ring buffer size, we map the full
+			 * buffer
+			 */
+			vpr_info("mapping the data buffer\n");
+
+			vmalloc_area_ptr = (char *)ring->buffer;
+			orig_vmalloc_area_ptr = vmalloc_area_ptr;
+
+			/*
+			 * Validate that the buffer access is read only
+			 */
+			if (vma->vm_flags & VM_WRITE) {
+				pr_err("invalid mmap flags 0x%lx\n", vma->vm_flags);
+				ret = -EIO;
+				goto cleanup_mmap;
+			}
+
+			/*
+			 * Map each single page of the buffer
+			 */
+			mlength = length / 2;
+
+			while (mlength > 0) {
+				pfn = vmalloc_to_pfn(vmalloc_area_ptr);
+
+				ret = remap_pfn_range(vma, useraddr, pfn,
+						      PAGE_SIZE, PAGE_SHARED);
+				if (ret < 0) {
+					pr_err("remap_pfn_range failed (1)\n");
+					goto cleanup_mmap;
+				}
+
+				useraddr += PAGE_SIZE;
+				vmalloc_area_ptr += PAGE_SIZE;
+				mlength -= PAGE_SIZE;
+			}
+
+			/*
+			 * Remap a second copy of the buffer pages at the end of the buffer.
+			 * This effectively mirrors the buffer at its end and helps simplify buffer management in userland.
+			 */
+			vmalloc_area_ptr = orig_vmalloc_area_ptr;
+			mlength = length / 2;
+
+			while (mlength > 0) {
+				pfn = vmalloc_to_pfn(vmalloc_area_ptr);
+
+				ret = remap_pfn_range(vma, useraddr, pfn,
+						      PAGE_SIZE, PAGE_SHARED);
+				if (ret < 0) {
+					pr_err("remap_pfn_range failed (1)\n");
+					goto cleanup_mmap;
+				}
+
+				useraddr += PAGE_SIZE;
+				vmalloc_area_ptr += PAGE_SIZE;
+				mlength -= PAGE_SIZE;
+			}
+
+			ret = 0;
+			goto cleanup_mmap;
+		}
+
+		pr_err("Invalid mmap size %ld\n", length);
+		ret = -EIO;
+		goto cleanup_mmap;
+	}
+
+	pr_err("invalid pgoff %lu, must be 0\n", vma->vm_pgoff);
+	ret = -EIO;
+
+cleanup_mmap:
+	mutex_unlock(&g_consumer_mutex);
+
+	return ret;
+}
+
+/* Argument list sizes for sys_socketcall */
+#define AL(x) ((x) * sizeof(unsigned long))
+static const unsigned char nas[21] = {
+	AL(0), AL(3), AL(3), AL(3), AL(2), AL(3),
+	AL(3), AL(3), AL(4), AL(4), AL(4), AL(6),
+	AL(6), AL(2), AL(5), AL(5), AL(3), AL(3),
+	AL(4), AL(5), AL(4)
+};
+#undef AL
+#ifdef CONFIG_COMPAT
+#define AL(x) ((x) * sizeof(compat_ulong_t))
+static const unsigned char compat_nas[21] = {
+	AL(0), AL(3), AL(3), AL(3), AL(2), AL(3),
+	AL(3), AL(3), AL(4), AL(4), AL(4), AL(6),
+	AL(6), AL(2), AL(5), AL(5), AL(3), AL(3),
+	AL(4), AL(5), AL(4)
+};
+#undef AL
+#endif
+
+
+#ifdef _HAS_SOCKETCALL
+static enum ppm_event_type parse_socketcall(struct event_filler_arguments *filler_args, struct pt_regs *regs)
+{
+	unsigned long __user args[2];
+	unsigned long __user *scargs;
+	int socketcall_id;
+
+	syscall_get_arguments(current, regs, 0, 2, args);
+	socketcall_id = args[0];
+	scargs = (unsigned long __user *)args[1];
+
+	if (unlikely(socketcall_id < SYS_SOCKET ||
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+		socketcall_id > SYS_SENDMMSG))
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
+		socketcall_id > SYS_RECVMMSG))
+#else
+		socketcall_id > SYS_ACCEPT4))
+#endif
+		return PPME_GENERIC_E;
+
+#ifdef CONFIG_COMPAT
+	if (unlikely(filler_args->compat)) {
+		compat_ulong_t socketcall_args32[6];
+		int j;
+
+		if (unlikely(ppm_copy_from_user(socketcall_args32, compat_ptr(args[1]), compat_nas[socketcall_id])))
+			return PPME_GENERIC_E;
+		for (j = 0; j < 6; ++j)
+			filler_args->socketcall_args[j] = (unsigned long)socketcall_args32[j];
+	} else {
+#endif
+		if (unlikely(ppm_copy_from_user(filler_args->socketcall_args, scargs, nas[socketcall_id])))
+			return PPME_GENERIC_E;
+#ifdef CONFIG_COMPAT
+	}
+#endif
+
+	switch (socketcall_id) {
+	case SYS_SOCKET:
+		return PPME_SOCKET_SOCKET_E;
+	case SYS_BIND:
+		return PPME_SOCKET_BIND_E;
+	case SYS_CONNECT:
+		return PPME_SOCKET_CONNECT_E;
+	case SYS_LISTEN:
+		return PPME_SOCKET_LISTEN_E;
+	case SYS_ACCEPT:
+		return PPME_SOCKET_ACCEPT_5_E;
+	case SYS_GETSOCKNAME:
+		return PPME_SOCKET_GETSOCKNAME_E;
+	case SYS_GETPEERNAME:
+		return PPME_SOCKET_GETPEERNAME_E;
+	case SYS_SOCKETPAIR:
+		return PPME_SOCKET_SOCKETPAIR_E;
+	case SYS_SEND:
+		return PPME_SOCKET_SEND_E;
+	case SYS_SENDTO:
+		return PPME_SOCKET_SENDTO_E;
+	case SYS_RECV:
+		return PPME_SOCKET_RECV_E;
+	case SYS_RECVFROM:
+		return PPME_SOCKET_RECVFROM_E;
+	case SYS_SHUTDOWN:
+		return PPME_SOCKET_SHUTDOWN_E;
+	case SYS_SETSOCKOPT:
+		return PPME_SOCKET_SETSOCKOPT_E;
+	case SYS_GETSOCKOPT:
+		return PPME_SOCKET_GETSOCKOPT_E;
+	case SYS_SENDMSG:
+		return PPME_SOCKET_SENDMSG_E;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+	case SYS_SENDMMSG:
+		return PPME_SOCKET_SENDMMSG_E;
+#endif
+	case SYS_RECVMSG:
+		return PPME_SOCKET_RECVMSG_E;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
+	case SYS_RECVMMSG:
+		return PPME_SOCKET_RECVMMSG_E;
+#endif
+	case SYS_ACCEPT4:
+		return PPME_SOCKET_ACCEPT4_5_E;
+	default:
+		ASSERT(false);
+		return PPME_GENERIC_E;
+	}
+}
+#endif /* _HAS_SOCKETCALL */
+
+static inline void record_drop_e(struct ppm_consumer_t *consumer, struct timespec *ts)
+{
+	struct event_data_t event_data = {0};
+
+	if (record_event_consumer(consumer, PPME_DROP_E, UF_NEVER_DROP, ts, &event_data) == 0) {
+		consumer->need_to_insert_drop_e = 1;
+	} else {
+		if (consumer->need_to_insert_drop_e == 1)
+			pr_err("drop enter event delayed insert\n");
+
+		consumer->need_to_insert_drop_e = 0;
+	}
+}
+
+static inline void record_drop_x(struct ppm_consumer_t *consumer, struct timespec *ts)
+{
+	struct event_data_t event_data = {0};
+
+	if (record_event_consumer(consumer, PPME_DROP_X, UF_NEVER_DROP, ts, &event_data) == 0) {
+		consumer->need_to_insert_drop_x = 1;
+	} else {
+		if (consumer->need_to_insert_drop_x == 1)
+			pr_err("drop exit event delayed insert\n");
+
+		consumer->need_to_insert_drop_x = 0;
+	}
+}
+
+static inline int drop_event(struct ppm_consumer_t *consumer,
+			     enum ppm_event_type event_type,
+			     enum syscall_flags drop_flags,
+			     struct timespec *ts,
+			     struct pt_regs *regs)
+{
+	unsigned long close_arg = 0;
+	int close_fd = -1;
+	struct files_struct *files;
+	struct fdtable *fdt;
+	bool close_return = false;
+
+	/*
+	 * It's annoying but valid for a program to make a large number of
+	 * close() calls on nonexistent fds. That can cause driver cpu usage
+	 * to spike dramatically, so drop close events if the fd is not valid.
+	 *
+	 * The invalid fd events don't matter to userspace in dropping mode,
+	 * so we do this before the UF_NEVER_DROP check
+	 */
+	if (consumer->dropping_mode) {
+		if (event_type == PPME_SYSCALL_CLOSE_X) {
+			if (syscall_get_return_value(current, regs) < 0)
+				close_return = true;
+		} else if (event_type == PPME_SYSCALL_CLOSE_E) {
+			syscall_get_arguments(current, regs, 0, 1, &close_arg);
+			close_fd = (int)close_arg;
+
+			files = current->files;
+			spin_lock(&files->file_lock);
+			fdt = files_fdtable(files);
+			if (close_fd < 0 || close_fd >= fdt->max_fds ||
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0))
+			    !FD_ISSET(close_fd, fdt->open_fds)
+#else
+			    !fd_is_open(close_fd, fdt)
+#endif
+				) {
+				close_return = true;
+			}
+			spin_unlock(&files->file_lock);
+		}
+
+		if (close_return)
+			return 1;
+	}
+
+	if (drop_flags & UF_NEVER_DROP) {
+		ASSERT((drop_flags & UF_ALWAYS_DROP) == 0);
+		return 0;
+	}
+
+	if (consumer->dropping_mode) {
+		if (drop_flags & UF_ALWAYS_DROP) {
+			ASSERT((drop_flags & UF_NEVER_DROP) == 0);
+			return 1;
+		}
+
+		if (ts->tv_nsec >= consumer->sampling_interval) {
+			if (consumer->is_dropping == 0) {
+				consumer->is_dropping = 1;
+				record_drop_e(consumer, ts);
+			}
+
+			return 1;
+		}
+
+		if (consumer->is_dropping == 1) {
+			consumer->is_dropping = 0;
+			record_drop_x(consumer, ts);
+		}
+	}
+
+	return 0;
+}
+
+static void record_event_all_consumers(enum ppm_event_type event_type,
+	enum syscall_flags drop_flags,
+	struct event_data_t *event_datap)
+{
+	struct ppm_consumer_t *consumer;
+	struct timespec ts;
+
+	getnstimeofday(&ts);
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(consumer, &g_consumer_list, node) {
+		record_event_consumer(consumer, event_type, drop_flags, &ts, event_datap);
+	}
+	rcu_read_unlock();
+}
+
+/*
+ * Returns 0 if the event is dropped
+ */
+static int record_event_consumer(struct ppm_consumer_t *consumer,
+	enum ppm_event_type event_type,
+	enum syscall_flags drop_flags,
+	struct timespec *ts,
+	struct event_data_t *event_datap)
+{
+	int res = 0;
+	size_t event_size = 0;
+	int next;
+	u32 freespace;
+	u32 usedspace;
+	u32 delta_from_end;
+	struct event_filler_arguments args;
+	u32 ttail;
+	u32 head;
+	struct ppm_ring_buffer_context *ring;
+	struct ppm_ring_buffer_info *ring_info;
+	int drop = 1;
+	int32_t cbres = PPM_SUCCESS;
+	int cpu;
+
+	if (!test_bit(event_type, g_events_mask))
+		return res;
+
+	if (event_type != PPME_DROP_E && event_type != PPME_DROP_X) {
+		if (consumer->need_to_insert_drop_e == 1)
+			record_drop_e(consumer, ts);
+		else if (consumer->need_to_insert_drop_x == 1)
+			record_drop_x(consumer, ts);
+
+		if (drop_event(consumer, event_type, drop_flags, ts,
+			       event_datap->event_info.syscall_data.regs))
+			return res;
+	}
+
+	/*
+	 * FROM THIS MOMENT ON, WE HAVE TO BE SUPER FAST
+	 */
+	cpu = get_cpu();
+	ring = per_cpu_ptr(consumer->ring_buffers, cpu);
+	ASSERT(ring);
+
+	ring_info = ring->info;
+
+	if (!ring->capture_enabled) {
+		put_cpu();
+		return res;
+	}
+
+	ring_info->n_evts++;
+	if (event_datap->category == PPMC_CONTEXT_SWITCH && event_datap->event_info.context_data.sched_prev != NULL) {
+		if (event_type != PPME_SYSDIGEVENT_E && event_type != PPME_CPU_HOTPLUG_E) {
+			ASSERT(event_datap->event_info.context_data.sched_prev != NULL);
+			ASSERT(event_datap->event_info.context_data.sched_next != NULL);
+			ring_info->n_context_switches++;
+		}
+	} else if (event_datap->category == PPMC_SIGNAL) {
+		if (event_type == PPME_SIGNALDELIVER_E)
+			ASSERT(event_datap->event_info.signal_data.info != NULL);
+	}
+
+	/*
+	 * Preemption gate
+	 */
+	if (unlikely(atomic_inc_return(&ring->preempt_count) != 1)) {
+		/* When this driver executing a filler calls ppm_copy_from_user(),
+		 * even if the page fault is disabled, the page fault tracepoint gets
+		 * called very early in the page fault handler, way before the kernel
+		 * terminates it, so this is legit. Still not sure how to solve this,
+		 * so for the moment handle this case by not complaining and ignoring
+		 * the false alarm if the preemption exception is generated by
+		 * page_fault_kernel. The alternative would be to disable the kernel
+		 * tracepoint completely, but there is value in seeing page faults
+		 * generated on this side, so let's see if someone complains.
+		 * This means that effectively those events would be lost.
+		 */
+		if (event_type != PPME_PAGE_FAULT_E) {
+			ring_info->n_preemptions++;
+			ASSERT(false);
+		}
+		atomic_dec(&ring->preempt_count);
+		put_cpu();
+		return res;
+	}
+
+	/*
+	 * Calculate the space currently available in the buffer
+	 */
+	head = ring_info->head;
+	ttail = ring_info->tail;
+
+	if (ttail > head)
+		freespace = ttail - head - 1;
+	else
+		freespace = RING_BUF_SIZE + ttail - head - 1;
+
+	usedspace = RING_BUF_SIZE - freespace - 1;
+	delta_from_end = RING_BUF_SIZE + (2 * PAGE_SIZE) - head - 1;
+
+	ASSERT(freespace <= RING_BUF_SIZE);
+	ASSERT(usedspace <= RING_BUF_SIZE);
+	ASSERT(ttail <= RING_BUF_SIZE);
+	ASSERT(head <= RING_BUF_SIZE);
+	ASSERT(delta_from_end < RING_BUF_SIZE + (2 * PAGE_SIZE));
+	ASSERT(delta_from_end > (2 * PAGE_SIZE) - 1);
+#ifdef _HAS_SOCKETCALL
+	/*
+	 * If this is a socketcall system call, determine the correct event type
+	 * by parsing the arguments and patch event_type accordingly
+	 * A bit of explanation: most linux architectures don't have a separate
+	 * syscall for each of the socket functions (bind, connect...). Instead,
+	 * the socket functions are aggregated into a single syscall, called
+	 * socketcall. The first socketcall argument is the call type, while the
+	 * second argument contains a pointer to the arguments of the original
+	 * call. I guess this was done to reduce the number of syscalls...
+	 */
+	if (event_datap->category == PPMC_SYSCALL && event_datap->event_info.syscall_data.regs && event_datap->event_info.syscall_data.id == event_datap->socketcall_syscall) {
+		enum ppm_event_type tet;
+
+		args.is_socketcall = true;
+		args.compat = event_datap->compat;
+		tet = parse_socketcall(&args, event_datap->event_info.syscall_data.regs);
+
+		if (event_type == PPME_GENERIC_E)
+			event_type = tet;
+		else
+			event_type = tet + 1;
+
+	} else {
+		args.is_socketcall = false;
+		args.compat = false;
+	}
+
+	args.socketcall_syscall = event_datap->socketcall_syscall;
+#endif
+
+	ASSERT(event_type < PPM_EVENT_MAX);
+
+	/*
+	 * Determine how many arguments this event has
+	 */
+	args.nargs = g_event_info[event_type].nparams;
+	args.arg_data_offset = args.nargs * sizeof(u16);
+
+	/*
+	 * Make sure we have enough space for the event header.
+	 * We need at least space for the header plus 16 bit per parameter for the lengths.
+	 */
+	if (likely(freespace >= sizeof(struct ppm_evt_hdr) + args.arg_data_offset)) {
+		/*
+		 * Populate the header
+		 */
+		struct ppm_evt_hdr *hdr = (struct ppm_evt_hdr *)(ring->buffer + head);
+
+#ifdef PPM_ENABLE_SENTINEL
+		hdr->sentinel_begin = ring->nevents;
+#endif
+		hdr->ts = timespec_to_ns(ts);
+		hdr->tid = current->pid;
+		hdr->type = event_type;
+
+		/*
+		 * Populate the parameters for the filler callback
+		 */
+		args.consumer = consumer;
+		args.buffer = ring->buffer + head + sizeof(struct ppm_evt_hdr);
+#ifdef PPM_ENABLE_SENTINEL
+		args.sentinel = ring->nevents;
+#endif
+		args.buffer_size = min(freespace, delta_from_end) - sizeof(struct ppm_evt_hdr); /* freespace is guaranteed to be bigger than sizeof(struct ppm_evt_hdr) */
+		args.event_type = event_type;
+
+		if (event_datap->category == PPMC_SYSCALL) {
+			args.regs = event_datap->event_info.syscall_data.regs;
+			args.syscall_id = event_datap->event_info.syscall_data.id;
+			args.cur_g_syscall_code_routing_table = event_datap->event_info.syscall_data.cur_g_syscall_code_routing_table;
+			args.compat = event_datap->compat;
+		} else {
+			args.regs = NULL;
+			args.syscall_id = -1;
+			args.cur_g_syscall_code_routing_table = NULL;
+			args.compat = false;
+		}
+
+		if (event_datap->category == PPMC_CONTEXT_SWITCH) {
+			args.sched_prev = event_datap->event_info.context_data.sched_prev;
+			args.sched_next = event_datap->event_info.context_data.sched_next;
+		} else {
+			args.sched_prev = NULL;
+			args.sched_next = NULL;
+		}
+
+		if (event_datap->category == PPMC_SIGNAL) {
+			args.signo = event_datap->event_info.signal_data.sig;
+
+			if (args.signo == SIGKILL) {
+				args.spid = event_datap->event_info.signal_data.info->_sifields._kill._pid;
+			} else if (args.signo == SIGTERM || args.signo == SIGHUP || args.signo == SIGINT ||
+					args.signo == SIGTSTP || args.signo == SIGQUIT) {
+				if (event_datap->event_info.signal_data.info->si_code == SI_USER ||
+						event_datap->event_info.signal_data.info->si_code == SI_QUEUE ||
+						event_datap->event_info.signal_data.info->si_code <= 0) {
+					args.spid = event_datap->event_info.signal_data.info->si_pid;
+				}
+			} else if (args.signo == SIGCHLD) {
+				args.spid = event_datap->event_info.signal_data.info->_sifields._sigchld._pid;
+			} else if (args.signo >= SIGRTMIN && args.signo <= SIGRTMAX) {
+				args.spid = event_datap->event_info.signal_data.info->_sifields._rt._pid;
+			} else {
+				args.spid = (__kernel_pid_t) 0;
+			}
+		} else {
+			args.signo = 0;
+			args.spid = (__kernel_pid_t) 0;
+		}
+		args.dpid = current->pid;
+
+		if (event_datap->category == PPMC_PAGE_FAULT)
+			args.fault_data = event_datap->event_info.fault_data;
+
+		args.curarg = 0;
+		args.arg_data_size = args.buffer_size - args.arg_data_offset;
+		args.nevents = ring->nevents;
+		args.str_storage = ring->str_storage;
+		args.enforce_snaplen = false;
+
+		/*
+		 * Fire the filler callback
+		 */
+		if (g_ppm_events[event_type].filler_callback == PPM_AUTOFILL) {
+			/*
+			 * This event is automatically filled. Hand it to f_sys_autofill.
+			 */
+			cbres = f_sys_autofill(&args, &g_ppm_events[event_type]);
+		} else {
+			/*
+			 * There's a callback function for this event
+			 */
+			cbres = g_ppm_events[event_type].filler_callback(&args);
+		}
+
+		if (likely(cbres == PPM_SUCCESS)) {
+			/*
+			 * Validate that the filler added the right number of parameters
+			 */
+			if (likely(args.curarg == args.nargs)) {
+				/*
+				 * The event was successfully inserted in the buffer
+				 */
+				event_size = sizeof(struct ppm_evt_hdr) + args.arg_data_offset;
+				hdr->len = event_size;
+				drop = 0;
+			} else {
+				pr_err("corrupted filler for event type %d (added %u args, should have added %u)\n",
+				       event_type,
+				       args.curarg,
+				       args.nargs);
+				ASSERT(0);
+			}
+		}
+	}
+
+	if (likely(!drop)) {
+		res = 1;
+
+		next = head + event_size;
+
+		if (unlikely(next >= RING_BUF_SIZE)) {
+			/*
+			 * If something has been written in the cushion space at the end of
+			 * the buffer, copy it to the beginning and wrap the head around.
+			 * Note, we don't check that the copy fits because we assume that
+			 * filler_callback failed if the space was not enough.
+			 */
+			if (next > RING_BUF_SIZE) {
+				memcpy(ring->buffer,
+				ring->buffer + RING_BUF_SIZE,
+				next - RING_BUF_SIZE);
+			}
+
+			next -= RING_BUF_SIZE;
+		}
+
+		/*
+		 * Make sure all the memory has been written in real memory before
+		 * we update the head and the user space process (on another CPU)
+		 * can access the buffer.
+		 */
+		smp_wmb();
+
+		ring_info->head = next;
+
+		++ring->nevents;
+	} else {
+		if (cbres == PPM_SUCCESS) {
+			ASSERT(freespace < sizeof(struct ppm_evt_hdr) + args.arg_data_offset);
+			ring_info->n_drops_buffer++;
+		} else if (cbres == PPM_FAILURE_INVALID_USER_MEMORY) {
+#ifdef _DEBUG
+			pr_err("Invalid read from user for event %d\n", event_type);
+#endif
+			ring_info->n_drops_pf++;
+		} else if (cbres == PPM_FAILURE_BUFFER_FULL) {
+			ring_info->n_drops_buffer++;
+		} else {
+			ASSERT(false);
+		}
+	}
+
+	if (ts->tv_sec > ring->last_print_time.tv_sec + 1) {
+		vpr_info("consumer:%p CPU:%d, use:%d%%, ev:%llu, dr_buf:%llu, dr_pf:%llu, pr:%llu, cs:%llu\n",
+			   consumer->consumer_id,
+		       smp_processor_id(),
+		       (usedspace * 100) / RING_BUF_SIZE,
+		       ring_info->n_evts,
+		       ring_info->n_drops_buffer,
+		       ring_info->n_drops_pf,
+		       ring_info->n_preemptions,
+		       ring->info->n_context_switches);
+
+		ring->last_print_time = *ts;
+	}
+
+	atomic_dec(&ring->preempt_count);
+	put_cpu();
+
+	return res;
+}
+
+static inline void g_n_tracepoint_hit_inc(void)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+	this_cpu_inc(g_n_tracepoint_hit);
+#elif defined(this_cpu_inc)
+	/* this_cpu_inc has been added with 2.6.33 but backported by RHEL/CentOS to 2.6.32
+	 * so just checking the existence of the symbol rather than matching the kernel version
+	 * https://github.com/torvalds/linux/commit/7340a0b15280c9d902c7dd0608b8e751b5a7c403
+	 * 
+	 * per_cpu_var removed with:
+	 * https://github.com/torvalds/linux/commit/dd17c8f72993f9461e9c19250e3f155d6d99df22
+	 */
+	this_cpu_inc(per_cpu_var(g_n_tracepoint_hit));
+#endif
+}
+
+TRACEPOINT_PROBE(syscall_enter_probe, struct pt_regs *regs, long id)
+{
+	long table_index;
+	const struct syscall_evt_pair *cur_g_syscall_table = g_syscall_table;
+	const enum ppm_syscall_code *cur_g_syscall_code_routing_table = g_syscall_code_routing_table;
+	bool compat = false;
+#ifdef __NR_socketcall
+	int socketcall_syscall = __NR_socketcall;
+#else
+	int socketcall_syscall = -1;
+#endif
+
+#if defined(CONFIG_X86_64) && defined(CONFIG_IA32_EMULATION)
+	/*
+	 * If this is a 32bit process running on a 64bit kernel (see the CONFIG_IA32_EMULATION
+	 * kernel flag), we switch to the ia32 syscall table.
+	 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
+	if (in_ia32_syscall()) {
+#else
+	if (unlikely(task_thread_info(current)->status & TS_COMPAT)) {
+#endif
+		cur_g_syscall_table = g_syscall_ia32_table;
+		cur_g_syscall_code_routing_table = g_syscall_ia32_code_routing_table;
+		socketcall_syscall = __NR_ia32_socketcall;
+		compat = true;
+	}
+#endif
+
+	g_n_tracepoint_hit_inc();
+	
+	table_index = id - SYSCALL_TABLE_ID0;
+	if (likely(table_index >= 0 && table_index < SYSCALL_TABLE_SIZE)) {
+		struct event_data_t event_data;
+		int used = cur_g_syscall_table[table_index].flags & UF_USED;
+		enum syscall_flags drop_flags = cur_g_syscall_table[table_index].flags;
+		enum ppm_event_type type;
+
+		/*
+		 * Simple mode event filtering
+		 */
+		if (g_simple_mode_enabled) {
+			if ((drop_flags & UF_SIMPLEDRIVER_KEEP) == 0) {
+				return;
+			}
+		}
+
+#ifdef _HAS_SOCKETCALL
+		if (id == socketcall_syscall) {
+			used = true;
+			drop_flags = UF_NEVER_DROP;
+			type = PPME_GENERIC_E;
+		} else
+			type = cur_g_syscall_table[table_index].enter_event_type;
+#else
+		type = cur_g_syscall_table[table_index].enter_event_type;
+#endif
+
+		event_data.category = PPMC_SYSCALL;
+		event_data.event_info.syscall_data.regs = regs;
+		event_data.event_info.syscall_data.id = id;
+		event_data.event_info.syscall_data.cur_g_syscall_code_routing_table = cur_g_syscall_code_routing_table;
+		event_data.socketcall_syscall = socketcall_syscall;
+		event_data.compat = compat;
+
+		if (used)
+			record_event_all_consumers(type, drop_flags, &event_data);
+		else
+			record_event_all_consumers(PPME_GENERIC_E, UF_ALWAYS_DROP, &event_data);
+	}
+}
+
+TRACEPOINT_PROBE(syscall_exit_probe, struct pt_regs *regs, long ret)
+{
+	int id;
+	long table_index;
+	const struct syscall_evt_pair *cur_g_syscall_table = g_syscall_table;
+	const enum ppm_syscall_code *cur_g_syscall_code_routing_table = g_syscall_code_routing_table;
+	bool compat = false;
+#ifdef __NR_socketcall
+	int socketcall_syscall = __NR_socketcall;
+#else
+	int socketcall_syscall = -1;
+#endif
+
+	id = syscall_get_nr(current, regs);
+
+#if defined(CONFIG_X86_64) && defined(CONFIG_IA32_EMULATION)
+	/*
+	 * When a process does execve from 64bit to 32bit, TS_COMPAT is marked true
+	 * but the id of the syscall is __NR_execve, so to correctly parse it we need to
+	 * use 64bit syscall table. On 32bit __NR_execve is equal to __NR_ia32_oldolduname
+	 * which is a very old syscall, not used anymore by most applications
+	 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
+	if (in_ia32_syscall() && id != __NR_execve) {
+#else
+	if (unlikely((task_thread_info(current)->status & TS_COMPAT) && id != __NR_execve)) {
+#endif
+		cur_g_syscall_table = g_syscall_ia32_table;
+		cur_g_syscall_code_routing_table = g_syscall_ia32_code_routing_table;
+		socketcall_syscall = __NR_ia32_socketcall;
+		compat = true;
+	}
+#endif
+
+	g_n_tracepoint_hit_inc();
+
+	table_index = id - SYSCALL_TABLE_ID0;
+	if (likely(table_index >= 0 && table_index < SYSCALL_TABLE_SIZE)) {
+		struct event_data_t event_data;
+		int used = cur_g_syscall_table[table_index].flags & UF_USED;
+		enum syscall_flags drop_flags = cur_g_syscall_table[table_index].flags;
+		enum ppm_event_type type;
+
+		/*
+		 * Simple mode event filtering
+		 */
+		if (g_simple_mode_enabled) {
+			if ((drop_flags & UF_SIMPLEDRIVER_KEEP) == 0) {
+				return;
+			}
+		}
+
+#ifdef _HAS_SOCKETCALL
+		if (id == socketcall_syscall) {
+			used = true;
+			drop_flags = UF_NEVER_DROP;
+			type = PPME_GENERIC_X;
+		} else
+			type = cur_g_syscall_table[table_index].exit_event_type;
+#else
+		type = cur_g_syscall_table[table_index].exit_event_type;
+#endif
+
+		event_data.category = PPMC_SYSCALL;
+		event_data.event_info.syscall_data.regs = regs;
+		event_data.event_info.syscall_data.id = id;
+		event_data.event_info.syscall_data.cur_g_syscall_code_routing_table = cur_g_syscall_code_routing_table;
+		event_data.socketcall_syscall = socketcall_syscall;
+		event_data.compat = compat;
+
+		if (used)
+			record_event_all_consumers(type, drop_flags, &event_data);
+		else
+			record_event_all_consumers(PPME_GENERIC_X, UF_ALWAYS_DROP, &event_data);
+	}
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 1)
+int __access_remote_vm(struct task_struct *t, struct mm_struct *mm, unsigned long addr,
+		       void *buf, int len, int write);
+#endif
+
+TRACEPOINT_PROBE(syscall_procexit_probe, struct task_struct *p)
+{
+	struct event_data_t event_data;
+
+	g_n_tracepoint_hit_inc();
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+	if (unlikely(current->flags & PF_KTHREAD)) {
+#else
+	if (unlikely(current->flags & PF_BORROWED_MM)) {
+#endif
+		/*
+		 * We are not interested in kernel threads
+		 */
+		return;
+	}
+
+	event_data.category = PPMC_CONTEXT_SWITCH;
+	event_data.event_info.context_data.sched_prev = p;
+	event_data.event_info.context_data.sched_next = p;
+
+	record_event_all_consumers(PPME_PROCEXIT_1_E, UF_NEVER_DROP, &event_data);
+}
+
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+
+#ifdef CAPTURE_CONTEXT_SWITCHES
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35))
+TRACEPOINT_PROBE(sched_switch_probe, struct rq *rq, struct task_struct *prev, struct task_struct *next)
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0))
+TRACEPOINT_PROBE(sched_switch_probe, struct task_struct *prev, struct task_struct *next)
+#else
+TRACEPOINT_PROBE(sched_switch_probe, bool preempt, struct task_struct *prev, struct task_struct *next)
+#endif
+{
+	struct event_data_t event_data;
+
+	g_n_tracepoint_hit_inc();
+
+	event_data.category = PPMC_CONTEXT_SWITCH;
+	event_data.event_info.context_data.sched_prev = prev;
+	event_data.event_info.context_data.sched_next = next;
+
+	record_event_all_consumers(PPME_SCHEDSWITCH_6_E, UF_USED, &event_data);
+}
+#endif
+
+#ifdef CAPTURE_SIGNAL_DELIVERIES
+TRACEPOINT_PROBE(signal_deliver_probe, int sig, struct siginfo *info, struct k_sigaction *ka)
+{
+	struct event_data_t event_data;
+
+	g_n_tracepoint_hit_inc();
+
+	event_data.category = PPMC_SIGNAL;
+	event_data.event_info.signal_data.sig = sig;
+	event_data.event_info.signal_data.info = info;
+	event_data.event_info.signal_data.ka = ka;
+
+	record_event_all_consumers(PPME_SIGNALDELIVER_E, UF_USED | UF_ALWAYS_DROP, &event_data);
+}
+#endif
+
+#ifdef CAPTURE_PAGE_FAULTS
+TRACEPOINT_PROBE(page_fault_probe, unsigned long address, struct pt_regs *regs, unsigned long error_code)
+{
+	struct event_data_t event_data;
+
+	/* We register both tracepoints under the same probe and
+	 * sysdig event since there's little reason to expose this
+	 * complexity to the sysdig user. The distinction can still be made
+	 * in the output by looking for the USER_FAULT/SUPERVISOR_FAULT
+	 * flags
+	 */
+	g_n_tracepoint_hit_inc();
+
+	/* I still haven't decided if I'm interested in kernel threads or not.
+	 * For the moment, I assume yes since I can see some value for it.
+	 */
+
+	event_data.category = PPMC_PAGE_FAULT;
+	event_data.event_info.fault_data.address = address;
+	event_data.event_info.fault_data.regs = regs;
+	event_data.event_info.fault_data.error_code = error_code;
+
+	record_event_all_consumers(PPME_PAGE_FAULT_E, UF_ALWAYS_DROP, &event_data);
+}
+#endif
+
+static int init_ring_buffer(struct ppm_ring_buffer_context *ring)
+{
+	unsigned int j;
+
+	/*
+	 * Allocate the string storage in the ring descriptor
+	 */
+	ring->str_storage = (char *)__get_free_page(GFP_USER);
+	if (!ring->str_storage) {
+		pr_err("Error allocating the string storage\n");
+		goto init_ring_err;
+	}
+
+	/*
+	 * Allocate the buffer.
+	 * Note how we allocate 2 additional pages: they are used as additional overflow space for
+	 * the event data generation functions, so that they always operate on a contiguous buffer.
+	 */
+	ring->buffer = vmalloc(RING_BUF_SIZE + 2 * PAGE_SIZE);
+	if (ring->buffer == NULL) {
+		pr_err("Error allocating ring memory\n");
+		goto init_ring_err;
+	}
+
+	for (j = 0; j < RING_BUF_SIZE + 2 * PAGE_SIZE; j++)
+		ring->buffer[j] = 0;
+
+	/*
+	 * Allocate the buffer info structure
+	 */
+	ring->info = vmalloc(sizeof(struct ppm_ring_buffer_info));
+	if (ring->info == NULL) {
+		pr_err("Error allocating ring memory\n");
+		goto init_ring_err;
+	}
+
+	/*
+	 * Initialize the buffer info structure
+	 */
+	reset_ring_buffer(ring);
+	atomic_set(&ring->preempt_count, 0);
+
+	pr_info("CPU buffer initialized, size=%d\n", RING_BUF_SIZE);
+
+	return 1;
+
+init_ring_err:
+	free_ring_buffer(ring);
+	return 0;
+}
+
+static void free_ring_buffer(struct ppm_ring_buffer_context *ring)
+{
+	if (ring->info) {
+		vfree(ring->info);
+		ring->info = NULL;
+	}
+
+	if (ring->buffer) {
+		vfree((void *)ring->buffer);
+		ring->buffer = NULL;
+	}
+
+	if (ring->str_storage) {
+		free_page((unsigned long)ring->str_storage);
+		ring->str_storage = NULL;
+	}
+}
+
+static void reset_ring_buffer(struct ppm_ring_buffer_context *ring)
+{
+	/*
+	 * ring->preempt_count is not reset to 0 on purpose, to prevent a race condition
+	 * see ppm_open
+	 */
+	ring->open = false;
+	ring->capture_enabled = false;
+	ring->info->head = 0;
+	ring->info->tail = 0;
+	ring->nevents = 0;
+	ring->info->n_evts = 0;
+	ring->info->n_drops_buffer = 0;
+	ring->info->n_drops_pf = 0;
+	ring->info->n_preemptions = 0;
+	ring->info->n_context_switches = 0;
+	getnstimeofday(&ring->last_print_time);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
+static void visit_tracepoint(struct tracepoint *tp, void *priv)
+{
+	if (!strcmp(tp->name, "sys_enter"))
+		tp_sys_enter = tp;
+	else if (!strcmp(tp->name, "sys_exit"))
+		tp_sys_exit = tp;
+	else if (!strcmp(tp->name, "sched_process_exit"))
+		tp_sched_process_exit = tp;
+#ifdef CAPTURE_CONTEXT_SWITCHES
+	else if (!strcmp(tp->name, "sched_switch"))
+		tp_sched_switch = tp;
+#endif
+#ifdef CAPTURE_SIGNAL_DELIVERIES
+	else if (!strcmp(tp->name, "signal_deliver"))
+		tp_signal_deliver = tp;
+#endif
+#ifdef CAPTURE_PAGE_FAULTS
+	else if (!strcmp(tp->name, "page_fault_user"))
+		tp_page_fault_user = tp;
+	else if (!strcmp(tp->name, "page_fault_kernel"))
+		tp_page_fault_kernel = tp;
+#endif
+}
+
+static int get_tracepoint_handles(void)
+{
+	for_each_kernel_tracepoint(visit_tracepoint, NULL);
+
+	if (!tp_sys_enter) {
+		pr_err("failed to find sys_enter tracepoint\n");
+		return -ENOENT;
+	}
+	if (!tp_sys_exit) {
+		pr_err("failed to find sys_exit tracepoint\n");
+		return -ENOENT;
+	}
+	if (!tp_sched_process_exit) {
+		pr_err("failed to find sched_process_exit tracepoint\n");
+		return -ENOENT;
+	}
+#ifdef CAPTURE_CONTEXT_SWITCHES
+	if (!tp_sched_switch) {
+		pr_err("failed to find sched_switch tracepoint\n");
+		return -ENOENT;
+	}
+#endif
+#ifdef CAPTURE_SIGNAL_DELIVERIES
+	if (!tp_signal_deliver) {
+		pr_err("failed to find signal_deliver tracepoint\n");
+		return -ENOENT;
+	}
+#endif
+#ifdef CAPTURE_PAGE_FAULTS
+	if (!tp_page_fault_user) {
+		pr_notice("failed to find page_fault_user tracepoint, disabling page-faults\n");
+		g_fault_tracepoint_disabled = true;
+	}
+	if (!tp_page_fault_kernel) {
+		pr_notice("failed to find page_fault_kernel tracepoint, disabling page-faults\n");
+		g_fault_tracepoint_disabled = true;
+	}
+#endif
+
+	return 0;
+}
+#else
+static int get_tracepoint_handles(void)
+{
+	return 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)
+static char *ppm_devnode(struct device *dev, umode_t *mode)
+#else
+static char *ppm_devnode(struct device *dev, mode_t *mode)
+#endif
+{
+	if (mode) {
+		*mode = 0400;
+
+		if (dev)
+			if (MINOR(dev->devt) == g_ppm_numdevs)
+				*mode = 0222;
+	}
+
+	return NULL;
+}
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20) */
+
+static int do_cpu_callback(unsigned long cpu, long sd_action)
+{
+	struct ppm_ring_buffer_context *ring;
+	struct ppm_consumer_t *consumer;
+	struct event_data_t event_data;
+
+	if (sd_action != 0) {
+		rcu_read_lock();
+
+		list_for_each_entry_rcu(consumer, &g_consumer_list, node) {
+			ring = per_cpu_ptr(consumer->ring_buffers, cpu);
+			if (sd_action == 1) {
+				/*
+				 * If the cpu was offline when the consumer was created,
+				 * this won't do anything because we never created a ring
+				 * buffer. We can't safely create one here because we're
+				 * in atomic context, and the consumer needs to call open
+				 * on this device anyways, so do it in ppm_open.
+				 */
+				ring->cpu_online = true;
+			} else if (sd_action == 2) {
+				ring->cpu_online = false;
+			}
+		}
+
+		rcu_read_unlock();
+
+		event_data.category = PPMC_CONTEXT_SWITCH;
+		event_data.event_info.context_data.sched_prev = (void *)cpu;
+		event_data.event_info.context_data.sched_next = (void *)sd_action;
+		record_event_all_consumers(PPME_CPU_HOTPLUG_E, UF_NEVER_DROP, &event_data);
+	}
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
+static int sysdig_cpu_online(unsigned int cpu)
+{
+	vpr_info("sysdig_cpu_online on cpu %d\n", cpu);
+	return do_cpu_callback(cpu, 1);
+}
+
+static int sysdig_cpu_offline(unsigned int cpu)
+{
+	vpr_info("sysdig_cpu_offline on cpu %d\n", cpu);
+	return do_cpu_callback(cpu, 2);
+}
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)) */
+/*
+ * This gets called every time a CPU is added or removed
+ */
+static int cpu_callback(struct notifier_block *self, unsigned long action,
+			void *hcpu)
+{
+	unsigned long cpu = (unsigned long)hcpu;
+	long sd_action = 0;
+
+	switch (action) {
+	case CPU_UP_PREPARE:
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+	case CPU_UP_PREPARE_FROZEN:
+#endif
+		sd_action = 1;
+		break;
+	case CPU_DOWN_PREPARE:
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+	case CPU_DOWN_PREPARE_FROZEN:
+#endif
+		sd_action = 2;
+		break;
+	default:
+		break;
+	}
+
+	if (do_cpu_callback(cpu, sd_action) < 0)
+		return NOTIFY_BAD;
+	else
+		return NOTIFY_OK;
+}
+
+static struct notifier_block cpu_notifier = {
+	.notifier_call = &cpu_callback,
+	.next = NULL,
+};
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0) */
+
+int sysdig_init(void)
+{
+	dev_t dev;
+	unsigned int cpu;
+	unsigned int num_cpus;
+	int ret;
+	int acrret = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
+	int hp_ret;
+#endif
+	int j;
+	int n_created_devices = 0;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+	struct device *device = NULL;
+#else
+	struct class_device *device = NULL;
+#endif
+	pr_info("driver loading, " PROBE_NAME " " PROBE_VERSION "\n");
+
+	ret = get_tracepoint_handles();
+	if (ret < 0)
+		goto init_module_err;
+
+	num_cpus = 0;
+	for_each_possible_cpu(cpu) {
+		++num_cpus;
+	}
+
+	/*
+	 * Initialize the user I/O
+	 * ( + 1 for sysdig-events)
+	 */
+	acrret = alloc_chrdev_region(&dev, 0, num_cpus + 1, PROBE_DEVICE_NAME);
+	if (acrret < 0) {
+		pr_err("could not allocate major number for %s\n", PROBE_DEVICE_NAME);
+		ret = -ENOMEM;
+		goto init_module_err;
+	}
+
+	g_ppm_class = class_create(THIS_MODULE, PROBE_DEVICE_NAME);
+	if (IS_ERR(g_ppm_class)) {
+		pr_err("can't allocate device class\n");
+		ret = -EFAULT;
+		goto init_module_err;
+	}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+	g_ppm_class->devnode = ppm_devnode;
+#endif
+
+	g_ppm_major = MAJOR(dev);
+	g_ppm_numdevs = num_cpus;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+	g_ppm_devs = kmalloc(g_ppm_numdevs * sizeof(struct ppm_device), GFP_KERNEL);
+#else
+	g_ppm_devs = kmalloc_array(g_ppm_numdevs, sizeof(struct ppm_device), GFP_KERNEL);
+#endif
+	if (!g_ppm_devs) {
+		pr_err("can't allocate devices\n");
+		ret = -ENOMEM;
+		goto init_module_err;
+	}
+
+	/*
+	 * We create a unique user level device for each of the ring buffers
+	 */
+	for (j = 0; j < g_ppm_numdevs; ++j) {
+		cdev_init(&g_ppm_devs[j].cdev, &g_ppm_fops);
+		g_ppm_devs[j].dev = MKDEV(g_ppm_major, j);
+
+		if (cdev_add(&g_ppm_devs[j].cdev, g_ppm_devs[j].dev, 1) < 0) {
+			pr_err("could not allocate chrdev for %s\n", PROBE_DEVICE_NAME);
+			ret = -EFAULT;
+			goto init_module_err;
+		}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+		device = device_create(
+#else
+		device = class_device_create(
+#endif
+						g_ppm_class, NULL, /* no parent device */
+						g_ppm_devs[j].dev,
+						NULL, /* no additional data */
+						PROBE_DEVICE_NAME "%d",
+						j);
+
+		if (IS_ERR(device)) {
+			pr_err("error creating the device for  %s\n", PROBE_DEVICE_NAME);
+			cdev_del(&g_ppm_devs[j].cdev);
+			ret = -EFAULT;
+			goto init_module_err;
+		}
+
+		init_waitqueue_head(&g_ppm_devs[j].read_queue);
+		n_created_devices++;
+	}
+
+	/* create_proc_read_entry(PPM_DEVICE_NAME, 0, NULL, ppm_read_proc, NULL); */
+
+	/*
+	 * Snaplen lookahead initialization
+	 */
+	if (dpi_lookahead_init() != PPM_SUCCESS) {
+		pr_err("initializing lookahead-based snaplen failed\n");
+		ret = -EFAULT;
+		goto init_module_err;
+	}
+
+	/*
+	 * Set up our callback in case we get a hotplug even while we are
+	 * initializing the cpu structures
+	 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
+	hp_ret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,
+					   "sysdig/probe:online",
+					   sysdig_cpu_online,
+					   sysdig_cpu_offline);
+	if (hp_ret <= 0) {
+		pr_err("error registering cpu hotplug callback\n");
+		ret = hp_ret;
+		goto init_module_err;
+	}
+	hp_state = hp_ret;
+#else
+	register_cpu_notifier(&cpu_notifier);
+#endif
+
+	/*
+	 * All ok. Final initializations.
+	 */
+	g_tracepoint_registered = false;
+
+	return 0;
+
+init_module_err:
+	for (j = 0; j < n_created_devices; ++j) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+		device_destroy(
+#else
+		class_device_destroy(
+#endif
+				g_ppm_class, g_ppm_devs[j].dev);
+
+		cdev_del(&g_ppm_devs[j].cdev);
+	}
+
+	if (g_ppm_class)
+		class_destroy(g_ppm_class);
+
+	if (acrret == 0)
+		unregister_chrdev_region(dev, g_ppm_numdevs);
+
+	kfree(g_ppm_devs);
+
+	return ret;
+}
+
+void sysdig_exit(void)
+{
+	int j;
+
+	pr_info("driver unloading\n");
+
+	for (j = 0; j < g_ppm_numdevs; ++j) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+		device_destroy(
+#else
+		class_device_destroy(
+#endif
+				g_ppm_class, g_ppm_devs[j].dev);
+		cdev_del(&g_ppm_devs[j].cdev);
+	}
+
+	if (g_ppm_class)
+		class_destroy(g_ppm_class);
+
+	/* + 1 for sysdig-events */
+	unregister_chrdev_region(MKDEV(g_ppm_major, 0), g_ppm_numdevs + 1);
+
+	kfree(g_ppm_devs);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+	tracepoint_synchronize_unregister();
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
+	if (hp_state > 0)
+		cpuhp_remove_state_nocalls(hp_state);
+#else
+	unregister_cpu_notifier(&cpu_notifier);
+#endif
+}
+
+module_init(sysdig_init);
+module_exit(sysdig_exit);
+module_param(max_consumers, uint, 0444);
+MODULE_PARM_DESC(max_consumers, "Maximum number of consumers that can simultaneously open the devices");
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+module_param(verbose, bool, 0444);
+#endif
+MODULE_PARM_DESC(verbose, "Enable verbose logging");
diff --git a/kernel/trace/sysdig/ppm.h b/kernel/trace/sysdig/ppm.h
new file mode 100644
index 0000000..8121782
--- /dev/null
+++ b/kernel/trace/sysdig/ppm.h
@@ -0,0 +1,142 @@
+/*
+Copyright (C) 2013-2014 Draios inc.
+
+This file is part of sysdig.
+
+sysdig is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License version 2 as
+published by the Free Software Foundation.
+
+sysdig is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with sysdig.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <linux/version.h>
+
+/*
+ * Our Own ASSERT implementation, so we can easily switch among BUG_ON, WARN_ON and nothing
+ */
+#ifdef _DEBUG
+#define ASSERT(expr) WARN_ON(!(expr))
+#else
+#define ASSERT(expr)
+#endif
+
+#include <linux/time.h>
+
+/*
+ * Global defines
+ */
+#define CAPTURE_CONTEXT_SWITCHES
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32))
+#define CAPTURE_SIGNAL_DELIVERIES
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(3, 12, 0)) && defined(CONFIG_X86)
+#define CAPTURE_PAGE_FAULTS
+#endif
+#define RW_SNAPLEN 80
+#define RW_SNAPLEN_EVENT 4096
+#define RW_MAX_SNAPLEN (256 * 1024 * 1024)
+#define DPI_LOOKAHED_SIZE 16
+#define PPM_NULL_RDEV MKDEV(1, 3)
+#define PPM_PORT_MYSQL 3306
+#define PPM_PORT_POSTGRES 5432
+#define PPM_PORT_STATSD 8125
+
+/*
+ * Global enums
+ */
+enum syscall_flags {
+	UF_NONE = 0,
+	UF_USED = (1 << 0),
+	UF_NEVER_DROP = (1 << 1),
+	UF_ALWAYS_DROP = (1 << 2),
+	UF_SIMPLEDRIVER_KEEP = (1 << 3),
+};
+
+/*
+ * Global structs
+ */
+struct syscall_evt_pair {
+	int flags;
+	enum ppm_event_type enter_event_type;
+	enum ppm_event_type exit_event_type;
+};
+
+/*
+ * The ring descriptor.
+ * We have one of these for each CPU.
+ */
+struct ppm_ring_buffer_context {
+	bool cpu_online;
+	bool open;
+	bool capture_enabled;
+	struct ppm_ring_buffer_info *info;
+	char *buffer;
+	struct timespec last_print_time;
+	u32 nevents;
+	atomic_t preempt_count;
+	char *str_storage;	/* String storage. Size is one page. */
+};
+
+struct ppm_consumer_t {
+	struct task_struct *consumer_id;
+#ifdef __percpu
+	struct ppm_ring_buffer_context __percpu *ring_buffers;
+#else
+	struct ppm_ring_buffer_context *ring_buffers;
+#endif
+	u32 snaplen;
+	u32 sampling_ratio;
+	bool do_dynamic_snaplen;
+	u32 sampling_interval;
+	int is_dropping;
+	int dropping_mode;
+	volatile int need_to_insert_drop_e;
+	volatile int need_to_insert_drop_x;
+	struct list_head node;
+};
+
+#define STR_STORAGE_SIZE PAGE_SIZE
+
+/*
+ * Global functions
+ *
+ * These are analogous to get_user(), copy_from_user() and strncpy_from_user(),
+ * but they can't sleep, barf on page fault or be preempted
+ */
+#define ppm_get_user(x, ptr) ({ ppm_copy_from_user(&x, ptr, sizeof(x)) ? -EFAULT : 0; })
+unsigned long ppm_copy_from_user(void *to, const void __user *from, unsigned long n);
+long ppm_strncpy_from_user(char *to, const char __user *from, unsigned long n);
+
+/*
+ * Global tables
+ */
+
+#ifdef CONFIG_MIPS
+  #define SYSCALL_TABLE_ID0 __NR_Linux
+#elif defined CONFIG_ARM
+  #define SYSCALL_TABLE_ID0 __NR_SYSCALL_BASE
+#elif defined CONFIG_X86 || defined CONFIG_SUPERH
+  #define SYSCALL_TABLE_ID0 0
+#elif defined CONFIG_PPC64
+  #define SYSCALL_TABLE_ID0 0
+#elif defined CONFIG_S390
+  #define SYSCALL_TABLE_ID0 0
+#endif
+
+#define SYSCALL_TABLE_SIZE 512
+
+extern const struct syscall_evt_pair g_syscall_table[];
+extern const struct ppm_event_info g_event_info[];
+extern const enum ppm_syscall_code g_syscall_code_routing_table[];
+
+#if defined(CONFIG_X86_64) && defined(CONFIG_IA32_EMULATION)
+extern const struct syscall_evt_pair g_syscall_ia32_table[];
+extern const enum ppm_syscall_code g_syscall_ia32_code_routing_table[];
+#endif
diff --git a/kernel/trace/sysdig/ppm_compat_unistd_32.h b/kernel/trace/sysdig/ppm_compat_unistd_32.h
new file mode 100644
index 0000000..acfe4ec
--- /dev/null
+++ b/kernel/trace/sysdig/ppm_compat_unistd_32.h
@@ -0,0 +1,401 @@
+#ifndef _ASM_X86_UNISTD_32_H
+#define _ASM_X86_UNISTD_32_H
+
+/*
+ * This file contains the system call numbers.
+ */
+
+#define __NR_ia32_restart_syscall      0
+#define __NR_ia32_exit		  1
+#define __NR_ia32_fork		  2
+#define __NR_ia32_read		  3
+#define __NR_ia32_write		  4
+#define __NR_ia32_open		  5
+#define __NR_ia32_close		  6
+#define __NR_ia32_waitpid		  7
+#define __NR_ia32_creat		  8
+#define __NR_ia32_link		  9
+#define __NR_ia32_unlink		 10
+#define __NR_ia32_execve		 11
+#define __NR_ia32_chdir		 12
+#define __NR_ia32_time		 13
+#define __NR_ia32_mknod		 14
+#define __NR_ia32_chmod		 15
+#define __NR_ia32_lchown		 16
+#define __NR_ia32_break		 17
+#define __NR_ia32_oldstat		 18
+#define __NR_ia32_lseek		 19
+#define __NR_ia32_getpid		 20
+#define __NR_ia32_mount		 21
+#define __NR_ia32_umount		 22
+#define __NR_ia32_setuid		 23
+#define __NR_ia32_getuid		 24
+#define __NR_ia32_stime		 25
+#define __NR_ia32_ptrace		 26
+#define __NR_ia32_alarm		 27
+#define __NR_ia32_oldfstat		 28
+#define __NR_ia32_pause		 29
+#define __NR_ia32_utime		 30
+#define __NR_ia32_stty		 31
+#define __NR_ia32_gtty		 32
+#define __NR_ia32_access		 33
+#define __NR_ia32_nice		 34
+#define __NR_ia32_ftime		 35
+#define __NR_ia32_sync		 36
+#define __NR_ia32_kill		 37
+#define __NR_ia32_rename		 38
+#define __NR_ia32_mkdir		 39
+#define __NR_ia32_rmdir		 40
+#define __NR_ia32_dup		 41
+#define __NR_ia32_pipe		 42
+#define __NR_ia32_times		 43
+#define __NR_ia32_prof		 44
+#define __NR_ia32_brk		 45
+#define __NR_ia32_setgid		 46
+#define __NR_ia32_getgid		 47
+#define __NR_ia32_signal		 48
+#define __NR_ia32_geteuid		 49
+#define __NR_ia32_getegid		 50
+#define __NR_ia32_acct		 51
+#define __NR_ia32_umount2		 52
+#define __NR_ia32_lock		 53
+#define __NR_ia32_ioctl		 54
+#define __NR_ia32_fcntl		 55
+#define __NR_ia32_mpx		 56
+#define __NR_ia32_setpgid		 57
+#define __NR_ia32_ulimit		 58
+#define __NR_ia32_oldolduname	 59
+#define __NR_ia32_umask		 60
+#define __NR_ia32_chroot		 61
+#define __NR_ia32_ustat		 62
+#define __NR_ia32_dup2		 63
+#define __NR_ia32_getppid		 64
+#define __NR_ia32_getpgrp		 65
+#define __NR_ia32_setsid		 66
+#define __NR_ia32_sigaction		 67
+#define __NR_ia32_sgetmask		 68
+#define __NR_ia32_ssetmask		 69
+#define __NR_ia32_setreuid		 70
+#define __NR_ia32_setregid		 71
+#define __NR_ia32_sigsuspend		 72
+#define __NR_ia32_sigpending		 73
+#define __NR_ia32_sethostname	 74
+#define __NR_ia32_setrlimit		 75
+#define __NR_ia32_getrlimit		 76   /* Back compatible 2Gig limited rlimit */
+#define __NR_ia32_getrusage		 77
+#define __NR_ia32_gettimeofday	 78
+#define __NR_ia32_settimeofday	 79
+#define __NR_ia32_getgroups		 80
+#define __NR_ia32_setgroups		 81
+#define __NR_ia32_select		 82
+#define __NR_ia32_symlink		 83
+#define __NR_ia32_oldlstat		 84
+#define __NR_ia32_readlink		 85
+#define __NR_ia32_uselib		 86
+#define __NR_ia32_swapon		 87
+#define __NR_ia32_reboot		 88
+#define __NR_ia32_readdir		 89
+#define __NR_ia32_mmap		 90
+#define __NR_ia32_munmap		 91
+#define __NR_ia32_truncate		 92
+#define __NR_ia32_ftruncate		 93
+#define __NR_ia32_fchmod		 94
+#define __NR_ia32_fchown		 95
+#define __NR_ia32_getpriority	 96
+#define __NR_ia32_setpriority	 97
+#define __NR_ia32_profil		 98
+#define __NR_ia32_statfs		 99
+#define __NR_ia32_fstatfs		100
+#define __NR_ia32_ioperm		101
+#define __NR_ia32_socketcall		102
+#define __NR_ia32_syslog		103
+#define __NR_ia32_setitimer		104
+#define __NR_ia32_getitimer		105
+#define __NR_ia32_stat		106
+#define __NR_ia32_lstat		107
+#define __NR_ia32_fstat		108
+#define __NR_ia32_olduname		109
+#define __NR_ia32_iopl		110
+#define __NR_ia32_vhangup		111
+#define __NR_ia32_idle		112
+#define __NR_ia32_vm86old		113
+#define __NR_ia32_wait4		114
+#define __NR_ia32_swapoff		115
+#define __NR_ia32_sysinfo		116
+#define __NR_ia32_ipc		117
+#define __NR_ia32_fsync		118
+#define __NR_ia32_sigreturn		119
+#define __NR_ia32_clone		120
+#define __NR_ia32_setdomainname	121
+#define __NR_ia32_uname		122
+#define __NR_ia32_modify_ldt		123
+#define __NR_ia32_adjtimex		124
+#define __NR_ia32_mprotect		125
+#define __NR_ia32_sigprocmask	126
+#define __NR_ia32_create_module	127
+#define __NR_ia32_init_module	128
+#define __NR_ia32_delete_module	129
+#define __NR_ia32_get_kernel_syms	130
+#define __NR_ia32_quotactl		131
+#define __NR_ia32_getpgid		132
+#define __NR_ia32_fchdir		133
+#define __NR_ia32_bdflush		134
+#define __NR_ia32_sysfs		135
+#define __NR_ia32_personality	136
+#define __NR_ia32_afs_syscall	137 /* Syscall for Andrew File System */
+#define __NR_ia32_setfsuid		138
+#define __NR_ia32_setfsgid		139
+#define __NR_ia32__llseek		140
+#define __NR_ia32_getdents		141
+#define __NR_ia32__newselect		142
+#define __NR_ia32_flock		143
+#define __NR_ia32_msync		144
+#define __NR_ia32_readv		145
+#define __NR_ia32_writev		146
+#define __NR_ia32_getsid		147
+#define __NR_ia32_fdatasync		148
+#define __NR_ia32__sysctl		149
+#define __NR_ia32_mlock		150
+#define __NR_ia32_munlock		151
+#define __NR_ia32_mlockall		152
+#define __NR_ia32_munlockall		153
+#define __NR_ia32_sched_setparam		154
+#define __NR_ia32_sched_getparam		155
+#define __NR_ia32_sched_setscheduler		156
+#define __NR_ia32_sched_getscheduler		157
+#define __NR_ia32_sched_yield		158
+#define __NR_ia32_sched_get_priority_max	159
+#define __NR_ia32_sched_get_priority_min	160
+#define __NR_ia32_sched_rr_get_interval	161
+#define __NR_ia32_nanosleep		162
+#define __NR_ia32_mremap		163
+#define __NR_ia32_setresuid		164
+#define __NR_ia32_getresuid		165
+#define __NR_ia32_vm86		166
+#define __NR_ia32_query_module	167
+#define __NR_ia32_poll		168
+#define __NR_ia32_nfsservctl		169
+#define __NR_ia32_setresgid		170
+#define __NR_ia32_getresgid		171
+#define __NR_ia32_prctl              172
+#define __NR_ia32_rt_sigreturn	173
+#define __NR_ia32_rt_sigaction	174
+#define __NR_ia32_rt_sigprocmask	175
+#define __NR_ia32_rt_sigpending	176
+#define __NR_ia32_rt_sigtimedwait	177
+#define __NR_ia32_rt_sigqueueinfo	178
+#define __NR_ia32_rt_sigsuspend	179
+#define __NR_ia32_pread64		180
+#define __NR_ia32_pwrite64		181
+#define __NR_ia32_chown		182
+#define __NR_ia32_getcwd		183
+#define __NR_ia32_capget		184
+#define __NR_ia32_capset		185
+#define __NR_ia32_sigaltstack	186
+#define __NR_ia32_sendfile		187
+#define __NR_ia32_getpmsg		188	/* some people actually want streams */
+#define __NR_ia32_putpmsg		189	/* some people actually want streams */
+#define __NR_ia32_vfork		190
+#define __NR_ia32_ugetrlimit		191	/* SuS compliant getrlimit */
+#define __NR_ia32_mmap2		192
+#define __NR_ia32_truncate64		193
+#define __NR_ia32_ftruncate64	194
+#define __NR_ia32_stat64		195
+#define __NR_ia32_lstat64		196
+#define __NR_ia32_fstat64		197
+#define __NR_ia32_lchown32		198
+#define __NR_ia32_getuid32		199
+#define __NR_ia32_getgid32		200
+#define __NR_ia32_geteuid32		201
+#define __NR_ia32_getegid32		202
+#define __NR_ia32_setreuid32		203
+#define __NR_ia32_setregid32		204
+#define __NR_ia32_getgroups32	205
+#define __NR_ia32_setgroups32	206
+#define __NR_ia32_fchown32		207
+#define __NR_ia32_setresuid32	208
+#define __NR_ia32_getresuid32	209
+#define __NR_ia32_setresgid32	210
+#define __NR_ia32_getresgid32	211
+#define __NR_ia32_chown32		212
+#define __NR_ia32_setuid32		213
+#define __NR_ia32_setgid32		214
+#define __NR_ia32_setfsuid32		215
+#define __NR_ia32_setfsgid32		216
+#define __NR_ia32_pivot_root		217
+#define __NR_ia32_mincore		218
+#define __NR_ia32_madvise		219
+#define __NR_ia32_madvise1		219	/* delete when C lib stub is removed */
+#define __NR_ia32_getdents64		220
+#define __NR_ia32_fcntl64		221
+/* 223 is unused */
+#define __NR_ia32_gettid		224
+#define __NR_ia32_readahead		225
+#define __NR_ia32_setxattr		226
+#define __NR_ia32_lsetxattr		227
+#define __NR_ia32_fsetxattr		228
+#define __NR_ia32_getxattr		229
+#define __NR_ia32_lgetxattr		230
+#define __NR_ia32_fgetxattr		231
+#define __NR_ia32_listxattr		232
+#define __NR_ia32_llistxattr		233
+#define __NR_ia32_flistxattr		234
+#define __NR_ia32_removexattr	235
+#define __NR_ia32_lremovexattr	236
+#define __NR_ia32_fremovexattr	237
+#define __NR_ia32_tkill		238
+#define __NR_ia32_sendfile64		239
+#define __NR_ia32_futex		240
+#define __NR_ia32_sched_setaffinity	241
+#define __NR_ia32_sched_getaffinity	242
+#define __NR_ia32_set_thread_area	243
+#define __NR_ia32_get_thread_area	244
+#define __NR_ia32_io_setup		245
+#define __NR_ia32_io_destroy		246
+#define __NR_ia32_io_getevents	247
+#define __NR_ia32_io_submit		248
+#define __NR_ia32_io_cancel		249
+#define __NR_ia32_fadvise64		250
+/* 251 is available for reuse (was briefly sys_set_zone_reclaim) */
+#define __NR_ia32_exit_group		252
+#define __NR_ia32_lookup_dcookie	253
+#define __NR_ia32_epoll_create	254
+#define __NR_ia32_epoll_ctl		255
+#define __NR_ia32_epoll_wait		256
+#define __NR_ia32_remap_file_pages	257
+#define __NR_ia32_set_tid_address	258
+#define __NR_ia32_timer_create	259
+#define __NR_ia32_timer_settime	(__NR_timer_create+1)
+#define __NR_ia32_timer_gettime	(__NR_timer_create+2)
+#define __NR_ia32_timer_getoverrun	(__NR_timer_create+3)
+#define __NR_ia32_timer_delete	(__NR_timer_create+4)
+#define __NR_ia32_clock_settime	(__NR_timer_create+5)
+#define __NR_ia32_clock_gettime	(__NR_timer_create+6)
+#define __NR_ia32_clock_getres	(__NR_timer_create+7)
+#define __NR_ia32_clock_nanosleep	(__NR_timer_create+8)
+#define __NR_ia32_statfs64		268
+#define __NR_ia32_fstatfs64		269
+#define __NR_ia32_tgkill		270
+#define __NR_ia32_utimes		271
+#define __NR_ia32_fadvise64_64	272
+#define __NR_ia32_vserver		273
+#define __NR_ia32_mbind		274
+#define __NR_ia32_get_mempolicy	275
+#define __NR_ia32_set_mempolicy	276
+#define __NR_ia32_mq_open 		277
+#define __NR_ia32_mq_unlink		(__NR_mq_open+1)
+#define __NR_ia32_mq_timedsend	(__NR_mq_open+2)
+#define __NR_ia32_mq_timedreceive	(__NR_mq_open+3)
+#define __NR_ia32_mq_notify		(__NR_mq_open+4)
+#define __NR_ia32_mq_getsetattr	(__NR_mq_open+5)
+#define __NR_ia32_kexec_load		283
+#define __NR_ia32_waitid		284
+/* #define __NR_ia32_sys_setaltroot	285 */
+#define __NR_ia32_add_key		286
+#define __NR_ia32_request_key	287
+#define __NR_ia32_keyctl		288
+#define __NR_ia32_ioprio_set		289
+#define __NR_ia32_ioprio_get		290
+#define __NR_ia32_inotify_init	291
+#define __NR_ia32_inotify_add_watch	292
+#define __NR_ia32_inotify_rm_watch	293
+#define __NR_ia32_migrate_pages	294
+#define __NR_ia32_openat		295
+#define __NR_ia32_mkdirat		296
+#define __NR_ia32_mknodat		297
+#define __NR_ia32_fchownat		298
+#define __NR_ia32_futimesat		299
+#define __NR_ia32_fstatat64		300
+#define __NR_ia32_unlinkat		301
+#define __NR_ia32_renameat		302
+#define __NR_ia32_linkat		303
+#define __NR_ia32_symlinkat		304
+#define __NR_ia32_readlinkat		305
+#define __NR_ia32_fchmodat		306
+#define __NR_ia32_faccessat		307
+#define __NR_ia32_pselect6		308
+#define __NR_ia32_ppoll		309
+#define __NR_ia32_unshare		310
+#define __NR_ia32_set_robust_list	311
+#define __NR_ia32_get_robust_list	312
+#define __NR_ia32_splice		313
+#define __NR_ia32_sync_file_range	314
+#define __NR_ia32_tee		315
+#define __NR_ia32_vmsplice		316
+#define __NR_ia32_move_pages		317
+#define __NR_ia32_getcpu		318
+#define __NR_ia32_epoll_pwait	319
+#define __NR_ia32_utimensat		320
+#define __NR_ia32_signalfd		321
+#define __NR_ia32_timerfd_create	322
+#define __NR_ia32_eventfd		323
+#define __NR_ia32_fallocate		324
+#define __NR_ia32_timerfd_settime	325
+#define __NR_ia32_timerfd_gettime	326
+#define __NR_ia32_signalfd4		327
+#define __NR_ia32_eventfd2		328
+#define __NR_ia32_epoll_create1	329
+#define __NR_ia32_dup3		330
+#define __NR_ia32_pipe2		331
+#define __NR_ia32_inotify_init1	332
+#define __NR_ia32_preadv		333
+#define __NR_ia32_pwritev		334
+#define __NR_ia32_rt_tgsigqueueinfo	335
+#define __NR_ia32_perf_event_open	336
+#define __NR_ia32_recvmmsg		337
+#define __NR_ia32_fanotify_init	338
+#define __NR_ia32_fanotify_mark	339
+#define __NR_ia32_prlimit64		340
+#define __NR_ia32_name_to_handle_at	341
+#define __NR_ia32_open_by_handle_at  342
+#define __NR_ia32_clock_adjtime	343
+#define __NR_ia32_syncfs             344
+#define __NR_ia32_sendmmsg		345
+#define __NR_ia32_setns		346
+#define __NR_ia32_process_vm_readv	347
+#define __NR_ia32_process_vm_writev	348
+
+#ifdef __KERNEL__
+
+#define NR_ia32_syscalls 349
+
+#define __ARCH_WANT_IPC_PARSE_VERSION
+#define __ARCH_WANT_OLD_READDIR
+#define __ARCH_WANT_OLD_STAT
+#define __ARCH_WANT_STAT64
+#define __ARCH_WANT_SYS_ALARM
+#define __ARCH_WANT_SYS_GETHOSTNAME
+#define __ARCH_WANT_SYS_IPC
+#define __ARCH_WANT_SYS_PAUSE
+#define __ARCH_WANT_SYS_SGETMASK
+#define __ARCH_WANT_SYS_SIGNAL
+#define __ARCH_WANT_SYS_TIME
+#define __ARCH_WANT_SYS_UTIME
+#define __ARCH_WANT_SYS_WAITPID
+#define __ARCH_WANT_SYS_SOCKETCALL
+#define __ARCH_WANT_SYS_FADVISE64
+#define __ARCH_WANT_SYS_GETPGRP
+#define __ARCH_WANT_SYS_LLSEEK
+#define __ARCH_WANT_SYS_NICE
+#define __ARCH_WANT_SYS_OLD_GETRLIMIT
+#define __ARCH_WANT_SYS_OLD_UNAME
+#define __ARCH_WANT_SYS_OLD_MMAP
+#define __ARCH_WANT_SYS_OLD_SELECT
+#define __ARCH_WANT_SYS_OLDUMOUNT
+#define __ARCH_WANT_SYS_SIGPENDING
+#define __ARCH_WANT_SYS_SIGPROCMASK
+#define __ARCH_WANT_SYS_RT_SIGACTION
+#define __ARCH_WANT_SYS_RT_SIGSUSPEND
+
+/*
+ * "Conditional" syscalls
+ *
+ * What we want is __attribute__((weak,alias("sys_ni_syscall"))),
+ * but it doesn't work on all toolchains, so we just do it by hand
+ */
+#ifndef cond_syscall
+#define cond_syscall(x) asm(".weak\t" #x "\n\t.set\t" #x ",sys_ni_syscall")
+#endif
+
+#endif /* __KERNEL__ */
+#endif /* _ASM_X86_UNISTD_32_H */
diff --git a/kernel/trace/sysdig/ppm_cputime.c b/kernel/trace/sysdig/ppm_cputime.c
new file mode 100644
index 0000000..93bd163
--- /dev/null
+++ b/kernel/trace/sysdig/ppm_cputime.c
@@ -0,0 +1,347 @@
+#include <linux/version.h>
+
+// These function are taken from the linux kernel and are used only
+// on versions that don't export task_cputime_adjusted()
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0))
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
+#include <asm/atomic.h>
+#else
+#include <linux/atomic.h>
+#endif
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/kdev_t.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/vmalloc.h>
+#include <linux/wait.h>
+#include <linux/tracepoint.h>
+#include <net/sock.h>
+
+#include <asm/unistd.h>
+
+#include "ppm_ringbuffer.h"
+#include "ppm_events_public.h"
+#include "ppm_events.h"
+#include "ppm.h"
+
+#if (defined CONFIG_VIRT_CPU_ACCOUNTING_NATIVE) || (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30))
+void ppm_task_cputime_adjusted(struct task_struct *p, cputime_t *ut, cputime_t *st)
+{
+	*ut = p->utime;
+	*st = p->stime;
+}
+#else
+
+#ifndef cmpxchg_cputime
+#define cmpxchg_cputime(ptr, old, new) cmpxchg(ptr, old, new)
+#endif
+
+#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN
+static unsigned long long vtime_delta(struct task_struct *tsk)
+{
+	unsigned long long clock;
+
+	clock = local_clock();
+	if (clock < tsk->vtime_snap)
+		return 0;
+
+	return clock - tsk->vtime_snap;
+}
+
+static void
+fetch_task_cputime(struct task_struct *t,
+		   cputime_t *u_dst, cputime_t *s_dst,
+		   cputime_t *u_src, cputime_t *s_src,
+		   cputime_t *udelta, cputime_t *sdelta)
+{
+	unsigned int seq;
+	unsigned long long delta;
+
+	do {
+		*udelta = 0;
+		*sdelta = 0;
+
+		seq = read_seqbegin(&t->vtime_seqlock);
+
+		if (u_dst)
+			*u_dst = *u_src;
+		if (s_dst)
+			*s_dst = *s_src;
+
+		/* Task is sleeping, nothing to add */
+		if (t->vtime_snap_whence == VTIME_SLEEPING ||
+		    is_idle_task(t))
+			continue;
+
+		delta = vtime_delta(t);
+
+		/*
+		 * Task runs either in user or kernel space, add pending nohz time to
+		 * the right place.
+		 */
+		if (t->vtime_snap_whence == VTIME_USER || t->flags & PF_VCPU) {
+			*udelta = delta;
+		} else {
+			if (t->vtime_snap_whence == VTIME_SYS)
+				*sdelta = delta;
+		}
+	} while (read_seqretry(&t->vtime_seqlock, seq));
+}
+
+void task_cputime(struct task_struct *t, cputime_t *utime, cputime_t *stime)
+{
+	cputime_t udelta, sdelta;
+
+	fetch_task_cputime(t, utime, stime, &t->utime,
+			   &t->stime, &udelta, &sdelta);
+	if (utime)
+		*utime += udelta;
+	if (stime)
+		*stime += sdelta;
+}
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0)
+static inline void task_cputime(struct task_struct *t,
+        cputime_t *utime, cputime_t *stime)
+{
+  if (utime)
+    *utime = t->utime;
+  if (stime)
+    *stime = t->stime;
+}
+#endif /* CONFIG_VIRT_CPU_ACCOUNTING_GEN */
+
+u64 nsecs_to_jiffies64(u64 n)
+{
+#if (NSEC_PER_SEC % HZ) == 0
+		/* Common case, HZ = 100, 128, 200, 250, 256, 500, 512, 1000 etc. */
+		return div_u64(n, NSEC_PER_SEC / HZ);
+#elif (HZ % 512) == 0
+		/* overflow after 292 years if HZ = 1024 */
+		return div_u64(n * HZ / 512, NSEC_PER_SEC / 512);
+#else
+		/*
+		 * Generic case - optimized for cases where HZ is a multiple of 3.
+		 * overflow after 64.99 years, exact for HZ = 60, 72, 90, 120 etc.
+		 */
+		return div_u64(n * 9, (9ull * NSEC_PER_SEC + HZ / 2) / HZ);
+#endif
+}
+
+unsigned long nsecs_to_jiffies(u64 n)
+{
+		return (unsigned long)nsecs_to_jiffies64(n);
+}
+
+#ifndef nsecs_to_cputime
+#ifdef msecs_to_cputime
+#define nsecs_to_cputime(__nsecs) \
+  msecs_to_cputime(div_u64((__nsecs), NSEC_PER_MSEC))
+#else
+#define  nsecs_to_cputime(__nsecs) nsecs_to_jiffies(__nsecs)
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
+/*
+ * Perform (stime * rtime) / total, but avoid multiplication overflow by
+ * loosing precision when the numbers are big.
+ */
+static cputime_t scale_stime(u64 stime, u64 rtime, u64 total)
+{
+	u64 scaled;
+
+	for (;;) {
+		/* Make sure "rtime" is the bigger of stime/rtime */
+		if (stime > rtime)
+			swap(rtime, stime);
+
+		/* Make sure 'total' fits in 32 bits */
+		if (total >> 32)
+			goto drop_precision;
+
+		/* Does rtime (and thus stime) fit in 32 bits? */
+		if (!(rtime >> 32))
+			break;
+
+		/* Can we just balance rtime/stime rather than dropping bits? */
+		if (stime >> 31)
+			goto drop_precision;
+
+		/* We can grow stime and shrink rtime and try to make them both fit */
+		stime <<= 1;
+		rtime >>= 1;
+		continue;
+
+drop_precision:
+		/* We drop from rtime, it has more bits than stime */
+		rtime >>= 1;
+		total >>= 1;
+	}
+
+	/*
+	 * Make sure gcc understands that this is a 32x32->64 multiply,
+	 * followed by a 64/32->64 divide.
+	 */
+	scaled = div_u64((u64) (u32) stime * (u64) (u32) rtime, (u32)total);
+	return (__force cputime_t) scaled;
+}
+
+/*
+ * Atomically advance counter to the new value. Interrupts, vcpu
+ * scheduling, and scaling inaccuracies can cause cputime_advance
+ * to be occasionally called with a new value smaller than counter.
+ * Let's enforce atomicity.
+ *
+ * Normally a caller will only go through this loop once, or not
+ * at all in case a previous caller updated counter the same jiffy.
+ */
+static void cputime_advance(cputime_t *counter, cputime_t new)
+{
+	cputime_t old;
+
+	while (new > (old = ACCESS_ONCE(*counter)))
+		cmpxchg_cputime(counter, old, new);
+}
+
+/*
+ * Adjust tick based cputime random precision against scheduler
+ * runtime accounting.
+ */
+static void cputime_adjust(struct task_cputime *curr,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 3, 0))
+			   struct prev_cputime *prev,
+#else
+			   struct cputime *prev,
+#endif
+			   cputime_t *ut, cputime_t *st)
+{
+	cputime_t rtime, stime, utime;
+
+	/*
+	 * Tick based cputime accounting depend on random scheduling
+	 * timeslices of a task to be interrupted or not by the timer.
+	 * Depending on these circumstances, the number of these interrupts
+	 * may be over or under-optimistic, matching the real user and system
+	 * cputime with a variable precision.
+	 *
+	 * Fix this by scaling these tick based values against the total
+	 * runtime accounted by the CFS scheduler.
+	 */
+	rtime = nsecs_to_cputime(curr->sum_exec_runtime);
+
+	/*
+	 * Update userspace visible utime/stime values only if actual execution
+	 * time is bigger than already exported. Note that can happen, that we
+	 * provided bigger values due to scaling inaccuracy on big numbers.
+	 */
+	if (prev->stime + prev->utime >= rtime)
+		goto out;
+
+	stime = curr->stime;
+	utime = curr->utime;
+
+	if (utime == 0) {
+		stime = rtime;
+	} else if (stime == 0) {
+		utime = rtime;
+	} else {
+		cputime_t total = stime + utime;
+
+		stime = scale_stime((__force u64)stime,
+				    (__force u64)rtime, (__force u64)total);
+		utime = rtime - stime;
+	}
+
+	cputime_advance(&prev->stime, stime);
+	cputime_advance(&prev->utime, utime);
+
+out:
+	*ut = prev->utime;
+	*st = prev->stime;
+}
+
+void ppm_task_cputime_adjusted(struct task_struct *p, cputime_t *ut, cputime_t *st)
+{
+	struct task_cputime cputime = {
+#ifdef CONFIG_SCHED_BFS
+		.sum_exec_runtime = tsk_seruntime(p),
+#else
+		.sum_exec_runtime = p->se.sum_exec_runtime,
+#endif
+	};
+
+	task_cputime(p, &cputime.utime, &cputime.stime);
+	cputime_adjust(&cputime, &p->prev_cputime, ut, st);
+}
+
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0) */
+
+static cputime_t scale_utime(cputime_t utime, cputime_t rtime, cputime_t total)
+{
+	u64 temp = (__force u64) rtime;
+
+	temp *= (__force u64) utime;
+
+	if (sizeof(cputime_t) == 4)
+		temp = div_u64(temp, (__force u32) total);
+	else
+		temp = div64_u64(temp, (__force u64) total);
+
+	return (__force cputime_t) temp;
+}
+
+// Taken from task_times(struct task_struct *p, cputime_t *ut, cputime_t *st)
+void ppm_task_cputime_adjusted(struct task_struct *p, cputime_t *ut, cputime_t *st)
+{
+	cputime_t rtime, utime = p->utime, total = utime + p->stime;
+
+	/*
+	 * Use CFS's precise accounting:
+	 */
+	rtime = nsecs_to_cputime(p->se.sum_exec_runtime);
+
+	if (total)
+		utime = scale_utime(utime, rtime, total);
+	else
+		utime = rtime;
+
+	/*
+	 * Compare with previous values, to keep monotonicity:
+	 */
+	p->prev_utime = max(p->prev_utime, utime);
+	p->prev_stime = max(p->prev_stime, rtime - p->prev_utime);
+
+	*ut = p->prev_utime;
+	*st = p->prev_stime;
+}
+
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)) */
+#endif /* (defined CONFIG_VIRT_CPU_ACCOUNTING_NATIVE) || (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)) */
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0)) */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0))
+#include <linux/time.h>
+#include <linux/param.h>
+
+/*
+ * Implementation copied from kernel/time/time.c in 4.11.0
+ */
+u64 nsec_to_clock_t(u64 x)
+{
+#if (NSEC_PER_SEC % USER_HZ) == 0
+	return div_u64(x, NSEC_PER_SEC / USER_HZ);
+#elif (USER_HZ % 512) == 0
+	return div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);
+#else
+	/*
+	 * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,
+	 * overflow after 64.99 years
+	 * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...
+	 */
+	return div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);
+#endif
+}
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(4, 11, 0)) */
diff --git a/kernel/trace/sysdig/ppm_events.c b/kernel/trace/sysdig/ppm_events.c
new file mode 100644
index 0000000..087223e
--- /dev/null
+++ b/kernel/trace/sysdig/ppm_events.c
@@ -0,0 +1,1508 @@
+/*
+Copyright (C) 2013-2014 Draios inc.
+
+This file is part of sysdig.
+
+sysdig is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License version 2 as
+published by the Free Software Foundation.
+
+sysdig is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with sysdig.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#define pr_fmt(fmt)	KBUILD_MODNAME ": " fmt
+
+#include <linux/compat.h>
+#include <linux/kobject.h>
+#include <linux/cdev.h>
+#include <net/sock.h>
+#include <net/af_unix.h>
+#include <net/compat.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/file.h>
+#include <linux/futex.h>
+#include <linux/fs_struct.h>
+#include <linux/uaccess.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <asm/mman.h>
+#include <linux/in.h>
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 20)
+#include <linux/mount.h>
+#include "ppm_syscall.h"
+#else
+#include <asm/syscall.h>
+#endif
+
+#include "ppm_ringbuffer.h"
+#include "ppm_events_public.h"
+#include "ppm_events.h"
+#include "ppm.h"
+
+
+/*
+ * The kernel patched with grsecurity makes the default access_ok trigger a
+ * might_sleep(), so if present we use the one defined by them
+ */
+#ifdef access_ok_noprefault
+#define ppm_access_ok access_ok_noprefault
+#else
+#define ppm_access_ok access_ok
+#endif
+
+extern bool g_tracers_enabled;
+
+static void memory_dump(char *p, size_t size)
+{
+	unsigned int j;
+
+	for (j = 0; j < size; j += 8)
+		pr_info("%*ph\n", 8, &p[j]);
+}
+
+/*
+ * Globals
+ */
+u32 g_http_options_intval;
+u32 g_http_get_intval;
+u32 g_http_head_intval;
+u32 g_http_post_intval;
+u32 g_http_put_intval;
+u32 g_http_delete_intval;
+u32 g_http_trace_intval;
+u32 g_http_connect_intval;
+u32 g_http_resp_intval;
+
+/*
+ * What this function does is basically a special memcpy
+ * so that, if the page fault handler detects the address is invalid,
+ * won't kill the process but will return a positive number
+ * Plus, this doesn't sleep.
+ * The risk is that if the buffer is partially paged out, we get an error.
+ * Returns the number of bytes NOT read.
+ */
+unsigned long ppm_copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	unsigned long res = n;
+
+	pagefault_disable();
+
+	if (likely(ppm_access_ok(VERIFY_READ, from, n)))
+		res = __copy_from_user_inatomic(to, from, n);
+
+	pagefault_enable();
+
+	return res;
+}
+
+/*
+ * On some kernels (e.g. 2.6.39), even with preemption disabled, the strncpy_from_user,
+ * instead of returning -1 after a page fault, schedules the process, so we drop events
+ * because of the preemption. This function reads the user buffer in atomic chunks, and
+ * returns when there's an error or the terminator is found
+ */
+long ppm_strncpy_from_user(char *to, const char __user *from, unsigned long n)
+{
+	long string_length = 0;
+	long res = -1;
+	unsigned long bytes_to_read = 4;
+	int j;
+
+	pagefault_disable();
+
+	while (n) {
+		/*
+		 * Read bytes_to_read bytes at a time, and look for the terminator. Should be fast
+		 * since the copy_from_user is optimized for the processor
+		 */
+		if (n < bytes_to_read)
+			bytes_to_read = n;
+
+		if (!ppm_access_ok(VERIFY_READ, from, bytes_to_read)) {
+			res = -1;
+			goto strncpy_end;
+		}
+
+		if (__copy_from_user_inatomic(to, from, bytes_to_read)) {
+			/*
+			 * Page fault
+			 */
+			res = -1;
+			goto strncpy_end;
+		}
+
+		n -= bytes_to_read;
+		from += bytes_to_read;
+
+		for (j = 0; j < bytes_to_read; ++j) {
+			++string_length;
+
+			if (!*to) {
+				res = string_length;
+				goto strncpy_end;
+			}
+
+			++to;
+		}
+	}
+
+strncpy_end:
+	pagefault_enable();
+	return res;
+}
+
+int32_t dpi_lookahead_init(void)
+{
+	g_http_options_intval = (*(u32 *)HTTP_OPTIONS_STR);
+	g_http_get_intval = (*(u32 *)HTTP_GET_STR);
+	g_http_head_intval = (*(u32 *)HTTP_HEAD_STR);
+	g_http_post_intval = (*(u32 *)HTTP_POST_STR);
+	g_http_put_intval = (*(u32 *)HTTP_PUT_STR);
+	g_http_delete_intval = (*(u32 *)HTTP_DELETE_STR);
+	g_http_trace_intval = (*(u32 *)HTTP_TRACE_STR);
+	g_http_connect_intval = (*(u32 *)HTTP_CONNECT_STR);
+	g_http_resp_intval = (*(u32 *)HTTP_RESP_STR);
+
+	return PPM_SUCCESS;
+}
+
+inline u32 compute_snaplen(struct event_filler_arguments *args, char *buf, u32 lookahead_size)
+{
+	u32 res = args->consumer->snaplen;
+	int err;
+	struct socket *sock;
+	sa_family_t family;
+	struct sockaddr_storage sock_address;
+	struct sockaddr_storage peer_address;
+	int sock_address_len;
+	int peer_address_len;
+	u16 sport, dport;
+
+	if (g_tracers_enabled && args->event_type == PPME_SYSCALL_WRITE_X) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+		struct fd f = fdget(args->fd);
+
+		if (f.file && f.file->f_inode) {
+			if (f.file->f_inode->i_rdev == PPM_NULL_RDEV) {
+				res = RW_SNAPLEN_EVENT;
+				fdput(f);
+				return res;
+			}
+
+			fdput(f);
+		}
+#else
+		struct file* file = fget(args->fd);
+		/* Use cached f_inode only on kernel versions that have it
+		 * https://github.com/torvalds/linux/commit/dd37978c50bc8b354e5c4633f69387f16572fdac
+		 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
+		if (file && file->f_inode) {
+			if (file->f_inode->i_rdev == PPM_NULL_RDEV) {
+		// Use f_dentry for older kernel versions
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,20)
+		if (file && file->f_dentry && file->f_dentry->d_inode) {
+			if (file->f_dentry->d_inode->i_rdev == PPM_NULL_RDEV) {
+#else
+		if (file && file->f_path.dentry && file->f_path.dentry->d_inode) {
+			if (file->f_path.dentry->d_inode->i_rdev == PPM_NULL_RDEV) {
+#endif
+				res = RW_SNAPLEN_EVENT;
+				fput(file);
+				return res;
+			}
+
+			fput(file);
+		}
+#endif
+	}
+
+	if (!args->consumer->do_dynamic_snaplen)
+		return res;
+
+	sock = sockfd_lookup(args->fd, &err);
+
+	if (sock) {
+
+		if (sock->sk) {
+			err = sock->ops->getname(sock, (struct sockaddr *)&sock_address, &sock_address_len, 0);
+
+			if (err == 0) {
+				if(args->event_type == PPME_SOCKET_SENDTO_X)
+				{
+					unsigned long val;
+					struct sockaddr __user * usrsockaddr;
+					/*
+					 * Get the address
+					 */
+					if (!args->is_socketcall)
+						syscall_get_arguments(current, args->regs, 4, 1, &val);
+					else
+						val = args->socketcall_args[4];
+
+					usrsockaddr = (struct sockaddr __user *)val;
+
+					if(usrsockaddr == NULL) {
+						/*
+						 * Suppose is a connected socket, fall back to fd
+						 */
+						err = sock->ops->getname(sock, (struct sockaddr *)&peer_address, &peer_address_len, 1);
+					} else {
+						/*
+						 * Get the address len
+						 */
+						if (!args->is_socketcall)
+							syscall_get_arguments(current, args->regs, 5, 1, &val);
+						else
+							val = args->socketcall_args[5];
+
+						if (val != 0) {
+							peer_address_len = val;
+							/*
+							 * Copy the address
+							 */
+							err = addr_to_kernel(usrsockaddr, val, (struct sockaddr *)&peer_address);
+						} else {
+							/*
+							 * This case should be very rare, fallback again to sock
+							 */
+							err = sock->ops->getname(sock, (struct sockaddr *)&peer_address, &peer_address_len, 1);
+						}
+					}
+				} else if (args->event_type == PPME_SOCKET_SENDMSG_X) {
+					unsigned long val;
+					struct sockaddr __user * usrsockaddr;
+					int addrlen;
+#ifdef CONFIG_COMPAT
+					struct compat_msghdr compat_mh;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+					struct user_msghdr mh;
+#else
+					struct msghdr mh;
+#endif
+
+					if (!args->is_socketcall)
+						syscall_get_arguments(current, args->regs, 1, 1, &val);
+					else
+						val = args->socketcall_args[1];
+
+#ifdef CONFIG_COMPAT
+					if (!args->compat) {
+#endif
+						if (unlikely(ppm_copy_from_user(&mh, (const void __user *)val, sizeof(mh)))) {
+							usrsockaddr = NULL;
+							addrlen = 0;
+						} else {
+							usrsockaddr = (struct sockaddr __user *)mh.msg_name;
+							addrlen = mh.msg_namelen;
+						}
+#ifdef CONFIG_COMPAT
+					} else {
+						if (unlikely(ppm_copy_from_user(&compat_mh, (const void __user *)compat_ptr(val), sizeof(compat_mh)))) {
+							usrsockaddr = NULL;
+							addrlen = 0;
+						} else {
+							usrsockaddr = (struct sockaddr __user *)compat_ptr(compat_mh.msg_name);
+							addrlen = compat_mh.msg_namelen;
+						}
+					}
+#endif
+
+					if (usrsockaddr != NULL && addrlen != 0) {
+						peer_address_len = addrlen;
+						/*
+						 * Copy the address
+						 */
+						err = addr_to_kernel(usrsockaddr, peer_address_len, (struct sockaddr *)&peer_address);
+					} else
+						/*
+						 * Suppose it is a connected socket, fall back to fd
+						 */
+						err = sock->ops->getname(sock, (struct sockaddr *)&peer_address, &peer_address_len, 1);
+				} else
+					err = sock->ops->getname(sock, (struct sockaddr *)&peer_address, &peer_address_len, 1);
+
+				if (err == 0) {
+					family = sock->sk->sk_family;
+
+					if (family == AF_INET) {
+						sport = ntohs(((struct sockaddr_in *) &sock_address)->sin_port);
+						dport = ntohs(((struct sockaddr_in *) &peer_address)->sin_port);
+					} else if (family == AF_INET6) {
+						sport = ntohs(((struct sockaddr_in6 *) &sock_address)->sin6_port);
+						dport = ntohs(((struct sockaddr_in6 *) &peer_address)->sin6_port);
+					} else {
+						sport = 0;
+						dport = 0;
+					}
+
+					if (sport == PPM_PORT_MYSQL || dport == PPM_PORT_MYSQL) {
+						if (lookahead_size >= 5) {
+							if (buf[0] == 3 || buf[1] == 3 || buf[2] == 3 || buf[3] == 3 || buf[4] == 3) {
+								sockfd_put(sock);
+								return 2000;
+							} else if (buf[2] == 0 && buf[3] == 0) {
+								sockfd_put(sock);
+								return 2000;
+							}
+						}
+					} else if (sport == PPM_PORT_POSTGRES || dport == PPM_PORT_POSTGRES) {
+						if (lookahead_size >= 2) {
+							if ((buf[0] == 'Q' && buf[1] == 0) || /* SimpleQuery command */
+								(buf[0] == 'P' && buf[1] == 0) || /* Prepare statement commmand */
+								(buf[4] == 0 && buf[5] == 3 && buf[6] == 0) || /* startup command */
+								(buf[0] == 'E' && buf[1] == 0) /* error or execute command */
+							) {
+								sockfd_put(sock);
+								return 2000;
+							}
+						}
+					} else if ((lookahead_size >= 4 && buf[1] == 0 && buf[2] == 0 && buf[2] == 0) || /* matches command */
+								(lookahead_size >= 16 && (*(int32_t *)(buf+12) == 1 || /* matches header */
+									*(int32_t *)(buf+12) == 2001 ||
+									*(int32_t *)(buf+12) == 2002 ||
+									*(int32_t *)(buf+12) == 2003 ||
+									*(int32_t *)(buf+12) == 2004 ||
+									*(int32_t *)(buf+12) == 2005 ||
+									*(int32_t *)(buf+12) == 2006 ||
+									*(int32_t *)(buf+12) == 2007)
+							   )
+							) {
+						sockfd_put(sock);
+						return 2000;
+					} else if (dport == PPM_PORT_STATSD) {
+						sockfd_put(sock);
+						return 2000;
+					} else {
+						if (lookahead_size >= 5) {
+							if (*(u32 *)buf == g_http_get_intval ||
+								*(u32 *)buf == g_http_post_intval ||
+								*(u32 *)buf == g_http_put_intval ||
+								*(u32 *)buf == g_http_delete_intval ||
+								*(u32 *)buf == g_http_trace_intval ||
+								*(u32 *)buf == g_http_connect_intval ||
+								*(u32 *)buf == g_http_options_intval ||
+								((*(u32 *)buf == g_http_resp_intval) && (buf[4] == '/'))
+							) {
+								sockfd_put(sock);
+								return 2000;
+							}
+						}
+					}
+				}
+			}
+		}
+
+		sockfd_put(sock);
+	}
+
+	return res;
+}
+
+/*
+ * NOTES:
+ * - val_len is ignored for everything other than PT_BYTEBUF.
+ * - fromuser is ignored for numeric types
+ * - dyn_idx is ignored for everything other than PT_DYN
+ */
+int val_to_ring(struct event_filler_arguments *args, uint64_t val, u16 val_len, bool fromuser, u8 dyn_idx)
+{
+	const struct ppm_param_info *param_info;
+	int len = -1;
+	u16 *psize = (u16 *)(args->buffer + args->curarg * sizeof(u16));
+
+	if (unlikely(args->curarg >= args->nargs)) {
+		pr_err("(%u)val_to_ring: too many arguments for event #%u, type=%u, curarg=%u, nargs=%u tid:%u\n",
+			smp_processor_id(),
+			args->nevents,
+			(u32)args->event_type,
+			args->curarg,
+			args->nargs,
+			current->pid);
+		memory_dump(args->buffer - sizeof(struct ppm_evt_hdr), 32);
+		ASSERT(0);
+		return PPM_FAILURE_BUG;
+	}
+
+	if (unlikely(args->arg_data_size == 0))
+		return PPM_FAILURE_BUFFER_FULL;
+
+	param_info = &(g_event_info[args->event_type].params[args->curarg]);
+	if (param_info->type == PT_DYN && param_info->info != NULL) {
+		const struct ppm_param_info *dyn_params;
+
+		if (unlikely(dyn_idx >= param_info->ninfo)) {
+			ASSERT(0);
+			return PPM_FAILURE_BUG;
+		}
+
+		dyn_params = (const struct ppm_param_info *)param_info->info;
+
+		param_info = &dyn_params[dyn_idx];
+		if (likely(args->arg_data_size >= sizeof(u8)))	{
+			*(u8 *)(args->buffer + args->arg_data_offset) = dyn_idx;
+			len = sizeof(u8);
+		} else {
+			return PPM_FAILURE_BUFFER_FULL;
+		}
+		args->arg_data_offset += len;
+		args->arg_data_size -= len;
+		*psize = (u16)len;
+	} else {
+		*psize = 0;
+	}
+
+	switch (param_info->type) {
+	case PT_CHARBUF:
+	case PT_FSPATH:
+		if (likely(val != 0)) {
+			if (fromuser) {
+				len = ppm_strncpy_from_user(args->buffer + args->arg_data_offset,
+					(const char __user *)(unsigned long)val, args->arg_data_size);
+
+				if (unlikely(len < 0))
+					return PPM_FAILURE_INVALID_USER_MEMORY;
+			} else {
+				len = strlcpy(args->buffer + args->arg_data_offset,
+								(const char *)(unsigned long)val,
+								args->arg_data_size);
+
+				if (++len > args->arg_data_size)
+					len = args->arg_data_size;
+			}
+
+			/*
+			 * Make sure the string is null-terminated
+			 */
+			*(char *)(args->buffer + args->arg_data_offset + len) = 0;
+		} else {
+			/*
+			 * Handle NULL pointers
+			 */
+			len = strlcpy(args->buffer + args->arg_data_offset,
+				"(NULL)",
+				args->arg_data_size);
+
+			if (++len > args->arg_data_size)
+				len = args->arg_data_size;
+		}
+
+		break;
+	case PT_BYTEBUF:
+		if (likely(val != 0)) {
+			if (fromuser) {
+				/*
+				 * Copy the lookahead portion of the buffer that we will use DPI-based
+				 * snaplen calculation
+				 */
+				u32 dpi_lookahead_size = DPI_LOOKAHED_SIZE;
+
+				if (dpi_lookahead_size > val_len)
+					dpi_lookahead_size = val_len;
+
+				if (unlikely(dpi_lookahead_size >= args->arg_data_size))
+					return PPM_FAILURE_BUFFER_FULL;
+
+				len = (int)ppm_copy_from_user(args->buffer + args->arg_data_offset,
+						(const void __user *)(unsigned long)val,
+						dpi_lookahead_size);
+
+				if (unlikely(len != 0))
+					return PPM_FAILURE_INVALID_USER_MEMORY;
+
+				/*
+				 * Check if there's more to copy
+				 */
+				if (likely((dpi_lookahead_size != val_len))) {
+					/*
+					 * Calculate the snaplen
+					 */
+					if (likely(args->enforce_snaplen)) {
+						u32 sl = args->consumer->snaplen;
+
+						sl = compute_snaplen(args, args->buffer + args->arg_data_offset, dpi_lookahead_size);
+
+						if (val_len > sl)
+							val_len = sl;
+					}
+
+					if (unlikely((val_len) >= args->arg_data_size))
+						val_len = args->arg_data_size;
+
+					if (val_len > dpi_lookahead_size) {
+						len = (int)ppm_copy_from_user(args->buffer + args->arg_data_offset + dpi_lookahead_size,
+								(const void __user *)(unsigned long)val + dpi_lookahead_size,
+								val_len - dpi_lookahead_size);
+
+						if (unlikely(len != 0))
+							return PPM_FAILURE_INVALID_USER_MEMORY;
+					}
+				}
+
+				len = val_len;
+			} else {
+				if (likely(args->enforce_snaplen)) {
+					u32 sl = compute_snaplen(args, (char *)(unsigned long)val, val_len);
+
+					if (val_len > sl)
+						val_len = sl;
+				}
+
+				if (unlikely(val_len >= args->arg_data_size))
+					return PPM_FAILURE_BUFFER_FULL;
+
+				memcpy(args->buffer + args->arg_data_offset,
+					(void *)(unsigned long)val, val_len);
+
+				len = val_len;
+			}
+		} else {
+			/*
+			 * Handle NULL pointers
+			 */
+			len = 0;
+		}
+
+		break;
+	case PT_SOCKADDR:
+	case PT_SOCKTUPLE:
+	case PT_FDLIST:
+		if (likely(val != 0)) {
+			if (unlikely(val_len >= args->arg_data_size))
+				return PPM_FAILURE_BUFFER_FULL;
+
+			if (fromuser) {
+				len = (int)ppm_copy_from_user(args->buffer + args->arg_data_offset,
+						(const void __user *)(unsigned long)val,
+						val_len);
+
+				if (unlikely(len != 0))
+					return PPM_FAILURE_INVALID_USER_MEMORY;
+
+				len = val_len;
+			} else {
+				memcpy(args->buffer + args->arg_data_offset,
+					(void *)(unsigned long)val, val_len);
+
+				len = val_len;
+			}
+		} else {
+			/*
+			 * Handle NULL pointers
+			 */
+			len = 0;
+		}
+
+		break;
+	case PT_FLAGS8:
+	case PT_UINT8:
+	case PT_SIGTYPE:
+		if (likely(args->arg_data_size >= sizeof(u8)))	{
+			*(u8 *)(args->buffer + args->arg_data_offset) = (u8)val;
+			len = sizeof(u8);
+		} else {
+			return PPM_FAILURE_BUFFER_FULL;
+		}
+
+		break;
+	case PT_FLAGS16:
+	case PT_UINT16:
+	case PT_SYSCALLID:
+		if (likely(args->arg_data_size >= sizeof(u16))) {
+			*(u16 *)(args->buffer + args->arg_data_offset) = (u16)val;
+			len = sizeof(u16);
+		} else {
+			return PPM_FAILURE_BUFFER_FULL;
+		}
+
+		break;
+	case PT_FLAGS32:
+	case PT_UINT32:
+	case PT_UID:
+	case PT_GID:
+	case PT_SIGSET:
+		if (likely(args->arg_data_size >= sizeof(u32))) {
+			*(u32 *)(args->buffer + args->arg_data_offset) = (u32)val;
+			len = sizeof(u32);
+		} else {
+			return PPM_FAILURE_BUFFER_FULL;
+		}
+
+		break;
+	case PT_RELTIME:
+	case PT_ABSTIME:
+	case PT_UINT64:
+		if (likely(args->arg_data_size >= sizeof(u64))) {
+			*(u64 *)(args->buffer + args->arg_data_offset) = (u64)val;
+			len = sizeof(u64);
+		} else {
+			return PPM_FAILURE_BUFFER_FULL;
+		}
+
+		break;
+	case PT_INT8:
+		if (likely(args->arg_data_size >= sizeof(s8))) {
+			*(s8 *)(args->buffer + args->arg_data_offset) = (s8)(long)val;
+			len = sizeof(s8);
+		} else {
+			return PPM_FAILURE_BUFFER_FULL;
+		}
+
+		break;
+	case PT_INT16:
+		if (likely(args->arg_data_size >= sizeof(s16))) {
+			*(s16 *)(args->buffer + args->arg_data_offset) = (s16)(long)val;
+			len = sizeof(s16);
+		} else {
+			return PPM_FAILURE_BUFFER_FULL;
+		}
+
+		break;
+	case PT_INT32:
+		if (likely(args->arg_data_size >= sizeof(s32))) {
+			*(s32 *)(args->buffer + args->arg_data_offset) = (s32)(long)val;
+			len = sizeof(s32);
+		} else {
+			return PPM_FAILURE_BUFFER_FULL;
+		}
+
+		break;
+	case PT_INT64:
+	case PT_ERRNO:
+	case PT_FD:
+	case PT_PID:
+		if (likely(args->arg_data_size >= sizeof(s64))) {
+			*(s64 *)(args->buffer + args->arg_data_offset) = (s64)(long)val;
+			len = sizeof(s64);
+		} else {
+			return PPM_FAILURE_BUFFER_FULL;
+		}
+
+		break;
+	default:
+		ASSERT(0);
+		pr_err("val_to_ring: invalid argument type %d. Event %u (%s) might have less parameters than what has been declared in nparams\n",
+			(int)g_event_info[args->event_type].params[args->curarg].type,
+			(u32)args->event_type,
+			g_event_info[args->event_type].name);
+		return PPM_FAILURE_BUG;
+	}
+
+	ASSERT(len <= 65535);
+	ASSERT(len <= args->arg_data_size);
+
+	*psize += (u16)len;
+	args->curarg++;
+	args->arg_data_offset += len;
+	args->arg_data_size -= len;
+
+	return PPM_SUCCESS;
+}
+
+static inline u8 socket_family_to_scap(u8 family)
+{
+	if (family == AF_INET)
+		return PPM_AF_INET;
+	else if (family == AF_INET6)
+		return PPM_AF_INET6;
+	else if (family == AF_UNIX)
+		return PPM_AF_UNIX;
+	else if (family == AF_NETLINK)
+		return PPM_AF_NETLINK;
+	else if (family == AF_PACKET)
+		return PPM_AF_PACKET;
+	else if (family == AF_UNSPEC)
+		return PPM_AF_UNSPEC;
+	else if (family == AF_AX25)
+		return PPM_AF_AX25;
+	else if (family == AF_IPX)
+		return PPM_AF_IPX;
+	else if (family == AF_APPLETALK)
+		return PPM_AF_APPLETALK;
+	else if (family == AF_NETROM)
+		return PPM_AF_NETROM;
+	else if (family == AF_BRIDGE)
+		return PPM_AF_BRIDGE;
+	else if (family == AF_ATMPVC)
+		return PPM_AF_ATMPVC;
+	else if (family == AF_X25)
+		return PPM_AF_X25;
+	else if (family == AF_ROSE)
+		return PPM_AF_ROSE;
+	else if (family == AF_DECnet)
+		return PPM_AF_DECnet;
+	else if (family == AF_NETBEUI)
+		return PPM_AF_NETBEUI;
+	else if (family == AF_SECURITY)
+		return PPM_AF_SECURITY;
+	else if (family == AF_KEY)
+		return PPM_AF_KEY;
+	else if (family == AF_ROUTE)
+		return PPM_AF_ROUTE;
+	else if (family == AF_ASH)
+		return PPM_AF_ASH;
+	else if (family == AF_ECONET)
+		return PPM_AF_ECONET;
+	else if (family == AF_ATMSVC)
+		return PPM_AF_ATMSVC;
+#ifdef AF_RDS
+	else if (family == AF_RDS)
+		return PPM_AF_RDS;
+#endif
+	else if (family == AF_SNA)
+		return PPM_AF_SNA;
+	else if (family == AF_IRDA)
+		return PPM_AF_IRDA;
+	else if (family == AF_PPPOX)
+		return PPM_AF_PPPOX;
+	else if (family == AF_WANPIPE)
+		return PPM_AF_WANPIPE;
+	else if (family == AF_LLC)
+		return PPM_AF_LLC;
+#ifdef AF_CAN
+	else if (family == AF_CAN)
+		return PPM_AF_CAN;
+#endif
+	 else if (family == AF_TIPC)
+		return PPM_AF_TIPC;
+	else if (family == AF_BLUETOOTH)
+		return PPM_AF_BLUETOOTH;
+	else if (family == AF_IUCV)
+		return PPM_AF_IUCV;
+#ifdef AF_RXRPC
+	else if (family == AF_RXRPC)
+		return PPM_AF_RXRPC;
+#endif
+#ifdef AF_ISDN
+	else if (family == AF_ISDN)
+		return PPM_AF_ISDN;
+#endif
+#ifdef AF_PHONET
+	else if (family == AF_PHONET)
+		return PPM_AF_PHONET;
+#endif
+#ifdef AF_IEEE802154
+	else if (family == AF_IEEE802154)
+		return PPM_AF_IEEE802154;
+#endif
+#ifdef AF_CAIF
+	else if (family == AF_CAIF)
+		return PPM_AF_CAIF;
+#endif
+#ifdef AF_ALG
+	else if (family == AF_ALG)
+		return PPM_AF_ALG;
+#endif
+#ifdef AF_NFC
+	else if (family == AF_NFC)
+		return PPM_AF_NFC;
+#endif
+	else {
+		ASSERT(false);
+		return PPM_AF_UNSPEC;
+	}
+}
+
+/*
+static struct socket *ppm_sockfd_lookup_light(int fd, int *err, int *fput_needed)
+{
+	struct file *file;
+	struct socket *sock;
+
+	*err = -EBADF;
+	file = fget_light(fd, fput_needed);
+	if (file) {
+		sock = sock_from_file(file, err);
+		if (sock)
+			return sock;
+		fput_light(file, *fput_needed);
+	}
+	return NULL;
+}
+*/
+
+/*
+ * Convert a sockaddr into our address representation and copy it to
+ * targetbuf
+ */
+u16 pack_addr(struct sockaddr *usrsockaddr,
+	int ulen,
+	char *targetbuf,
+	u16 targetbufsize)
+{
+	u32 ip;
+	u16 port;
+	sa_family_t family = usrsockaddr->sa_family;
+	struct sockaddr_in *usrsockaddr_in;
+	struct sockaddr_in6 *usrsockaddr_in6;
+	struct sockaddr_un *usrsockaddr_un;
+	u16 size;
+	char *dest;
+
+	switch (family) {
+	case AF_INET:
+		/*
+		 * Map the user-provided address to a sockaddr_in
+		 */
+		usrsockaddr_in = (struct sockaddr_in *)usrsockaddr;
+
+		/*
+		 * Retrieve the src address
+		 */
+		ip = usrsockaddr_in->sin_addr.s_addr;
+		port = ntohs(usrsockaddr_in->sin_port);
+
+		/*
+		 * Pack the tuple info in the temporary buffer
+		 */
+		size = 1 + 4 + 2; /* family + ip + port */
+
+		*targetbuf = socket_family_to_scap(family);
+		*(u32 *)(targetbuf + 1) = ip;
+		*(u16 *)(targetbuf + 5) = port;
+
+		break;
+	case AF_INET6:
+		/*
+		 * Map the user-provided address to a sockaddr_in
+		 */
+		usrsockaddr_in6 = (struct sockaddr_in6 *)usrsockaddr;
+
+		/*
+		 * Retrieve the src address
+		 */
+		port = ntohs(usrsockaddr_in6->sin6_port);
+
+		/*
+		 * Pack the tuple info in the temporary buffer
+		 */
+		size = 1 + 16 + 2; /* family + ip + port */
+
+		*targetbuf = socket_family_to_scap(family);
+		memcpy(targetbuf + 1,
+			usrsockaddr_in6->sin6_addr.s6_addr,
+			16);
+		*(u16 *)(targetbuf + 17) = port;
+
+		break;
+	case AF_UNIX:
+		/*
+		 * Map the user-provided address to a sockaddr_in
+		 */
+		usrsockaddr_un = (struct sockaddr_un *)usrsockaddr;
+
+		/*
+		 * Put a 0 at the end of struct sockaddr_un because
+		 * the user might not have considered it in the length
+		 */
+		if (ulen == sizeof(struct sockaddr_storage))
+			*(((char *)usrsockaddr_un) + ulen - 1) = 0;
+		else
+			*(((char *)usrsockaddr_un) + ulen) = 0;
+
+		/*
+		 * Pack the data into the target buffer
+		 */
+		size = 1;
+
+		*targetbuf = socket_family_to_scap(family);
+		dest = strncpy(targetbuf + 1,
+					usrsockaddr_un->sun_path,
+					UNIX_PATH_MAX);	/* we assume this will be smaller than (targetbufsize - (1 + 8 + 8)) */
+
+		dest[UNIX_PATH_MAX - 1] = 0;
+		size += strlen(dest) + 1;
+
+		break;
+	default:
+		size = 0;
+		break;
+	}
+
+	return size;
+}
+
+/*
+ * Convert a connection tuple into our tuple representation and copy it to
+ * targetbuf
+ */
+u16 fd_to_socktuple(int fd,
+	struct sockaddr *usrsockaddr,
+	int ulen,
+	bool use_userdata,
+	bool is_inbound,
+	char *targetbuf,
+	u16 targetbufsize)
+{
+	struct socket *sock;
+	int err = 0;
+	sa_family_t family;
+	struct unix_sock *us;
+	char *us_name;
+	struct sock *speer;
+	u32 sip;
+	u32 dip;
+	u8 *sip6;
+	u8 *dip6;
+	u16 sport;
+	u16 dport;
+	struct sockaddr_in *usrsockaddr_in;
+	struct sockaddr_in6 *usrsockaddr_in6;
+	struct sockaddr_un *usrsockaddr_un;
+	u16 size;
+	char *dest;
+	struct sockaddr_storage sock_address;
+	struct sockaddr_storage peer_address;
+	int sock_address_len;
+	int peer_address_len;
+
+	/*
+	 * Get the socket from the fd
+	 * NOTE: sockfd_lookup() locks the socket, so we don't need to worry when we dig in it
+	 */
+	sock = sockfd_lookup(fd, &err);
+
+	if (unlikely(!sock || !(sock->sk))) {
+		/*
+		 * This usually happens if the call failed without being able to establish a connection,
+		 * i.e. if it didn't return something like SE_EINPROGRESS.
+		 */
+		if (sock)
+			sockfd_put(sock);
+		return 0;
+	}
+
+	err = sock->ops->getname(sock, (struct sockaddr *)&sock_address, &sock_address_len, 0);
+	ASSERT(err == 0);
+
+	family = sock->sk->sk_family;
+
+	/*
+	 * Extract and pack the info, based on the family
+	 */
+	switch (family) {
+	case AF_INET:
+		if (!use_userdata) {
+			err = sock->ops->getname(sock, (struct sockaddr *)&peer_address, &peer_address_len, 1);
+			if (err == 0) {
+				if (is_inbound) {
+					sip = ((struct sockaddr_in *) &peer_address)->sin_addr.s_addr;
+					sport = ntohs(((struct sockaddr_in *) &peer_address)->sin_port);
+					dip = ((struct sockaddr_in *) &sock_address)->sin_addr.s_addr;
+					dport = ntohs(((struct sockaddr_in *) &sock_address)->sin_port);
+				} else {
+					sip = ((struct sockaddr_in *) &sock_address)->sin_addr.s_addr;
+					sport = ntohs(((struct sockaddr_in *) &sock_address)->sin_port);
+					dip = ((struct sockaddr_in *) &peer_address)->sin_addr.s_addr;
+					dport = ntohs(((struct sockaddr_in *) &peer_address)->sin_port);
+				}
+			} else {
+				sip = 0;
+				sport = 0;
+				dip = 0;
+				dport = 0;
+			}
+		} else {
+			/*
+			 * Map the user-provided address to a sockaddr_in
+			 */
+			usrsockaddr_in = (struct sockaddr_in *)usrsockaddr;
+
+			if (is_inbound) {
+				sip = usrsockaddr_in->sin_addr.s_addr;
+				sport = ntohs(usrsockaddr_in->sin_port);
+				dip = ((struct sockaddr_in *) &sock_address)->sin_addr.s_addr;
+				dport = ntohs(((struct sockaddr_in *) &sock_address)->sin_port);
+			} else {
+				sip = ((struct sockaddr_in *) &sock_address)->sin_addr.s_addr;
+				sport = ntohs(((struct sockaddr_in *) &sock_address)->sin_port);
+				dip = usrsockaddr_in->sin_addr.s_addr;
+				dport = ntohs(usrsockaddr_in->sin_port);
+			}
+		}
+
+		/*
+		 * Pack the tuple info in the temporary buffer
+		 */
+		size = 1 + 4 + 4 + 2 + 2; /* family + sip + dip + sport + dport */
+
+		*targetbuf = socket_family_to_scap(family);
+		*(u32 *)(targetbuf + 1) = sip;
+		*(u16 *)(targetbuf + 5) = sport;
+		*(u32 *)(targetbuf + 7) = dip;
+		*(u16 *)(targetbuf + 11) = dport;
+
+		break;
+	case AF_INET6:
+		if (!use_userdata) {
+			err = sock->ops->getname(sock, (struct sockaddr *)&peer_address, &peer_address_len, 1);
+			ASSERT(err == 0);
+
+			if (is_inbound) {
+				sip6 = ((struct sockaddr_in6 *) &peer_address)->sin6_addr.s6_addr;
+				sport = ntohs(((struct sockaddr_in6 *) &peer_address)->sin6_port);
+				dip6 = ((struct sockaddr_in6 *) &sock_address)->sin6_addr.s6_addr;
+				dport = ntohs(((struct sockaddr_in6 *) &sock_address)->sin6_port);
+			} else {
+				sip6 = ((struct sockaddr_in6 *) &sock_address)->sin6_addr.s6_addr;
+				sport = ntohs(((struct sockaddr_in6 *) &sock_address)->sin6_port);
+				dip6 = ((struct sockaddr_in6 *) &peer_address)->sin6_addr.s6_addr;
+				dport = ntohs(((struct sockaddr_in6 *) &peer_address)->sin6_port);
+			}
+		} else {
+			/*
+			 * Map the user-provided address to a sockaddr_in6
+			 */
+			usrsockaddr_in6 = (struct sockaddr_in6 *)usrsockaddr;
+
+			if (is_inbound) {
+				sip6 = usrsockaddr_in6->sin6_addr.s6_addr;
+				sport = ntohs(usrsockaddr_in6->sin6_port);
+				dip6 = ((struct sockaddr_in6 *) &sock_address)->sin6_addr.s6_addr;
+				dport = ntohs(((struct sockaddr_in6 *) &sock_address)->sin6_port);
+			} else {
+				sip6 = ((struct sockaddr_in6 *) &sock_address)->sin6_addr.s6_addr;
+				sport = ntohs(((struct sockaddr_in6 *) &sock_address)->sin6_port);
+				dip6 = usrsockaddr_in6->sin6_addr.s6_addr;
+				dport = ntohs(usrsockaddr_in6->sin6_port);
+			}
+		}
+
+		/*
+		 * Pack the tuple info in the temporary buffer
+		 */
+		size = 1 + 16 + 16 + 2 + 2; /* family + sip + dip + sport + dport */
+
+		*targetbuf = socket_family_to_scap(family);
+		memcpy(targetbuf + 1,
+			sip6,
+			16);
+		*(u16 *)(targetbuf + 17) = sport;
+		memcpy(targetbuf + 19,
+			dip6,
+			16);
+		*(u16 *)(targetbuf + 35) = dport;
+
+		break;
+	case AF_UNIX:
+		/*
+		 * Retrieve the addresses
+		 */
+		us = unix_sk(sock->sk);
+		speer = us->peer;
+
+		*targetbuf = socket_family_to_scap(family);
+
+		if (is_inbound) {
+			*(uint64_t *)(targetbuf + 1) = (uint64_t)(unsigned long)us;
+			*(uint64_t *)(targetbuf + 1 + 8) = (uint64_t)(unsigned long)speer;
+		} else {
+			*(uint64_t *)(targetbuf + 1) = (uint64_t)(unsigned long)speer;
+			*(uint64_t *)(targetbuf + 1 + 8) = (uint64_t)(unsigned long)us;
+		}
+
+		/*
+		 * Pack the data into the target buffer
+		 */
+		size = 1 + 8 + 8;
+
+		if (!use_userdata) {
+			if (is_inbound) {
+				us_name = ((struct sockaddr_un *) &sock_address)->sun_path;
+			} else {
+				err = sock->ops->getname(sock, (struct sockaddr *)&peer_address, &peer_address_len, 1);
+				ASSERT(err == 0);
+
+				us_name = ((struct sockaddr_un *) &peer_address)->sun_path;
+			}
+		} else {
+			/*
+			 * Map the user-provided address to a sockaddr_in
+			 */
+			usrsockaddr_un = (struct sockaddr_un *)usrsockaddr;
+
+			/*
+			 * Put a 0 at the end of struct sockaddr_un because
+			 * the user might not have considered it in the length
+			 */
+			if (ulen == sizeof(struct sockaddr_storage))
+				*(((char *)usrsockaddr_un) + ulen - 1) = 0;
+			else
+				*(((char *)usrsockaddr_un) + ulen) = 0;
+
+			if (is_inbound)
+				us_name = ((struct sockaddr_un *) &sock_address)->sun_path;
+			else
+				us_name = usrsockaddr_un->sun_path;
+		}
+
+		ASSERT(us_name);
+		dest = strncpy(targetbuf + 1 + 8 + 8,
+					(char *)us_name,
+					UNIX_PATH_MAX);	/* we assume this will be smaller than (targetbufsize - (1 + 8 + 8)) */
+
+		dest[UNIX_PATH_MAX - 1] = 0;
+		size += strlen(dest) + 1;
+		break;
+	default:
+		size = 0;
+		break;
+	}
+
+	/*
+	 * Digging finished. We can release the fd.
+	 */
+	sockfd_put(sock);
+
+	return size;
+}
+
+int addr_to_kernel(void __user *uaddr, int ulen, struct sockaddr *kaddr)
+{
+	if (unlikely(ulen < 0 || ulen > sizeof(struct sockaddr_storage)))
+		return -EINVAL;
+
+	if (unlikely(ulen == 0))
+		return 0;
+
+	if (unlikely(ppm_copy_from_user(kaddr, uaddr, ulen)))
+		return -EFAULT;
+
+	return 0;
+}
+
+/*
+ * Parses the list of buffers of a xreadv or xwritev call, and pushes the size
+ * (and optionally the data) to the ring.
+ */
+int32_t parse_readv_writev_bufs(struct event_filler_arguments *args, const struct iovec __user *iovsrc, unsigned long iovcnt, int64_t retval, int flags)
+{
+	int32_t res;
+	const struct iovec *iov;
+	u32 copylen;
+	u32 j;
+	u64 size = 0;
+	unsigned long bufsize;
+	char *targetbuf = args->str_storage;
+	u32 targetbuflen = STR_STORAGE_SIZE;
+	unsigned long val;
+	u32 notcopied_len;
+	size_t tocopy_len;
+
+	copylen = iovcnt * sizeof(struct iovec);
+
+	if (unlikely(copylen >= STR_STORAGE_SIZE))
+		return PPM_FAILURE_BUFFER_FULL;
+
+	if (unlikely(ppm_copy_from_user(args->str_storage, iovsrc, copylen)))
+		return PPM_FAILURE_INVALID_USER_MEMORY;
+
+	iov = (const struct iovec *)(args->str_storage);
+
+	targetbuf += copylen;
+	targetbuflen -= copylen;
+
+	/*
+	 * Size
+	 */
+	if (flags & PRB_FLAG_PUSH_SIZE) {
+		for (j = 0; j < iovcnt; j++)
+			size += iov[j].iov_len;
+
+		/*
+		 * Size is the total size of the buffers provided by the user. The number of
+		 * received bytes can be smaller
+		 */
+		if ((flags & PRB_FLAG_IS_WRITE) == 0)
+			if (size > retval)
+				size = retval;
+
+		res = val_to_ring(args, size, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	}
+
+	/*
+	 * data
+	 */
+	if (flags & PRB_FLAG_PUSH_DATA) {
+		if (retval > 0 && iovcnt > 0) {
+			/*
+			 * Retrieve the FD. It will be used for dynamic snaplen calculation.
+			 */
+			if (!args->is_socketcall)
+				syscall_get_arguments(current, args->regs, 0, 1, &val);
+			else
+				val = args->socketcall_args[0];
+			args->fd = (int)val;
+
+			/*
+			 * Merge the buffers
+			 */
+			bufsize = 0;
+
+			for (j = 0; j < iovcnt; j++) {
+				if ((flags & PRB_FLAG_IS_WRITE) == 0) {
+					if (bufsize >= retval) {
+						ASSERT(bufsize >= retval);
+
+						/*
+						 * Copied all the data even if we haven't reached the
+						 * end of the buffer.
+						 * Copy must stop here.
+						 */
+						break;
+					}
+
+					tocopy_len = min(iov[j].iov_len, (size_t)retval - bufsize);
+					tocopy_len = min(tocopy_len, (size_t)targetbuflen - bufsize - 1);
+				} else {
+					tocopy_len = min(iov[j].iov_len, targetbuflen - bufsize - 1);
+				}
+
+				notcopied_len = (int)ppm_copy_from_user(targetbuf + bufsize,
+						iov[j].iov_base,
+						tocopy_len);
+
+				if (unlikely(notcopied_len != 0)) {
+					/*
+					 * This means we had a page fault. Skip this event.
+					 */
+					return PPM_FAILURE_INVALID_USER_MEMORY;
+				}
+
+				bufsize += tocopy_len;
+
+				if (tocopy_len != iov[j].iov_len) {
+					/*
+					 * No space left in the args->str_storage buffer.
+					 * Copy must stop here.
+					 */
+					break;
+				}
+			}
+
+			args->enforce_snaplen = true;
+
+			res = val_to_ring(args,
+				(unsigned long)targetbuf,
+				bufsize,
+				false,
+				0);
+			if (unlikely(res != PPM_SUCCESS))
+				return res;
+		} else {
+			res = val_to_ring(args, 0, 0, false, 0);
+			if (unlikely(res != PPM_SUCCESS))
+				return res;
+		}
+	}
+
+	return PPM_SUCCESS;
+}
+
+#ifdef CONFIG_COMPAT
+/*
+ * Parses the list of buffers of a xreadv or xwritev call, and pushes the size
+ * (and optionally the data) to the ring.
+ */
+int32_t compat_parse_readv_writev_bufs(struct event_filler_arguments *args, const struct compat_iovec __user *iovsrc, unsigned long iovcnt, int64_t retval, int flags)
+{
+	int32_t res;
+	const struct compat_iovec *iov;
+	u32 copylen;
+	u32 j;
+	u64 size = 0;
+	unsigned long bufsize;
+	char *targetbuf = args->str_storage;
+	u32 targetbuflen = STR_STORAGE_SIZE;
+	unsigned long val;
+	u32 notcopied_len;
+	compat_size_t tocopy_len;
+
+	copylen = iovcnt * sizeof(struct compat_iovec);
+
+	if (unlikely(copylen >= STR_STORAGE_SIZE))
+		return PPM_FAILURE_BUFFER_FULL;
+
+	if (unlikely(ppm_copy_from_user(args->str_storage, iovsrc, copylen)))
+		return PPM_FAILURE_INVALID_USER_MEMORY;
+
+	iov = (const struct compat_iovec *)(args->str_storage);
+
+	targetbuf += copylen;
+	targetbuflen -= copylen;
+
+	/*
+	 * Size
+	 */
+	if (flags & PRB_FLAG_PUSH_SIZE) {
+		for (j = 0; j < iovcnt; j++)
+			size += iov[j].iov_len;
+
+		/*
+		 * Size is the total size of the buffers provided by the user. The number of
+		 * received bytes can be smaller
+		 */
+		if ((flags & PRB_FLAG_IS_WRITE) == 0)
+			if (size > retval)
+				size = retval;
+
+		res = val_to_ring(args, size, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	}
+
+	/*
+	 * data
+	 */
+	if (flags & PRB_FLAG_PUSH_DATA) {
+		if (retval > 0 && iovcnt > 0) {
+			/*
+			 * Retrieve the FD. It will be used for dynamic snaplen calculation.
+			 */
+			if (!args->is_socketcall)
+				syscall_get_arguments(current, args->regs, 0, 1, &val);
+			else
+				val = args->socketcall_args[0];
+			args->fd = (int)val;
+
+			/*
+			 * Merge the buffers
+			 */
+			bufsize = 0;
+
+			for (j = 0; j < iovcnt; j++) {
+				if ((flags & PRB_FLAG_IS_WRITE) == 0) {
+					if (bufsize >= retval) {
+						ASSERT(bufsize >= retval);
+
+						/*
+						 * Copied all the data even if we haven't reached the
+						 * end of the buffer.
+						 * Copy must stop here.
+						 */
+						break;
+					}
+
+					tocopy_len = min(iov[j].iov_len, (compat_size_t)((size_t)retval - bufsize));
+					tocopy_len = min(tocopy_len, (compat_size_t)(targetbuflen - bufsize - 1));
+				} else {
+					tocopy_len = min(iov[j].iov_len, (compat_size_t)(targetbuflen - bufsize - 1));
+				}
+
+				notcopied_len = (int)ppm_copy_from_user(targetbuf + bufsize,
+									compat_ptr(iov[j].iov_base),
+						tocopy_len);
+
+				if (unlikely(notcopied_len != 0)) {
+					/*
+					 * This means we had a page fault. Skip this event.
+					 */
+					return PPM_FAILURE_INVALID_USER_MEMORY;
+				}
+
+				bufsize += tocopy_len;
+
+				if (tocopy_len != iov[j].iov_len) {
+					/*
+					 * No space left in the args->str_storage buffer.
+					 * Copy must stop here.
+					 */
+					break;
+				}
+			}
+
+			args->enforce_snaplen = true;
+
+			res = val_to_ring(args,
+				(unsigned long)targetbuf,
+				bufsize,
+				false,
+				0);
+			if (unlikely(res != PPM_SUCCESS))
+				return res;
+		} else {
+			res = val_to_ring(args, 0, 0, false, 0);
+			if (unlikely(res != PPM_SUCCESS))
+				return res;
+		}
+	}
+
+	return PPM_SUCCESS;
+}
+#endif /* CONFIG_COMPAT */
+
+/*
+ * STANDARD FILLERS
+ */
+
+/*
+ * AUTOFILLER
+ * In simple cases in which extracting an event is just a matter of moving the
+ * arguments to the buffer, this filler can be used instead of writing a
+ * filler function.
+ * The arguments to extract are be specified in g_ppm_events.
+ */
+int f_sys_autofill(struct event_filler_arguments *args, const struct ppm_event_entry *evinfo)
+{
+	int res;
+	unsigned long val;
+	u32 j;
+	int64_t retval;
+
+	ASSERT(evinfo->n_autofill_args <= PPM_MAX_AUTOFILL_ARGS);
+
+	for (j = 0; j < evinfo->n_autofill_args; j++) {
+		if (evinfo->autofill_args[j].id >= 0) {
+#ifdef _HAS_SOCKETCALL
+			if (args->is_socketcall && evinfo->paramtype == APT_SOCK) {
+				val = args->socketcall_args[evinfo->autofill_args[j].id];
+			} else
+#endif
+			{
+				/*
+				 * Regular argument
+				 */
+				syscall_get_arguments(current,
+						args->regs,
+						evinfo->autofill_args[j].id,
+						1,
+						&val);
+			}
+
+			res = val_to_ring(args, val, 0, true, 0);
+			if (unlikely(res != PPM_SUCCESS))
+				return res;
+		} else if (evinfo->autofill_args[j].id == AF_ID_RETVAL) {
+			/*
+			 * Return value
+			 */
+			retval = (int64_t)(long)syscall_get_return_value(current, args->regs);
+			res = val_to_ring(args, retval, 0, false, 0);
+			if (unlikely(res != PPM_SUCCESS))
+				return res;
+		} else if (evinfo->autofill_args[j].id == AF_ID_USEDEFAULT) {
+			/*
+			 * Default Value
+			 */
+			res = val_to_ring(args, evinfo->autofill_args[j].default_val, 0, false, 0);
+			if (unlikely(res != PPM_SUCCESS))
+				return res;
+		} else {
+			ASSERT(false);
+		}
+	}
+
+	return add_sentinel(args);
+}
diff --git a/kernel/trace/sysdig/ppm_events.h b/kernel/trace/sysdig/ppm_events.h
new file mode 100644
index 0000000..3b7df00
--- /dev/null
+++ b/kernel/trace/sysdig/ppm_events.h
@@ -0,0 +1,167 @@
+/*
+Copyright (C) 2013-2014 Draios inc.
+
+This file is part of sysdig.
+
+sysdig is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License version 2 as
+published by the Free Software Foundation.
+
+sysdig is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with sysdig.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef EVENTS_H_
+#define EVENTS_H_
+
+/* To know about __NR_socketcall */
+#include <asm/unistd.h>
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+
+#ifdef __NR_socketcall
+	#define _HAS_SOCKETCALL
+#endif
+#if defined(CONFIG_X86_64) && defined(CONFIG_IA32_EMULATION)
+	#define _HAS_SOCKETCALL
+#endif
+
+/*
+ * Various crap that a callback might need
+ */
+struct fault_data_t {
+	unsigned long address;
+	struct pt_regs *regs;
+	unsigned long error_code;
+};
+
+struct event_filler_arguments {
+	struct ppm_consumer_t *consumer;
+	char *buffer; /* the buffer that will be filled with the data */
+	u32 buffer_size; /* the space in the ring buffer available for this event */
+	u32 syscall_id; /* the system call ID */
+	const enum ppm_syscall_code *cur_g_syscall_code_routing_table;
+#ifdef PPM_ENABLE_SENTINEL
+	u32 sentinel;
+#endif
+	u32 nevents;
+	u32 curarg;
+	u32 nargs;
+	u32 arg_data_offset;
+	u32 arg_data_size;
+	enum ppm_event_type event_type;	/* the event type */
+	/* Eventually convert this to an event_info union and move all the
+	 * below per-event params in this union, it's not good to waste kernel
+	 * stack since all this stuff is always exclusive
+	 */
+	struct pt_regs *regs; /* the registers containing the call arguments */
+	struct task_struct *sched_prev; /* for context switch events, the task that is being scheduled out */
+	struct task_struct *sched_next; /* for context switch events, the task that is being scheduled in */
+	char *str_storage; /* String storage. Size is one page. */
+	unsigned long socketcall_args[6];
+	bool is_socketcall;
+	int socketcall_syscall;
+	bool compat;
+	int fd; /* Passed by some of the fillers to val_to_ring to compute the snaplen dynamically */
+	bool enforce_snaplen;
+	int signo; /* Signal number */
+	__kernel_pid_t spid; /* PID of source process */
+	__kernel_pid_t dpid; /* PID of destination process */
+	struct fault_data_t fault_data; /* For page faults */
+};
+
+/*
+ * Filler table-related definitions
+ */
+#define PPM_AUTOFILL NULL
+#define PPM_MAX_AUTOFILL_ARGS 4
+
+/*
+ * Return codes
+ */
+#define PPM_SUCCESS 0
+#define PPM_FAILURE_BUFFER_FULL -1
+#define PPM_FAILURE_INVALID_USER_MEMORY -2
+#define PPM_FAILURE_BUG -3
+
+typedef int (*filler_callback) (struct event_filler_arguments *args);
+
+struct ppm_autofill_arg {
+#define AF_ID_RETVAL -1
+#define AF_ID_USEDEFAULT -2
+	int16_t id;
+	long default_val;
+};
+
+enum autofill_paramtype {
+	APT_REG,
+	APT_SOCK,
+};
+
+struct ppm_event_entry {
+	filler_callback filler_callback;
+	u16 n_autofill_args;
+	enum autofill_paramtype paramtype;
+	struct ppm_autofill_arg autofill_args[PPM_MAX_AUTOFILL_ARGS];
+};
+
+extern const struct ppm_event_entry g_ppm_events[];
+
+/*
+ * parse_readv_writev_bufs flags
+ */
+#define PRB_FLAG_PUSH_SIZE	1
+#define PRB_FLAG_PUSH_DATA	2
+#define PRB_FLAG_PUSH_ALL	(PRB_FLAG_PUSH_SIZE | PRB_FLAG_PUSH_DATA)
+#define PRB_FLAG_IS_WRITE	4
+
+/*
+ * HTTP markers
+ */
+#define HTTP_GET_STR "GET "
+#define HTTP_OPTIONS_STR "OPTI"
+#define HTTP_HEAD_STR "HEAD"
+#define HTTP_POST_STR "POST"
+#define HTTP_PUT_STR "PUT "
+#define HTTP_DELETE_STR "DELE"
+#define HTTP_TRACE_STR "TRAC"
+#define HTTP_CONNECT_STR "CONN"
+#define HTTP_RESP_STR "HTTP"
+
+/*
+ * Functions
+ */
+int32_t dpi_lookahead_init(void);
+int32_t f_sys_autofill(struct event_filler_arguments *args, const struct ppm_event_entry *evinfo);
+int32_t val_to_ring(struct event_filler_arguments *args, u64 val, u16 val_len, bool fromuser, u8 dyn_idx);
+u16 pack_addr(struct sockaddr *usrsockaddr, int ulen, char *targetbuf, u16 targetbufsize);
+u16 fd_to_socktuple(int fd, struct sockaddr *usrsockaddr, int ulen, bool use_userdata, bool is_inbound, char *targetbuf, u16 targetbufsize);
+int addr_to_kernel(void __user *uaddr, int ulen, struct sockaddr *kaddr);
+int32_t parse_readv_writev_bufs(struct event_filler_arguments *args, const struct iovec __user *iovsrc, unsigned long iovcnt, int64_t retval, int flags);
+
+#ifdef CONFIG_COMPAT
+int32_t compat_parse_readv_writev_bufs(struct event_filler_arguments *args, const struct compat_iovec __user *iovsrc, unsigned long iovcnt, int64_t retval, int flags);
+#endif
+
+static inline int add_sentinel(struct event_filler_arguments *args)
+{
+#ifdef PPM_ENABLE_SENTINEL
+	if (likely(args->arg_data_size >= sizeof(u32))) {
+		*(u32 *)(args->buffer + args->arg_data_offset) = args->sentinel;
+		args->arg_data_offset += 4;
+		args->arg_data_size -= 4;
+		return PPM_SUCCESS;
+	}
+	return PPM_FAILURE_BUFFER_FULL;
+#else
+	return PPM_SUCCESS;
+#endif
+}
+
+#endif /* EVENTS_H_ */
diff --git a/kernel/trace/sysdig/ppm_events_public.h b/kernel/trace/sysdig/ppm_events_public.h
new file mode 100644
index 0000000..65ec7e4
--- /dev/null
+++ b/kernel/trace/sysdig/ppm_events_public.h
@@ -0,0 +1,1396 @@
+/*
+Copyright (C) 2013-2014 Draios inc.
+
+This file is part of sysdig.
+
+sysdig is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License version 2 as
+published by the Free Software Foundation.
+
+sysdig is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with sysdig.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef EVENTS_PUBLIC_H_
+#define EVENTS_PUBLIC_H_
+
+#if defined(__sun)
+#include <sys/ioccom.h>
+#endif
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#endif
+
+/*
+ * Limits
+ */
+#define PPM_MAX_EVENT_PARAMS 20	/* Max number of parameters an event can have */
+#define PPM_MAX_PATH_SIZE 256	/* Max size that an event parameter can have in the circular buffer, in bytes */
+#define PPM_MAX_NAME_LEN 32
+
+/*
+ * Socket families
+ */
+#define PPM_AF_UNSPEC       0
+#define PPM_AF_UNIX         1       /* Unix domain sockets          */
+#define PPM_AF_LOCAL        1       /* POSIX name for PPM_AF_UNIX   */
+#define PPM_AF_INET         2       /* Internet IP Protocol         */
+#define PPM_AF_AX25         3       /* Amateur Radio AX.25          */
+#define PPM_AF_IPX          4       /* Novell IPX                   */
+#define PPM_AF_APPLETALK    5       /* AppleTalk DDP                */
+#define PPM_AF_NETROM       6       /* Amateur Radio NET/ROM        */
+#define PPM_AF_BRIDGE       7       /* Multiprotocol bridge         */
+#define PPM_AF_ATMPVC       8       /* ATM PVCs                     */
+#define PPM_AF_X25          9       /* Reserved for X.25 project    */
+#define PPM_AF_INET6        10      /* IP version 6                 */
+#define PPM_AF_ROSE         11      /* Amateur Radio X.25 PLP       */
+#define PPM_AF_DECnet       12      /* Reserved for DECnet project  */
+#define PPM_AF_NETBEUI      13      /* Reserved for 802.2LLC project*/
+#define PPM_AF_SECURITY     14      /* Security callback pseudo AF */
+#define PPM_AF_KEY          15      /* PF_KEY key management API */
+#define PPM_AF_NETLINK      16
+#define PPM_AF_ROUTE        PPM_AF_NETLINK /* Alias to emulate 4.4BSD */
+#define PPM_AF_PACKET       17      /* Packet family                */
+#define PPM_AF_ASH          18      /* Ash                          */
+#define PPM_AF_ECONET       19      /* Acorn Econet                 */
+#define PPM_AF_ATMSVC       20      /* ATM SVCs                     */
+#define PPM_AF_RDS          21      /* RDS sockets                  */
+#define PPM_AF_SNA          22      /* Linux SNA Project (nutters!) */
+#define PPM_AF_IRDA         23      /* IRDA sockets                 */
+#define PPM_AF_PPPOX        24      /* PPPoX sockets                */
+#define PPM_AF_WANPIPE      25      /* Wanpipe API Sockets */
+#define PPM_AF_LLC          26      /* Linux LLC                    */
+#define PPM_AF_CAN          29      /* Controller Area Network      */
+#define PPM_AF_TIPC         30      /* TIPC sockets                 */
+#define PPM_AF_BLUETOOTH    31      /* Bluetooth sockets            */
+#define PPM_AF_IUCV         32      /* IUCV sockets                 */
+#define PPM_AF_RXRPC        33      /* RxRPC sockets                */
+#define PPM_AF_ISDN         34      /* mISDN sockets                */
+#define PPM_AF_PHONET       35      /* Phonet sockets               */
+#define PPM_AF_IEEE802154   36      /* IEEE802154 sockets           */
+#define PPM_AF_CAIF         37      /* CAIF sockets                 */
+#define PPM_AF_ALG          38      /* Algorithm sockets            */
+#define PPM_AF_NFC          39      /* NFC sockets                  */
+
+/*
+ * File flags
+ */
+#define PPM_O_NONE	0
+#define PPM_O_RDONLY	(1 << 0)	/* Open for reading only */
+#define PPM_O_WRONLY	(1 << 1)	/* Open for writing only */
+#define PPM_O_RDWR	(PPM_O_RDONLY | PPM_O_WRONLY)	/* Open for reading and writing */
+#define PPM_O_CREAT	(1 << 2)	/* Create a new file if it doesn't exist. */
+#define PPM_O_APPEND	(1 << 3)	/* If set, the file offset shall be set to the end of the file prior to each write. */
+#define PPM_O_DSYNC	(1 << 4)
+#define PPM_O_EXCL	(1 << 5)
+#define PPM_O_NONBLOCK	(1 << 6)
+#define PPM_O_SYNC	(1 << 7)
+#define PPM_O_TRUNC	(1 << 8)
+#define PPM_O_DIRECT	(1 << 9)
+#define PPM_O_DIRECTORY (1 << 10)
+#define PPM_O_LARGEFILE (1 << 11)
+#define PPM_O_CLOEXEC	(1 << 12)
+
+/*
+ * File modes
+ */
+#define PPM_S_NONE  0
+#define PPM_S_IXOTH (1 << 0)
+#define PPM_S_IWOTH (1 << 1)
+#define PPM_S_IROTH (1 << 2)
+#define PPM_S_IXGRP (1 << 3)
+#define PPM_S_IWGRP (1 << 4)
+#define PPM_S_IRGRP (1 << 5)
+#define PPM_S_IXUSR (1 << 6)
+#define PPM_S_IWUSR (1 << 7)
+#define PPM_S_IRUSR (1 << 8)
+#define PPM_S_ISVTX (1 << 9)
+#define PPM_S_ISGID (1 << 10)
+#define PPM_S_ISUID (1 << 11)
+
+/*
+ * flock() flags
+ */
+#define PPM_LOCK_NONE 0
+#define PPM_LOCK_SH (1 << 0)
+#define PPM_LOCK_EX (1 << 1)
+#define PPM_LOCK_NB (1 << 2)
+#define PPM_LOCK_UN (1 << 3)
+
+/*
+ * Clone flags
+ */
+#define PPM_CL_NONE 0
+#define PPM_CL_CLONE_FILES (1 << 0)
+#define PPM_CL_CLONE_FS (1 << 1)
+#define PPM_CL_CLONE_IO (1 << 2)
+#define PPM_CL_CLONE_NEWIPC (1 << 3)
+#define PPM_CL_CLONE_NEWNET (1 << 4)
+#define PPM_CL_CLONE_NEWNS (1 << 5)
+#define PPM_CL_CLONE_NEWPID (1 << 6)
+#define PPM_CL_CLONE_NEWUTS (1 << 7)
+#define PPM_CL_CLONE_PARENT (1 << 8)
+#define PPM_CL_CLONE_PARENT_SETTID (1 << 9)
+#define PPM_CL_CLONE_PTRACE (1 << 10)
+#define PPM_CL_CLONE_SIGHAND (1 << 11)
+#define PPM_CL_CLONE_SYSVSEM (1 << 12)
+#define PPM_CL_CLONE_THREAD (1 << 13)
+#define PPM_CL_CLONE_UNTRACED (1 << 14)
+#define PPM_CL_CLONE_VM (1 << 15)
+#define PPM_CL_CLONE_INVERTED (1 << 16)	/* libsinsp-specific flag. It's set if clone() returned in */
+										/* the child process before than in the parent process. */
+#define PPM_CL_NAME_CHANGED (1 << 17)	/* libsinsp-specific flag. Set when the thread name changes */
+										/* (for example because execve was called) */
+#define PPM_CL_CLOSED (1 << 18)			/* thread has been closed. */
+#define PPM_CL_ACTIVE (1 << 19)			/* libsinsp-specific flag. Set in the first non-clone event for
+										   this thread. */
+#define PPM_CL_CLONE_NEWUSER (1 << 20)
+#define PPM_CL_PIPE_SRC (1 << 21)			/* libsinsp-specific flag. Set if this thread has been 
+										       detected to be the source in a shell pipe. */
+#define PPM_CL_PIPE_DST (1 << 22)			/* libsinsp-specific flag. Set if this thread has been 
+										       detected to be the destination in a shell pipe. */
+#define PPM_CL_CLONE_CHILD_CLEARTID (1 << 23)
+#define PPM_CL_CLONE_CHILD_SETTID (1 << 24)
+#define PPM_CL_CLONE_SETTLS (1 << 25)
+#define PPM_CL_CLONE_STOPPED (1 << 26)
+#define PPM_CL_CLONE_VFORK (1 << 27)
+#define PPM_CL_CLONE_NEWCGROUP (1 << 28)
+
+/*
+ * Futex Operations
+ */
+#define PPM_FU_FUTEX_WAIT 0
+#define PPM_FU_FUTEX_WAKE 1
+#define PPM_FU_FUTEX_FD 2
+#define PPM_FU_FUTEX_REQUEUE 3
+#define PPM_FU_FUTEX_CMP_REQUEUE 4
+#define PPM_FU_FUTEX_WAKE_OP 5
+#define PPM_FU_FUTEX_LOCK_PI 6
+#define PPM_FU_FUTEX_UNLOCK_PI 7
+#define PPM_FU_FUTEX_TRYLOCK_PI 8
+#define PPM_FU_FUTEX_WAIT_BITSET 9
+#define PPM_FU_FUTEX_WAKE_BITSET 10
+#define PPM_FU_FUTEX_WAIT_REQUEUE_PI 11
+#define PPM_FU_FUTEX_CMP_REQUEUE_PI 12
+#define PPM_FU_FUTEX_PRIVATE_FLAG	128
+#define PPM_FU_FUTEX_CLOCK_REALTIME 256
+
+/*
+ * lseek() and llseek() whence
+ */
+#define PPM_SEEK_SET 0
+#define PPM_SEEK_CUR 1
+#define PPM_SEEK_END 2
+
+/*
+ * poll() flags
+ */
+#define PPM_POLLIN (1 << 0)
+#define PPM_POLLPRI (1 << 1)
+#define PPM_POLLOUT (1 << 2)
+#define PPM_POLLRDHUP (1 << 3)
+#define PPM_POLLERR (1 << 4)
+#define PPM_POLLHUP (1 << 5)
+#define PPM_POLLNVAL (1 << 6)
+#define PPM_POLLRDNORM (1 << 7)
+#define PPM_POLLRDBAND (1 << 8)
+#define PPM_POLLWRNORM (1 << 9)
+#define PPM_POLLWRBAND (1 << 10)
+
+/*
+ * mount() flags
+ */
+#define PPM_MS_RDONLY       (1<<0)
+#define PPM_MS_NOSUID       (1<<1)
+#define PPM_MS_NODEV        (1<<2)
+#define PPM_MS_NOEXEC       (1<<3)
+#define PPM_MS_SYNCHRONOUS  (1<<4)
+#define PPM_MS_REMOUNT      (1<<5)
+#define PPM_MS_MANDLOCK     (1<<6)
+#define PPM_MS_DIRSYNC      (1<<7)
+
+#define PPM_MS_NOATIME      (1<<10)
+#define PPM_MS_NODIRATIME   (1<<11)
+#define PPM_MS_BIND         (1<<12)
+#define PPM_MS_MOVE         (1<<13)
+#define PPM_MS_REC          (1<<14)
+#define PPM_MS_SILENT       (1<<15)
+#define PPM_MS_POSIXACL     (1<<16)
+#define PPM_MS_UNBINDABLE   (1<<17)
+#define PPM_MS_PRIVATE      (1<<18)
+#define PPM_MS_SLAVE        (1<<19)
+#define PPM_MS_SHARED       (1<<20)
+#define PPM_MS_RELATIME     (1<<21)
+#define PPM_MS_KERNMOUNT    (1<<22)
+#define PPM_MS_I_VERSION    (1<<23)
+#define PPM_MS_STRICTATIME  (1<<24)
+#define PPM_MS_LAZYTIME     (1<<25)
+
+#define PPM_MS_NOSEC        (1<<28)
+#define PPM_MS_BORN         (1<<29)
+#define PPM_MS_ACTIVE       (1<<30)
+#define PPM_MS_NOUSER       (1<<31)
+
+/*
+ * umount() flags
+ */
+#define PPM_MNT_FORCE       1
+#define PPM_MNT_DETACH      2
+#define PPM_MNT_EXPIRE      4
+#define PPM_UMOUNT_NOFOLLOW 8
+
+/*
+ * shutdown() how
+ */
+#define PPM_SHUT_RD 0
+#define PPM_SHUT_WR 1
+#define PPM_SHUT_RDWR 2
+
+/*
+ * openat() flags
+ */
+#define PPM_AT_FDCWD -100
+
+/*
+ * rlimit resources
+ */
+#define PPM_RLIMIT_CPU 0 /* CPU time in sec */
+#define PPM_RLIMIT_FSIZE 1 /* Maximum filesize */
+#define PPM_RLIMIT_DATA 2 /* max data size */
+#define PPM_RLIMIT_STACK 3 /* max stack size */
+#define PPM_RLIMIT_CORE 4 /* max core file size */
+#define PPM_RLIMIT_RSS 5 /* max resident set size */
+#define PPM_RLIMIT_NPROC 6 /* max number of processes */
+#define PPM_RLIMIT_NOFILE 7 /* max number of open files */
+#define PPM_RLIMIT_MEMLOCK 8 /* max locked-in-memory address space */
+#define PPM_RLIMIT_AS 9 /* address space limit */
+#define PPM_RLIMIT_LOCKS 10  /* maximum file locks held */
+#define PPM_RLIMIT_SIGPENDING 11 /* max number of pending signals */
+#define PPM_RLIMIT_MSGQUEUE 12 /* maximum bytes in POSIX mqueues */
+#define PPM_RLIMIT_NICE 13 /* max nice prio allowed to raise to 0-39 for nice level 19 .. -20 */
+#define PPM_RLIMIT_RTPRIO 14 /* maximum realtime priority */
+#define PPM_RLIMIT_RTTIME 15 /* timeout for RT tasks in us */
+#define PPM_RLIMIT_UNKNOWN 255 /* CPU time in sec */
+
+/*
+ * fcntl commands
+ */
+#define PPM_FCNTL_UNKNOWN 0
+#define PPM_FCNTL_F_DUPFD 1
+#define PPM_FCNTL_F_GETFD 2
+#define PPM_FCNTL_F_SETFD 3
+#define PPM_FCNTL_F_GETFL 4
+#define PPM_FCNTL_F_SETFL 5
+#define PPM_FCNTL_F_GETLK 6
+#define PPM_FCNTL_F_SETLK 8
+#define PPM_FCNTL_F_SETLKW 9
+#define PPM_FCNTL_F_SETOWN 10
+#define PPM_FCNTL_F_GETOWN 12
+#define PPM_FCNTL_F_SETSIG 13
+#define PPM_FCNTL_F_GETSIG 15
+#ifndef CONFIG_64BIT
+#define PPM_FCNTL_F_GETLK64 17
+#define PPM_FCNTL_F_SETLK64 18
+#define PPM_FCNTL_F_SETLKW64 19
+#endif
+#define PPM_FCNTL_F_SETOWN_EX 21
+#define PPM_FCNTL_F_GETOWN_EX 22
+#define PPM_FCNTL_F_SETLEASE 23
+#define PPM_FCNTL_F_GETLEASE 24
+#define PPM_FCNTL_F_CANCELLK 25
+#define PPM_FCNTL_F_DUPFD_CLOEXEC 26
+#define PPM_FCNTL_F_NOTIFY 27
+#define PPM_FCNTL_F_SETPIPE_SZ 28
+#define PPM_FCNTL_F_GETPIPE_SZ 29
+#define PPM_FCNTL_F_OFD_GETLK 30
+#define PPM_FCNTL_F_OFD_SETLK 31
+#define PPM_FCNTL_F_OFD_SETLKW 32
+
+ /*
+ * ptrace requests
+ */
+#define PPM_PTRACE_UNKNOWN 0
+#define PPM_PTRACE_TRACEME 1
+#define PPM_PTRACE_PEEKTEXT 2
+#define PPM_PTRACE_PEEKDATA 3
+#define PPM_PTRACE_PEEKUSR 4
+#define PPM_PTRACE_POKETEXT 5
+#define PPM_PTRACE_POKEDATA 6
+#define PPM_PTRACE_POKEUSR 7
+#define PPM_PTRACE_CONT 8
+#define PPM_PTRACE_KILL 9
+#define PPM_PTRACE_SINGLESTEP 10
+#define PPM_PTRACE_ATTACH 11
+#define PPM_PTRACE_DETACH 12
+#define PPM_PTRACE_SYSCALL 13
+#define PPM_PTRACE_SETOPTIONS 14
+#define PPM_PTRACE_GETEVENTMSG 15
+#define PPM_PTRACE_GETSIGINFO 16
+#define PPM_PTRACE_SETSIGINFO 17
+#define PPM_PTRACE_GETREGSET 18
+#define PPM_PTRACE_SETREGSET 19
+#define PPM_PTRACE_SEIZE 20
+#define PPM_PTRACE_INTERRUPT 21
+#define PPM_PTRACE_LISTEN 22
+#define PPM_PTRACE_PEEKSIGINFO 23
+#define PPM_PTRACE_GETSIGMASK 24
+#define PPM_PTRACE_SETSIGMASK 25
+#define PPM_PTRACE_GETREGS 26
+#define PPM_PTRACE_SETREGS 27
+#define PPM_PTRACE_GETFPREGS 28
+#define PPM_PTRACE_SETFPREGS 29
+#define PPM_PTRACE_GETFPXREGS 30
+#define PPM_PTRACE_SETFPXREGS 31
+#define PPM_PTRACE_OLDSETOPTIONS 32
+#define PPM_PTRACE_GET_THREAD_AREA 33
+#define PPM_PTRACE_SET_THREAD_AREA 34
+#define PPM_PTRACE_ARCH_PRCTL 35
+#define PPM_PTRACE_SYSEMU 36
+#define PPM_PTRACE_SYSEMU_SINGLESTEP 37
+#define PPM_PTRACE_SINGLEBLOCK 38
+
+/*
+ * ptrace dynamic table indexes
+ */
+#define PPM_PTRACE_IDX_UINT64 0
+#define PPM_PTRACE_IDX_SIGTYPE 1
+
+#define PPM_PTRACE_IDX_MAX 2
+
+#define PPM_BPF_IDX_FD 0
+#define PPM_BPF_IDX_RES 1
+
+#define PPM_BPF_IDX_MAX 2
+
+/*
+ * memory protection flags
+ */
+#define PPM_PROT_NONE		0
+#define PPM_PROT_READ		(1 << 0)
+#define PPM_PROT_WRITE		(1 << 1)
+#define PPM_PROT_EXEC		(1 << 2)
+#define PPM_PROT_SEM		(1 << 3)
+#define PPM_PROT_GROWSDOWN	(1 << 4)
+#define PPM_PROT_GROWSUP	(1 << 5)
+#define PPM_PROT_SAO		(1 << 6)
+
+/*
+ * mmap flags
+ */
+#define PPM_MAP_SHARED		(1 << 0)
+#define PPM_MAP_PRIVATE		(1 << 1)
+#define PPM_MAP_FIXED		(1 << 2)
+#define PPM_MAP_ANONYMOUS	(1 << 3)
+#define PPM_MAP_32BIT		(1 << 4)
+#define PPM_MAP_RENAME		(1 << 5)
+#define PPM_MAP_NORESERVE	(1 << 6)
+#define PPM_MAP_POPULATE	(1 << 7)
+#define PPM_MAP_NONBLOCK	(1 << 8)
+#define PPM_MAP_GROWSDOWN	(1 << 9)
+#define PPM_MAP_DENYWRITE	(1 << 10)
+#define PPM_MAP_EXECUTABLE	(1 << 11)
+#define PPM_MAP_INHERIT		(1 << 12)
+#define PPM_MAP_FILE		(1 << 13)
+#define PPM_MAP_LOCKED		(1 << 14)
+
+/*
+ * splice flags
+ */
+#define PPM_SPLICE_F_MOVE		(1 << 0)
+#define PPM_SPLICE_F_NONBLOCK	(1 << 1)
+#define PPM_SPLICE_F_MORE		(1 << 2)
+#define PPM_SPLICE_F_GIFT		(1 << 3)
+
+/*
+ * quotactl cmds
+ */
+#define PPM_Q_QUOTAON		(1 << 0)
+#define PPM_Q_QUOTAOFF		(1 << 1)
+#define PPM_Q_GETFMT		(1 << 2)
+#define PPM_Q_GETINFO		(1 << 3)
+#define PPM_Q_SETINFO		(1 << 4)
+#define PPM_Q_GETQUOTA		(1 << 5)
+#define PPM_Q_SETQUOTA		(1 << 6)
+#define PPM_Q_SYNC			(1 << 7)
+#define PPM_Q_XQUOTAON		(1 << 8)
+#define PPM_Q_XQUOTAOFF		(1 << 9)
+#define PPM_Q_XGETQUOTA		(1 << 10)
+#define PPM_Q_XSETQLIM		(1 << 11)
+#define PPM_Q_XGETQSTAT		(1 << 12)
+#define PPM_Q_XQUOTARM		(1 << 13)
+#define PPM_Q_XQUOTASYNC	(1 << 14)
+#define PPM_Q_XGETQSTATV	(1 << 15)
+
+/*
+ * quotactl types
+ */
+#define PPM_USRQUOTA		(1 << 0)
+#define PPM_GRPQUOTA		(1 << 1)
+
+/*
+ * quotactl dqi_flags
+ */
+#define PPM_DQF_NONE		(1 << 0)
+#define PPM_V1_DQF_RSQUASH	(1 << 1)
+
+/*
+ * quotactl quotafmts
+ */
+#define PPM_QFMT_NOT_USED		(1 << 0)
+#define PPM_QFMT_VFS_OLD	(1 << 1)
+#define PPM_QFMT_VFS_V0		(1 << 2)
+#define PPM_QFMT_VFS_V1		(1 << 3)
+
+/*
+ * Semop flags
+ */
+#define PPM_IPC_NOWAIT		(1 << 0)
+#define PPM_SEM_UNDO		(1 << 1)
+
+/*
+ * Semget flags
+ */
+#define PPM_IPC_CREAT  (1 << 13)
+#define PPM_IPC_EXCL   (1 << 14)
+
+#define PPM_IPC_STAT		(1 << 0)
+#define PPM_IPC_SET		(1 << 1)
+#define PPM_IPC_RMID		(1 << 2)
+#define PPM_IPC_INFO		(1 << 3)
+#define PPM_SEM_INFO		(1 << 4)
+#define PPM_SEM_STAT		(1 << 5)
+#define PPM_GETALL		(1 << 6)
+#define PPM_GETNCNT		(1 << 7)
+#define PPM_GETPID		(1 << 8)
+#define PPM_GETVAL		(1 << 9)
+#define PPM_GETZCNT		(1 << 10)
+#define PPM_SETALL		(1 << 11)
+#define PPM_SETVAL		(1 << 12)
+
+/*
+ * Access flags
+ */
+#define PPM_F_OK            (0)
+#define PPM_X_OK            (1 << 0)
+#define PPM_W_OK            (1 << 1)
+#define PPM_R_OK            (1 << 2)
+
+/*
+ * Page fault flags
+ */
+#define PPM_PF_PROTECTION_VIOLATION	(1 << 0)
+#define PPM_PF_PAGE_NOT_PRESENT		(1 << 1)
+#define PPM_PF_WRITE_ACCESS		(1 << 2)
+#define PPM_PF_READ_ACCESS		(1 << 3)
+#define PPM_PF_USER_FAULT		(1 << 4)
+#define PPM_PF_SUPERVISOR_FAULT		(1 << 5)
+#define PPM_PF_RESERVED_PAGE		(1 << 6)
+#define PPM_PF_INSTRUCTION_FETCH	(1 << 7)
+
+/*
+ * SuS says limits have to be unsigned.
+ * Which makes a ton more sense anyway.
+ *
+ * Some architectures override this (for compatibility reasons):
+ */
+#ifndef RLIM_INFINITY
+# define RLIM_INFINITY          (~0UL)
+#endif
+
+/*
+ * RLIMIT_STACK default maximum - some architectures override it:
+ */
+#ifndef _STK_LIM_MAX
+# define _STK_LIM_MAX           RLIM_INFINITY
+#endif
+
+/*
+ * The list of event types
+ * Enter events have even numbers while exit events have odd numbers.
+ * NOTE: there can't be gaps in the numbering, because these numbers correspond
+ * to the entries in the g_event_info table
+ */
+#define PPME_DIRECTION_FLAG 1
+#define PPME_IS_ENTER(x) ((x & PPME_DIRECTION_FLAG) == 0)
+#define PPME_IS_EXIT(x) (x & PPME_DIRECTION_FLAG)
+#define PPME_MAKE_ENTER(x) (x & (~1))
+
+/*
+ * Event category to classify events in generic categories
+ */
+enum ppm_capture_category {
+	PPMC_NONE = 0,
+	PPMC_SYSCALL = 1,
+	PPMC_CONTEXT_SWITCH = 2,
+	PPMC_SIGNAL = 3,
+	PPMC_PAGE_FAULT = 4,
+};
+
+/** @defgroup etypes Event Types
+ *  @{
+ */
+enum ppm_event_type {
+	PPME_GENERIC_E = 0,
+	PPME_GENERIC_X = 1,
+	PPME_SYSCALL_OPEN_E = 2,
+	PPME_SYSCALL_OPEN_X = 3,
+	PPME_SYSCALL_CLOSE_E = 4,
+	PPME_SYSCALL_CLOSE_X = 5,
+	PPME_SYSCALL_READ_E = 6,
+	PPME_SYSCALL_READ_X = 7,
+	PPME_SYSCALL_WRITE_E = 8,
+	PPME_SYSCALL_WRITE_X = 9,
+	PPME_SYSCALL_BRK_1_E = 10,
+	PPME_SYSCALL_BRK_1_X = 11,
+	PPME_SYSCALL_EXECVE_8_E = 12,
+	PPME_SYSCALL_EXECVE_8_X = 13,
+	PPME_SYSCALL_CLONE_11_E = 14,
+	PPME_SYSCALL_CLONE_11_X = 15,
+	PPME_PROCEXIT_E = 16,
+	PPME_PROCEXIT_X = 17,	/* This should never be called */
+	PPME_SOCKET_SOCKET_E = 18,
+	PPME_SOCKET_SOCKET_X = 19,
+	PPME_SOCKET_BIND_E = 20,
+	PPME_SOCKET_BIND_X = 21,
+	PPME_SOCKET_CONNECT_E = 22,
+	PPME_SOCKET_CONNECT_X = 23,
+	PPME_SOCKET_LISTEN_E = 24,
+	PPME_SOCKET_LISTEN_X = 25,
+	PPME_SOCKET_ACCEPT_E = 26,
+	PPME_SOCKET_ACCEPT_X = 27,
+	PPME_SOCKET_SEND_E = 28,
+	PPME_SOCKET_SEND_X = 29,
+	PPME_SOCKET_SENDTO_E = 30,
+	PPME_SOCKET_SENDTO_X = 31,
+	PPME_SOCKET_RECV_E = 32,
+	PPME_SOCKET_RECV_X = 33,
+	PPME_SOCKET_RECVFROM_E = 34,
+	PPME_SOCKET_RECVFROM_X = 35,
+	PPME_SOCKET_SHUTDOWN_E = 36,
+	PPME_SOCKET_SHUTDOWN_X = 37,
+	PPME_SOCKET_GETSOCKNAME_E = 38,
+	PPME_SOCKET_GETSOCKNAME_X = 39,
+	PPME_SOCKET_GETPEERNAME_E = 40,
+	PPME_SOCKET_GETPEERNAME_X = 41,
+	PPME_SOCKET_SOCKETPAIR_E = 42,
+	PPME_SOCKET_SOCKETPAIR_X = 43,
+	PPME_SOCKET_SETSOCKOPT_E = 44,
+	PPME_SOCKET_SETSOCKOPT_X = 45,
+	PPME_SOCKET_GETSOCKOPT_E = 46,
+	PPME_SOCKET_GETSOCKOPT_X = 47,
+	PPME_SOCKET_SENDMSG_E = 48,
+	PPME_SOCKET_SENDMSG_X = 49,
+	PPME_SOCKET_SENDMMSG_E = 50,
+	PPME_SOCKET_SENDMMSG_X = 51,
+	PPME_SOCKET_RECVMSG_E = 52,
+	PPME_SOCKET_RECVMSG_X = 53,
+	PPME_SOCKET_RECVMMSG_E = 54,
+	PPME_SOCKET_RECVMMSG_X = 55,
+	PPME_SOCKET_ACCEPT4_E = 56,
+	PPME_SOCKET_ACCEPT4_X = 57,
+	PPME_SYSCALL_CREAT_E = 58,
+	PPME_SYSCALL_CREAT_X = 59,
+	PPME_SYSCALL_PIPE_E = 60,
+	PPME_SYSCALL_PIPE_X = 61,
+	PPME_SYSCALL_EVENTFD_E = 62,
+	PPME_SYSCALL_EVENTFD_X = 63,
+	PPME_SYSCALL_FUTEX_E = 64,
+	PPME_SYSCALL_FUTEX_X = 65,
+	PPME_SYSCALL_STAT_E = 66,
+	PPME_SYSCALL_STAT_X = 67,
+	PPME_SYSCALL_LSTAT_E = 68,
+	PPME_SYSCALL_LSTAT_X = 69,
+	PPME_SYSCALL_FSTAT_E = 70,
+	PPME_SYSCALL_FSTAT_X = 71,
+	PPME_SYSCALL_STAT64_E = 72,
+	PPME_SYSCALL_STAT64_X = 73,
+	PPME_SYSCALL_LSTAT64_E = 74,
+	PPME_SYSCALL_LSTAT64_X = 75,
+	PPME_SYSCALL_FSTAT64_E = 76,
+	PPME_SYSCALL_FSTAT64_X = 77,
+	PPME_SYSCALL_EPOLLWAIT_E = 78,
+	PPME_SYSCALL_EPOLLWAIT_X = 79,
+	PPME_SYSCALL_POLL_E = 80,
+	PPME_SYSCALL_POLL_X = 81,
+	PPME_SYSCALL_SELECT_E = 82,
+	PPME_SYSCALL_SELECT_X = 83,
+	PPME_SYSCALL_NEWSELECT_E = 84,
+	PPME_SYSCALL_NEWSELECT_X = 85,
+	PPME_SYSCALL_LSEEK_E = 86,
+	PPME_SYSCALL_LSEEK_X = 87,
+	PPME_SYSCALL_LLSEEK_E = 88,
+	PPME_SYSCALL_LLSEEK_X = 89,
+	PPME_SYSCALL_IOCTL_2_E = 90,
+	PPME_SYSCALL_IOCTL_2_X = 91,
+	PPME_SYSCALL_GETCWD_E = 92,
+	PPME_SYSCALL_GETCWD_X = 93,
+	PPME_SYSCALL_CHDIR_E = 94,
+	PPME_SYSCALL_CHDIR_X = 95,
+	PPME_SYSCALL_FCHDIR_E = 96,
+	PPME_SYSCALL_FCHDIR_X = 97,
+	/* mkdir/rmdir events are not emitted anymore */
+	PPME_SYSCALL_MKDIR_E = 98,
+	PPME_SYSCALL_MKDIR_X = 99,
+	PPME_SYSCALL_RMDIR_E = 100,
+	PPME_SYSCALL_RMDIR_X = 101,
+	PPME_SYSCALL_OPENAT_E = 102,
+	PPME_SYSCALL_OPENAT_X = 103,
+	PPME_SYSCALL_LINK_E = 104,
+	PPME_SYSCALL_LINK_X = 105,
+	PPME_SYSCALL_LINKAT_E = 106,
+	PPME_SYSCALL_LINKAT_X = 107,
+	PPME_SYSCALL_UNLINK_E = 108,
+	PPME_SYSCALL_UNLINK_X = 109,
+	PPME_SYSCALL_UNLINKAT_E = 110,
+	PPME_SYSCALL_UNLINKAT_X = 111,
+	PPME_SYSCALL_PREAD_E = 112,
+	PPME_SYSCALL_PREAD_X = 113,
+	PPME_SYSCALL_PWRITE_E = 114,
+	PPME_SYSCALL_PWRITE_X = 115,
+	PPME_SYSCALL_READV_E = 116,
+	PPME_SYSCALL_READV_X = 117,
+	PPME_SYSCALL_WRITEV_E = 118,
+	PPME_SYSCALL_WRITEV_X = 119,
+	PPME_SYSCALL_PREADV_E = 120,
+	PPME_SYSCALL_PREADV_X = 121,
+	PPME_SYSCALL_PWRITEV_E = 122,
+	PPME_SYSCALL_PWRITEV_X = 123,
+	PPME_SYSCALL_DUP_E = 124,
+	PPME_SYSCALL_DUP_X = 125,
+	PPME_SYSCALL_SIGNALFD_E = 126,
+	PPME_SYSCALL_SIGNALFD_X = 127,
+	PPME_SYSCALL_KILL_E = 128,
+	PPME_SYSCALL_KILL_X = 129,
+	PPME_SYSCALL_TKILL_E = 130,
+	PPME_SYSCALL_TKILL_X = 131,
+	PPME_SYSCALL_TGKILL_E = 132,
+	PPME_SYSCALL_TGKILL_X = 133,
+	PPME_SYSCALL_NANOSLEEP_E = 134,
+	PPME_SYSCALL_NANOSLEEP_X = 135,
+	PPME_SYSCALL_TIMERFD_CREATE_E = 136,
+	PPME_SYSCALL_TIMERFD_CREATE_X = 137,
+	PPME_SYSCALL_INOTIFY_INIT_E = 138,
+	PPME_SYSCALL_INOTIFY_INIT_X = 139,
+	PPME_SYSCALL_GETRLIMIT_E = 140,
+	PPME_SYSCALL_GETRLIMIT_X = 141,
+	PPME_SYSCALL_SETRLIMIT_E = 142,
+	PPME_SYSCALL_SETRLIMIT_X = 143,
+	PPME_SYSCALL_PRLIMIT_E = 144,
+	PPME_SYSCALL_PRLIMIT_X = 145,
+	PPME_SCHEDSWITCH_1_E = 146,
+	PPME_SCHEDSWITCH_1_X = 147,	/* This should never be called */
+	PPME_DROP_E = 148,  /* For internal use */
+	PPME_DROP_X = 149,	/* For internal use */
+	PPME_SYSCALL_FCNTL_E = 150,  /* For internal use */
+	PPME_SYSCALL_FCNTL_X = 151,	/* For internal use */
+	PPME_SCHEDSWITCH_6_E = 152,
+	PPME_SCHEDSWITCH_6_X = 153,	/* This should never be called */
+	PPME_SYSCALL_EXECVE_13_E = 154,
+	PPME_SYSCALL_EXECVE_13_X = 155,
+	PPME_SYSCALL_CLONE_16_E = 156,
+	PPME_SYSCALL_CLONE_16_X = 157,
+	PPME_SYSCALL_BRK_4_E = 158,
+	PPME_SYSCALL_BRK_4_X = 159,
+	PPME_SYSCALL_MMAP_E = 160,
+	PPME_SYSCALL_MMAP_X = 161,
+	PPME_SYSCALL_MMAP2_E = 162,
+	PPME_SYSCALL_MMAP2_X = 163,
+	PPME_SYSCALL_MUNMAP_E = 164,
+	PPME_SYSCALL_MUNMAP_X = 165,
+	PPME_SYSCALL_SPLICE_E = 166,
+	PPME_SYSCALL_SPLICE_X = 167,
+	PPME_SYSCALL_PTRACE_E = 168,
+	PPME_SYSCALL_PTRACE_X = 169,
+	PPME_SYSCALL_IOCTL_3_E = 170,
+	PPME_SYSCALL_IOCTL_3_X = 171,
+	PPME_SYSCALL_EXECVE_14_E = 172,
+	PPME_SYSCALL_EXECVE_14_X = 173,
+	PPME_SYSCALL_RENAME_E = 174,
+	PPME_SYSCALL_RENAME_X = 175,
+	PPME_SYSCALL_RENAMEAT_E = 176,
+	PPME_SYSCALL_RENAMEAT_X = 177,
+	PPME_SYSCALL_SYMLINK_E = 178,
+	PPME_SYSCALL_SYMLINK_X = 179,
+	PPME_SYSCALL_SYMLINKAT_E = 180,
+	PPME_SYSCALL_SYMLINKAT_X = 181,
+	PPME_SYSCALL_FORK_E = 182,
+	PPME_SYSCALL_FORK_X = 183,
+	PPME_SYSCALL_VFORK_E = 184,
+	PPME_SYSCALL_VFORK_X = 185,
+	PPME_PROCEXIT_1_E = 186,
+	PPME_PROCEXIT_1_X = 187,	/* This should never be called */
+	PPME_SYSCALL_SENDFILE_E = 188,
+	PPME_SYSCALL_SENDFILE_X = 189,	/* This should never be called */
+	PPME_SYSCALL_QUOTACTL_E = 190,
+	PPME_SYSCALL_QUOTACTL_X = 191,
+	PPME_SYSCALL_SETRESUID_E = 192,
+	PPME_SYSCALL_SETRESUID_X = 193,
+	PPME_SYSCALL_SETRESGID_E = 194,
+	PPME_SYSCALL_SETRESGID_X = 195,
+	PPME_SYSDIGEVENT_E = 196,
+	PPME_SYSDIGEVENT_X = 197, /* This should never be called */
+	PPME_SYSCALL_SETUID_E = 198,
+	PPME_SYSCALL_SETUID_X = 199,
+	PPME_SYSCALL_SETGID_E = 200,
+	PPME_SYSCALL_SETGID_X = 201,
+	PPME_SYSCALL_GETUID_E = 202,
+	PPME_SYSCALL_GETUID_X = 203,
+	PPME_SYSCALL_GETEUID_E = 204,
+	PPME_SYSCALL_GETEUID_X = 205,
+	PPME_SYSCALL_GETGID_E = 206,
+	PPME_SYSCALL_GETGID_X = 207,
+	PPME_SYSCALL_GETEGID_E = 208,
+	PPME_SYSCALL_GETEGID_X = 209,
+	PPME_SYSCALL_GETRESUID_E = 210,
+	PPME_SYSCALL_GETRESUID_X = 211,
+	PPME_SYSCALL_GETRESGID_E = 212,
+	PPME_SYSCALL_GETRESGID_X = 213,
+	PPME_SYSCALL_EXECVE_15_E = 214,
+	PPME_SYSCALL_EXECVE_15_X = 215,
+	PPME_SYSCALL_CLONE_17_E = 216,
+	PPME_SYSCALL_CLONE_17_X = 217,
+	PPME_SYSCALL_FORK_17_E = 218,
+	PPME_SYSCALL_FORK_17_X = 219,
+	PPME_SYSCALL_VFORK_17_E = 220,
+	PPME_SYSCALL_VFORK_17_X = 221,
+	PPME_SYSCALL_CLONE_20_E = 222,
+	PPME_SYSCALL_CLONE_20_X = 223,
+	PPME_SYSCALL_FORK_20_E = 224,
+	PPME_SYSCALL_FORK_20_X = 225,
+	PPME_SYSCALL_VFORK_20_E = 226,
+	PPME_SYSCALL_VFORK_20_X = 227,
+	PPME_CONTAINER_E = 228,
+	PPME_CONTAINER_X = 229,
+	PPME_SYSCALL_EXECVE_16_E = 230,
+	PPME_SYSCALL_EXECVE_16_X = 231,
+	PPME_SIGNALDELIVER_E = 232,
+	PPME_SIGNALDELIVER_X = 233, /* This should never be called */
+	PPME_PROCINFO_E = 234,
+	PPME_PROCINFO_X = 235,	/* This should never be called */
+	PPME_SYSCALL_GETDENTS_E = 236,
+	PPME_SYSCALL_GETDENTS_X = 237,
+	PPME_SYSCALL_GETDENTS64_E = 238,
+	PPME_SYSCALL_GETDENTS64_X = 239,
+	PPME_SYSCALL_SETNS_E = 240,
+	PPME_SYSCALL_SETNS_X = 241,
+	PPME_SYSCALL_FLOCK_E = 242,
+	PPME_SYSCALL_FLOCK_X = 243,
+	PPME_CPU_HOTPLUG_E = 244,
+	PPME_CPU_HOTPLUG_X = 245, /* This should never be called */
+	PPME_SOCKET_ACCEPT_5_E = 246,
+	PPME_SOCKET_ACCEPT_5_X = 247,
+	PPME_SOCKET_ACCEPT4_5_E = 248,
+	PPME_SOCKET_ACCEPT4_5_X = 249,
+	PPME_SYSCALL_SEMOP_E = 250,
+	PPME_SYSCALL_SEMOP_X = 251,
+	PPME_SYSCALL_SEMCTL_E = 252,
+	PPME_SYSCALL_SEMCTL_X = 253,
+	PPME_SYSCALL_PPOLL_E = 254,
+	PPME_SYSCALL_PPOLL_X = 255,
+	PPME_SYSCALL_MOUNT_E = 256,
+	PPME_SYSCALL_MOUNT_X = 257,
+	PPME_SYSCALL_UMOUNT_E = 258,
+	PPME_SYSCALL_UMOUNT_X = 259,
+	PPME_K8S_E = 260,
+	PPME_K8S_X = 261,
+	PPME_SYSCALL_SEMGET_E = 262,
+	PPME_SYSCALL_SEMGET_X = 263,
+	PPME_SYSCALL_ACCESS_E = 264,
+	PPME_SYSCALL_ACCESS_X = 265,
+	PPME_SYSCALL_CHROOT_E = 266,
+	PPME_SYSCALL_CHROOT_X = 267,
+	PPME_TRACER_E = 268,
+	PPME_TRACER_X = 269,
+	PPME_MESOS_E = 270,
+	PPME_MESOS_X = 271,
+	PPME_CONTAINER_JSON_E = 272,
+	PPME_CONTAINER_JSON_X = 273,
+	PPME_SYSCALL_SETSID_E = 274,
+	PPME_SYSCALL_SETSID_X = 275,
+	PPME_SYSCALL_MKDIR_2_E = 276,
+	PPME_SYSCALL_MKDIR_2_X = 277,
+	PPME_SYSCALL_RMDIR_2_E = 278,
+	PPME_SYSCALL_RMDIR_2_X = 279,
+	PPME_NOTIFICATION_E = 280,
+	PPME_NOTIFICATION_X = 281,
+	PPME_SYSCALL_EXECVE_17_E = 282,
+	PPME_SYSCALL_EXECVE_17_X = 283,
+	PPME_SYSCALL_UNSHARE_E = 284,
+	PPME_SYSCALL_UNSHARE_X = 285,
+	PPME_INFRASTRUCTURE_EVENT_E = 286,
+	PPME_INFRASTRUCTURE_EVENT_X = 287,
+	PPME_SYSCALL_EXECVE_18_E = 288,
+	PPME_SYSCALL_EXECVE_18_X = 289,
+	PPME_PAGE_FAULT_E = 290,
+	PPME_PAGE_FAULT_X = 291,
+	PPME_SYSCALL_BPF_E = 292,
+	PPME_SYSCALL_BPF_X = 293,
+	PPME_SYSCALL_SECCOMP_E = 294,
+	PPME_SYSCALL_SECCOMP_X = 295,
+	PPM_EVENT_MAX = 296
+};
+/*@}*/
+
+/*
+ * System-independent syscall codes
+ */
+enum ppm_syscall_code {
+	PPM_SC_UNKNOWN = 0,
+	PPM_SC_RESTART_SYSCALL = 1,
+	PPM_SC_EXIT = 2,
+	PPM_SC_READ = 3,
+	PPM_SC_WRITE = 4,
+	PPM_SC_OPEN = 5,
+	PPM_SC_CLOSE = 6,
+	PPM_SC_CREAT = 7,
+	PPM_SC_LINK = 8,
+	PPM_SC_UNLINK = 9,
+	PPM_SC_CHDIR = 10,
+	PPM_SC_TIME = 11,
+	PPM_SC_MKNOD = 12,
+	PPM_SC_CHMOD = 13,
+	PPM_SC_STAT = 14,
+	PPM_SC_LSEEK = 15,
+	PPM_SC_GETPID = 16,
+	PPM_SC_MOUNT = 17,
+	PPM_SC_PTRACE = 18,
+	PPM_SC_ALARM = 19,
+	PPM_SC_FSTAT = 20,
+	PPM_SC_PAUSE = 21,
+	PPM_SC_UTIME = 22,
+	PPM_SC_ACCESS = 23,
+	PPM_SC_SYNC = 24,
+	PPM_SC_KILL = 25,
+	PPM_SC_RENAME = 26,
+	PPM_SC_MKDIR = 27,
+	PPM_SC_RMDIR = 28,
+	PPM_SC_DUP = 29,
+	PPM_SC_PIPE = 30,
+	PPM_SC_TIMES = 31,
+	PPM_SC_BRK = 32,
+	PPM_SC_ACCT = 33,
+	PPM_SC_IOCTL = 34,
+	PPM_SC_FCNTL = 35,
+	PPM_SC_SETPGID = 36,
+	PPM_SC_UMASK = 37,
+	PPM_SC_CHROOT = 38,
+	PPM_SC_USTAT = 39,
+	PPM_SC_DUP2 = 40,
+	PPM_SC_GETPPID = 41,
+	PPM_SC_GETPGRP = 42,
+	PPM_SC_SETSID = 43,
+	PPM_SC_SETHOSTNAME = 44,
+	PPM_SC_SETRLIMIT = 45,
+	PPM_SC_GETRUSAGE = 46,
+	PPM_SC_GETTIMEOFDAY = 47,
+	PPM_SC_SETTIMEOFDAY = 48,
+	PPM_SC_SYMLINK = 49,
+	PPM_SC_LSTAT = 50,
+	PPM_SC_READLINK = 51,
+	PPM_SC_USELIB = 52,
+	PPM_SC_SWAPON = 53,
+	PPM_SC_REBOOT = 54,
+	PPM_SC_MMAP = 55,
+	PPM_SC_MUNMAP = 56,
+	PPM_SC_TRUNCATE = 57,
+	PPM_SC_FTRUNCATE = 58,
+	PPM_SC_FCHMOD = 59,
+	PPM_SC_GETPRIORITY = 60,
+	PPM_SC_SETPRIORITY = 61,
+	PPM_SC_STATFS = 62,
+	PPM_SC_FSTATFS = 63,
+	PPM_SC_SYSLOG = 64,
+	PPM_SC_SETITIMER = 65,
+	PPM_SC_GETITIMER = 66,
+	PPM_SC_UNAME = 67,
+	PPM_SC_VHANGUP = 68,
+	PPM_SC_WAIT4 = 69,
+	PPM_SC_SWAPOFF = 70,
+	PPM_SC_SYSINFO = 71,
+	PPM_SC_FSYNC = 72,
+	PPM_SC_SETDOMAINNAME = 73,
+	PPM_SC_ADJTIMEX = 74,
+	PPM_SC_MPROTECT = 75,
+	PPM_SC_INIT_MODULE = 76,
+	PPM_SC_DELETE_MODULE = 77,
+	PPM_SC_QUOTACTL = 78,
+	PPM_SC_GETPGID = 79,
+	PPM_SC_FCHDIR = 80,
+	PPM_SC_SYSFS = 81,
+	PPM_SC_PERSONALITY = 82,
+	PPM_SC_GETDENTS = 83,
+	PPM_SC_SELECT = 84,
+	PPM_SC_FLOCK = 85,
+	PPM_SC_MSYNC = 86,
+	PPM_SC_READV = 87,
+	PPM_SC_WRITEV = 88,
+	PPM_SC_GETSID = 89,
+	PPM_SC_FDATASYNC = 90,
+	PPM_SC_MLOCK = 91,
+	PPM_SC_MUNLOCK = 92,
+	PPM_SC_MLOCKALL = 93,
+	PPM_SC_MUNLOCKALL = 94,
+	PPM_SC_SCHED_SETPARAM = 95,
+	PPM_SC_SCHED_GETPARAM = 96,
+	PPM_SC_SCHED_SETSCHEDULER = 97,
+	PPM_SC_SCHED_GETSCHEDULER = 98,
+	PPM_SC_SCHED_YIELD = 99,
+	PPM_SC_SCHED_GET_PRIORITY_MAX = 100,
+	PPM_SC_SCHED_GET_PRIORITY_MIN = 101,
+	PPM_SC_SCHED_RR_GET_INTERVAL = 102,
+	PPM_SC_NANOSLEEP = 103,
+	PPM_SC_MREMAP = 104,
+	PPM_SC_POLL = 105,
+	PPM_SC_PRCTL = 106,
+	PPM_SC_RT_SIGACTION = 107,
+	PPM_SC_RT_SIGPROCMASK = 108,
+	PPM_SC_RT_SIGPENDING = 109,
+	PPM_SC_RT_SIGTIMEDWAIT = 110,
+	PPM_SC_RT_SIGQUEUEINFO = 111,
+	PPM_SC_RT_SIGSUSPEND = 112,
+	PPM_SC_GETCWD = 113,
+	PPM_SC_CAPGET = 114,
+	PPM_SC_CAPSET = 115,
+	PPM_SC_SENDFILE = 116,
+	PPM_SC_GETRLIMIT = 117,
+	PPM_SC_LCHOWN = 118,
+	PPM_SC_GETUID = 119,
+	PPM_SC_GETGID = 120,
+	PPM_SC_GETEUID = 121,
+	PPM_SC_GETEGID = 122,
+	PPM_SC_SETREUID = 123,
+	PPM_SC_SETREGID = 124,
+	PPM_SC_GETGROUPS = 125,
+	PPM_SC_SETGROUPS = 126,
+	PPM_SC_FCHOWN = 127,
+	PPM_SC_SETRESUID = 128,
+	PPM_SC_GETRESUID = 129,
+	PPM_SC_SETRESGID = 130,
+	PPM_SC_GETRESGID = 131,
+	PPM_SC_CHOWN = 132,
+	PPM_SC_SETUID = 133,
+	PPM_SC_SETGID = 134,
+	PPM_SC_SETFSUID = 135,
+	PPM_SC_SETFSGID = 136,
+	PPM_SC_PIVOT_ROOT = 137,
+	PPM_SC_MINCORE = 138,
+	PPM_SC_MADVISE = 139,
+	PPM_SC_GETTID = 140,
+	PPM_SC_SETXATTR = 141,
+	PPM_SC_LSETXATTR = 142,
+	PPM_SC_FSETXATTR = 143,
+	PPM_SC_GETXATTR = 144,
+	PPM_SC_LGETXATTR = 145,
+	PPM_SC_FGETXATTR = 146,
+	PPM_SC_LISTXATTR = 147,
+	PPM_SC_LLISTXATTR = 148,
+	PPM_SC_FLISTXATTR = 149,
+	PPM_SC_REMOVEXATTR = 150,
+	PPM_SC_LREMOVEXATTR = 151,
+	PPM_SC_FREMOVEXATTR = 152,
+	PPM_SC_TKILL = 153,
+	PPM_SC_FUTEX = 154,
+	PPM_SC_SCHED_SETAFFINITY = 155,
+	PPM_SC_SCHED_GETAFFINITY = 156,
+	PPM_SC_SET_THREAD_AREA = 157,
+	PPM_SC_GET_THREAD_AREA = 158,
+	PPM_SC_IO_SETUP = 159,
+	PPM_SC_IO_DESTROY = 160,
+	PPM_SC_IO_GETEVENTS = 161,
+	PPM_SC_IO_SUBMIT = 162,
+	PPM_SC_IO_CANCEL = 163,
+	PPM_SC_EXIT_GROUP = 164,
+	PPM_SC_EPOLL_CREATE = 165,
+	PPM_SC_EPOLL_CTL = 166,
+	PPM_SC_EPOLL_WAIT = 167,
+	PPM_SC_REMAP_FILE_PAGES = 168,
+	PPM_SC_SET_TID_ADDRESS = 169,
+	PPM_SC_TIMER_CREATE = 170,
+	PPM_SC_TIMER_SETTIME = 171,
+	PPM_SC_TIMER_GETTIME = 172,
+	PPM_SC_TIMER_GETOVERRUN = 173,
+	PPM_SC_TIMER_DELETE = 174,
+	PPM_SC_CLOCK_SETTIME = 175,
+	PPM_SC_CLOCK_GETTIME = 176,
+	PPM_SC_CLOCK_GETRES = 177,
+	PPM_SC_CLOCK_NANOSLEEP = 178,
+	PPM_SC_TGKILL = 179,
+	PPM_SC_UTIMES = 180,
+	PPM_SC_MQ_OPEN = 181,
+	PPM_SC_MQ_UNLINK = 182,
+	PPM_SC_MQ_TIMEDSEND = 183,
+	PPM_SC_MQ_TIMEDRECEIVE = 184,
+	PPM_SC_MQ_NOTIFY = 185,
+	PPM_SC_MQ_GETSETATTR = 186,
+	PPM_SC_KEXEC_LOAD = 187,
+	PPM_SC_WAITID = 188,
+	PPM_SC_ADD_KEY = 189,
+	PPM_SC_REQUEST_KEY = 190,
+	PPM_SC_KEYCTL = 191,
+	PPM_SC_IOPRIO_SET = 192,
+	PPM_SC_IOPRIO_GET = 193,
+	PPM_SC_INOTIFY_INIT = 194,
+	PPM_SC_INOTIFY_ADD_WATCH = 195,
+	PPM_SC_INOTIFY_RM_WATCH = 196,
+	PPM_SC_OPENAT = 197,
+	PPM_SC_MKDIRAT = 198,
+	PPM_SC_MKNODAT = 199,
+	PPM_SC_FCHOWNAT = 200,
+	PPM_SC_FUTIMESAT = 201,
+	PPM_SC_UNLINKAT = 202,
+	PPM_SC_RENAMEAT = 203,
+	PPM_SC_LINKAT = 204,
+	PPM_SC_SYMLINKAT = 205,
+	PPM_SC_READLINKAT = 206,
+	PPM_SC_FCHMODAT = 207,
+	PPM_SC_FACCESSAT = 208,
+	PPM_SC_PSELECT6 = 209,
+	PPM_SC_PPOLL = 210,
+	PPM_SC_UNSHARE = 211,
+	PPM_SC_SET_ROBUST_LIST = 212,
+	PPM_SC_GET_ROBUST_LIST = 213,
+	PPM_SC_SPLICE = 214,
+	PPM_SC_TEE = 215,
+	PPM_SC_VMSPLICE = 216,
+	PPM_SC_GETCPU = 217,
+	PPM_SC_EPOLL_PWAIT = 218,
+	PPM_SC_UTIMENSAT = 219,
+	PPM_SC_SIGNALFD = 220,
+	PPM_SC_TIMERFD_CREATE = 221,
+	PPM_SC_EVENTFD = 222,
+	PPM_SC_TIMERFD_SETTIME = 223,
+	PPM_SC_TIMERFD_GETTIME = 224,
+	PPM_SC_SIGNALFD4 = 225,
+	PPM_SC_EVENTFD2 = 226,
+	PPM_SC_EPOLL_CREATE1 = 227,
+	PPM_SC_DUP3 = 228,
+	PPM_SC_PIPE2 = 229,
+	PPM_SC_INOTIFY_INIT1 = 230,
+	PPM_SC_PREADV = 231,
+	PPM_SC_PWRITEV = 232,
+	PPM_SC_RT_TGSIGQUEUEINFO = 233,
+	PPM_SC_PERF_EVENT_OPEN = 234,
+	PPM_SC_FANOTIFY_INIT = 235,
+	PPM_SC_PRLIMIT64 = 236,
+	PPM_SC_CLOCK_ADJTIME = 237,
+	PPM_SC_SYNCFS = 238,
+	PPM_SC_SETNS = 239,
+	PPM_SC_GETDENTS64 = 240,
+	PPM_SC_SOCKET = 241,
+	PPM_SC_BIND = 242,
+	PPM_SC_CONNECT = 243,
+	PPM_SC_LISTEN = 244,
+	PPM_SC_ACCEPT = 245,
+	PPM_SC_GETSOCKNAME = 246,
+	PPM_SC_GETPEERNAME = 247,
+	PPM_SC_SOCKETPAIR = 248,
+	PPM_SC_SENDTO = 249,
+	PPM_SC_RECVFROM = 250,
+	PPM_SC_SHUTDOWN = 251,
+	PPM_SC_SETSOCKOPT = 252,
+	PPM_SC_GETSOCKOPT = 253,
+	PPM_SC_SENDMSG = 254,
+	PPM_SC_SENDMMSG = 255,
+	PPM_SC_RECVMSG = 256,
+	PPM_SC_RECVMMSG = 257,
+	PPM_SC_ACCEPT4 = 258,
+	PPM_SC_SEMOP = 259,
+	PPM_SC_SEMGET = 260,
+	PPM_SC_SEMCTL = 261,
+	PPM_SC_MSGSND = 262,
+	PPM_SC_MSGRCV = 263,
+	PPM_SC_MSGGET = 264,
+	PPM_SC_MSGCTL = 265,
+	PPM_SC_SHMDT = 266,
+	PPM_SC_SHMGET = 267,
+	PPM_SC_SHMCTL = 268,
+	PPM_SC_STATFS64 = 269,
+	PPM_SC_FSTATFS64 = 270,
+	PPM_SC_FSTATAT64 = 271,
+	PPM_SC_SENDFILE64 = 272,
+	PPM_SC_UGETRLIMIT = 273,
+	PPM_SC_BDFLUSH = 274,
+	PPM_SC_SIGPROCMASK = 275,
+	PPM_SC_IPC = 276,
+	PPM_SC_SOCKETCALL = 277,
+	PPM_SC_STAT64 = 278,
+	PPM_SC_LSTAT64 = 279,
+	PPM_SC_FSTAT64 = 280,
+	PPM_SC_FCNTL64 = 281,
+	PPM_SC_MMAP2 = 282,
+	PPM_SC__NEWSELECT = 283,
+	PPM_SC_SGETMASK = 284,
+	PPM_SC_SSETMASK = 285,
+	PPM_SC_SIGPENDING = 286,
+	PPM_SC_OLDUNAME = 287,
+	PPM_SC_UMOUNT = 288,
+	PPM_SC_SIGNAL = 289,
+	PPM_SC_NICE = 290,
+	PPM_SC_STIME = 291,
+	PPM_SC__LLSEEK = 292,
+	PPM_SC_WAITPID = 293,
+	PPM_SC_PREAD64 = 294,
+	PPM_SC_PWRITE64 = 295,
+	PPM_SC_ARCH_PRCTL = 296,
+	PPM_SC_SHMAT = 297,
+	PPM_SC_SIGRETURN = 298,
+	PPM_SC_FALLOCATE = 299,
+	PPM_SC_NEWFSSTAT = 300,
+	PPM_SC_PROCESS_VM_READV = 301,
+	PPM_SC_PROCESS_VM_WRITEV = 302,
+	PPM_SC_FORK = 303,
+	PPM_SC_VFORK = 304,
+	PPM_SC_SETUID32 = 305,
+	PPM_SC_GETUID32 = 306,
+	PPM_SC_SETGID32 = 307,
+	PPM_SC_GETEUID32 = 308,
+	PPM_SC_GETGID32 = 309,
+	PPM_SC_SETRESUID32 = 310,
+	PPM_SC_SETRESGID32 = 311,
+	PPM_SC_GETRESUID32 = 312,
+	PPM_SC_GETRESGID32 = 313,
+	PPM_SC_FINIT_MODULE = 314,
+	PPM_SC_BPF = 315,
+	PPM_SC_SECCOMP = 316,
+	PPM_SC_MAX = 317,
+};
+
+/*
+ * Event information enums
+ */
+enum ppm_event_category {
+	EC_UNKNOWN = 0,	/* Unknown */
+	EC_OTHER = 1,	/* No specific category */
+	EC_FILE = 2,	/* File operation (open, close...) or file I/O */
+	EC_NET = 3,		/* Network operation (socket, bind...) or network I/O */
+	EC_IPC = 4,		/* IPC operation (pipe, futex...) or IPC I/O (e.g. on a pipe) */
+	EC_MEMORY = 5,	/* Memory-related operation (e.g. brk) */
+	EC_PROCESS = 6,	/* Process-related operation (fork, clone...) */
+	EC_SLEEP = 7,	/* Plain sleep */
+	EC_SYSTEM = 8,	/* System-related operations (e.g. reboot) */
+	EC_SIGNAL = 9,	/* Signal-related operations (e.g. signal) */
+	EC_USER = 10,	/* User-related operations (e.g. getuid) */
+	EC_TIME = 11,	/* Time-related syscalls (e.g. gettimeofday) */
+	EC_PROCESSING = 12,	/* User level processing. Never used for system calls */
+	EC_IO_BASE = 32,/* used for masking */
+	EC_IO_READ = 32,/* General I/O read (can be file, socket, IPC...) */
+	EC_IO_WRITE = 33,/* General I/O write (can be file, socket, IPC...) */
+	EC_IO_OTHER = 34,/* General I/O that is neither read not write (can be file, socket, IPC...) */
+	EC_WAIT = 64,	/* General wait (can be file, socket, IPC...) */
+	EC_SCHEDULER = 128,	/* Scheduler event (e.g. context switch) */
+	EC_INTERNAL = 256,	/* Internal event that shouldn't be shown to the user */
+};
+
+enum ppm_event_flags {
+	EF_NONE = 0,
+	EF_CREATES_FD = (1 << 0), /* This event creates an FD (e.g. open) */
+	EF_DESTROYS_FD = (1 << 1), /* This event destroys an FD (e.g. close) */
+	EF_USES_FD = (1 << 2), /* This event operates on an FD. */
+	EF_READS_FROM_FD = (1 << 3), /* This event reads data from an FD. */
+	EF_WRITES_TO_FD = (1 << 4), /* This event writes data to an FD. */
+	EF_MODIFIES_STATE = (1 << 5), /* This event causes the machine state to change and should not be dropped by the filtering engine. */
+	EF_UNUSED = (1 << 6), /* This event is not used */
+	EF_WAITS = (1 << 7), /* This event reads data from an FD. */
+	EF_SKIPPARSERESET = (1 << 8), /* This event shouldn't pollute the parser lastevent state tracker. */
+	EF_OLD_VERSION = (1 << 9), /* This event is kept for backward compatibility */
+	EF_DROP_FALCO = (1 << 10) /* This event should not be passed up to Falco */
+};
+
+/*
+ * types of event parameters
+ */
+enum ppm_param_type {
+	PT_NONE = 0,
+	PT_INT8 = 1,
+	PT_INT16 = 2,
+	PT_INT32 = 3,
+	PT_INT64 = 4,
+	PT_UINT8 = 5,
+	PT_UINT16 = 6,
+	PT_UINT32 = 7,
+	PT_UINT64 = 8,
+	PT_CHARBUF = 9,	/* A printable buffer of bytes, NULL terminated */
+	PT_BYTEBUF = 10, /* A raw buffer of bytes not suitable for printing */
+	PT_ERRNO = 11,	/* this is an INT64, but will be interpreted as an error code */
+	PT_SOCKADDR = 12, /* A sockaddr structure, 1byte family + data */
+	PT_SOCKTUPLE = 13, /* A sockaddr tuple,1byte family + 12byte data + 12byte data */
+	PT_FD = 14, /* An fd, 64bit */
+	PT_PID = 15, /* A pid/tid, 64bit */
+	PT_FDLIST = 16, /* A list of fds, 16bit count + count * (64bit fd + 16bit flags) */
+	PT_FSPATH = 17,	/* A string containing a relative or absolute file system path, null terminated */
+	PT_SYSCALLID = 18, /* A 16bit system call ID. Can be used as a key for the g_syscall_info_table table. */
+	PT_SIGTYPE = 19, /* An 8bit signal number */
+	PT_RELTIME = 20, /* A relative time. Seconds * 10^9  + nanoseconds. 64bit. */
+	PT_ABSTIME = 21, /* An absolute time interval. Seconds from epoch * 10^9  + nanoseconds. 64bit. */
+	PT_PORT = 22, /* A TCP/UDP prt. 2 bytes. */
+	PT_L4PROTO = 23, /* A 1 byte IP protocol type. */
+	PT_SOCKFAMILY = 24, /* A 1 byte socket family. */
+	PT_BOOL = 25, /* A boolean value, 4 bytes. */
+	PT_IPV4ADDR = 26, /* A 4 byte raw IPv4 address. */
+	PT_DYN = 27, /* Type can vary depending on the context. Used for filter fields like evt.rawarg. */
+	PT_FLAGS8 = 28, /* this is an UINT8, but will be interpreted as 8 bit flags. */
+	PT_FLAGS16 = 29, /* this is an UINT16, but will be interpreted as 16 bit flags. */
+	PT_FLAGS32 = 30, /* this is an UINT32, but will be interpreted as 32 bit flags. */
+	PT_UID = 31, /* this is an UINT32, MAX_UINT32 will be interpreted as no value. */
+	PT_GID = 32, /* this is an UINT32, MAX_UINT32 will be interpreted as no value. */
+	PT_DOUBLE = 33, /* this is a double precision floating point number. */
+	PT_SIGSET = 34, /* sigset_t. I only store the lower UINT32 of it */
+	PT_CHARBUFARRAY = 35,	/* Pointer to an array of strings, exported by the user events decoder. 64bit. For internal use only. */
+	PT_CHARBUF_PAIR_ARRAY = 36,	/* Pointer to an array of string pairs, exported by the user events decoder. 64bit. For internal use only. */
+	PT_IPV4NET = 37, /* An IPv4 network. */
+	PT_MAX = 38 /* array size */
+};
+
+enum ppm_print_format {
+	PF_NA = 0,
+	PF_DEC = 1,	/* decimal */
+	PF_HEX = 2,	/* hexadecimal */
+	PF_10_PADDED_DEC = 3, /* decimal padded to 10 digits, useful to print the fractional part of a ns timestamp */
+	PF_ID = 4,
+	PF_DIR = 5,
+	PF_OCT = 6,	/* octal */
+};
+
+/*!
+  \brief Name-value pair, used to store flags information.
+*/
+struct ppm_name_value {
+	const char *name;
+	uint32_t value;
+};
+
+/*!
+  \brief Event parameter information.
+*/
+struct ppm_param_info {
+	char name[PPM_MAX_NAME_LEN];  /**< Parameter name, e.g. 'size'. */
+	enum ppm_param_type type; /**< Parameter type, e.g. 'uint16', 'string'... */
+	enum ppm_print_format fmt; /**< If this is a numeric parameter, this flag specifies if it should be rendered as decimal or hex. */
+	const void *info; /**< If this is a flags parameter, it points to an array of ppm_name_value,
+			       else if this is a dynamic parameter it points to an array of ppm_param_info */
+	uint8_t ninfo; /**< Number of entry in the info array. */
+};
+
+/*!
+  \brief Event information.
+  This structure contains the full description of an event type (e.g. 'open') that
+   is supported by the sysdig infrastructure.
+*/
+struct ppm_event_info {
+	char name[PPM_MAX_NAME_LEN]; /**< Name. */
+	enum ppm_event_category category; /**< Event category, e.g. 'file', 'net', etc. */
+	enum ppm_event_flags flags; /**< flags for this event. */
+	uint32_t nparams; /**< Number of parameter in the params array. */
+	/* XXX this 16 limit comes out of my ass. Determine something that makes sense or use a dynamic array. */
+	struct ppm_param_info params[PPM_MAX_EVENT_PARAMS]; /**< parameters descriptions. */
+};
+
+#if defined _MSC_VER
+#pragma pack(push)
+#pragma pack(1)
+#elif defined __sun
+#pragma pack(1)
+#else
+#pragma pack(push, 1)
+#endif
+struct ppm_evt_hdr {
+#ifdef PPM_ENABLE_SENTINEL
+	uint32_t sentinel_begin;
+#endif
+	uint64_t ts; /* timestamp, in nanoseconds from epoch */
+	uint64_t tid; /* the tid of the thread that generated this event */
+	uint32_t len; /* the event len, including the header */
+	uint16_t type; /* the event type */
+};
+#if defined __sun
+#pragma pack()
+#else
+#pragma pack(pop)
+#endif
+
+/*
+ * IOCTL codes
+ */
+#define PPM_IOCTL_MAGIC	's'
+#define PPM_IOCTL_DISABLE_CAPTURE _IO(PPM_IOCTL_MAGIC, 0)
+#define PPM_IOCTL_ENABLE_CAPTURE _IO(PPM_IOCTL_MAGIC, 1)
+#define PPM_IOCTL_DISABLE_DROPPING_MODE _IO(PPM_IOCTL_MAGIC, 2)
+#define PPM_IOCTL_ENABLE_DROPPING_MODE _IO(PPM_IOCTL_MAGIC, 3)
+#define PPM_IOCTL_SET_SNAPLEN _IO(PPM_IOCTL_MAGIC, 4)
+#define PPM_IOCTL_MASK_ZERO_EVENTS _IO(PPM_IOCTL_MAGIC, 5)
+#define PPM_IOCTL_MASK_SET_EVENT   _IO(PPM_IOCTL_MAGIC, 6)
+#define PPM_IOCTL_MASK_UNSET_EVENT _IO(PPM_IOCTL_MAGIC, 7)
+#define PPM_IOCTL_DISABLE_DYNAMIC_SNAPLEN _IO(PPM_IOCTL_MAGIC, 8)
+#define PPM_IOCTL_ENABLE_DYNAMIC_SNAPLEN _IO(PPM_IOCTL_MAGIC, 9)
+#define PPM_IOCTL_GET_VTID _IO(PPM_IOCTL_MAGIC, 10)
+#define PPM_IOCTL_GET_VPID _IO(PPM_IOCTL_MAGIC, 11)
+#define PPM_IOCTL_GET_CURRENT_TID _IO(PPM_IOCTL_MAGIC, 12)
+#define PPM_IOCTL_GET_CURRENT_PID _IO(PPM_IOCTL_MAGIC, 13)
+#define PPM_IOCTL_DISABLE_SIGNAL_DELIVER _IO(PPM_IOCTL_MAGIC, 14)
+#define PPM_IOCTL_ENABLE_SIGNAL_DELIVER _IO(PPM_IOCTL_MAGIC, 15)
+#define PPM_IOCTL_GET_PROCLIST _IO(PPM_IOCTL_MAGIC, 16)
+#define PPM_IOCTL_SET_TRACERS_CAPTURE _IO(PPM_IOCTL_MAGIC, 17)
+#define PPM_IOCTL_SET_SIMPLE_MODE _IO(PPM_IOCTL_MAGIC, 18)
+#define PPM_IOCTL_ENABLE_PAGE_FAULTS _IO(PPM_IOCTL_MAGIC, 19)
+#define PPM_IOCTL_GET_N_TRACEPOINT_HIT _IO(PPM_IOCTL_MAGIC, 20)
+
+extern const struct ppm_name_value socket_families[];
+extern const struct ppm_name_value file_flags[];
+extern const struct ppm_name_value flock_flags[];
+extern const struct ppm_name_value clone_flags[];
+extern const struct ppm_name_value futex_operations[];
+extern const struct ppm_name_value lseek_whence[];
+extern const struct ppm_name_value poll_flags[];
+extern const struct ppm_name_value mount_flags[];
+extern const struct ppm_name_value umount_flags[];
+extern const struct ppm_name_value shutdown_how[];
+extern const struct ppm_name_value rlimit_resources[];
+extern const struct ppm_name_value fcntl_commands[];
+extern const struct ppm_name_value ptrace_requests[];
+extern const struct ppm_name_value prot_flags[];
+extern const struct ppm_name_value mmap_flags[];
+extern const struct ppm_name_value splice_flags[];
+extern const struct ppm_name_value quotactl_cmds[];
+extern const struct ppm_name_value quotactl_types[];
+extern const struct ppm_name_value quotactl_dqi_flags[];
+extern const struct ppm_name_value quotactl_quota_fmts[];
+extern const struct ppm_name_value semop_flags[];
+extern const struct ppm_name_value semget_flags[];
+extern const struct ppm_name_value semctl_commands[];
+extern const struct ppm_name_value access_flags[];
+extern const struct ppm_name_value pf_flags[];
+
+extern const struct ppm_param_info ptrace_dynamic_param[];
+extern const struct ppm_param_info bpf_dynamic_param[];
+
+/*
+ * Driver event notification ID
+ */
+enum ppm_driver_event_id {
+	DEI_NONE = 0,
+	DEI_DISABLE_DROPPING = 1,
+	DEI_ENABLE_DROPPING = 2,
+};
+
+/*!
+  \brief Process information as returned by the PPM_IOCTL_GET_PROCLIST IOCTL.
+*/
+struct ppm_proc_info {
+	uint64_t pid;
+	uint64_t utime;
+	uint64_t stime;
+};
+
+struct ppm_proclist_info {
+	int64_t n_entries;
+	int64_t max_entries;
+	struct ppm_proc_info entries[0];
+};
+
+#endif /* EVENTS_PUBLIC_H_ */
diff --git a/kernel/trace/sysdig/ppm_fillers.c b/kernel/trace/sysdig/ppm_fillers.c
new file mode 100644
index 0000000..4d9ecbc
--- /dev/null
+++ b/kernel/trace/sysdig/ppm_fillers.c
@@ -0,0 +1,5648 @@
+/*
+Copyright (C) 2013-2014 Draios inc.
+
+This file is part of sysdig.
+
+sysdig is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License version 2 as
+published by the Free Software Foundation.
+
+sysdig is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with sysdig.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#define pr_fmt(fmt)	KBUILD_MODNAME ": " fmt
+
+#include <linux/compat.h>
+#include <linux/cdev.h>
+#include <asm/unistd.h>
+#include <net/sock.h>
+#include <net/af_unix.h>
+#include <net/compat.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/file.h>
+#include <linux/futex.h>
+#include <linux/fs_struct.h>
+#include <linux/ptrace.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/quota.h>
+#include <linux/tty.h>
+#include <linux/uaccess.h>
+#ifdef CONFIG_CGROUPS
+#include <linux/cgroup.h>
+#endif
+#include <asm/mman.h>
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 20)
+#include "ppm_syscall.h"
+#else
+#include <asm/syscall.h>
+#endif
+
+#include "ppm_ringbuffer.h"
+#include "ppm_events_public.h"
+#include "ppm_events.h"
+#include "ppm.h"
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+#include <linux/bpf.h>
+#endif
+
+/* This is described in syscall(2). Some syscalls take 64-bit arguments. On
+ * arches that have 64-bit registers, these arguments are shipped in a register.
+ * On 32-bit arches, however, these are split between two consecutive registers,
+ * with some alignment requirements. Some require an odd/even pair while some
+ * others require even/odd. For now I assume they all do what x86_32 does, and
+ * we can handle the rest when we port those.
+ */
+#ifdef CONFIG_64BIT
+#define _64BIT_ARGS_SINGLE_REGISTER
+#endif
+
+static int f_sys_generic(struct event_filler_arguments *args);	/* generic syscall event filler that includes the system call number */
+static int f_sys_empty(struct event_filler_arguments *args);		/* empty filler */
+static int f_sys_single(struct event_filler_arguments *args);		/* generic enter filler that copies a single argument syscall into a single parameter event */
+static int f_sys_single_x(struct event_filler_arguments *args);		/* generic exit filler that captures an integer */
+static int f_sys_open_x(struct event_filler_arguments *args);
+static int f_sys_read_x(struct event_filler_arguments *args);
+static int f_sys_write_x(struct event_filler_arguments *args);
+static int f_sys_execve_e(struct event_filler_arguments *args);
+static int f_proc_startupdate(struct event_filler_arguments *args);
+static int f_sys_socketpair_x(struct event_filler_arguments *args);
+static int f_sys_connect_x(struct event_filler_arguments *args);
+static int f_sys_accept4_e(struct event_filler_arguments *args);
+static int f_sys_accept_x(struct event_filler_arguments *args);
+static int f_sys_send_e(struct event_filler_arguments *args);
+static int f_sys_send_x(struct event_filler_arguments *args);
+static int f_sys_sendto_e(struct event_filler_arguments *args);
+static int f_sys_sendmsg_e(struct event_filler_arguments *args);
+static int f_sys_sendmsg_x(struct event_filler_arguments *args);
+static int f_sys_recv_e(struct event_filler_arguments *args);
+static int f_sys_recv_x(struct event_filler_arguments *args);
+static int f_sys_recvfrom_e(struct event_filler_arguments *args);
+static int f_sys_recvfrom_x(struct event_filler_arguments *args);
+static int f_sys_recvmsg_e(struct event_filler_arguments *args);
+static int f_sys_recvmsg_x(struct event_filler_arguments *args);
+static int f_sys_shutdown_e(struct event_filler_arguments *args);
+static int f_sys_pipe_x(struct event_filler_arguments *args);
+static int f_sys_eventfd_e(struct event_filler_arguments *args);
+static int f_sys_futex_e(struct event_filler_arguments *args);
+static int f_sys_lseek_e(struct event_filler_arguments *args);
+static int f_sys_llseek_e(struct event_filler_arguments *args);
+static int f_sys_socket_bind_x(struct event_filler_arguments *args);
+static int f_sys_poll_e(struct event_filler_arguments *args);
+static int f_sys_poll_x(struct event_filler_arguments *args);
+static int f_sys_openat_e(struct event_filler_arguments *args);
+#ifndef _64BIT_ARGS_SINGLE_REGISTER
+static int f_sys_pread64_e(struct event_filler_arguments *args);
+static int f_sys_preadv_e(struct event_filler_arguments *args);
+#endif
+static int f_sys_writev_e(struct event_filler_arguments *args);
+static int f_sys_pwrite64_e(struct event_filler_arguments *args);
+static int f_sys_readv_x(struct event_filler_arguments *args);
+static int f_sys_writev_e(struct event_filler_arguments *args);
+static int f_sys_writev_pwritev_x(struct event_filler_arguments *args);
+static int f_sys_preadv_x(struct event_filler_arguments *args);
+static int f_sys_pwritev_e(struct event_filler_arguments *args);
+static int f_sys_nanosleep_e(struct event_filler_arguments *args);
+static int f_sys_getrlimit_setrlimit_e(struct event_filler_arguments *args);
+static int f_sys_getrlimit_setrlrimit_x(struct event_filler_arguments *args);
+static int f_sys_prlimit_e(struct event_filler_arguments *args);
+static int f_sys_prlimit_x(struct event_filler_arguments *args);
+#ifdef CAPTURE_CONTEXT_SWITCHES
+static int f_sched_switch_e(struct event_filler_arguments *args);
+#endif
+static int f_sched_drop(struct event_filler_arguments *args);
+static int f_sched_fcntl_e(struct event_filler_arguments *args);
+static int f_sys_ptrace_e(struct event_filler_arguments *args);
+static int f_sys_ptrace_x(struct event_filler_arguments *args);
+static int f_sys_mmap_e(struct event_filler_arguments *args);
+static int f_sys_brk_munmap_mmap_x(struct event_filler_arguments *args);
+static int f_sys_renameat_x(struct event_filler_arguments *args);
+static int f_sys_symlinkat_x(struct event_filler_arguments *args);
+static int f_sys_procexit_e(struct event_filler_arguments *args);
+static int f_sys_sendfile_e(struct event_filler_arguments *args);
+static int f_sys_sendfile_x(struct event_filler_arguments *args);
+static int f_sys_quotactl_e(struct event_filler_arguments *args);
+static int f_sys_quotactl_x(struct event_filler_arguments *args);
+static int f_sys_sysdigevent_e(struct event_filler_arguments *args);
+static int f_sys_getresuid_and_gid_x(struct event_filler_arguments *args);
+#ifdef CAPTURE_SIGNAL_DELIVERIES
+static int f_sys_signaldeliver_e(struct event_filler_arguments *args);
+#endif
+#ifdef CAPTURE_PAGE_FAULTS
+static int f_sys_pagefault_e(struct event_filler_arguments *args);
+#endif
+static int f_sys_setns_e(struct event_filler_arguments *args);
+static int f_sys_unshare_e(struct event_filler_arguments *args);
+static int f_sys_flock_e(struct event_filler_arguments *args);
+static int f_cpu_hotplug_e(struct event_filler_arguments *args);
+static int f_sys_semop_e(struct event_filler_arguments *args);
+static int f_sys_semop_x(struct event_filler_arguments *args);
+static int f_sys_semget_e(struct event_filler_arguments *args);
+static int f_sys_semctl_e(struct event_filler_arguments *args);
+static int f_sys_semctl_x(struct event_filler_arguments *args);
+static int f_sys_ppoll_e(struct event_filler_arguments *args);
+static int f_sys_mount_e(struct event_filler_arguments *args);
+static int f_sys_access_e(struct event_filler_arguments *args);
+static int f_sys_access_x(struct event_filler_arguments *args);
+static int f_sys_bpf_x(struct event_filler_arguments *args);
+
+/*
+ * Note, this is not part of g_event_info because we want to share g_event_info with userland.
+ * However, separating this information in a different struct is not ideal and we should find a better way.
+ */
+const struct ppm_event_entry g_ppm_events[PPM_EVENT_MAX] = {
+	[PPME_GENERIC_E] = {f_sys_generic},
+	[PPME_GENERIC_X] = {f_sys_generic},
+	[PPME_SYSCALL_OPEN_E] = {f_sys_empty},
+	[PPME_SYSCALL_OPEN_X] = {f_sys_open_x},
+	[PPME_SYSCALL_CREAT_E] = {f_sys_empty},
+	[PPME_SYSCALL_CREAT_X] = {PPM_AUTOFILL, 3, APT_REG, {{AF_ID_RETVAL}, {0}, {AF_ID_USEDEFAULT, 0} } },
+	[PPME_SYSCALL_CLOSE_E] = {f_sys_single},
+	[PPME_SYSCALL_CLOSE_X] = {f_sys_single_x},
+	[PPME_SYSCALL_READ_E] = {PPM_AUTOFILL, 2, APT_REG, {{0}, {2} } },
+	[PPME_SYSCALL_READ_X] = {f_sys_read_x},
+	[PPME_SYSCALL_WRITE_E] = {PPM_AUTOFILL, 2, APT_REG, {{0}, {2} } },
+	[PPME_SYSCALL_WRITE_X] = {f_sys_write_x},
+	[PPME_PROCEXIT_1_E] = {f_sys_procexit_e},
+	[PPME_SOCKET_SOCKET_E] = {PPM_AUTOFILL, 3, APT_SOCK, {{0}, {1}, {2} } },
+	[PPME_SOCKET_SOCKET_X] = {f_sys_single_x},
+	[PPME_SOCKET_SOCKETPAIR_E] = {PPM_AUTOFILL, 3, APT_SOCK, {{0}, {1}, {2} } },
+	[PPME_SOCKET_SOCKETPAIR_X] = {f_sys_socketpair_x},
+	[PPME_SOCKET_BIND_E] = {PPM_AUTOFILL, 1, APT_SOCK, {{0} } },
+	[PPME_SOCKET_BIND_X] = {f_sys_socket_bind_x},
+	[PPME_SOCKET_CONNECT_E] = {PPM_AUTOFILL, 1, APT_SOCK, {{0} } },
+	[PPME_SOCKET_CONNECT_X] = {f_sys_connect_x},
+	[PPME_SOCKET_LISTEN_E] = {PPM_AUTOFILL, 2, APT_SOCK, {{0}, {1} } },
+	[PPME_SOCKET_LISTEN_X] = {f_sys_single_x},
+	[PPME_SOCKET_ACCEPT_5_E] = {f_sys_empty},
+	[PPME_SOCKET_ACCEPT_5_X] = {f_sys_accept_x},
+	[PPME_SOCKET_ACCEPT4_5_E] = {f_sys_accept4_e},
+	[PPME_SOCKET_ACCEPT4_5_X] = {f_sys_accept_x},
+	[PPME_SOCKET_SEND_E] = {f_sys_send_e},
+	[PPME_SOCKET_SEND_X] = {f_sys_send_x},
+	[PPME_SOCKET_SENDTO_E] = {f_sys_sendto_e},
+	[PPME_SOCKET_SENDTO_X] = {f_sys_send_x},
+	[PPME_SOCKET_SENDMSG_E] = {f_sys_sendmsg_e},
+	[PPME_SOCKET_SENDMSG_X] = {f_sys_sendmsg_x},
+	[PPME_SOCKET_RECV_E] = {f_sys_recv_e},
+	[PPME_SOCKET_RECV_X] = {f_sys_recv_x},
+	[PPME_SOCKET_RECVFROM_E] = {f_sys_recvfrom_e},
+	[PPME_SOCKET_RECVFROM_X] = {f_sys_recvfrom_x},
+	[PPME_SOCKET_RECVMSG_E] = {f_sys_recvmsg_e},
+	[PPME_SOCKET_RECVMSG_X] = {f_sys_recvmsg_x},
+	[PPME_SOCKET_SHUTDOWN_E] = {f_sys_shutdown_e},
+	[PPME_SOCKET_SHUTDOWN_X] = {f_sys_single_x},
+	[PPME_SYSCALL_PIPE_E] = {f_sys_empty},
+	[PPME_SYSCALL_PIPE_X] = {f_sys_pipe_x},
+	[PPME_SYSCALL_EVENTFD_E] = {f_sys_eventfd_e},
+	[PPME_SYSCALL_EVENTFD_X] = {f_sys_single_x},
+	[PPME_SYSCALL_FUTEX_E] = {f_sys_futex_e},
+	[PPME_SYSCALL_FUTEX_X] = {f_sys_single_x},
+	[PPME_SYSCALL_STAT_E] = {f_sys_empty},
+	[PPME_SYSCALL_STAT_X] = {PPM_AUTOFILL, 2, APT_REG, {{AF_ID_RETVAL}, {0} } },
+	[PPME_SYSCALL_LSTAT_E] = {f_sys_empty},
+	[PPME_SYSCALL_LSTAT_X] = {PPM_AUTOFILL, 2, APT_REG, {{AF_ID_RETVAL}, {0} } },
+	[PPME_SYSCALL_FSTAT_E] = {f_sys_single},
+	[PPME_SYSCALL_FSTAT_X] = {f_sys_single_x},
+	[PPME_SYSCALL_STAT64_E] = {f_sys_empty},
+	[PPME_SYSCALL_STAT64_X] = {PPM_AUTOFILL, 2, APT_REG, {{AF_ID_RETVAL}, {0} } },
+	[PPME_SYSCALL_LSTAT64_E] = {f_sys_empty},
+	[PPME_SYSCALL_LSTAT64_X] = {PPM_AUTOFILL, 2, APT_REG, {{AF_ID_RETVAL}, {0} } },
+	[PPME_SYSCALL_FSTAT64_E] = {f_sys_single},
+	[PPME_SYSCALL_FSTAT64_X] = {f_sys_single_x},
+	[PPME_SYSCALL_EPOLLWAIT_E] = {PPM_AUTOFILL, 1, APT_REG, {{2} } },
+	[PPME_SYSCALL_EPOLLWAIT_X] = {f_sys_single_x},
+	[PPME_SYSCALL_POLL_E] = {f_sys_poll_e},
+	[PPME_SYSCALL_POLL_X] = {f_sys_poll_x},
+	[PPME_SYSCALL_SELECT_E] = {f_sys_empty},
+	[PPME_SYSCALL_SELECT_X] = {f_sys_single_x},
+	[PPME_SYSCALL_NEWSELECT_E] = {f_sys_empty},
+	[PPME_SYSCALL_NEWSELECT_X] = {f_sys_single_x},
+	[PPME_SYSCALL_LSEEK_E] = {f_sys_lseek_e},
+	[PPME_SYSCALL_LSEEK_X] = {f_sys_single_x},
+	[PPME_SYSCALL_LLSEEK_E] = {f_sys_llseek_e},
+	[PPME_SYSCALL_LLSEEK_X] = {f_sys_single_x},
+	[PPME_SYSCALL_IOCTL_3_E] = {PPM_AUTOFILL, 3, APT_REG, {{0}, {1}, {2} } },
+	[PPME_SYSCALL_IOCTL_3_X] = {f_sys_single_x},
+	[PPME_SYSCALL_GETCWD_E] = {f_sys_empty},
+	[PPME_SYSCALL_GETCWD_X] = {PPM_AUTOFILL, 2, APT_REG, {{AF_ID_RETVAL}, {0} } },
+	[PPME_SYSCALL_CHDIR_E] = {f_sys_empty},
+	[PPME_SYSCALL_CHDIR_X] = {PPM_AUTOFILL, 2, APT_REG, {{AF_ID_RETVAL}, {0} } },
+	[PPME_SYSCALL_FCHDIR_E] = {f_sys_single},
+	[PPME_SYSCALL_FCHDIR_X] = {f_sys_single_x},
+	[PPME_SYSCALL_MKDIR_E] = {PPM_AUTOFILL, 2, APT_REG, {{0}, {AF_ID_USEDEFAULT, 0} } },
+	[PPME_SYSCALL_MKDIR_X] = {f_sys_single_x},
+	[PPME_SYSCALL_RMDIR_E] = {f_sys_single},
+	[PPME_SYSCALL_RMDIR_X] = {f_sys_single_x},
+	[PPME_SYSCALL_OPENAT_E] = {f_sys_openat_e},
+	[PPME_SYSCALL_OPENAT_X] = {f_sys_single_x},
+	[PPME_SYSCALL_LINK_E] = {PPM_AUTOFILL, 2, APT_REG, {{0}, {1} } },
+	[PPME_SYSCALL_LINK_X] = {f_sys_single_x},
+	[PPME_SYSCALL_LINKAT_E] = {PPM_AUTOFILL, 4, APT_REG, {{0}, {1}, {2}, {3} } },
+	[PPME_SYSCALL_LINKAT_X] = {f_sys_single_x},
+	[PPME_SYSCALL_UNLINK_E] = {f_sys_single},
+	[PPME_SYSCALL_UNLINK_X] = {f_sys_single_x},
+	[PPME_SYSCALL_UNLINKAT_E] = {PPM_AUTOFILL, 2, APT_REG, {{0}, {1} } },
+	[PPME_SYSCALL_UNLINKAT_X] = {f_sys_single_x},
+#ifdef _64BIT_ARGS_SINGLE_REGISTER
+	[PPME_SYSCALL_PREAD_E] = {PPM_AUTOFILL, 3, APT_REG, {{0}, {2}, {3} } },
+#else
+	[PPME_SYSCALL_PREAD_E] = {f_sys_pread64_e},
+#endif
+	[PPME_SYSCALL_PREAD_X] = {f_sys_read_x},
+	[PPME_SYSCALL_PWRITE_E] = {f_sys_pwrite64_e},
+	[PPME_SYSCALL_PWRITE_X] = {f_sys_write_x},
+	[PPME_SYSCALL_READV_E] = {f_sys_single},
+	[PPME_SYSCALL_READV_X] = {f_sys_readv_x},
+	[PPME_SYSCALL_WRITEV_E] = {f_sys_writev_e},
+	[PPME_SYSCALL_WRITEV_X] = {f_sys_writev_pwritev_x},
+#ifdef _64BIT_ARGS_SINGLE_REGISTER
+	[PPME_SYSCALL_PREADV_E] = {PPM_AUTOFILL, 2, APT_REG, {{0}, {3} } },
+#else
+	[PPME_SYSCALL_PREADV_E] = {f_sys_preadv_e},
+#endif
+	[PPME_SYSCALL_PREADV_X] = {f_sys_preadv_x},
+	[PPME_SYSCALL_PWRITEV_E] = {f_sys_pwritev_e},
+	[PPME_SYSCALL_PWRITEV_X] = {f_sys_writev_pwritev_x},
+	[PPME_SYSCALL_DUP_E] = {PPM_AUTOFILL, 1, APT_REG, {{0} } },
+	[PPME_SYSCALL_DUP_X] = {f_sys_single_x},
+	/* Mask and Flags not implemented yet */
+	[PPME_SYSCALL_SIGNALFD_E] = {PPM_AUTOFILL, 3, APT_REG, {{0}, {AF_ID_USEDEFAULT, 0}, {AF_ID_USEDEFAULT, 0} } },
+	[PPME_SYSCALL_SIGNALFD_X] = {f_sys_single_x},
+	[PPME_SYSCALL_KILL_E] = {PPM_AUTOFILL, 2, APT_REG, {{0}, {1} } },
+	[PPME_SYSCALL_KILL_X] = {f_sys_single_x},
+	[PPME_SYSCALL_TKILL_E] = {PPM_AUTOFILL, 2, APT_REG, {{0}, {1} } },
+	[PPME_SYSCALL_TKILL_X] = {f_sys_single_x},
+	[PPME_SYSCALL_TGKILL_E] = {PPM_AUTOFILL, 3, APT_REG, {{0}, {1}, {2} } },
+	[PPME_SYSCALL_TGKILL_X] = {f_sys_single_x},
+	[PPME_SYSCALL_NANOSLEEP_E] = {f_sys_nanosleep_e},
+	[PPME_SYSCALL_NANOSLEEP_X] = {f_sys_single_x},
+	[PPME_SYSCALL_TIMERFD_CREATE_E] = {PPM_AUTOFILL, 2, APT_REG, {{AF_ID_USEDEFAULT, 0}, {AF_ID_USEDEFAULT, 0} } },
+	[PPME_SYSCALL_TIMERFD_CREATE_X] = {f_sys_single_x},
+	[PPME_SYSCALL_INOTIFY_INIT_E] = {PPM_AUTOFILL, 1, APT_REG, {{AF_ID_USEDEFAULT, 0} } },
+	[PPME_SYSCALL_INOTIFY_INIT_X] = {f_sys_single_x},
+	[PPME_SYSCALL_GETRLIMIT_E] = {f_sys_getrlimit_setrlimit_e},
+	[PPME_SYSCALL_GETRLIMIT_X] = {f_sys_getrlimit_setrlrimit_x},
+	[PPME_SYSCALL_SETRLIMIT_E] = {f_sys_getrlimit_setrlimit_e},
+	[PPME_SYSCALL_SETRLIMIT_X] = {f_sys_getrlimit_setrlrimit_x},
+	[PPME_SYSCALL_PRLIMIT_E] = {f_sys_prlimit_e},
+	[PPME_SYSCALL_PRLIMIT_X] = {f_sys_prlimit_x},
+#ifdef CAPTURE_CONTEXT_SWITCHES
+	[PPME_SCHEDSWITCH_6_E] = {f_sched_switch_e},
+#endif
+	[PPME_DROP_E] = {f_sched_drop},
+	[PPME_DROP_X] = {f_sched_drop},
+	[PPME_SYSCALL_FCNTL_E] = {f_sched_fcntl_e},
+	[PPME_SYSCALL_FCNTL_X] = {f_sys_single_x},
+	[PPME_SYSCALL_EXECVE_18_E] = {f_sys_execve_e},
+	[PPME_SYSCALL_EXECVE_18_X] = {f_proc_startupdate},
+	[PPME_SYSCALL_CLONE_20_E] = {f_sys_empty},
+	[PPME_SYSCALL_CLONE_20_X] = {f_proc_startupdate},
+	[PPME_SYSCALL_BRK_4_E] = {PPM_AUTOFILL, 1, APT_REG, {{0} } },
+	[PPME_SYSCALL_BRK_4_X] = {f_sys_brk_munmap_mmap_x},
+	[PPME_SYSCALL_MMAP_E] = {f_sys_mmap_e},
+	[PPME_SYSCALL_MMAP_X] = {f_sys_brk_munmap_mmap_x},
+	[PPME_SYSCALL_MMAP2_E] = {f_sys_mmap_e},
+	[PPME_SYSCALL_MMAP2_X] = {f_sys_brk_munmap_mmap_x},
+	[PPME_SYSCALL_MUNMAP_E] = {PPM_AUTOFILL, 2, APT_REG, {{0}, {1} } },
+	[PPME_SYSCALL_MUNMAP_X] = {f_sys_brk_munmap_mmap_x},
+	[PPME_SYSCALL_SPLICE_E] = {PPM_AUTOFILL, 4, APT_REG, {{0}, {2}, {4}, {5} } },
+	[PPME_SYSCALL_SPLICE_X] = {PPM_AUTOFILL, 1, APT_REG, {{AF_ID_RETVAL} } },
+	[PPME_SYSCALL_PTRACE_E] = {f_sys_ptrace_e},
+	[PPME_SYSCALL_PTRACE_X] = {f_sys_ptrace_x},
+	[PPME_SYSCALL_RENAME_E] = {f_sys_empty},
+	[PPME_SYSCALL_RENAME_X] = {PPM_AUTOFILL, 3, APT_REG, {{AF_ID_RETVAL}, {0}, {1} } },
+	[PPME_SYSCALL_RENAMEAT_E] = {f_sys_empty},
+	[PPME_SYSCALL_RENAMEAT_X] = {f_sys_renameat_x},
+	[PPME_SYSCALL_SYMLINK_E] = {f_sys_empty},
+	[PPME_SYSCALL_SYMLINK_X] = {PPM_AUTOFILL, 3, APT_REG, {{AF_ID_RETVAL}, {0}, {1} } },
+	[PPME_SYSCALL_SYMLINKAT_E] = {f_sys_empty},
+	[PPME_SYSCALL_SYMLINKAT_X] = {f_sys_symlinkat_x},
+	[PPME_SYSCALL_FORK_20_E] = {f_sys_empty},
+	[PPME_SYSCALL_FORK_20_X] = {f_proc_startupdate},
+	[PPME_SYSCALL_VFORK_20_E] = {f_sys_empty},
+	[PPME_SYSCALL_VFORK_20_X] = {f_proc_startupdate},
+	[PPME_SYSCALL_SENDFILE_E] = {f_sys_sendfile_e},
+	[PPME_SYSCALL_SENDFILE_X] = {f_sys_sendfile_x},
+	[PPME_SYSCALL_QUOTACTL_E] = {f_sys_quotactl_e},
+	[PPME_SYSCALL_QUOTACTL_X] = {f_sys_quotactl_x},
+	[PPME_SYSCALL_SETRESUID_E] = {PPM_AUTOFILL, 3, APT_REG, {{0}, {1}, {2} } },
+	[PPME_SYSCALL_SETRESUID_X] = {PPM_AUTOFILL, 1, APT_REG, {{AF_ID_RETVAL} } },
+	[PPME_SYSCALL_SETRESGID_E] = {PPM_AUTOFILL, 3, APT_REG, {{0}, {1}, {2} } },
+	[PPME_SYSCALL_SETRESGID_X] = {PPM_AUTOFILL, 1, APT_REG, {{AF_ID_RETVAL} } },
+	[PPME_SYSDIGEVENT_E] = {f_sys_sysdigevent_e},
+	[PPME_SYSCALL_SETUID_E] = {PPM_AUTOFILL, 1, APT_REG, {{0} } },
+	[PPME_SYSCALL_SETUID_X] = {PPM_AUTOFILL, 1, APT_REG, {{AF_ID_RETVAL} } },
+	[PPME_SYSCALL_SETGID_E] = {PPM_AUTOFILL, 1, APT_REG, {{0} } },
+	[PPME_SYSCALL_SETGID_X] = {PPM_AUTOFILL, 1, APT_REG, {{AF_ID_RETVAL} } },
+	[PPME_SYSCALL_GETUID_E] = {f_sys_empty},
+	[PPME_SYSCALL_GETUID_X] = {PPM_AUTOFILL, 1, APT_REG, {{AF_ID_RETVAL} } },
+	[PPME_SYSCALL_GETEUID_E] = {f_sys_empty},
+	[PPME_SYSCALL_GETEUID_X] = {PPM_AUTOFILL, 1, APT_REG, {{AF_ID_RETVAL} } },
+	[PPME_SYSCALL_GETGID_E] = {f_sys_empty},
+	[PPME_SYSCALL_GETGID_X] = {PPM_AUTOFILL, 1, APT_REG, {{AF_ID_RETVAL} } },
+	[PPME_SYSCALL_GETEGID_E] = {f_sys_empty},
+	[PPME_SYSCALL_GETEGID_X] = {PPM_AUTOFILL, 1, APT_REG, {{AF_ID_RETVAL} } },
+	[PPME_SYSCALL_GETRESUID_E] = {f_sys_empty},
+	[PPME_SYSCALL_GETRESUID_X] = {f_sys_getresuid_and_gid_x},
+	[PPME_SYSCALL_GETRESGID_E] = {f_sys_empty},
+	[PPME_SYSCALL_GETRESGID_X] = {f_sys_getresuid_and_gid_x},
+#ifdef CAPTURE_SIGNAL_DELIVERIES
+	[PPME_SIGNALDELIVER_E] = {f_sys_signaldeliver_e},
+	[PPME_SIGNALDELIVER_X] = {f_sys_empty},
+#endif
+	[PPME_SYSCALL_GETDENTS_E] = {f_sys_single},
+	[PPME_SYSCALL_GETDENTS_X] = {f_sys_single_x},
+	[PPME_SYSCALL_GETDENTS64_E] = {f_sys_single},
+	[PPME_SYSCALL_GETDENTS64_X] = {f_sys_single_x},
+	[PPME_SYSCALL_SETNS_E] = {f_sys_setns_e},
+	[PPME_SYSCALL_SETNS_X] = {PPM_AUTOFILL, 1, APT_REG, {{AF_ID_RETVAL} } },
+	[PPME_SYSCALL_FLOCK_E] = {f_sys_flock_e},
+	[PPME_SYSCALL_FLOCK_X] = {PPM_AUTOFILL, 1, APT_REG, {{AF_ID_RETVAL} } },
+	[PPME_CPU_HOTPLUG_E] = {f_cpu_hotplug_e},
+	[PPME_SYSCALL_SEMOP_E] = {f_sys_semop_e},
+	[PPME_SYSCALL_SEMOP_X] = {f_sys_semop_x},
+	[PPME_SYSCALL_SEMGET_E] = {f_sys_semget_e},
+	[PPME_SYSCALL_SEMGET_X] = {f_sys_single_x},
+	[PPME_SYSCALL_SEMCTL_E] = {f_sys_semctl_e},
+	[PPME_SYSCALL_SEMCTL_X] = {f_sys_semctl_x},
+	[PPME_SYSCALL_PPOLL_E] = {f_sys_ppoll_e},
+	[PPME_SYSCALL_PPOLL_X] = {f_sys_poll_x}, /* exit same for poll() and ppoll() */
+	[PPME_SYSCALL_MOUNT_E] = {f_sys_mount_e},
+	[PPME_SYSCALL_MOUNT_X] = {PPM_AUTOFILL, 4, APT_REG, {{AF_ID_RETVAL}, {0}, {1}, {2} } },
+	[PPME_SYSCALL_UMOUNT_E] = {PPM_AUTOFILL, 1, APT_REG, {{1} } },
+	[PPME_SYSCALL_UMOUNT_X] = {PPM_AUTOFILL, 2, APT_REG, {{AF_ID_RETVAL}, {0} } },
+	[PPME_SYSCALL_ACCESS_E] = {f_sys_access_e},
+	[PPME_SYSCALL_ACCESS_X] = {f_sys_access_x},
+	[PPME_SYSCALL_CHROOT_E] = {f_sys_empty},
+	[PPME_SYSCALL_CHROOT_X] = {PPM_AUTOFILL, 2, APT_REG, {{AF_ID_RETVAL}, {0} } },
+	[PPME_SYSCALL_SETSID_E] = {f_sys_empty},
+	[PPME_SYSCALL_SETSID_X] = {PPM_AUTOFILL, 1, APT_REG, {{AF_ID_RETVAL} } },
+	[PPME_SYSCALL_MKDIR_2_E] = {PPM_AUTOFILL, 1, APT_REG, {{AF_ID_USEDEFAULT, 0} } },
+	[PPME_SYSCALL_MKDIR_2_X] = {PPM_AUTOFILL, 2, APT_REG, {{AF_ID_RETVAL}, {0} } },
+	[PPME_SYSCALL_RMDIR_2_E] = {f_sys_empty},
+	[PPME_SYSCALL_RMDIR_2_X] = {PPM_AUTOFILL, 2, APT_REG, {{AF_ID_RETVAL}, {0} } },
+	[PPME_SYSCALL_UNSHARE_E] = {f_sys_unshare_e},
+	[PPME_SYSCALL_UNSHARE_X] = {PPM_AUTOFILL, 1, APT_REG, {{AF_ID_RETVAL} } },
+#ifdef CAPTURE_PAGE_FAULTS
+	[PPME_PAGE_FAULT_E] = {f_sys_pagefault_e},
+	[PPME_PAGE_FAULT_X] = {f_sys_empty},
+#endif
+	[PPME_SYSCALL_BPF_E] = {PPM_AUTOFILL, 1, APT_REG, {{0} } },
+	[PPME_SYSCALL_BPF_X] = {f_sys_bpf_x},
+	[PPME_SYSCALL_SECCOMP_E] = {PPM_AUTOFILL, 1, APT_REG, {{0}, {1} } },
+	[PPME_SYSCALL_SECCOMP_X] = {PPM_AUTOFILL, 1, APT_REG, {{AF_ID_RETVAL} } }
+};
+
+#define merge_64(hi, lo) ((((unsigned long long)(hi)) << 32) + ((lo) & 0xffffffffUL))
+
+static int f_sys_generic(struct event_filler_arguments *args)
+{
+	int res;
+	long table_index = args->syscall_id - SYSCALL_TABLE_ID0;
+	const enum ppm_syscall_code *cur_g_syscall_code_routing_table = args->cur_g_syscall_code_routing_table;
+
+#ifdef _HAS_SOCKETCALL
+	if (unlikely(args->syscall_id == args->socketcall_syscall)) {
+		/*
+		 * All the socket calls should be implemented
+		 */
+		ASSERT(false);
+		return PPM_FAILURE_BUG;
+	}
+#endif
+
+	/*
+	 * name
+	 */
+
+	if (likely(table_index >= 0 &&
+		   table_index <  SYSCALL_TABLE_SIZE)) {
+		enum ppm_syscall_code sc_code = cur_g_syscall_code_routing_table[table_index];
+
+		/*
+		 * ID
+		 */
+		res = val_to_ring(args, sc_code, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+		if (args->event_type == PPME_GENERIC_E) {
+			/*
+			 * nativeID
+			 */
+			res = val_to_ring(args, args->syscall_id, 0, false, 0);
+			if (unlikely(res != PPM_SUCCESS))
+				return res;
+		}
+	} else {
+		ASSERT(false);
+		res = val_to_ring(args, (unsigned long)"<out of bound>", 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	}
+
+	return add_sentinel(args);
+}
+
+static int f_sys_empty(struct event_filler_arguments *args)
+{
+	return add_sentinel(args);
+}
+
+static int f_sys_single(struct event_filler_arguments *args)
+{
+	int res;
+	unsigned long val;
+
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_single_x(struct event_filler_arguments *args)
+{
+	int res;
+	int64_t retval;
+
+	retval = (int64_t)(long)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static inline u32 open_flags_to_scap(unsigned long flags)
+{
+	u32 res = 0;
+
+	switch (flags & (O_RDONLY | O_WRONLY | O_RDWR)) {
+	case O_WRONLY:
+		res |= PPM_O_WRONLY;
+		break;
+	case O_RDWR:
+		res |= PPM_O_RDWR;
+		break;
+	default:
+		res |= PPM_O_RDONLY;
+		break;
+	}
+
+	if (flags & O_CREAT)
+		res |= PPM_O_CREAT;
+
+	if (flags & O_APPEND)
+		res |= PPM_O_APPEND;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
+	if (flags & O_DSYNC)
+		res |= PPM_O_DSYNC;
+#endif
+
+	if (flags & O_EXCL)
+		res |= PPM_O_EXCL;
+
+	if (flags & O_NONBLOCK)
+		res |= PPM_O_NONBLOCK;
+
+	if (flags & O_SYNC)
+		res |= PPM_O_SYNC;
+
+	if (flags & O_TRUNC)
+		res |= PPM_O_TRUNC;
+
+	if (flags & O_DIRECT)
+		res |= PPM_O_DIRECT;
+
+	if (flags & O_DIRECTORY)
+		res |= PPM_O_DIRECTORY;
+
+	if (flags & O_LARGEFILE)
+		res |= PPM_O_LARGEFILE;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23)
+	if (flags & O_CLOEXEC)
+		res |= PPM_O_CLOEXEC;
+#endif
+	return res;
+}
+
+
+static inline u32 open_modes_to_scap(unsigned long modes)
+{
+	u32 res = 0;
+
+	if (modes & S_IRUSR)
+		res |= PPM_S_IRUSR;
+
+	if (modes & S_IWUSR)
+		res |= PPM_S_IWUSR;
+
+	if (modes & S_IXUSR)
+		res |= PPM_S_IXUSR;
+
+	/*
+	* PPM_S_IRWXU == S_IRUSR | S_IWUSR | S_IXUSR 
+	*/
+
+	if (modes & S_IRGRP)
+		res |= PPM_S_IRGRP;
+
+	if (modes & S_IWGRP)
+		res |= PPM_S_IWGRP;
+
+	if (modes & S_IXGRP)
+		res |= PPM_S_IXGRP;
+
+	/*
+	* PPM_S_IRWXG == S_IRGRP | S_IWGRP | S_IXGRP 
+	*/
+
+	if (modes & S_IROTH)
+		res |= PPM_S_IROTH;
+
+	if (modes & S_IWOTH)
+		res |= PPM_S_IWOTH;
+
+	if (modes & S_IXOTH)
+		res |= PPM_S_IXOTH;
+	
+	/*
+	* PPM_S_IRWXO == S_IROTH | S_IWOTH | S_IXOTH
+	*/
+	
+	if (modes & S_ISUID)
+		res |= PPM_S_ISUID;
+
+	if (modes & S_ISGID)
+		res |= PPM_S_ISGID;
+
+	if (modes & S_ISVTX)
+		res |= PPM_S_ISVTX;
+
+	return res;
+}
+
+static inline int open_mode_to_ring(struct event_filler_arguments *args,
+				    unsigned long flags,
+				    unsigned int i)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+	unsigned long flags_mask = O_CREAT | O_TMPFILE;
+#else
+	unsigned long flags_mask = O_CREAT;
+#endif
+	int res;
+
+	if (flags & flags_mask) {
+		unsigned long val;
+
+		/*
+		 * Mode
+		 * Note that we convert them into the ppm portable
+		 * representation before pushing them to the ring
+		 */
+		syscall_get_arguments(current, args->regs, i, 1, &val);
+		res = val_to_ring(args, open_modes_to_scap(val), 0, false, 0);
+	} else {
+		res = val_to_ring(args, 0, 0, false, 0);
+	}
+	return res;
+}
+
+static int f_sys_open_x(struct event_filler_arguments *args)
+{
+	unsigned long val, flags;
+	int res;
+	int64_t retval;
+
+	/*
+	 * fd
+	 */
+	retval = (int64_t)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * name
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * Flags
+	 * Note that we convert them into the ppm portable representation before pushing them to the ring
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &flags);
+	res = val_to_ring(args, open_flags_to_scap(flags), 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 *  mode
+	 */
+	res = open_mode_to_ring(args, flags, 2);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_read_x(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	int64_t retval;
+	unsigned long bufsize;
+
+	/*
+	 * Retrieve the FD. It will be used for dynamic snaplen calculation.
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	args->fd = (int)val;
+
+	/*
+	 * res
+	 */
+	retval = (int64_t)(long)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * data
+	 */
+	if (retval < 0) {
+		/*
+		 * The operation failed, return an empty buffer
+		 */
+		val = 0;
+		bufsize = 0;
+	} else {
+		syscall_get_arguments(current, args->regs, 1, 1, &val);
+
+		/*
+		 * The return value can be lower than the value provided by the user,
+		 * and we take that into account.
+		 */
+		bufsize = retval;
+	}
+
+	/*
+	 * Copy the buffer
+	 */
+	args->enforce_snaplen = true;
+	res = val_to_ring(args, val, bufsize, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_write_x(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	int64_t retval;
+	unsigned long bufsize;
+
+	/*
+	 * Retrieve the FD. It will be used for dynamic snaplen calculation.
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	args->fd = (int)val;
+
+	/*
+	 * res
+	 */
+	retval = (int64_t)(long)syscall_get_return_value(current, args->regs);
+
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * data
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &val);
+	bufsize = val;
+
+	/*
+	 * Copy the buffer
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+	args->enforce_snaplen = true;
+	res = val_to_ring(args, val, bufsize, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static inline u32 clone_flags_to_scap(unsigned long flags)
+{
+	u32 res = 0;
+
+	if (flags & CLONE_FILES)
+		res |= PPM_CL_CLONE_FILES;
+
+	if (flags & CLONE_FS)
+		res |= PPM_CL_CLONE_FS;
+
+#ifdef CLONE_IO
+	if (flags & CLONE_IO)
+		res |= PPM_CL_CLONE_IO;
+#endif
+
+#ifdef CLONE_NEWIPC
+	if (flags & CLONE_NEWIPC)
+		res |= PPM_CL_CLONE_NEWIPC;
+#endif
+
+#ifdef CLONE_NEWNET
+	if (flags & CLONE_NEWNET)
+		res |= PPM_CL_CLONE_NEWNET;
+#endif
+
+#ifdef CLONE_NEWNS
+	if (flags & CLONE_NEWNS)
+		res |= PPM_CL_CLONE_NEWNS;
+#endif
+
+#ifdef CLONE_NEWPID
+	if (flags & CLONE_NEWPID)
+		res |= PPM_CL_CLONE_NEWPID;
+#endif
+
+#ifdef CLONE_NEWUTS
+	if (flags & CLONE_NEWUTS)
+		res |= PPM_CL_CLONE_NEWUTS;
+#endif
+
+	if (flags & CLONE_PARENT_SETTID)
+		res |= PPM_CL_CLONE_PARENT_SETTID;
+
+	if (flags & CLONE_PARENT)
+		res |= PPM_CL_CLONE_PARENT;
+
+	if (flags & CLONE_PTRACE)
+		res |= PPM_CL_CLONE_PTRACE;
+
+	if (flags & CLONE_SIGHAND)
+		res |= PPM_CL_CLONE_SIGHAND;
+
+	if (flags & CLONE_SYSVSEM)
+		res |= PPM_CL_CLONE_SYSVSEM;
+
+	if (flags & CLONE_THREAD)
+		res |= PPM_CL_CLONE_THREAD;
+
+	if (flags & CLONE_UNTRACED)
+		res |= PPM_CL_CLONE_UNTRACED;
+
+	if (flags & CLONE_VM)
+		res |= PPM_CL_CLONE_VM;
+
+#ifdef CLONE_NEWUSER
+	if (flags & CLONE_NEWUSER)
+		res |= PPM_CL_CLONE_NEWUSER;
+#endif
+
+	if (flags & CLONE_CHILD_CLEARTID)
+		res |= PPM_CL_CLONE_CHILD_CLEARTID;
+
+	if (flags & CLONE_CHILD_SETTID)
+		res |= PPM_CL_CLONE_CHILD_SETTID;
+
+	if (flags & CLONE_SETTLS)
+		res |= PPM_CL_CLONE_SETTLS;
+
+#ifdef CLONE_STOPPED
+	if (flags & CLONE_STOPPED)
+		res |= PPM_CL_CLONE_STOPPED;
+#endif
+
+	if (flags & CLONE_VFORK)
+		res |= PPM_CL_CLONE_VFORK;
+
+#ifdef CLONE_NEWCGROUP
+	if (flags & CLONE_NEWCGROUP)
+		res |= 	PPM_CL_CLONE_NEWCGROUP;
+#endif
+
+	return res;
+}
+
+/*
+ * get_mm_counter was not inline and exported between 3.0 and 3.4
+ * https://github.com/torvalds/linux/commit/69c978232aaa99476f9bd002c2a29a84fa3779b5
+ * Hence the crap in these two functions
+ */
+unsigned long ppm_get_mm_counter(struct mm_struct *mm, int member)
+{
+	long val = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+	val = get_mm_counter(mm, member);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+	val = atomic_long_read(&mm->rss_stat.count[member]);
+
+	if (val < 0)
+		val = 0;
+#endif
+
+	return val;
+}
+
+static unsigned long ppm_get_mm_swap(struct mm_struct *mm)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+	return ppm_get_mm_counter(mm, MM_SWAPENTS);
+#endif
+	return 0;
+}
+
+static unsigned long ppm_get_mm_rss(struct mm_struct *mm)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+	return get_mm_rss(mm);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+	return ppm_get_mm_counter(mm, MM_FILEPAGES) +
+		ppm_get_mm_counter(mm, MM_ANONPAGES);
+#else
+	return get_mm_rss(mm);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_CGROUPS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 34)
+static int ppm_cgroup_path(const struct cgroup *cgrp, char *buf, int buflen)
+{
+	char *start;
+	struct dentry *dentry = rcu_dereference(cgrp->dentry);
+
+	if (!dentry) {
+		/*
+		 * Inactive subsystems have no dentry for their root
+		 * cgroup
+		 */
+		strcpy(buf, "/");
+		return 0;
+	}
+
+	start = buf + buflen;
+
+	*--start = '\0';
+	for (;;) {
+		int len = dentry->d_name.len;
+
+		start -= len;
+		if (start < buf)
+			return -ENAMETOOLONG;
+		memcpy(start, cgrp->dentry->d_name.name, len);
+		cgrp = cgrp->parent;
+		if (!cgrp)
+			break;
+		dentry = rcu_dereference(cgrp->dentry);
+		if (!cgrp->parent)
+			continue;
+		if (--start < buf)
+			return -ENAMETOOLONG;
+		*start = '/';
+	}
+	memmove(buf, start, buf + buflen - start);
+	return 0;
+}
+#endif
+
+static int append_cgroup(const char *subsys_name, int subsys_id, char *buf, int *available)
+{
+	int pathlen;
+	int subsys_len;
+	char *path;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0) || LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
+	int res;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
+	struct cgroup_subsys_state *css = task_css(current, subsys_id);
+#else
+	struct cgroup_subsys_state *css = task_subsys_state(current, subsys_id);
+#endif
+
+	if (!css) {
+		ASSERT(false);
+		return 1;
+	}
+
+	if (!css->cgroup) {
+		ASSERT(false);
+		return 1;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
+	// According to https://github.com/torvalds/linux/commit/4c737b41de7f4eef2a593803bad1b918dd718b10
+	// cgroup_path now returns an int again
+	res = cgroup_path(css->cgroup, buf, *available);
+	if (res < 0) {
+		ASSERT(false);
+		path = "NA";
+	} else {
+		path = buf;
+	}
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+	path = cgroup_path(css->cgroup, buf, *available);
+	if (!path) {
+		ASSERT(false);
+		path = "NA";
+	}
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+	res = cgroup_path(css->cgroup, buf, *available);
+	if (res < 0) {
+		ASSERT(false);
+		path = "NA";
+	} else {
+		path = buf;
+	}
+#else
+	res = ppm_cgroup_path(css->cgroup, buf, *available);
+	if (res < 0) {
+		ASSERT(false);
+		path = "NA";
+	} else {
+		path = buf;
+	}
+#endif
+
+	pathlen = strlen(path);
+	subsys_len = strlen(subsys_name);
+	if (subsys_len + 1 + pathlen + 1 > *available)
+		return 1;
+
+	memmove(buf + subsys_len + 1, path, pathlen);
+	memcpy(buf, subsys_name, subsys_len);
+	buf += subsys_len;
+	*buf++ = '=';
+	buf += pathlen;
+	*buf++ = 0;
+	*available -= (subsys_len + 1 + pathlen + 1);
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+#define SUBSYS(_x)																						\
+if (append_cgroup(#_x, _x ## _cgrp_id, args->str_storage + STR_STORAGE_SIZE - available, &available))	\
+	goto cgroups_error;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+#define IS_SUBSYS_ENABLED(option) IS_BUILTIN(option)
+#define SUBSYS(_x)																						\
+if (append_cgroup(#_x, _x ## _subsys_id, args->str_storage + STR_STORAGE_SIZE - available, &available)) \
+	goto cgroups_error;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)
+#define IS_SUBSYS_ENABLED(option) IS_ENABLED(option)
+#define SUBSYS(_x)																						\
+if (append_cgroup(#_x, _x ## _subsys_id, args->str_storage + STR_STORAGE_SIZE - available, &available)) \
+	goto cgroups_error;
+#else
+#define SUBSYS(_x)																						\
+if (append_cgroup(#_x, _x ## _subsys_id, args->str_storage + STR_STORAGE_SIZE - available, &available)) \
+	goto cgroups_error;
+#endif
+
+#endif
+
+/* Takes in a NULL-terminated array of pointers to strings in userspace, and
+ * concatenates them to a single \0-separated string. Return the length of this
+ * string, or <0 on error */
+static int accumulate_argv_or_env(const char __user * __user *argv,
+				  char *str_storage,
+				  int available)
+{
+	int len = 0;
+	int n_bytes_copied;
+
+	if (argv == NULL)
+		return len;
+
+	for (;;) {
+		const char __user *p;
+
+		if (unlikely(ppm_get_user(p, argv)))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+
+		if (p == NULL)
+			break;
+
+		/* need at least enough space for a \0 */
+		if (available < 1)
+			return PPM_FAILURE_BUFFER_FULL;
+
+		n_bytes_copied = ppm_strncpy_from_user(&str_storage[len], p,
+						       available);
+
+		/* ppm_strncpy_from_user includes the trailing \0 in its return
+		 * count. I want to pretend it was strncpy_from_user() so I
+		 * subtract off the 1 */
+		n_bytes_copied--;
+
+		if (n_bytes_copied < 0)
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+
+		if (n_bytes_copied >= available)
+			return PPM_FAILURE_BUFFER_FULL;
+
+		/* update buffer. I want to keep the trailing \0, so I +1 */
+		available   -= n_bytes_copied+1;
+		len         += n_bytes_copied+1;
+
+		argv++;
+	}
+
+	return len;
+}
+
+#ifdef CONFIG_COMPAT
+/* compat version that deals correctly with 32bits pointers of argv */
+static int compat_accumulate_argv_or_env(compat_uptr_t argv,
+				  char *str_storage,
+				  int available)
+{
+	int len = 0;
+	int n_bytes_copied;
+
+	if (compat_ptr(argv) == NULL)
+		return len;
+
+	for (;;) {
+		compat_uptr_t compat_p;
+		const char __user *p;
+
+		if (unlikely(ppm_get_user(compat_p, compat_ptr(argv))))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+		p = compat_ptr(compat_p);
+
+		if (p == NULL)
+			break;
+
+		/* need at least enough space for a \0 */
+		if (available < 1)
+			return PPM_FAILURE_BUFFER_FULL;
+
+		n_bytes_copied = ppm_strncpy_from_user(&str_storage[len], p,
+						       available);
+
+		/* ppm_strncpy_from_user includes the trailing \0 in its return
+		 * count. I want to pretend it was strncpy_from_user() so I
+		 * subtract off the 1 */
+		n_bytes_copied--;
+
+		if (n_bytes_copied < 0) {
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+		}
+		if (n_bytes_copied >= available)
+			return PPM_FAILURE_BUFFER_FULL;
+
+		/* update buffer. I want to keep the trailing \0, so I +1 */
+		available   -= n_bytes_copied+1;
+		len         += n_bytes_copied+1;
+
+		argv += sizeof(compat_uptr_t);
+	}
+
+	return len;
+}
+
+#endif
+
+// probe_kernel_read() only added in kernel 2.6.26
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+long probe_kernel_read(void *dst, const void *src, size_t size)
+{
+	long ret;
+	mm_segment_t old_fs = get_fs();
+
+	set_fs(KERNEL_DS);
+	pagefault_disable();
+	ret = __copy_from_user_inatomic(dst, (__force const void __user *)src, size);
+	pagefault_enable();
+	set_fs(old_fs);
+
+	return ret ? -EFAULT : 0;
+}
+#endif
+
+static int ppm_get_tty(void)
+{
+	/* Locking of the signal structures seems too complicated across
+	 * multiple kernel versions to get it right, so simply do protected
+	 * memory accesses, and in the worst case we get some garbage,
+	 * which is not the end of the world. In the vast majority of accesses,
+	 * we'll be just fine.
+	 */
+	struct signal_struct *sig;
+	struct tty_struct *tty;
+	struct tty_driver *driver;
+	int major;
+	int minor_start;
+	int index;
+	int tty_nr = 0;
+
+	sig = current->signal;
+	if (!sig)
+		return 0;
+
+	if (unlikely(probe_kernel_read(&tty, &sig->tty, sizeof(tty))))
+		return 0;
+
+	if (!tty)
+		return 0;
+
+	if (unlikely(probe_kernel_read(&index, &tty->index, sizeof(index))))
+		return 0;
+
+	if (unlikely(probe_kernel_read(&driver, &tty->driver, sizeof(driver))))
+		return 0;
+
+	if (!driver)
+		return 0;
+
+	if (unlikely(probe_kernel_read(&major, &driver->major, sizeof(major))))
+		return 0;
+
+	if (unlikely(probe_kernel_read(&minor_start, &driver->minor_start, sizeof(minor_start))))
+		return 0;
+
+	tty_nr = new_encode_dev(MKDEV(major, minor_start) + index);
+
+	return tty_nr;
+}
+
+static int f_proc_startupdate(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res = 0;
+	unsigned int exe_len = 0;  /* the length of the executable string */
+	int args_len = 0; /*the combined length of the arguments string + executable string */
+	struct mm_struct *mm = current->mm;
+	int64_t retval;
+	int ptid;
+	char *spwd = "";
+	long total_vm = 0;
+	long total_rss = 0;
+	long swap = 0;
+	int available = STR_STORAGE_SIZE;
+
+	/*
+	 * Make sure the operation was successful
+	 */
+	retval = (int64_t)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	if (unlikely(retval < 0 &&
+		     args->event_type != PPME_SYSCALL_EXECVE_18_X)) {
+
+		/* The call failed, but this syscall has no exe, args
+		 * anyway, so I report empty ones */
+		*args->str_storage = 0;
+
+		/*
+		 * exe
+		 */
+		res = val_to_ring(args, (uint64_t)(long)args->str_storage, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+		/*
+		 * Args
+		 */
+		res = val_to_ring(args, (int64_t)(long)args->str_storage, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	} else {
+
+		if (likely(retval >= 0)) {
+			/*
+			 * The call succeeded. Get exe, args from the current
+			 * process; put one \0-separated exe-args string into
+			 * str_storage
+			 */
+
+			if (unlikely(!mm)) {
+				args->str_storage[0] = 0;
+				pr_info("f_proc_startupdate drop, mm=NULL\n");
+				return PPM_FAILURE_BUG;
+			}
+
+			if (unlikely(!mm->arg_end)) {
+				args->str_storage[0] = 0;
+				pr_info("f_proc_startupdate drop, mm->arg_end=NULL\n");
+				return PPM_FAILURE_BUG;
+			}
+
+			args_len = mm->arg_end - mm->arg_start;
+
+			if (args_len) {
+				if (args_len > PAGE_SIZE)
+					args_len = PAGE_SIZE;
+
+				if (unlikely(ppm_copy_from_user(args->str_storage, (const void __user *)mm->arg_start, args_len)))
+					args_len = 0;
+				else
+					args->str_storage[args_len - 1] = 0;
+			}
+		} else {
+
+			/*
+			 * The execve call failed. I get exe, args from the
+			 * input args; put one \0-separated exe-args string into
+			 * str_storage
+			 */
+			args->str_storage[0] = 0;
+
+			syscall_get_arguments(current, args->regs, 1, 1, &val);
+#ifdef CONFIG_COMPAT
+			if (unlikely(args->compat))
+				args_len = compat_accumulate_argv_or_env((compat_uptr_t)val,
+							   args->str_storage, available);
+			else
+#endif
+				args_len = accumulate_argv_or_env((const char __user * __user *)val,
+							   args->str_storage, available);
+
+			if (unlikely(args_len < 0))
+				args_len = 0;
+		}
+
+		if (args_len == 0)
+			*args->str_storage = 0;
+
+		exe_len = strnlen(args->str_storage, args_len);
+		if (exe_len < args_len)
+			++exe_len;
+
+		/*
+		 * exe
+		 */
+		res = val_to_ring(args, (uint64_t)(long)args->str_storage, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+		/*
+		 * Args
+		 */
+		res = val_to_ring(args, (int64_t)(long)args->str_storage + exe_len, args_len - exe_len, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	}
+
+
+	/*
+	 * tid
+	 */
+	res = val_to_ring(args, (int64_t)current->pid, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * pid
+	 */
+	res = val_to_ring(args, (int64_t)current->tgid, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * ptid
+	 */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+	if (current->real_parent)
+		ptid = current->real_parent->pid;
+#else
+	if (current->parent)
+		ptid = current->parent->pid;
+#endif
+	else
+		ptid = 0;
+
+	res = val_to_ring(args, (int64_t)ptid, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * cwd, pushed empty to avoid breaking compatibility
+	 * with the older event format
+	 */
+	res = val_to_ring(args, (uint64_t)(long)spwd, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * fdlimit
+	 */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+	res = val_to_ring(args, (int64_t)rlimit(RLIMIT_NOFILE), 0, false, 0);
+#else
+	res = val_to_ring(args, (int64_t)0, 0, false, 0);
+#endif
+	if (res != PPM_SUCCESS)
+		return res;
+
+	/*
+	 * pgft_maj
+	 */
+	res = val_to_ring(args, current->maj_flt, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * pgft_min
+	 */
+	res = val_to_ring(args, current->min_flt, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	if (mm) {
+		total_vm = mm->total_vm << (PAGE_SHIFT-10);
+		total_rss = ppm_get_mm_rss(mm) << (PAGE_SHIFT-10);
+		swap = ppm_get_mm_swap(mm) << (PAGE_SHIFT-10);
+	}
+
+	/*
+	 * vm_size
+	 */
+	res = val_to_ring(args, total_vm, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * vm_rss
+	 */
+	res = val_to_ring(args, total_rss, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * vm_swap
+	 */
+	res = val_to_ring(args, swap, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * comm
+	 */
+	res = val_to_ring(args, (uint64_t)current->comm, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * cgroups
+	 */
+	args->str_storage[0] = 0;
+#ifdef CONFIG_CGROUPS
+	rcu_read_lock();
+#include <linux/cgroup_subsys.h>
+cgroups_error:
+	rcu_read_unlock();
+#endif
+
+	res = val_to_ring(args, (int64_t)(long)args->str_storage, STR_STORAGE_SIZE - available, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	if (args->event_type == PPME_SYSCALL_CLONE_20_X ||
+		args->event_type == PPME_SYSCALL_FORK_20_X ||
+		args->event_type == PPME_SYSCALL_VFORK_20_X) {
+		/*
+		 * clone-only parameters
+		 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)
+		uint64_t euid = from_kuid_munged(current_user_ns(), current_euid());
+		uint64_t egid = from_kgid_munged(current_user_ns(), current_egid());
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+		uint64_t euid = current_euid();
+		uint64_t egid = current_egid();
+#else
+		uint64_t euid = current->euid;
+		uint64_t egid = current->egid;
+#endif
+
+		/*
+		 * flags
+		 */
+		if (args->event_type == PPME_SYSCALL_CLONE_20_X) {
+#ifdef CONFIG_S390
+			syscall_get_arguments(current, args->regs, 1, 1, &val);
+#else
+			syscall_get_arguments(current, args->regs, 0, 1, &val);
+#endif
+		} else
+			val = 0;
+
+		res = val_to_ring(args, (uint64_t)clone_flags_to_scap(val), 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+		/*
+		 * uid
+		 */
+		res = val_to_ring(args, euid, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+		/*
+		 * gid
+		 */
+		res = val_to_ring(args, egid, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+		/*
+		 * vtid
+		 */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+		res = val_to_ring(args, task_pid_vnr(current), 0, false, 0);
+#else
+		/* Not relevant in old kernels */
+		res = val_to_ring(args, 0, 0, false, 0);
+#endif
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+		/*
+		 * vpid
+		 */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+		res = val_to_ring(args, task_tgid_vnr(current), 0, false, 0);
+#else
+		/* Not relevant in old kernels */
+		res = val_to_ring(args, 0, 0, false, 0);
+#endif
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+	} else if (args->event_type == PPME_SYSCALL_EXECVE_18_X) {
+		/*
+		 * execve-only parameters
+		 */
+		long env_len = 0;
+		int tty_nr = 0;
+
+		if (likely(retval >= 0)) {
+			/*
+			 * Already checked for mm validity
+			 */
+			env_len = mm->env_end - mm->env_start;
+
+			if (env_len) {
+				if (env_len > PAGE_SIZE)
+					env_len = PAGE_SIZE;
+
+				if (unlikely(ppm_copy_from_user(args->str_storage, (const void __user *)mm->env_start, env_len)))
+					env_len = 0;
+				else
+					args->str_storage[env_len - 1] = 0;
+			}
+		} else {
+			/*
+			 * The call failed, so get the env from the arguments
+			 */
+			syscall_get_arguments(current, args->regs, 2, 1, &val);
+#ifdef CONFIG_COMPAT
+			if (unlikely(args->compat))
+				env_len = compat_accumulate_argv_or_env((compat_uptr_t)val,
+							  args->str_storage, available);
+			else
+#endif
+				env_len = accumulate_argv_or_env((const char __user * __user *)val,
+							  args->str_storage, available);
+
+			if (unlikely(env_len < 0))
+				env_len = 0;
+		}
+
+		if (env_len == 0)
+			*args->str_storage = 0;
+
+		/*
+		 * environ
+		 */
+		res = val_to_ring(args, (int64_t)(long)args->str_storage, env_len, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+		/*
+		 * tty
+		 */
+		tty_nr = ppm_get_tty();
+		res = val_to_ring(args, tty_nr, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	}
+
+	return add_sentinel(args);
+}
+
+static int f_sys_execve_e(struct event_filler_arguments *args)
+{
+	int res;
+	unsigned long val;
+
+	/*
+	 * filename
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (res == PPM_FAILURE_INVALID_USER_MEMORY)
+		res = val_to_ring(args, (unsigned long)"<NA>", 0, false, 0);
+
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_socket_bind_x(struct event_filler_arguments *args)
+{
+	int res;
+	int64_t retval;
+	int err = 0;
+	u16 size = 0;
+	struct sockaddr __user *usrsockaddr;
+	unsigned long val;
+	struct sockaddr_storage address;
+	char *targetbuf = args->str_storage;
+
+	/*
+	 * res
+	 */
+	retval = (int64_t)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+
+	/*
+	 * addr
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 1, 1, &val);
+	else
+		val = args->socketcall_args[1];
+
+	usrsockaddr = (struct sockaddr __user *)val;
+
+	/*
+	 * Get the address len
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 2, 1, &val);
+	else
+		val = args->socketcall_args[2];
+
+	if (usrsockaddr != NULL && val != 0) {
+		/*
+		 * Copy the address
+		 */
+		err = addr_to_kernel(usrsockaddr, val, (struct sockaddr *)&address);
+		if (likely(err >= 0)) {
+			/*
+			 * Convert the fd into socket endpoint information
+			 */
+			size = pack_addr((struct sockaddr *)&address,
+				val,
+				targetbuf,
+				STR_STORAGE_SIZE);
+		}
+	}
+
+	/*
+	 * Copy the endpoint info into the ring
+	 */
+	res = val_to_ring(args,
+			    (uint64_t)(unsigned long)targetbuf,
+			    size,
+			    false,
+			    0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_connect_x(struct event_filler_arguments *args)
+{
+	int res;
+	int64_t retval;
+	int err = 0;
+	int fd;
+	struct sockaddr __user *usrsockaddr;
+	u16 size = 0;
+	char *targetbuf = args->str_storage;
+	struct sockaddr_storage address;
+	unsigned long val;
+
+	/*
+	 * Push the result
+	 */
+	retval = (int64_t)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+
+	/*
+	 * Retrieve the fd and push it to the ring.
+	 * Note that, even if we are in the exit callback, the arguments are still
+	 * in the stack, and therefore we can consume them.
+	 */
+	if (!args->is_socketcall) {
+		syscall_get_arguments(current, args->regs, 0, 1, &val);
+		fd = (int)val;
+	} else
+		fd = (int)args->socketcall_args[0];
+
+	if (fd >= 0) {
+		/*
+		 * Get the address
+		 */
+		if (!args->is_socketcall)
+			syscall_get_arguments(current, args->regs, 1, 1, &val);
+		else
+			val = args->socketcall_args[1];
+
+		usrsockaddr = (struct sockaddr __user *)val;
+
+		/*
+		 * Get the address len
+		 */
+		if (!args->is_socketcall)
+			syscall_get_arguments(current, args->regs, 2, 1, &val);
+		else
+			val = args->socketcall_args[2];
+
+		if (usrsockaddr != NULL && val != 0) {
+			/*
+			 * Copy the address
+			 */
+			err = addr_to_kernel(usrsockaddr, val, (struct sockaddr *)&address);
+			if (likely(err >= 0)) {
+				/*
+				 * Convert the fd into socket endpoint information
+				 */
+				size = fd_to_socktuple(fd,
+					(struct sockaddr *)&address,
+					val,
+					true,
+					false,
+					targetbuf,
+					STR_STORAGE_SIZE);
+			}
+		}
+	}
+
+	/*
+	 * Copy the endpoint info into the ring
+	 */
+	res = val_to_ring(args,
+			    (uint64_t)(unsigned long)targetbuf,
+			    size,
+			    false,
+			    0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_socketpair_x(struct event_filler_arguments *args)
+{
+	int res;
+	int64_t retval;
+	unsigned long val;
+	int fds[2];
+	int err;
+	struct socket *sock;
+	struct unix_sock *us;
+	struct sock *speer;
+
+	/*
+	 * retval
+	 */
+	retval = (int64_t)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * If the call was successful, copy the FDs
+	 */
+	if (likely(retval >= 0)) {
+		/*
+		 * fds
+		 */
+		if (!args->is_socketcall)
+			syscall_get_arguments(current, args->regs, 3, 1, &val);
+		else
+			val = args->socketcall_args[3];
+#ifdef CONFIG_COMPAT
+		if (!args->compat) {
+#endif
+			if (unlikely(ppm_copy_from_user(fds, (const void __user *)val, sizeof(fds))))
+				return PPM_FAILURE_INVALID_USER_MEMORY;
+#ifdef CONFIG_COMPAT
+		} else {
+			if (unlikely(ppm_copy_from_user(fds, (const void __user *)compat_ptr(val), sizeof(fds))))
+				return PPM_FAILURE_INVALID_USER_MEMORY;
+		}
+#endif
+
+		res = val_to_ring(args, fds[0], 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+		res = val_to_ring(args, fds[1], 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+		/* get socket source and peer address */
+		sock = sockfd_lookup(fds[0], &err);
+		if (likely(sock != NULL)) {
+			us = unix_sk(sock->sk);
+			speer = us->peer;
+			res = val_to_ring(args, (unsigned long)us, 0, false, 0);
+			if (unlikely(res != PPM_SUCCESS)) {
+				sockfd_put(sock);
+				return res;
+			}
+
+			res = val_to_ring(args, (unsigned long)speer, 0, false, 0);
+			if (unlikely(res != PPM_SUCCESS)) {
+				sockfd_put(sock);
+				return res;
+			}
+
+			sockfd_put(sock);
+		} else {
+			return err;
+		}
+	} else {
+		res = val_to_ring(args, 0, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+		res = val_to_ring(args, 0, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	}
+
+	return add_sentinel(args);
+}
+
+static int f_sys_accept4_e(struct event_filler_arguments *args)
+{
+	int res;
+
+	/*
+	 * push the flags into the ring.
+	 * XXX we don't support flags yet and so we just return zero
+	 */
+	/* res = val_to_ring(args, args->socketcall_args[3]); */
+	res = val_to_ring(args, 0, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_accept_x(struct event_filler_arguments *args)
+{
+	int res;
+	int fd;
+	char *targetbuf = args->str_storage;
+	u16 size = 0;
+	unsigned long queuepct = 0;
+	unsigned long ack_backlog = 0;
+	unsigned long max_ack_backlog = 0;
+	unsigned long srvskfd;
+	int err = 0;
+	struct socket *sock;
+
+	/*
+	 * Push the fd
+	 */
+	fd = syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, (int64_t)fd, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * Convert the fd into socket endpoint information
+	 */
+	size = fd_to_socktuple(fd,
+		NULL,
+		0,
+		false,
+		true,
+		targetbuf,
+		STR_STORAGE_SIZE);
+
+	/*
+	 * Copy the endpoint info into the ring
+	 */
+	res = val_to_ring(args,
+			    (uint64_t)(unsigned long)targetbuf,
+			    size,
+			    false,
+			    0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * queuepct
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 0, 1, &srvskfd);
+	else
+		srvskfd = args->socketcall_args[0];
+
+	sock = sockfd_lookup(srvskfd, &err);
+
+	if (sock && sock->sk) {
+		ack_backlog = sock->sk->sk_ack_backlog;
+		max_ack_backlog = sock->sk->sk_max_ack_backlog;
+	}
+
+	if (sock)
+		sockfd_put(sock);
+
+	if (max_ack_backlog)
+		queuepct = (unsigned long)ack_backlog * 100 / max_ack_backlog;
+
+	res = val_to_ring(args, queuepct, 0, false, 0);
+	if (res != PPM_SUCCESS)
+		return res;
+
+	res = val_to_ring(args, ack_backlog, 0, false, 0);
+	if (res != PPM_SUCCESS)
+		return res;
+
+	res = val_to_ring(args, max_ack_backlog, 0, false, 0);
+	if (res != PPM_SUCCESS)
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_send_e_common(struct event_filler_arguments *args, int *fd)
+{
+	int res;
+	unsigned long size;
+	unsigned long val;
+
+	/*
+	 * fd
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 0, 1, &val);
+	else
+		val = args->socketcall_args[0];
+
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	*fd = val;
+
+	/*
+	 * size
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 2, 1, &size);
+	else
+		size = args->socketcall_args[2];
+
+	res = val_to_ring(args, size, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return PPM_SUCCESS;
+}
+
+static int f_sys_send_e(struct event_filler_arguments *args)
+{
+	int res;
+	int fd;
+
+	res = f_sys_send_e_common(args, &fd);
+
+	if (likely(res == PPM_SUCCESS))
+		return add_sentinel(args);
+	return res;
+}
+
+static int f_sys_sendto_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	u16 size = 0;
+	char *targetbuf = args->str_storage;
+	int fd;
+	struct sockaddr __user *usrsockaddr;
+	struct sockaddr_storage address;
+	int err = 0;
+
+	*targetbuf = 250;
+
+	/*
+	 * Push the common params to the ring
+	 */
+	res = f_sys_send_e_common(args, &fd);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * Get the address
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 4, 1, &val);
+	else
+		val = args->socketcall_args[4];
+
+	usrsockaddr = (struct sockaddr __user *)val;
+
+	/*
+	 * Get the address len
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 5, 1, &val);
+	else
+		val = args->socketcall_args[5];
+
+	if (usrsockaddr != NULL && val != 0) {
+		/*
+		 * Copy the address
+		 */
+		err = addr_to_kernel(usrsockaddr, val, (struct sockaddr *)&address);
+		if (likely(err >= 0)) {
+			/*
+			 * Convert the fd into socket endpoint information
+			 */
+			size = fd_to_socktuple(fd,
+				(struct sockaddr *)&address,
+				val,
+				true,
+				false,
+				targetbuf,
+				STR_STORAGE_SIZE);
+		}
+	}
+
+	/*
+	 * Copy the endpoint info into the ring
+	 */
+	res = val_to_ring(args,
+			    (uint64_t)(unsigned long)targetbuf,
+			    size,
+			    false,
+			    0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_send_x(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	int64_t retval;
+	unsigned long bufsize;
+
+	/*
+	 * Retrieve the FD. It will be used for dynamic snaplen calculation.
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 0, 1, &val);
+	else
+		val = args->socketcall_args[0];
+
+	args->fd = (int)val;
+
+	/*
+	 * res
+	 */
+	retval = (int64_t)(long)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * data
+	 */
+	if (retval < 0) {
+		/*
+		 * The operation failed, return an empty buffer
+		 */
+		val = 0;
+		bufsize = 0;
+	} else {
+		if (!args->is_socketcall)
+			syscall_get_arguments(current, args->regs, 1, 1, &val);
+		else
+			val = args->socketcall_args[1];
+
+		/*
+		 * The return value can be lower than the value provided by the user,
+		 * and we take that into account.
+		 */
+		bufsize = retval;
+	}
+
+	args->enforce_snaplen = true;
+	res = val_to_ring(args, val, bufsize, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_recv_e_common(struct event_filler_arguments *args)
+{
+	int res;
+	unsigned long val;
+
+	/*
+	 * fd
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 0, 1, &val);
+	else
+		val = args->socketcall_args[0];
+
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * size
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 2, 1, &val);
+	else
+		val = args->socketcall_args[2];
+
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return PPM_SUCCESS;
+}
+
+static int f_sys_recv_e(struct event_filler_arguments *args)
+{
+	int res;
+
+	res = f_sys_recv_e_common(args);
+
+	if (likely(res == PPM_SUCCESS))
+		return add_sentinel(args);
+	return res;
+}
+
+static int f_sys_recvfrom_e(struct event_filler_arguments *args)
+{
+	int res;
+
+	res = f_sys_recv_e_common(args);
+	if (likely(res == PPM_SUCCESS))
+		return add_sentinel(args);
+	return res;
+}
+
+static int f_sys_recv_x_common(struct event_filler_arguments *args, int64_t *retval)
+{
+	int res;
+	unsigned long val;
+	unsigned long bufsize;
+
+	/*
+	 * Retrieve the FD. It will be used for dynamic snaplen calculation.
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 0, 1, &val);
+	else
+		val = args->socketcall_args[1];
+
+	args->fd = (int)val;
+
+	/*
+	 * res
+	 */
+	*retval = (int64_t)(long)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, *retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * data
+	 */
+	if (*retval < 0) {
+		/*
+		 * The operation failed, return an empty buffer
+		 */
+		val = 0;
+		bufsize = 0;
+	} else {
+		if (!args->is_socketcall)
+			syscall_get_arguments(current, args->regs, 1, 1, &val);
+		else
+			val = args->socketcall_args[1];
+
+		/*
+		 * The return value can be lower than the value provided by the user,
+		 * and we take that into account.
+		 */
+		bufsize = *retval;
+	}
+
+	args->enforce_snaplen = true;
+	res = val_to_ring(args, val, bufsize, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return PPM_SUCCESS;
+}
+
+static int f_sys_recv_x(struct event_filler_arguments *args)
+{
+	int res;
+	int64_t retval;
+
+	res = f_sys_recv_x_common(args, &retval);
+
+	if (likely(res == PPM_SUCCESS))
+		return add_sentinel(args);
+	return res;
+}
+
+static int f_sys_recvfrom_x(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	u16 size = 0;
+	int64_t retval;
+	char *targetbuf = args->str_storage;
+	int fd;
+	struct sockaddr __user *usrsockaddr;
+	struct sockaddr_storage address;
+	int addrlen;
+	int err = 0;
+
+	/*
+	 * Push the common params to the ring
+	 */
+	res = f_sys_recv_x_common(args, &retval);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	if (retval >= 0) {
+		/*
+		 * Get the fd
+		 */
+		if (!args->is_socketcall) {
+			syscall_get_arguments(current, args->regs, 0, 1, &val);
+			fd = (int)val;
+		} else
+			fd = (int)args->socketcall_args[0];
+
+		/*
+		 * Get the address
+		 */
+		if (!args->is_socketcall)
+			syscall_get_arguments(current, args->regs, 4, 1, &val);
+		else
+			val = args->socketcall_args[4];
+		usrsockaddr = (struct sockaddr __user *)val;
+
+		/*
+		 * Get the address len
+		 */
+		if (!args->is_socketcall)
+			syscall_get_arguments(current, args->regs, 5, 1, &val);
+		else
+			val = args->socketcall_args[5];
+		if (usrsockaddr != NULL && val != 0) {
+#ifdef CONFIG_COMPAT
+			if (!args->compat) {
+#endif
+				if (unlikely(ppm_copy_from_user(&addrlen, (const void __user *)val, sizeof(addrlen))))
+					return PPM_FAILURE_INVALID_USER_MEMORY;
+#ifdef CONFIG_COMPAT
+			} else {
+				if (unlikely(ppm_copy_from_user(&addrlen, (const void __user *)compat_ptr(val), sizeof(addrlen))))
+					return PPM_FAILURE_INVALID_USER_MEMORY;
+			}
+#endif
+
+			/*
+			 * Copy the address
+			 */
+			err = addr_to_kernel(usrsockaddr, addrlen, (struct sockaddr *)&address);
+			if (likely(err >= 0)) {
+				/*
+				 * Convert the fd into socket endpoint information
+				 */
+				size = fd_to_socktuple(fd,
+					(struct sockaddr *)&address,
+					addrlen,
+					true,
+					true,
+					targetbuf,
+					STR_STORAGE_SIZE);
+			}
+		}
+	}
+
+	/*
+	 * Copy the endpoint info into the ring
+	 */
+	res = val_to_ring(args,
+			    (uint64_t)(unsigned long)targetbuf,
+			    size,
+			    false,
+			    0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_sendmsg_e(struct event_filler_arguments *args)
+{
+	int res;
+	unsigned long val;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+	struct user_msghdr mh;
+#else
+	struct msghdr mh;
+#endif
+	char *targetbuf = args->str_storage;
+	const struct iovec __user *iov;
+#ifdef CONFIG_COMPAT
+	const struct compat_iovec __user *compat_iov;
+	struct compat_msghdr compat_mh;
+#endif
+	unsigned long iovcnt;
+	int fd;
+	u16 size = 0;
+	int addrlen;
+	int err = 0;
+	struct sockaddr __user *usrsockaddr;
+	struct sockaddr_storage address;
+
+	/*
+	 * fd
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 0, 1, &val);
+	else
+		val = args->socketcall_args[0];
+
+	fd = val;
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * Retrieve the message header
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 1, 1, &val);
+	else
+		val = args->socketcall_args[1];
+
+#ifdef CONFIG_COMPAT
+	if (!args->compat) {
+#endif
+		if (unlikely(ppm_copy_from_user(&mh, (const void __user *)val, sizeof(mh))))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+
+		/*
+		 * size
+		 */
+		iov = (const struct iovec __user *)mh.msg_iov;
+		iovcnt = mh.msg_iovlen;
+
+		res = parse_readv_writev_bufs(args, iov, iovcnt, args->consumer->snaplen, PRB_FLAG_PUSH_SIZE | PRB_FLAG_IS_WRITE);
+
+
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+		/*
+		 * tuple
+		 */
+		usrsockaddr = (struct sockaddr __user *)mh.msg_name;
+		addrlen = mh.msg_namelen;
+#ifdef CONFIG_COMPAT
+	} else {
+		if (unlikely(ppm_copy_from_user(&compat_mh, (const void __user *)compat_ptr(val), sizeof(compat_mh))))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+
+		/*
+		 * size
+		 */
+		compat_iov = (const struct compat_iovec __user *)compat_ptr(compat_mh.msg_iov);
+		iovcnt = compat_mh.msg_iovlen;
+
+		res = compat_parse_readv_writev_bufs(args, compat_iov, iovcnt, args->consumer->snaplen, PRB_FLAG_PUSH_SIZE | PRB_FLAG_IS_WRITE);
+
+
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+		/*
+		 * tuple
+		 */
+		usrsockaddr = (struct sockaddr __user *)compat_ptr(compat_mh.msg_name);
+		addrlen = compat_mh.msg_namelen;
+	}
+#endif
+
+	if (usrsockaddr != NULL && addrlen != 0) {
+		/*
+		 * Copy the address
+		 */
+		err = addr_to_kernel(usrsockaddr, addrlen, (struct sockaddr *)&address);
+		if (likely(err >= 0)) {
+			/*
+			 * Convert the fd into socket endpoint information
+			 */
+			size = fd_to_socktuple(fd,
+				(struct sockaddr *)&address,
+				addrlen,
+				true,
+				false,
+				targetbuf,
+				STR_STORAGE_SIZE);
+		}
+	}
+
+	/* Copy the endpoint info into the ring */
+	res = val_to_ring(args,
+			    (uint64_t)(unsigned long)targetbuf,
+			    size,
+			    false,
+			    0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_sendmsg_x(struct event_filler_arguments *args)
+{
+	int res;
+	unsigned long val;
+	int64_t retval;
+	const struct iovec __user *iov;
+#ifdef CONFIG_COMPAT
+	const struct compat_iovec __user *compat_iov;
+	struct compat_msghdr compat_mh;
+#endif
+	unsigned long iovcnt;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+	struct user_msghdr mh;
+#else
+	struct msghdr mh;
+#endif
+
+	/*
+	 * res
+	 */
+	retval = (int64_t)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * Retrieve the message header
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 1, 1, &val);
+	else
+		val = args->socketcall_args[1];
+
+	/*
+	 * data
+	 */
+#ifdef CONFIG_COMPAT
+	if (!args->compat) {
+#endif
+		if (unlikely(ppm_copy_from_user(&mh, (const void __user *)val, sizeof(mh))))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+
+
+		iov = (const struct iovec __user *)mh.msg_iov;
+		iovcnt = mh.msg_iovlen;
+
+		res = parse_readv_writev_bufs(args, iov, iovcnt, args->consumer->snaplen, PRB_FLAG_PUSH_DATA | PRB_FLAG_IS_WRITE);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+#ifdef CONFIG_COMPAT
+	} else {
+		if (unlikely(ppm_copy_from_user(&compat_mh, (const void __user *)compat_ptr(val), sizeof(compat_mh))))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+
+		compat_iov = (const struct compat_iovec __user *)compat_ptr(compat_mh.msg_iov);
+		iovcnt = compat_mh.msg_iovlen;
+
+		res = compat_parse_readv_writev_bufs(args, compat_iov, iovcnt, args->consumer->snaplen, PRB_FLAG_PUSH_DATA | PRB_FLAG_IS_WRITE);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	}
+#endif
+
+	return add_sentinel(args);
+}
+
+static int f_sys_recvmsg_e(struct event_filler_arguments *args)
+{
+	int res;
+	unsigned long val;
+
+	/*
+	 * fd
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 0, 1, &val);
+	else
+		val = args->socketcall_args[0];
+
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_recvmsg_x(struct event_filler_arguments *args)
+{
+	int res;
+	unsigned long val;
+	int64_t retval;
+	const struct iovec __user *iov;
+#ifdef CONFIG_COMPAT
+	const struct compat_iovec __user *compat_iov;
+	struct compat_msghdr compat_mh;
+#endif
+	unsigned long iovcnt;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+	struct user_msghdr mh;
+#else
+	struct msghdr mh;
+#endif
+	char *targetbuf = args->str_storage;
+	int fd;
+	struct sockaddr __user *usrsockaddr;
+	struct sockaddr_storage address;
+	u16 size = 0;
+	int addrlen;
+	int err = 0;
+
+	/*
+	 * res
+	 */
+	retval = (int64_t)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * Retrieve the message header
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 1, 1, &val);
+	else
+		val = args->socketcall_args[1];
+
+
+#ifdef CONFIG_COMPAT
+	if (!args->compat) {
+#endif
+		if (unlikely(ppm_copy_from_user(&mh, (const void __user *)val, sizeof(mh))))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+
+		/*
+		 * data and size
+		 */
+		iov = (const struct iovec __user *)mh.msg_iov;
+		iovcnt = mh.msg_iovlen;
+
+		res = parse_readv_writev_bufs(args, iov, iovcnt, retval, PRB_FLAG_PUSH_ALL);
+#ifdef CONFIG_COMPAT
+	} else {
+		if (unlikely(ppm_copy_from_user(&compat_mh, (const void __user *)compat_ptr(val), sizeof(compat_mh))))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+
+		/*
+		 * data and size
+		 */
+		compat_iov = (const struct compat_iovec __user *)compat_ptr(compat_mh.msg_iov);
+		iovcnt = compat_mh.msg_iovlen;
+
+		res = compat_parse_readv_writev_bufs(args, compat_iov, iovcnt, retval, PRB_FLAG_PUSH_ALL);
+	}
+#endif
+
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * tuple
+	 */
+	if (retval >= 0) {
+		/*
+		 * Get the fd
+		 */
+		if (!args->is_socketcall) {
+			syscall_get_arguments(current, args->regs, 0, 1, &val);
+			fd = (int)val;
+		} else
+			fd = (int)args->socketcall_args[0];
+
+		/*
+		 * Get the address
+		 */
+		usrsockaddr = (struct sockaddr __user *)mh.msg_name;
+		addrlen = mh.msg_namelen;
+
+		if (usrsockaddr != NULL && addrlen != 0) {
+			/*
+			 * Copy the address
+			 */
+			err = addr_to_kernel(usrsockaddr, addrlen, (struct sockaddr *)&address);
+			if (likely(err >= 0)) {
+				/*
+				 * Convert the fd into socket endpoint information
+				 */
+				size = fd_to_socktuple(fd,
+					(struct sockaddr *)&address,
+					addrlen,
+					true,
+					true,
+					targetbuf,
+					STR_STORAGE_SIZE);
+			}
+		}
+	}
+
+	/* Copy the endpoint info into the ring */
+	res = val_to_ring(args,
+			    (uint64_t)(unsigned long)targetbuf,
+			    size,
+			    false,
+			    0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+
+static int f_sys_pipe_x(struct event_filler_arguments *args)
+{
+	int res;
+	int64_t retval;
+	unsigned long val;
+	int fds[2];
+	struct file *file;
+
+	/*
+	 * retval
+	 */
+	retval = (int64_t)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * fds
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+
+#ifdef CONFIG_COMPAT
+	if (!args->compat) {
+#endif
+		if (unlikely(ppm_copy_from_user(fds, (const void __user *)val, sizeof(fds))))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+#ifdef CONFIG_COMPAT
+	} else {
+		if (unlikely(ppm_copy_from_user(fds, (const void __user *)compat_ptr(val), sizeof(fds))))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+	}
+#endif
+
+	res = val_to_ring(args, fds[0], 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	res = val_to_ring(args, fds[1], 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	file = fget(fds[0]);
+	val = 0;
+	if (likely(file != NULL)) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 20)
+		val = file->f_path.dentry->d_inode->i_ino;
+#else
+		val = file->f_dentry->d_inode->i_ino;
+#endif
+		fput(file);
+	}
+
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_eventfd_e(struct event_filler_arguments *args)
+{
+	int res;
+	unsigned long val;
+
+	/*
+	 * initval
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * flags
+	 * XXX not implemented yet
+	 */
+	/* syscall_get_arguments(current, args->regs, 1, 1, &val); */
+	val = 0;
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static inline u16 shutdown_how_to_scap(unsigned long how)
+{
+#ifdef SHUT_RD
+	if (how == SHUT_RD)
+		return PPM_SHUT_RD;
+	else if (how == SHUT_WR)
+		return SHUT_WR;
+	else if (how == SHUT_RDWR)
+		return SHUT_RDWR;
+
+	ASSERT(false);
+#endif
+	return (u16)how;
+}
+
+static int f_sys_shutdown_e(struct event_filler_arguments *args)
+{
+	int res;
+	unsigned long val;
+
+	/*
+	 * fd
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 0, 1, &val);
+	else
+		val = args->socketcall_args[0];
+
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * how
+	 */
+	if (!args->is_socketcall)
+		syscall_get_arguments(current, args->regs, 1, 1, &val);
+	else
+		val = args->socketcall_args[1];
+
+	res = val_to_ring(args, (unsigned long)shutdown_how_to_scap(val), 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static inline u16 futex_op_to_scap(unsigned long op)
+{
+	u16 res = 0;
+	unsigned long flt_op = op & 127;
+
+	if (flt_op == FUTEX_WAIT)
+		res = PPM_FU_FUTEX_WAIT;
+	else if (flt_op == FUTEX_WAKE)
+		res = PPM_FU_FUTEX_WAKE;
+	else if (flt_op == FUTEX_FD)
+		res = PPM_FU_FUTEX_FD;
+	else if (flt_op == FUTEX_REQUEUE)
+		res = PPM_FU_FUTEX_REQUEUE;
+	else if (flt_op == FUTEX_CMP_REQUEUE)
+		res = PPM_FU_FUTEX_CMP_REQUEUE;
+	else if (flt_op == FUTEX_WAKE_OP)
+		res = PPM_FU_FUTEX_WAKE_OP;
+	else if (flt_op == FUTEX_LOCK_PI)
+		res = PPM_FU_FUTEX_LOCK_PI;
+	else if (flt_op == FUTEX_UNLOCK_PI)
+		res = PPM_FU_FUTEX_UNLOCK_PI;
+	else if (flt_op == FUTEX_TRYLOCK_PI)
+		res = PPM_FU_FUTEX_TRYLOCK_PI;
+#ifdef FUTEX_WAIT_BITSET
+	else if (flt_op == FUTEX_WAIT_BITSET)
+		res = PPM_FU_FUTEX_WAIT_BITSET;
+#endif
+#ifdef FUTEX_WAKE_BITSET
+	else if (flt_op == FUTEX_WAKE_BITSET)
+		res = PPM_FU_FUTEX_WAKE_BITSET;
+#endif
+#ifdef FUTEX_WAIT_REQUEUE_PI
+	else if (flt_op == FUTEX_WAIT_REQUEUE_PI)
+		res = PPM_FU_FUTEX_WAIT_REQUEUE_PI;
+#endif
+#ifdef FUTEX_CMP_REQUEUE_PI
+	else if (flt_op == FUTEX_CMP_REQUEUE_PI)
+		res = PPM_FU_FUTEX_CMP_REQUEUE_PI;
+#endif
+
+	if (op & FUTEX_PRIVATE_FLAG)
+		res |= PPM_FU_FUTEX_PRIVATE_FLAG;
+
+#ifdef FUTEX_CLOCK_REALTIME
+	if (op & FUTEX_CLOCK_REALTIME)
+		res |= PPM_FU_FUTEX_CLOCK_REALTIME;
+#endif
+
+	return res;
+}
+
+static int f_sys_futex_e(struct event_filler_arguments *args)
+{
+	int res;
+	unsigned long val;
+
+	/*
+	 * addr
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * op
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+	res = val_to_ring(args, (unsigned long)futex_op_to_scap(val), 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * val
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static inline uint64_t lseek_whence_to_scap(unsigned long whence)
+{
+	uint64_t res = 0;
+
+	if (whence == SEEK_SET)
+		res = PPM_SEEK_SET;
+	else if (whence == SEEK_CUR)
+		res = PPM_SEEK_CUR;
+	else if (whence == SEEK_END)
+		res = PPM_SEEK_END;
+
+	return res;
+}
+
+static int f_sys_lseek_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+
+	/*
+	 * fd
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * offset
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * whence
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &val);
+	res = val_to_ring(args, lseek_whence_to_scap(val), 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_llseek_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	unsigned long oh;
+	unsigned long ol;
+	uint64_t offset;
+
+	/*
+	 * fd
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * offset
+	 * We build it by combining the offset_high and offset_low system call arguments
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &oh);
+	syscall_get_arguments(current, args->regs, 2, 1, &ol);
+	offset = (((uint64_t)oh) << 32) + ((uint64_t)ol);
+	res = val_to_ring(args, offset, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * whence
+	 */
+	syscall_get_arguments(current, args->regs, 4, 1, &val);
+	res = val_to_ring(args, lseek_whence_to_scap(val), 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+/* XXX this is very basic for the moment, we'll need to improve it */
+static inline u16 poll_events_to_scap(short revents)
+{
+	u16 res = 0;
+
+	if (revents & POLLIN)
+		res |= PPM_POLLIN;
+
+	if (revents & PPM_POLLPRI)
+		res |= PPM_POLLPRI;
+
+	if (revents & POLLOUT)
+		res |= PPM_POLLOUT;
+
+	if (revents & POLLRDHUP)
+		res |= PPM_POLLRDHUP;
+
+	if (revents & POLLERR)
+		res |= PPM_POLLERR;
+
+	if (revents & POLLHUP)
+		res |= PPM_POLLHUP;
+
+	if (revents & POLLNVAL)
+		res |= PPM_POLLNVAL;
+
+	if (revents & POLLRDNORM)
+		res |= PPM_POLLRDNORM;
+
+	if (revents & POLLRDBAND)
+		res |= PPM_POLLRDBAND;
+
+	if (revents & POLLWRNORM)
+		res |= PPM_POLLWRNORM;
+
+	if (revents & POLLWRBAND)
+		res |= PPM_POLLWRBAND;
+
+	return res;
+}
+
+static int poll_parse_fds(struct event_filler_arguments *args, bool enter_event)
+{
+	struct pollfd *fds;
+	char *targetbuf;
+	unsigned long val;
+	unsigned long nfds;
+	unsigned long fds_count;
+	u32 j;
+	u32 pos;
+	u16 flags;
+
+	/*
+	 * fds
+	 *
+	 * Get the number of fds
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &nfds);
+
+	/*
+	 * Check if we have enough space to store both the fd list
+	 * from user space and the temporary buffer to serialize to the ring
+	 */
+	if (unlikely(sizeof(struct pollfd) * nfds + 2 + 10 * nfds > STR_STORAGE_SIZE))
+		return PPM_FAILURE_BUFFER_FULL;
+
+	/* Get the fds pointer */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+
+	fds = (struct pollfd *)args->str_storage;
+#ifdef CONFIG_COMPAT
+	if (!args->compat) {
+#endif
+		if (unlikely(ppm_copy_from_user(fds, (const void __user *)val, nfds * sizeof(struct pollfd))))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+#ifdef CONFIG_COMPAT
+	} else {
+		if (unlikely(ppm_copy_from_user(fds, (const void __user *)compat_ptr(val), nfds * sizeof(struct pollfd))))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+	}
+#endif
+
+	pos = 2;
+	targetbuf = args->str_storage + nfds * sizeof(struct pollfd) + pos;
+	fds_count = 0;
+
+	/* Copy each fd into the temporary buffer */
+	for (j = 0; j < nfds; j++) {
+		if (enter_event) {
+			flags = poll_events_to_scap(fds[j].events);
+		} else {
+			/*
+			 * If it's an exit event, we copy only the fds that
+			 * returned something
+			 */
+			if (!fds[j].revents)
+				continue;
+
+			flags = poll_events_to_scap(fds[j].revents);
+		}
+
+		*(int64_t *)(targetbuf + pos) = fds[j].fd;
+		*(int16_t *)(targetbuf + pos + 8) = flags;
+		pos += 10;
+		++fds_count;
+	}
+
+	*(u16 *)(targetbuf) = (u16)fds_count;
+
+	return val_to_ring(args, (uint64_t)(unsigned long)targetbuf, pos, false, 0);
+}
+
+static int f_sys_poll_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+
+	res = poll_parse_fds(args, true);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * timeout
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int timespec_parse(struct event_filler_arguments *args, unsigned long val)
+{
+	uint64_t longtime;
+	char *targetbuf = args->str_storage;
+	struct timespec *tts = (struct timespec *)targetbuf;
+#ifdef CONFIG_COMPAT
+	struct compat_timespec *compat_tts = (struct compat_timespec *)targetbuf;
+#endif
+	int cfulen;
+
+	/*
+	 * interval
+	 * We copy the timespec structure and then convert it to a 64bit relative time
+	 */
+#ifdef CONFIG_COMPAT
+	if (!args->compat) {
+#endif
+		cfulen = (int)ppm_copy_from_user(targetbuf, (void __user *)val, sizeof(struct timespec));
+		if (unlikely(cfulen != 0))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+
+		longtime = ((uint64_t)tts->tv_sec) * 1000000000 + tts->tv_nsec;
+#ifdef CONFIG_COMPAT
+	} else {
+		cfulen = (int)ppm_copy_from_user(targetbuf, (void __user *)compat_ptr(val), sizeof(struct compat_timespec));
+		if (unlikely(cfulen != 0))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+
+		longtime = ((uint64_t)compat_tts->tv_sec) * 1000000000 + compat_tts->tv_nsec;
+	}
+#endif
+
+	return val_to_ring(args, longtime, 0, false, 0);
+}
+
+static int f_sys_ppoll_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+
+	res = poll_parse_fds(args, true);
+	if (res != PPM_SUCCESS)
+		return res;
+
+	/*
+	 * timeout
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &val);
+	/* NULL timeout specified as 0xFFFFFF.... */
+	if (val == (unsigned long)NULL)
+		res = val_to_ring(args, (uint64_t)(-1), 0, false, 0);
+	else
+		res = timespec_parse(args, val);
+	if (res != PPM_SUCCESS)
+		return res;
+
+	/*
+	 * sigmask
+	 */
+	syscall_get_arguments(current, args->regs, 3, 1, &val);
+	if (val != (unsigned long)NULL)
+		if (0 != ppm_copy_from_user(&val, (void __user *)val, sizeof(val)))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+
+	res = val_to_ring(args, val, 0, false, 0);
+	if (res != PPM_SUCCESS)
+		return res;
+
+	return add_sentinel(args);
+}
+
+/* This is the same for poll() and ppoll() */
+static int f_sys_poll_x(struct event_filler_arguments *args)
+{
+	int64_t retval;
+	int res;
+
+	/*
+	 * res
+	 */
+	retval = (int64_t)(long)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	res = poll_parse_fds(args, false);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+#define PPM_MS_MGC_MSK 0xffff0000
+#define PPM_MS_MGC_VAL 0xC0ED0000
+
+static int f_sys_mount_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+
+	/*
+	 * Fix mount flags in arg 3.
+	 * See http://lxr.free-electrons.com/source/fs/namespace.c?v=4.2#L2650
+	 */
+	syscall_get_arguments(current, args->regs, 3, 1, &val);
+	if ((val & PPM_MS_MGC_MSK) == PPM_MS_MGC_VAL)
+		val &= ~PPM_MS_MGC_MSK;
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_openat_e(struct event_filler_arguments *args)
+{
+	unsigned long val, flags;
+	int res;
+
+	/*
+	 * dirfd
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+
+	if ((int)val == AT_FDCWD)
+		val = PPM_AT_FDCWD;
+
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * name
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * Flags
+	 * Note that we convert them into the ppm portable representation before pushing them to the ring
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &flags);
+	res = val_to_ring(args, open_flags_to_scap(flags), 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 *  mode
+	 */
+	res = open_mode_to_ring(args, flags, 3);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+#ifndef _64BIT_ARGS_SINGLE_REGISTER
+static int f_sys_pread64_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	unsigned long size;
+	int res;
+	unsigned long pos0;
+	unsigned long pos1;
+	uint64_t pos64;
+
+	/*
+	 * fd
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * size
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &size);
+	res = val_to_ring(args, size, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * pos
+	 */
+#if defined CONFIG_X86
+	syscall_get_arguments(current, args->regs, 3, 1, &pos0);
+	syscall_get_arguments(current, args->regs, 4, 1, &pos1);
+#elif defined CONFIG_ARM && CONFIG_AEABI
+	syscall_get_arguments(current, args->regs, 4, 1, &pos0);
+	syscall_get_arguments(current, args->regs, 5, 1, &pos1);
+#else
+ #error This architecture/abi not yet supported
+#endif
+
+	pos64 = merge_64(pos1, pos0);
+
+	res = val_to_ring(args, pos64, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+#endif /* _64BIT_ARGS_SINGLE_REGISTER */
+
+static int f_sys_pwrite64_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	unsigned long size;
+	int res;
+#ifndef _64BIT_ARGS_SINGLE_REGISTER
+	unsigned long pos0;
+	unsigned long pos1;
+	uint64_t pos64;
+#endif
+
+	/*
+	 * fd
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * size
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &size);
+	res = val_to_ring(args, size, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * pos
+	 * NOTE: this is a 64bit value, which means that on 32bit systems it uses two
+	 * separate registers that we need to merge.
+	 */
+#ifdef _64BIT_ARGS_SINGLE_REGISTER
+	syscall_get_arguments(current, args->regs, 3, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+#else
+ #if defined CONFIG_X86
+	syscall_get_arguments(current, args->regs, 3, 1, &pos0);
+	syscall_get_arguments(current, args->regs, 4, 1, &pos1);
+ #elif defined CONFIG_ARM && CONFIG_AEABI
+	syscall_get_arguments(current, args->regs, 4, 1, &pos0);
+	syscall_get_arguments(current, args->regs, 5, 1, &pos1);
+ #else
+  #error This architecture/abi not yet supported
+ #endif
+
+	pos64 = merge_64(pos1, pos0);
+
+	res = val_to_ring(args, pos64, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+#endif
+
+	return add_sentinel(args);
+}
+
+static int f_sys_readv_x(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int64_t retval;
+	int res;
+#ifdef CONFIG_COMPAT
+	const struct compat_iovec __user *compat_iov;
+#endif
+	const struct iovec __user *iov;
+	unsigned long iovcnt;
+
+	/*
+	 * res
+	 */
+	retval = (int64_t)(long)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * data and size
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+
+	syscall_get_arguments(current, args->regs, 2, 1, &iovcnt);
+
+#ifdef CONFIG_COMPAT
+	if (unlikely(args->compat)) {
+		compat_iov = (const struct compat_iovec __user *)compat_ptr(val);
+		res = compat_parse_readv_writev_bufs(args, compat_iov, iovcnt, retval, PRB_FLAG_PUSH_ALL);
+	} else
+#endif
+	{
+		iov = (const struct iovec __user *)val;
+		res = parse_readv_writev_bufs(args, iov, iovcnt, retval, PRB_FLAG_PUSH_ALL);
+	}
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_writev_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+#ifdef CONFIG_COMPAT
+	const struct compat_iovec __user *compat_iov;
+#endif
+	const struct iovec __user *iov;
+	unsigned long iovcnt;
+
+	/*
+	 * fd
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * size
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &iovcnt);
+
+	/*
+	 * Copy the buffer
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+#ifdef CONFIG_COMPAT
+	if (unlikely(args->compat)) {
+		compat_iov = (const struct compat_iovec __user *)compat_ptr(val);
+		res = compat_parse_readv_writev_bufs(args, compat_iov, iovcnt,
+											args->consumer->snaplen,
+											PRB_FLAG_PUSH_SIZE | PRB_FLAG_IS_WRITE);
+	} else
+#endif
+	{
+		iov = (const struct iovec __user *)val;
+		res = parse_readv_writev_bufs(args, iov, iovcnt, args->consumer->snaplen,
+									  PRB_FLAG_PUSH_SIZE | PRB_FLAG_IS_WRITE);
+	}
+
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_writev_pwritev_x(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	int64_t retval;
+#ifdef CONFIG_COMPAT
+	const struct compat_iovec __user *compat_iov;
+#endif
+	const struct iovec __user *iov;
+	unsigned long iovcnt;
+
+	/*
+	 * res
+	 */
+	retval = (int64_t)(long)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * data and size
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &iovcnt);
+
+
+	/*
+	 * Copy the buffer
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+#ifdef CONFIG_COMPAT
+	if (unlikely(args->compat)) {
+		compat_iov = (const struct compat_iovec __user *)compat_ptr(val);
+		res = compat_parse_readv_writev_bufs(args, compat_iov, iovcnt, args->consumer->snaplen, PRB_FLAG_PUSH_DATA | PRB_FLAG_IS_WRITE);
+	} else
+#endif
+	{
+		iov = (const struct iovec __user *)val;
+		res = parse_readv_writev_bufs(args, iov, iovcnt, args->consumer->snaplen, PRB_FLAG_PUSH_DATA | PRB_FLAG_IS_WRITE);
+	}
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+#ifndef _64BIT_ARGS_SINGLE_REGISTER
+static int f_sys_preadv_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	unsigned long pos0;
+	unsigned long pos1;
+	uint64_t pos64;
+
+	/*
+	 * fd
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * pos
+	 */
+
+	/*
+	 * Note that in preadv and pwritev have NO 64-bit arguments in the
+	 * syscall (despite having one in the userspace API), so no alignment
+	 * requirements apply here. For an overly-detailed discussion about
+	 * this, see https://lwn.net/Articles/311630/
+	 */
+	syscall_get_arguments(current, args->regs, 3, 1, &pos0);
+	syscall_get_arguments(current, args->regs, 4, 1, &pos1);
+
+	pos64 = merge_64(pos1, pos0);
+
+	res = val_to_ring(args, pos64, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+#endif /* _64BIT_ARGS_SINGLE_REGISTER */
+
+static int f_sys_preadv_x(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int64_t retval;
+	int res;
+#ifdef CONFIG_COMPAT
+	const struct compat_iovec __user *compat_iov;
+#endif
+	const struct iovec __user *iov;
+	unsigned long iovcnt;
+
+	/*
+	 * res
+	 */
+	retval = (int64_t)(long)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * data and size
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &iovcnt);
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+
+#ifdef CONFIG_COMPAT
+	if (unlikely(args->compat)) {
+		compat_iov = (const struct compat_iovec __user *)compat_ptr(val);
+		res = compat_parse_readv_writev_bufs(args, compat_iov, iovcnt, retval, PRB_FLAG_PUSH_ALL);
+	} else
+#endif
+	{
+		iov = (const struct iovec __user *)val;
+		res = parse_readv_writev_bufs(args, iov, iovcnt, retval, PRB_FLAG_PUSH_ALL);
+	}
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_pwritev_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+#ifndef _64BIT_ARGS_SINGLE_REGISTER
+	unsigned long pos0;
+	unsigned long pos1;
+	uint64_t pos64;
+#endif
+#ifdef CONFIG_COMPAT
+	const struct compat_iovec __user *compat_iov;
+#endif
+	const struct iovec __user *iov;
+	unsigned long iovcnt;
+
+	/*
+	 * fd
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * size
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &iovcnt);
+
+	/*
+	 * Copy the buffer
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+#ifdef CONFIG_COMPAT
+	if (unlikely(args->compat)) {
+		compat_iov = (const struct compat_iovec __user *)compat_ptr(val);
+		res = compat_parse_readv_writev_bufs(args, compat_iov, iovcnt,
+									args->consumer->snaplen,
+									PRB_FLAG_PUSH_SIZE | PRB_FLAG_IS_WRITE);
+	} else
+#endif
+	{
+		iov = (const struct iovec __user *)val;
+		res = parse_readv_writev_bufs(args, iov, iovcnt, args->consumer->snaplen,
+									  PRB_FLAG_PUSH_SIZE | PRB_FLAG_IS_WRITE);
+	}
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * pos
+	 * NOTE: this is a 64bit value, which means that on 32bit systems it uses two
+	 * separate registers that we need to merge.
+	 */
+#ifdef _64BIT_ARGS_SINGLE_REGISTER
+	syscall_get_arguments(current, args->regs, 3, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+#else
+	/*
+	 * Note that in preadv and pwritev have NO 64-bit arguments in the
+	 * syscall (despite having one in the userspace API), so no alignment
+	 * requirements apply here. For an overly-detailed discussion about
+	 * this, see https://lwn.net/Articles/311630/
+	 */
+	syscall_get_arguments(current, args->regs, 3, 1, &pos0);
+	syscall_get_arguments(current, args->regs, 4, 1, &pos1);
+
+	pos64 = merge_64(pos1, pos0);
+
+	res = val_to_ring(args, pos64, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+#endif
+
+	return add_sentinel(args);
+}
+
+static int f_sys_nanosleep_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = timespec_parse(args, val);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static inline u8 rlimit_resource_to_scap(unsigned long rresource)
+{
+	switch (rresource) {
+	case RLIMIT_CPU:
+		return PPM_RLIMIT_CPU;
+	case RLIMIT_FSIZE:
+		return PPM_RLIMIT_FSIZE;
+	case RLIMIT_DATA:
+		return PPM_RLIMIT_DATA;
+	case RLIMIT_STACK:
+		return PPM_RLIMIT_STACK;
+	case RLIMIT_CORE:
+		return PPM_RLIMIT_CORE;
+	case RLIMIT_RSS:
+		return PPM_RLIMIT_RSS;
+	case RLIMIT_NPROC:
+		return PPM_RLIMIT_NPROC;
+	case RLIMIT_NOFILE:
+		return PPM_RLIMIT_NOFILE;
+	case RLIMIT_MEMLOCK:
+		return PPM_RLIMIT_MEMLOCK;
+	case RLIMIT_AS:
+		return PPM_RLIMIT_AS;
+	case RLIMIT_LOCKS:
+		return PPM_RLIMIT_LOCKS;
+	case RLIMIT_SIGPENDING:
+		return PPM_RLIMIT_SIGPENDING;
+	case RLIMIT_MSGQUEUE:
+		return PPM_RLIMIT_MSGQUEUE;
+	case RLIMIT_NICE:
+		return PPM_RLIMIT_NICE;
+	case RLIMIT_RTPRIO:
+		return PPM_RLIMIT_RTPRIO;
+#ifdef RLIMIT_RTTIME
+	case RLIMIT_RTTIME:
+		return PPM_RLIMIT_RTTIME;
+#endif
+	default:
+		return PPM_RLIMIT_UNKNOWN;
+	}
+}
+
+static int f_sys_getrlimit_setrlimit_e(struct event_filler_arguments *args)
+{
+	u8 ppm_resource;
+	unsigned long val;
+	int res;
+
+	/*
+	 * resource
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+
+	ppm_resource = rlimit_resource_to_scap(val);
+
+	res = val_to_ring(args, (uint64_t)ppm_resource, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_getrlimit_setrlrimit_x(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	int64_t retval;
+	struct rlimit rl;
+#ifdef CONFIG_COMPAT
+	struct compat_rlimit compat_rl;
+#endif
+	int64_t cur;
+	int64_t max;
+
+	/*
+	 * res
+	 */
+	retval = (int64_t)(long)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * Copy the user structure and extract cur and max
+	 */
+	if (retval >= 0 || args->event_type == PPME_SYSCALL_SETRLIMIT_X) {
+		syscall_get_arguments(current, args->regs, 1, 1, &val);
+
+#ifdef CONFIG_COMPAT
+		if (!args->compat) {
+#endif
+			if (unlikely(ppm_copy_from_user(&rl, (const void __user *)val, sizeof(struct rlimit))))
+				return PPM_FAILURE_INVALID_USER_MEMORY;
+			cur = rl.rlim_cur;
+			max = rl.rlim_max;
+#ifdef CONFIG_COMPAT
+		} else {
+			if (unlikely(ppm_copy_from_user(&compat_rl, (const void __user *)compat_ptr(val), sizeof(struct compat_rlimit))))
+				return PPM_FAILURE_INVALID_USER_MEMORY;
+			cur = compat_rl.rlim_cur;
+			max = compat_rl.rlim_max;
+		}
+#endif
+	} else {
+		cur = -1;
+		max = -1;
+	}
+
+	/*
+	 * cur
+	 */
+	res = val_to_ring(args, cur, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * max
+	 */
+	res = val_to_ring(args, max, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_prlimit_e(struct event_filler_arguments *args)
+{
+	u8 ppm_resource;
+	unsigned long val;
+	int res;
+
+	/*
+	 * pid
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * resource
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+
+	ppm_resource = rlimit_resource_to_scap(val);
+
+	res = val_to_ring(args, (uint64_t)ppm_resource, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_prlimit_x(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	int64_t retval;
+	struct rlimit rl;
+#ifdef CONFIG_COMPAT
+	struct compat_rlimit compat_rl;
+#endif
+	int64_t newcur;
+	int64_t newmax;
+	int64_t oldcur;
+	int64_t oldmax;
+
+	/*
+	 * res
+	 */
+	retval = (int64_t)(long)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * Copy the user structure and extract cur and max
+	 */
+	if (retval >= 0) {
+		syscall_get_arguments(current, args->regs, 2, 1, &val);
+
+#ifdef CONFIG_COMPAT
+		if (!args->compat) {
+#endif
+			if (unlikely(ppm_copy_from_user(&rl, (const void __user *)val, sizeof(struct rlimit)))) {
+				newcur = -1;
+				newmax = -1;
+			} else {
+				newcur = rl.rlim_cur;
+				newmax = rl.rlim_max;
+			}
+#ifdef CONFIG_COMPAT
+		} else {
+			if (unlikely(ppm_copy_from_user(&compat_rl, (const void __user *)val, sizeof(struct compat_rlimit)))) {
+				newcur = -1;
+				newmax = -1;
+			} else {
+				newcur = compat_rl.rlim_cur;
+				newmax = compat_rl.rlim_max;
+			}
+		}
+#endif
+	} else {
+		newcur = -1;
+		newmax = -1;
+	}
+
+	syscall_get_arguments(current, args->regs, 3, 1, &val);
+
+#ifdef CONFIG_COMPAT
+	if (!args->compat) {
+#endif
+		if (unlikely(ppm_copy_from_user(&rl, (const void __user *)val, sizeof(struct rlimit)))) {
+			oldcur = -1;
+			oldmax = -1;
+		} else {
+			oldcur = rl.rlim_cur;
+			oldmax = rl.rlim_max;
+		}
+#ifdef CONFIG_COMPAT
+	} else {
+		if (unlikely(ppm_copy_from_user(&compat_rl, (const void __user *)val, sizeof(struct compat_rlimit)))) {
+			oldcur = -1;
+			oldmax = -1;
+		} else {
+			oldcur = compat_rl.rlim_cur;
+			oldmax = compat_rl.rlim_max;
+		}
+	}
+#endif
+
+	/*
+	 * newcur
+	 */
+	res = val_to_ring(args, newcur, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * newmax
+	 */
+	res = val_to_ring(args, newmax, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * oldcur
+	 */
+	res = val_to_ring(args, oldcur, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * oldmax
+	 */
+	res = val_to_ring(args, oldmax, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+#ifdef CAPTURE_CONTEXT_SWITCHES
+
+static int f_sched_switch_e(struct event_filler_arguments *args)
+{
+	int res;
+	long total_vm = 0;
+	long total_rss = 0;
+	long swap = 0;
+	struct mm_struct *mm = NULL;
+
+	if (args->sched_prev == NULL || args->sched_next == NULL) {
+		ASSERT(false);
+		return -1;
+	}
+
+	/*
+	 * next
+	 */
+	res = val_to_ring(args, args->sched_next->pid, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * pgft_maj
+	 */
+	res = val_to_ring(args, args->sched_prev->maj_flt, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * pgft_min
+	 */
+	res = val_to_ring(args, args->sched_prev->min_flt, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	mm = args->sched_prev->mm;
+	if (mm) {
+		total_vm = mm->total_vm << (PAGE_SHIFT-10);
+		total_rss = ppm_get_mm_rss(mm) << (PAGE_SHIFT-10);
+		swap = ppm_get_mm_swap(mm) << (PAGE_SHIFT-10);
+	}
+
+	/*
+	 * vm_size
+	 */
+	res = val_to_ring(args, total_vm, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * vm_rss
+	 */
+	res = val_to_ring(args, total_rss, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * vm_swap
+	 */
+	res = val_to_ring(args, swap, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+#if 0
+	/*
+	 * steal
+	 */
+	steal = cputime64_to_clock_t(kcpustat_this_cpu->cpustat[CPUTIME_STEAL]);
+	res = val_to_ring(args, steal, 0, false);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+#endif
+
+	return add_sentinel(args);
+}
+#endif /* CAPTURE_CONTEXT_SWITCHES */
+
+static int f_sched_drop(struct event_filler_arguments *args)
+{
+	int res;
+
+	/*
+	 * next
+	 */
+	res = val_to_ring(args, args->consumer->sampling_ratio, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static inline u8 fcntl_cmd_to_scap(unsigned long cmd)
+{
+	switch (cmd) {
+	case F_DUPFD:
+		return PPM_FCNTL_F_DUPFD;
+	case F_GETFD:
+		return PPM_FCNTL_F_GETFD;
+	case F_SETFD:
+		return PPM_FCNTL_F_SETFD;
+	case F_GETFL:
+		return PPM_FCNTL_F_GETFL;
+	case F_SETFL:
+		return PPM_FCNTL_F_SETFL;
+	case F_GETLK:
+		return PPM_FCNTL_F_GETLK;
+	case F_SETLK:
+		return PPM_FCNTL_F_SETLK;
+	case F_SETLKW:
+		return PPM_FCNTL_F_SETLKW;
+	case F_SETOWN:
+		return PPM_FCNTL_F_SETOWN;
+	case F_GETOWN:
+		return PPM_FCNTL_F_GETOWN;
+	case F_SETSIG:
+		return PPM_FCNTL_F_SETSIG;
+	case F_GETSIG:
+		return PPM_FCNTL_F_GETSIG;
+#ifndef CONFIG_64BIT
+	case F_GETLK64:
+		return PPM_FCNTL_F_GETLK64;
+	case F_SETLK64:
+		return PPM_FCNTL_F_SETLK64;
+	case F_SETLKW64:
+		return PPM_FCNTL_F_SETLKW64;
+#endif
+#ifdef F_SETOWN_EX
+	case F_SETOWN_EX:
+		return PPM_FCNTL_F_SETOWN_EX;
+#endif
+#ifdef F_GETOWN_EX
+	case F_GETOWN_EX:
+		return PPM_FCNTL_F_GETOWN_EX;
+#endif
+	case F_SETLEASE:
+		return PPM_FCNTL_F_SETLEASE;
+	case F_GETLEASE:
+		return PPM_FCNTL_F_GETLEASE;
+	case F_CANCELLK:
+		return PPM_FCNTL_F_CANCELLK;
+#ifdef F_DUPFD_CLOEXEC
+	case F_DUPFD_CLOEXEC:
+		return PPM_FCNTL_F_DUPFD_CLOEXEC;
+#endif
+	case F_NOTIFY:
+		return PPM_FCNTL_F_NOTIFY;
+#ifdef F_SETPIPE_SZ
+	case F_SETPIPE_SZ:
+		return PPM_FCNTL_F_SETPIPE_SZ;
+#endif
+#ifdef F_GETPIPE_SZ
+	case F_GETPIPE_SZ:
+		return PPM_FCNTL_F_GETPIPE_SZ;
+#endif
+#ifdef F_OFD_GETLK
+	case F_OFD_GETLK:
+		return PPM_FCNTL_F_OFD_GETLK;
+#endif
+#ifdef F_OFD_SETLK
+	case F_OFD_SETLK:
+		return PPM_FCNTL_F_OFD_SETLK;
+#endif
+#ifdef F_OFD_SETLKW
+	case F_OFD_SETLKW:
+		return PPM_FCNTL_F_OFD_SETLKW;
+#endif
+	default:
+		ASSERT(false);
+		return PPM_FCNTL_UNKNOWN;
+	}
+}
+
+static int f_sched_fcntl_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+
+	/*
+	 * fd
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * cmd
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+	res = val_to_ring(args, fcntl_cmd_to_scap(val), 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static inline u16 ptrace_requests_to_scap(unsigned long req)
+{
+	switch (req) {
+#ifdef PTRACE_SINGLEBLOCK
+	case PTRACE_SINGLEBLOCK:
+		return PPM_PTRACE_SINGLEBLOCK;
+#endif
+#ifdef PTRACE_SYSEMU_SINGLESTEP
+	case PTRACE_SYSEMU_SINGLESTEP:
+		return PPM_PTRACE_SYSEMU_SINGLESTEP;
+#endif
+
+#ifdef PTRACE_SYSEMU
+	case PTRACE_SYSEMU:
+		return PPM_PTRACE_SYSEMU;
+#endif
+#ifdef PTRACE_ARCH_PRCTL
+	case PTRACE_ARCH_PRCTL:
+		return PPM_PTRACE_ARCH_PRCTL;
+#endif
+#ifdef PTRACE_SET_THREAD_AREA
+	case PTRACE_SET_THREAD_AREA:
+		return PPM_PTRACE_SET_THREAD_AREA;
+#endif
+#ifdef PTRACE_GET_THREAD_AREA
+	case PTRACE_GET_THREAD_AREA:
+		return PPM_PTRACE_GET_THREAD_AREA;
+#endif
+#ifdef PTRACE_OLDSETOPTIONS
+	case PTRACE_OLDSETOPTIONS:
+		return PPM_PTRACE_OLDSETOPTIONS;
+#endif
+#ifdef PTRACE_SETFPXREGS
+	case PTRACE_SETFPXREGS:
+		return PPM_PTRACE_SETFPXREGS;
+#endif
+#ifdef PTRACE_GETFPXREGS
+	case PTRACE_GETFPXREGS:
+		return PPM_PTRACE_GETFPXREGS;
+#endif
+#ifdef PTRACE_SETFPREGS
+	case PTRACE_SETFPREGS:
+		return PPM_PTRACE_SETFPREGS;
+#endif
+#ifdef PTRACE_GETFPREGS
+	case PTRACE_GETFPREGS:
+		return PPM_PTRACE_GETFPREGS;
+#endif
+#ifdef PTRACE_SETREGS
+	case PTRACE_SETREGS:
+		return PPM_PTRACE_SETREGS;
+#endif
+#ifdef PTRACE_GETREGS
+	case PTRACE_GETREGS:
+		return PPM_PTRACE_GETREGS;
+#endif
+#ifdef PTRACE_SETSIGMASK
+	case PTRACE_SETSIGMASK:
+		return PPM_PTRACE_SETSIGMASK;
+#endif
+#ifdef PTRACE_GETSIGMASK
+	case PTRACE_GETSIGMASK:
+		return PPM_PTRACE_GETSIGMASK;
+#endif
+#ifdef PTRACE_PEEKSIGINFO
+	case PTRACE_PEEKSIGINFO:
+		return PPM_PTRACE_PEEKSIGINFO;
+#endif
+#ifdef PTRACE_LISTEN
+	case PTRACE_LISTEN:
+		return PPM_PTRACE_LISTEN;
+#endif
+#ifdef PTRACE_INTERRUPT
+	case PTRACE_INTERRUPT:
+		return PPM_PTRACE_INTERRUPT;
+#endif
+#ifdef PTRACE_SEIZE
+	case PTRACE_SEIZE:
+		return PPM_PTRACE_SEIZE;
+#endif
+#ifdef PTRACE_SETREGSET
+	case PTRACE_SETREGSET:
+		return PPM_PTRACE_SETREGSET;
+#endif
+#ifdef PTRACE_GETREGSET
+	case PTRACE_GETREGSET:
+		return PPM_PTRACE_GETREGSET;
+#endif
+	case PTRACE_SETSIGINFO:
+		return PPM_PTRACE_SETSIGINFO;
+	case PTRACE_GETSIGINFO:
+		return PPM_PTRACE_GETSIGINFO;
+	case PTRACE_GETEVENTMSG:
+		return PPM_PTRACE_GETEVENTMSG;
+	case PTRACE_SETOPTIONS:
+		return PPM_PTRACE_SETOPTIONS;
+	case PTRACE_SYSCALL:
+		return PPM_PTRACE_SYSCALL;
+	case PTRACE_DETACH:
+		return PPM_PTRACE_DETACH;
+	case PTRACE_ATTACH:
+		return PPM_PTRACE_ATTACH;
+	case PTRACE_SINGLESTEP:
+		return PPM_PTRACE_SINGLESTEP;
+	case PTRACE_KILL:
+		return PPM_PTRACE_KILL;
+	case PTRACE_CONT:
+		return PPM_PTRACE_CONT;
+	case PTRACE_POKEUSR:
+		return PPM_PTRACE_POKEUSR;
+	case PTRACE_POKEDATA:
+		return PPM_PTRACE_POKEDATA;
+	case PTRACE_POKETEXT:
+		return PPM_PTRACE_POKETEXT;
+	case PTRACE_PEEKUSR:
+		return PPM_PTRACE_PEEKUSR;
+	case PTRACE_PEEKDATA:
+		return PPM_PTRACE_PEEKDATA;
+	case PTRACE_PEEKTEXT:
+		return PPM_PTRACE_PEEKTEXT;
+	case PTRACE_TRACEME:
+		return PPM_PTRACE_TRACEME;
+	default:
+		return PPM_PTRACE_UNKNOWN;
+	}
+}
+
+static inline int parse_ptrace_addr(struct event_filler_arguments *args, u16 request)
+{
+	unsigned long val;
+	uint64_t dst;
+	u8 idx;
+
+	syscall_get_arguments(current, args->regs, 2, 1, &val);
+	switch (request) {
+	default:
+		idx = PPM_PTRACE_IDX_UINT64;
+		dst = (uint64_t)val;
+	}
+
+	return val_to_ring(args, dst, 0, false, idx);
+}
+
+static inline int parse_ptrace_data(struct event_filler_arguments *args, u16 request)
+{
+	unsigned long val;
+	unsigned long len;
+	uint64_t dst;
+	u8 idx;
+
+	syscall_get_arguments(current, args->regs, 3, 1, &val);
+	switch (request) {
+	case PPM_PTRACE_PEEKTEXT:
+	case PPM_PTRACE_PEEKDATA:
+	case PPM_PTRACE_PEEKUSR:
+		idx = PPM_PTRACE_IDX_UINT64;
+#ifdef CONFIG_COMPAT
+		if (!args->compat) {
+#endif
+			len = ppm_copy_from_user(&dst, (const void __user *)val, sizeof(long));
+#ifdef CONFIG_COMPAT
+		} else {
+			len = ppm_copy_from_user(&dst, (const void __user *)compat_ptr(val), sizeof(compat_long_t));
+		}
+#endif
+		if (unlikely(len != 0))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+
+		break;
+	case PPM_PTRACE_CONT:
+	case PPM_PTRACE_SINGLESTEP:
+	case PPM_PTRACE_DETACH:
+	case PPM_PTRACE_SYSCALL:
+		idx = PPM_PTRACE_IDX_SIGTYPE;
+		dst = (uint64_t)val;
+		break;
+	case PPM_PTRACE_ATTACH:
+	case PPM_PTRACE_TRACEME:
+	case PPM_PTRACE_POKETEXT:
+	case PPM_PTRACE_POKEDATA:
+	case PPM_PTRACE_POKEUSR:
+	default:
+		idx = PPM_PTRACE_IDX_UINT64;
+		dst = (uint64_t)val;
+		break;
+	}
+
+	return val_to_ring(args, dst, 0, false, idx);
+}
+
+static int f_sys_ptrace_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+
+	/*
+	 * request
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, ptrace_requests_to_scap(val), 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * pid
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_ptrace_x(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int64_t retval;
+	u16 request;
+	int res;
+
+	/*
+	 * res
+	 */
+	retval = (int64_t)(long)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	if (retval < 0) {
+		res = val_to_ring(args, 0, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+		res = val_to_ring(args, 0, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+		return add_sentinel(args);
+	}
+
+	/*
+	 * request
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	request = ptrace_requests_to_scap(val);
+
+	res = parse_ptrace_addr(args, request);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	res = parse_ptrace_data(args, request);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_brk_munmap_mmap_x(struct event_filler_arguments *args)
+{
+	int64_t retval;
+	int res = 0;
+	struct mm_struct *mm = current->mm;
+	long total_vm = 0;
+	long total_rss = 0;
+	long swap = 0;
+
+	retval = (int64_t)(long)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	if (mm) {
+		total_vm = mm->total_vm << (PAGE_SHIFT-10);
+		total_rss = ppm_get_mm_rss(mm) << (PAGE_SHIFT-10);
+		swap = ppm_get_mm_swap(mm) << (PAGE_SHIFT-10);
+	}
+
+	/*
+	 * vm_size
+	 */
+	res = val_to_ring(args, total_vm, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * vm_rss
+	 */
+	res = val_to_ring(args, total_rss, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * vm_swap
+	 */
+	res = val_to_ring(args, swap, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static u32 prot_flags_to_scap(int prot)
+{
+	u32 res = 0;
+
+	if (prot & PROT_READ)
+		res |= PPM_PROT_READ;
+
+	if (prot & PROT_WRITE)
+		res |= PPM_PROT_WRITE;
+
+	if (prot & PROT_EXEC)
+		res |= PPM_PROT_EXEC;
+
+	if (prot & PROT_SEM)
+		res |= PPM_PROT_SEM;
+
+	if (prot & PROT_GROWSDOWN)
+		res |= PPM_PROT_GROWSDOWN;
+
+	if (prot & PROT_GROWSUP)
+		res |= PPM_PROT_GROWSUP;
+
+#ifdef PROT_SAO
+	if (prot & PROT_SAO)
+		res |= PPM_PROT_SAO;
+#endif
+
+	return res;
+}
+
+static u32 mmap_flags_to_scap(int flags)
+{
+	u32 res = 0;
+
+	if (flags & MAP_SHARED)
+		res |= PPM_MAP_SHARED;
+
+	if (flags & MAP_PRIVATE)
+		res |= PPM_MAP_PRIVATE;
+
+	if (flags & MAP_FIXED)
+		res |= PPM_MAP_FIXED;
+
+	if (flags & MAP_ANONYMOUS)
+		res |= PPM_MAP_ANONYMOUS;
+
+#ifdef MAP_32BIT
+	if (flags & MAP_32BIT)
+		res |= PPM_MAP_32BIT;
+#endif
+
+#ifdef MAP_RENAME
+	if (flags & MAP_RENAME)
+		res |= PPM_MAP_RENAME;
+#endif
+
+	if (flags & MAP_NORESERVE)
+		res |= PPM_MAP_NORESERVE;
+
+	if (flags & MAP_POPULATE)
+		res |= PPM_MAP_POPULATE;
+
+	if (flags & MAP_NONBLOCK)
+		res |= PPM_MAP_NONBLOCK;
+
+	if (flags & MAP_GROWSDOWN)
+		res |= PPM_MAP_GROWSDOWN;
+
+	if (flags & MAP_DENYWRITE)
+		res |= PPM_MAP_DENYWRITE;
+
+	if (flags & MAP_EXECUTABLE)
+		res |= PPM_MAP_EXECUTABLE;
+
+#ifdef MAP_INHERIT
+	if (flags & MAP_INHERIT)
+		res |= PPM_MAP_INHERIT;
+#endif
+
+	if (flags & MAP_FILE)
+		res |= PPM_MAP_FILE;
+
+	if (flags & MAP_LOCKED)
+		res |= PPM_MAP_LOCKED;
+
+	return res;
+}
+
+static int f_sys_mmap_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+
+	/*
+	 * addr
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * length
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * prot
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &val);
+	res = val_to_ring(args, prot_flags_to_scap(val), 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * flags
+	 */
+	syscall_get_arguments(current, args->regs, 3, 1, &val);
+	res = val_to_ring(args, mmap_flags_to_scap(val), 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * fd
+	 */
+	syscall_get_arguments(current, args->regs, 4, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * offset/pgoffset
+	 */
+	syscall_get_arguments(current, args->regs, 5, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_renameat_x(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	int64_t retval;
+
+	retval = (int64_t)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * olddirfd
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+
+	if ((int)val == AT_FDCWD)
+		val = PPM_AT_FDCWD;
+
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * oldpath
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * newdirfd
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &val);
+
+	if ((int)val == AT_FDCWD)
+		val = PPM_AT_FDCWD;
+
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * newpath
+	 */
+	syscall_get_arguments(current, args->regs, 3, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_symlinkat_x(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	int64_t retval;
+
+	retval = (int64_t)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * oldpath
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * newdirfd
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+
+	if ((int)val == AT_FDCWD)
+		val = PPM_AT_FDCWD;
+
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * newpath
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_procexit_e(struct event_filler_arguments *args)
+{
+	int res;
+
+	if (args->sched_prev == NULL) {
+		ASSERT(false);
+		return -1;
+	}
+
+	/*
+	 * status
+	 */
+	res = val_to_ring(args, args->sched_prev->exit_code, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_sendfile_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	off_t offset;
+
+	/*
+	 * out_fd
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * in_fd
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * offset
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &val);
+
+	if (val != 0) {
+#ifdef CONFIG_COMPAT
+		if (!args->compat) {
+#endif
+			res = ppm_copy_from_user(&offset, (void *)val, sizeof(off_t));
+#ifdef CONFIG_COMPAT
+		} else {
+			res = ppm_copy_from_user(&offset, (void *)compat_ptr(val), sizeof(compat_off_t));
+		}
+#endif
+		if (unlikely(res))
+			val = 0;
+		else
+			val = offset;
+	}
+
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * size
+	 */
+	syscall_get_arguments(current, args->regs, 3, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_sendfile_x(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	int64_t retval;
+	off_t offset;
+
+	/*
+	 * res
+	 */
+	retval = (int64_t)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * offset
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &val);
+
+	if (val != 0) {
+#ifdef CONFIG_COMPAT
+		if (!args->compat) {
+#endif
+			res = ppm_copy_from_user(&offset, (void *)val, sizeof(off_t));
+#ifdef CONFIG_COMPAT
+		} else {
+			res = ppm_copy_from_user(&offset, (void *)compat_ptr(val), sizeof(compat_off_t));
+		}
+#endif
+		if (unlikely(res))
+			val = 0;
+		else
+			val = offset;
+	}
+
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static inline uint8_t quotactl_type_to_scap(unsigned long cmd)
+{
+	switch (cmd & SUBCMDMASK) {
+	case USRQUOTA:
+		return PPM_USRQUOTA;
+	case GRPQUOTA:
+		return PPM_GRPQUOTA;
+	}
+	return 0;
+}
+
+static inline uint16_t quotactl_cmd_to_scap(unsigned long cmd)
+{
+	uint16_t res;
+
+	switch (cmd >> SUBCMDSHIFT) {
+	case Q_SYNC:
+		res = PPM_Q_SYNC;
+		break;
+	case Q_QUOTAON:
+		res = PPM_Q_QUOTAON;
+		break;
+	case Q_QUOTAOFF:
+		res = PPM_Q_QUOTAOFF;
+		break;
+	case Q_GETFMT:
+		res = PPM_Q_GETFMT;
+		break;
+	case Q_GETINFO:
+		res = PPM_Q_GETINFO;
+		break;
+	case Q_SETINFO:
+		res = PPM_Q_SETINFO;
+		break;
+	case Q_GETQUOTA:
+		res = PPM_Q_GETQUOTA;
+		break;
+	case Q_SETQUOTA:
+		res = PPM_Q_SETQUOTA;
+		break;
+	/*
+	 *  XFS specific
+	 */
+	case Q_XQUOTAON:
+		res = PPM_Q_XQUOTAON;
+		break;
+	case Q_XQUOTAOFF:
+		res = PPM_Q_XQUOTAOFF;
+		break;
+	case Q_XGETQUOTA:
+		res = PPM_Q_XGETQUOTA;
+		break;
+	case Q_XSETQLIM:
+		res = PPM_Q_XSETQLIM;
+		break;
+	case Q_XGETQSTAT:
+		res = PPM_Q_XGETQSTAT;
+		break;
+	case Q_XQUOTARM:
+		res = PPM_Q_XQUOTARM;
+		break;
+	case Q_XQUOTASYNC:
+		res = PPM_Q_XQUOTASYNC;
+		break;
+	default:
+		res = 0;
+	}
+	return res;
+}
+
+static inline uint8_t quotactl_fmt_to_scap(unsigned long fmt)
+{
+	switch (fmt) {
+	case QFMT_VFS_OLD:
+		return PPM_QFMT_VFS_OLD;
+	case QFMT_VFS_V0:
+		return PPM_QFMT_VFS_V0;
+#ifdef QFMT_VFS_V1
+	case QFMT_VFS_V1:
+		return PPM_QFMT_VFS_V1;
+#endif
+	default:
+		return PPM_QFMT_NOT_USED;
+	}
+}
+
+static int f_sys_quotactl_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	uint32_t id;
+	uint8_t quota_fmt;
+	uint16_t cmd;
+
+	/*
+	 * extract cmd
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	cmd = quotactl_cmd_to_scap(val);
+	res = val_to_ring(args, cmd, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * extract type
+	 */
+	res = val_to_ring(args, quotactl_type_to_scap(val), 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 *  extract id
+	 */
+	id = 0;
+	syscall_get_arguments(current, args->regs, 2, 1, &val);
+	if ((cmd == PPM_Q_GETQUOTA) ||
+		 (cmd == PPM_Q_SETQUOTA) ||
+		 (cmd == PPM_Q_XGETQUOTA) ||
+		 (cmd == PPM_Q_XSETQLIM)) {
+		/*
+		 * in this case id represent an userid or groupid so add it
+		 */
+		id = val;
+	}
+	res = val_to_ring(args, id, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * extract quota_fmt from id
+	 */
+	quota_fmt = PPM_QFMT_NOT_USED;
+	if (cmd == PPM_Q_QUOTAON)
+		quota_fmt = quotactl_fmt_to_scap(val);
+
+	res = val_to_ring(args, quota_fmt, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_quotactl_x(struct event_filler_arguments *args)
+{
+	unsigned long val, len;
+	int res;
+	int64_t retval;
+	uint16_t cmd;
+	struct if_dqblk dqblk;
+	struct if_dqinfo dqinfo;
+	uint32_t quota_fmt_out;
+
+	const char empty_string[] = "";
+
+	/*
+	 * extract cmd
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	cmd = quotactl_cmd_to_scap(val);
+
+	/*
+	 * return value
+	 */
+	retval = (int64_t)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * Add special
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * get addr
+	 */
+	syscall_get_arguments(current, args->regs, 3, 1, &val);
+
+	/*
+	 * get quotafilepath only for QUOTAON
+	 */
+	if (cmd == PPM_Q_QUOTAON)
+		res = val_to_ring(args, val, 0, true, 0);
+	else
+		res = val_to_ring(args, (unsigned long)empty_string, 0, false, 0);
+
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+
+	/*
+	 * dqblk fields if present
+	 */
+	dqblk.dqb_valid = 0;
+	if ((cmd == PPM_Q_GETQUOTA) || (cmd == PPM_Q_SETQUOTA)) {
+		len = ppm_copy_from_user(&dqblk, (void *)val, sizeof(struct if_dqblk));
+		if (unlikely(len != 0))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+	}
+	if (dqblk.dqb_valid & QIF_BLIMITS) {
+		res = val_to_ring(args, dqblk.dqb_bhardlimit, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+		res = val_to_ring(args, dqblk.dqb_bsoftlimit, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	} else {
+		res = val_to_ring(args, 0, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+		res = val_to_ring(args, 0, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	}
+
+	if (dqblk.dqb_valid & QIF_SPACE) {
+		res = val_to_ring(args, dqblk.dqb_curspace, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	} else {
+		res = val_to_ring(args, 0, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	}
+
+	if (dqblk.dqb_valid & QIF_ILIMITS) {
+		res = val_to_ring(args, dqblk.dqb_ihardlimit, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+		res = val_to_ring(args, dqblk.dqb_isoftlimit, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	} else {
+		res = val_to_ring(args, 0, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+		res = val_to_ring(args, 0, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	}
+
+	if (dqblk.dqb_valid & QIF_BTIME) {
+		res = val_to_ring(args, dqblk.dqb_btime, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	} else {
+		res = val_to_ring(args, 0, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	}
+
+	if (dqblk.dqb_valid & QIF_ITIME) {
+		res = val_to_ring(args, dqblk.dqb_itime, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	} else {
+		res = val_to_ring(args, 0, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	}
+
+	/*
+	 * dqinfo fields if present
+	 */
+	dqinfo.dqi_valid = 0;
+	if ((cmd == PPM_Q_GETINFO) || (cmd == PPM_Q_SETINFO)) {
+		len = ppm_copy_from_user(&dqinfo, (void *)val, sizeof(struct if_dqinfo));
+		if (unlikely(len != 0))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+	}
+
+	if (dqinfo.dqi_valid & IIF_BGRACE) {
+		res = val_to_ring(args, dqinfo.dqi_bgrace, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	} else {
+		res = val_to_ring(args, 0, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	}
+
+	if (dqinfo.dqi_valid & IIF_IGRACE) {
+		res = val_to_ring(args, dqinfo.dqi_igrace, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	} else {
+		res = val_to_ring(args, 0, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	}
+
+	if (dqinfo.dqi_valid & IIF_FLAGS) {
+		res = val_to_ring(args, dqinfo.dqi_flags, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	} else {
+		res = val_to_ring(args, 0, 0, false, 0);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+	}
+
+	quota_fmt_out = PPM_QFMT_NOT_USED;
+	if (cmd == PPM_Q_GETFMT) {
+		len = ppm_copy_from_user(&quota_fmt_out, (void *)val, sizeof(uint32_t));
+		if (unlikely(len != 0))
+			return PPM_FAILURE_INVALID_USER_MEMORY;
+		quota_fmt_out = quotactl_fmt_to_scap(quota_fmt_out);
+	}
+	res = val_to_ring(args, quota_fmt_out, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_sysdigevent_e(struct event_filler_arguments *args)
+{
+	int res;
+
+	/*
+	 * event_type
+	 */
+	res = val_to_ring(args, (unsigned long)args->sched_prev, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * event_data
+	 */
+	res = val_to_ring(args, (unsigned long)args->sched_next, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_getresuid_and_gid_x(struct event_filler_arguments *args)
+{
+	int res;
+	unsigned long val, len;
+	uint32_t uid;
+	int16_t retval;
+
+	/*
+	 * return value
+	 */
+	retval = (int64_t)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * ruid
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+#ifdef CONFIG_COMPAT
+	if (!args->compat) {
+#endif
+		len = ppm_copy_from_user(&uid, (void *)val, sizeof(uint32_t));
+#ifdef CONFIG_COMPAT
+	} else {
+		len = ppm_copy_from_user(&uid, (void *)compat_ptr(val), sizeof(uint32_t));
+	}
+#endif
+	if (unlikely(len != 0))
+		return PPM_FAILURE_INVALID_USER_MEMORY;
+
+	res = val_to_ring(args, uid, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * euid
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+	len = ppm_copy_from_user(&uid, (void *)val, sizeof(uint32_t));
+	if (unlikely(len != 0))
+		return PPM_FAILURE_INVALID_USER_MEMORY;
+
+	res = val_to_ring(args, uid, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * suid
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &val);
+	len = ppm_copy_from_user(&uid, (void *)val, sizeof(uint32_t));
+	if (unlikely(len != 0))
+		return PPM_FAILURE_INVALID_USER_MEMORY;
+
+	res = val_to_ring(args, uid, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static inline u32 flock_flags_to_scap(unsigned long flags)
+{
+	u32 res = 0;
+
+	if (flags & LOCK_EX)
+		res |= PPM_LOCK_EX;
+
+	if (flags & LOCK_SH)
+		res |= PPM_LOCK_SH;
+
+	if (flags & LOCK_UN)
+		res |= PPM_LOCK_UN;
+
+	if (flags & LOCK_NB)
+		res |= PPM_LOCK_NB;
+
+	return res;
+}
+
+static int f_sys_flock_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	u32 flags;
+
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+	flags = flock_flags_to_scap(val);
+	res = val_to_ring(args, flags, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_setns_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	u32 flags;
+
+	/*
+	 * parse fd
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * get type, parse as clone flags as it's a subset of it
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+	flags = clone_flags_to_scap(val);
+	res = val_to_ring(args, flags, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_unshare_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	u32 flags;
+
+	/*
+	 * get type, parse as clone flags as it's a subset of it
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	flags = clone_flags_to_scap(val);
+	res = val_to_ring(args, flags, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+#ifdef CAPTURE_SIGNAL_DELIVERIES
+static int f_sys_signaldeliver_e(struct event_filler_arguments *args)
+{
+	int res;
+
+	/*
+	 * source pid
+	 */
+	res = val_to_ring(args, args->spid, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * destination pid
+	 */
+	res = val_to_ring(args, args->dpid, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * signal number
+	 */
+	res = val_to_ring(args, args->signo, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+#endif
+
+#ifdef CAPTURE_PAGE_FAULTS
+static inline u32 pf_flags_to_scap(unsigned long flags)
+{
+	u32 res = 0;
+
+	/* Page fault error codes don't seem to be clearly defined in header
+	 * files througout the kernel except in some emulation modes (e.g. kvm)
+	 * which we can't assume to exist, so I just took the definitions from
+	 * the x86 manual. If we end up supporting another arch for page faults,
+	 * refactor this.
+	 */
+	if (flags & 0x1)
+		res |= PPM_PF_PROTECTION_VIOLATION;
+	else
+		res |= PPM_PF_PAGE_NOT_PRESENT;
+
+	if (flags & 0x2)
+		res |= PPM_PF_WRITE_ACCESS;
+	else
+		res |= PPM_PF_READ_ACCESS;
+
+	if (flags & 0x4)
+		res |= PPM_PF_USER_FAULT;
+	else
+		res |= PPM_PF_SUPERVISOR_FAULT;
+
+	if (flags & 0x8)
+		res |= PPM_PF_RESERVED_PAGE;
+
+	if (flags & 0x10)
+		res |= PPM_PF_INSTRUCTION_FETCH;
+
+	return res;
+}
+
+static int f_sys_pagefault_e(struct event_filler_arguments *args)
+{
+	int res;
+
+	res = val_to_ring(args, args->fault_data.address, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	res = val_to_ring(args, args->fault_data.regs->ip, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	res = val_to_ring(args, pf_flags_to_scap(args->fault_data.error_code), 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+#endif
+
+static int f_cpu_hotplug_e(struct event_filler_arguments *args)
+{
+	int res;
+
+	/*
+	 * cpu
+	 */
+	res = val_to_ring(args, (uint64_t)args->sched_prev, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * action
+	 */
+	res = val_to_ring(args, (uint64_t)args->sched_next, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static inline u16 semop_flags_to_scap(short flags)
+{
+	u16 res = 0;
+
+	if (flags & IPC_NOWAIT)
+		res |= PPM_IPC_NOWAIT;
+
+	if (flags & SEM_UNDO)
+		res |= PPM_SEM_UNDO;
+
+	return res;
+}
+
+static int f_sys_semop_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+
+	/*
+	 * semid
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_semop_x(struct event_filler_arguments *args)
+{
+	unsigned long nsops;
+	int res;
+	int64_t retval;
+	struct sembuf *ptr;
+
+	/*
+	 * return value
+	 */
+	retval = (int64_t)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * nsops
+	 * actually this could be read in the enter function but
+	 * we also need to know the value to access the sembuf structs
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &nsops);
+	res = val_to_ring(args, nsops, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * sembuf
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, (unsigned long *) &ptr);
+
+	if (nsops && ptr) {
+		/* max length of sembuf array in g_event_info = 2 */
+		const unsigned max_nsops = 2;
+		unsigned       j;
+
+		for (j = 0; j < max_nsops; j++) {
+			struct sembuf sops = {0, 0, 0};
+
+			if (nsops--)
+				if (unlikely(ppm_copy_from_user(&sops, (void *)&ptr[j], sizeof(struct sembuf))))
+					return PPM_FAILURE_INVALID_USER_MEMORY;
+
+			res = val_to_ring(args, sops.sem_num, 0, true, 0);
+			if (unlikely(res != PPM_SUCCESS))
+				return res;
+
+			res = val_to_ring(args, sops.sem_op, 0, true, 0);
+			if (unlikely(res != PPM_SUCCESS))
+				return res;
+
+			res = val_to_ring(args, semop_flags_to_scap(sops.sem_flg), 0, true, 0);
+			if (unlikely(res != PPM_SUCCESS))
+				return res;
+		}
+	}
+
+	return add_sentinel(args);
+}
+
+static inline u32 semget_flags_to_scap(unsigned flags)
+{
+	u32 res = 0;
+
+	if (flags & IPC_CREAT)
+		res |= PPM_IPC_CREAT;
+
+	if (flags & IPC_EXCL)
+		res |= PPM_IPC_EXCL;
+
+	return res;
+}
+
+static int f_sys_semget_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+
+	/*
+	 * key
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * nsems
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * semflg
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &val);
+	res = val_to_ring(args, semget_flags_to_scap(val), 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static inline u32 semctl_cmd_to_scap(unsigned cmd)
+{
+	switch (cmd) {
+	case IPC_STAT: return PPM_IPC_STAT;
+	case IPC_SET: return PPM_IPC_SET;
+	case IPC_RMID: return PPM_IPC_RMID;
+	case IPC_INFO: return PPM_IPC_INFO;
+	case SEM_INFO: return PPM_SEM_INFO;
+	case SEM_STAT: return PPM_SEM_STAT;
+	case GETALL: return PPM_GETALL;
+	case GETNCNT: return PPM_GETNCNT;
+	case GETPID: return PPM_GETPID;
+	case GETVAL: return PPM_GETVAL;
+	case GETZCNT: return PPM_GETZCNT;
+	case SETALL: return PPM_SETALL;
+	case SETVAL: return PPM_SETVAL;
+	}
+	return 0;
+}
+
+static int f_sys_semctl_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+
+	/*
+	 * semid
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * semnum
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * cmd
+	 */
+	syscall_get_arguments(current, args->regs, 2, 1, &val);
+	res = val_to_ring(args, semctl_cmd_to_scap(val), 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * optional argument semun/val
+	 */
+	if (val == SETVAL)
+		syscall_get_arguments(current, args->regs, 3, 1, &val);
+	else
+		val = 0;
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_semctl_x(struct event_filler_arguments *args)
+{
+	int res;
+	int64_t retval;
+
+	/*
+	 * return value
+	 */
+	retval = (int64_t)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static inline u32 access_flags_to_scap(unsigned flags)
+{
+	u32 res = 0;
+
+	if (flags == 0/*F_OK*/) {
+		res = PPM_F_OK;
+	} else {
+		if (flags & MAY_EXEC)
+			res |= PPM_X_OK;
+		if (flags & MAY_READ)
+			res |= PPM_R_OK;
+		if (flags & MAY_WRITE)
+			res |= PPM_W_OK;
+	}
+
+	return res;
+}
+
+static int f_sys_access_e(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+
+	/*
+	 * mode
+	 */
+	syscall_get_arguments(current, args->regs, 1, 1, &val);
+	res = val_to_ring(args, access_flags_to_scap(val), 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_access_x(struct event_filler_arguments *args)
+{
+	unsigned long val;
+	int res;
+	int64_t retval;
+
+	/*
+	 * return value
+	 */
+	retval = (int64_t)syscall_get_return_value(current, args->regs);
+	res = val_to_ring(args, retval, 0, false, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	/*
+	 * pathname
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &val);
+	res = val_to_ring(args, val, 0, true, 0);
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
+
+static int f_sys_bpf_x(struct event_filler_arguments *args)
+{
+	int64_t retval;
+	unsigned long cmd;
+	int res;
+
+	/*
+	 * res, if failure or depending on cmd
+	 */
+	retval = (int64_t)(long)syscall_get_return_value(current, args->regs);
+	if (retval < 0) {
+		res = val_to_ring(args, retval, 0, false, PPM_BPF_IDX_RES);
+		if (unlikely(res != PPM_SUCCESS))
+			return res;
+
+		return add_sentinel(args);
+	}
+	/*
+	 * fd, depending on cmd
+	 */
+	syscall_get_arguments(current, args->regs, 0, 1, &cmd);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+	if(cmd == BPF_MAP_CREATE || cmd == BPF_PROG_LOAD)
+#else
+	if(0)
+#endif
+	{
+		res = val_to_ring(args, retval, 0, false, PPM_BPF_IDX_FD);
+	}
+	else
+	{
+		res = val_to_ring(args, retval, 0, false, PPM_BPF_IDX_RES);
+	}
+	if (unlikely(res != PPM_SUCCESS))
+		return res;
+
+	return add_sentinel(args);
+}
diff --git a/kernel/trace/sysdig/ppm_ringbuffer.h b/kernel/trace/sysdig/ppm_ringbuffer.h
new file mode 100644
index 0000000..5b23ad5
--- /dev/null
+++ b/kernel/trace/sysdig/ppm_ringbuffer.h
@@ -0,0 +1,42 @@
+/*
+Copyright (C) 2013-2014 Draios inc.
+
+This file is part of sysdig.
+
+sysdig is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License version 2 as
+published by the Free Software Foundation.
+
+sysdig is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with sysdig.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef PPM_H_
+#define PPM_H_
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#endif
+
+static const __u32 RING_BUF_SIZE = 8 * 1024 * 1024;
+static const __u32 MIN_USERSPACE_READ_SIZE = 128 * 1024;
+
+/*
+ * This gets mapped to user level, so we want to keep it as clean as possible
+ */
+struct ppm_ring_buffer_info {
+	volatile __u32 head;
+	volatile __u32 tail;
+	volatile __u64 n_evts;			/* Total number of events that were received by the driver. */
+	volatile __u64 n_drops_buffer;		/* Number of dropped events (buffer full). */
+	volatile __u64 n_drops_pf;		/* Number of dropped events (page faults). */
+	volatile __u64 n_preemptions;		/* Number of preemptions. */
+	volatile __u64 n_context_switches;	/* Number of received context switch events. */
+};
+
+#endif /* PPM_H_ */
diff --git a/kernel/trace/sysdig/ppm_syscall.h b/kernel/trace/sysdig/ppm_syscall.h
new file mode 100644
index 0000000..deace07
--- /dev/null
+++ b/kernel/trace/sysdig/ppm_syscall.h
@@ -0,0 +1,229 @@
+/*
+ * Access to user system call parameters and results
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc.  All rights reserved.
+ *
+ * This copyrighted material is made available to anyone wishing to use,
+ * modify, copy, or redistribute it subject to the terms and conditions
+ * of the GNU General Public License v.2.
+ *
+ * See asm-generic/syscall.h for descriptions of what we must do here.
+ */
+
+#ifndef _ASM_X86_SYSCALL_H
+#define _ASM_X86_SYSCALL_H
+
+//#include <uapi/linux/audit.h>
+#include <linux/sched.h>
+#include <linux/err.h>
+#include <asm/asm-offsets.h>	/* For NR_syscalls */
+#include <asm/thread_info.h>	/* for TS_COMPAT */
+#include <asm/unistd.h>
+
+#ifndef NS_syscalls
+#define NR_syscalls (__NR_syscall_max + 1)
+#endif
+
+typedef void (*sys_call_ptr_t)(void);
+extern const sys_call_ptr_t sys_call_table[];
+
+/*
+ * Only the low 32 bits of orig_ax are meaningful, so we return int.
+ * This importantly ignores the high bits on 64-bit, so comparisons
+ * sign-extend the low 32 bits.
+ */
+static inline int syscall_get_nr(struct task_struct *task, struct pt_regs *regs)
+{
+	return regs->orig_rax;
+}
+
+static inline void syscall_rollback(struct task_struct *task,
+				    struct pt_regs *regs)
+{
+	regs->rax = regs->orig_rax;
+}
+
+static inline long syscall_get_error(struct task_struct *task,
+				     struct pt_regs *regs)
+{
+	unsigned long error = regs->rax;
+#ifdef CONFIG_IA32_EMULATION
+	/*
+	 * TS_COMPAT is set for 32-bit syscall entries and then
+	 * remains set until we return to user mode.
+	 */
+	if (task_thread_info(task)->status & TS_COMPAT)
+		/*
+		 * Sign-extend the value so (int)-EFOO becomes (long)-EFOO
+		 * and will match correctly in comparisons.
+		 */
+		error = (long) (int) error;
+#endif
+	return IS_ERR_VALUE(error) ? error : 0;
+}
+
+static inline long syscall_get_return_value(struct task_struct *task,
+					    struct pt_regs *regs)
+{
+	return regs->rax;
+}
+
+static inline void syscall_set_return_value(struct task_struct *task,
+					    struct pt_regs *regs,
+					    int error, long val)
+{
+	regs->rax = (long) error ?: val;
+}
+
+#ifdef CONFIG_X86_32
+
+static inline void syscall_get_arguments(struct task_struct *task,
+					 struct pt_regs *regs,
+					 unsigned int i, unsigned int n,
+					 unsigned long *args)
+{
+	BUG_ON(i + n > 6);
+	memcpy(args, &regs->rbx + i, n * sizeof(args[0]));
+}
+
+static inline void syscall_set_arguments(struct task_struct *task,
+					 struct pt_regs *regs,
+					 unsigned int i, unsigned int n,
+					 const unsigned long *args)
+{
+	BUG_ON(i + n > 6);
+	memcpy(&regs->rbx + i, args, n * sizeof(args[0]));
+}
+
+static inline int syscall_get_arch(void)
+{
+	return AUDIT_ARCH_I386;
+}
+
+#else	 /* CONFIG_X86_64 */
+
+static inline void syscall_get_arguments(struct task_struct *task,
+					 struct pt_regs *regs,
+					 unsigned int i, unsigned int n,
+					 unsigned long *args)
+{
+# ifdef CONFIG_IA32_EMULATION
+	if (task_thread_info(task)->status & TS_COMPAT)
+		switch (i) {
+		case 0:
+			if (!n--) break;
+			*args++ = regs->rbx;
+		case 1:
+			if (!n--) break;
+			*args++ = regs->rcx;
+		case 2:
+			if (!n--) break;
+			*args++ = regs->rdx;
+		case 3:
+			if (!n--) break;
+			*args++ = regs->rsi;
+		case 4:
+			if (!n--) break;
+			*args++ = regs->rdi;
+		case 5:
+			if (!n--) break;
+			*args++ = regs->rbp;
+		case 6:
+			if (!n--) break;
+		default:
+			BUG();
+			break;
+		}
+	else
+# endif
+		switch (i) {
+		case 0:
+			if (!n--) break;
+			*args++ = regs->rdi;
+		case 1:
+			if (!n--) break;
+			*args++ = regs->rsi;
+		case 2:
+			if (!n--) break;
+			*args++ = regs->rdx;
+		case 3:
+			if (!n--) break;
+			*args++ = regs->r10;
+		case 4:
+			if (!n--) break;
+			*args++ = regs->r8;
+		case 5:
+			if (!n--) break;
+			*args++ = regs->r9;
+		case 6:
+			if (!n--) break;
+		default:
+			BUG();
+			break;
+		}
+}
+
+static inline void syscall_set_arguments(struct task_struct *task,
+					 struct pt_regs *regs,
+					 unsigned int i, unsigned int n,
+					 const unsigned long *args)
+{
+# ifdef CONFIG_IA32_EMULATION
+	if (task_thread_info(task)->status & TS_COMPAT)
+		switch (i) {
+		case 0:
+			if (!n--) break;
+			regs->rbx = *args++;
+		case 1:
+			if (!n--) break;
+			regs->rcx = *args++;
+		case 2:
+			if (!n--) break;
+			regs->rdx = *args++;
+		case 3:
+			if (!n--) break;
+			regs->rsi = *args++;
+		case 4:
+			if (!n--) break;
+			regs->rdi = *args++;
+		case 5:
+			if (!n--) break;
+			regs->rbp = *args++;
+		case 6:
+			if (!n--) break;
+		default:
+			BUG();
+			break;
+		}
+	else
+# endif
+		switch (i) {
+		case 0:
+			if (!n--) break;
+			regs->rdi = *args++;
+		case 1:
+			if (!n--) break;
+			regs->rsi = *args++;
+		case 2:
+			if (!n--) break;
+			regs->rdx = *args++;
+		case 3:
+			if (!n--) break;
+			regs->r10 = *args++;
+		case 4:
+			if (!n--) break;
+			regs->r8 = *args++;
+		case 5:
+			if (!n--) break;
+			regs->r9 = *args++;
+		case 6:
+			if (!n--) break;
+		default:
+			BUG();
+			break;
+		}
+}
+
+#endif	/* CONFIG_X86_32 */
+
+#endif	/* _ASM_X86_SYSCALL_H */
diff --git a/kernel/trace/sysdig/syscall_table.c b/kernel/trace/sysdig/syscall_table.c
new file mode 100644
index 0000000..8b2f9c3
--- /dev/null
+++ b/kernel/trace/sysdig/syscall_table.c
@@ -0,0 +1,1623 @@
+/*
+Copyright (C) 2013-2014 Draios inc.
+
+This file is part of sysdig.
+
+sysdig is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License version 2 as
+published by the Free Software Foundation.
+
+sysdig is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with sysdig.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <linux/kobject.h>
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/kdev_t.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/version.h>
+#include <linux/wait.h>
+#include <net/sock.h>
+#include <asm/unistd.h>
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 20)
+#include "ppm_syscall.h"
+#else
+#include <asm/syscall.h>
+#endif
+
+#include "ppm_ringbuffer.h"
+#include "ppm_events_public.h"
+#include "ppm_events.h"
+#include "ppm.h"
+#if defined(CONFIG_IA32_EMULATION) && !defined(__NR_ia32_socketcall)
+#include "ppm_compat_unistd_32.h"
+#endif
+
+/*
+ * SYSCALL TABLE
+ */
+const struct syscall_evt_pair g_syscall_table[SYSCALL_TABLE_SIZE] = {
+	[__NR_open - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_OPEN_E, PPME_SYSCALL_OPEN_X},
+	[__NR_creat - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_CREAT_E, PPME_SYSCALL_CREAT_X},
+	[__NR_close - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_CLOSE_E, PPME_SYSCALL_CLOSE_X},
+	[__NR_brk - SYSCALL_TABLE_ID0] =                        {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_BRK_4_E, PPME_SYSCALL_BRK_4_X},
+	[__NR_read - SYSCALL_TABLE_ID0] =                       {UF_USED, PPME_SYSCALL_READ_E, PPME_SYSCALL_READ_X},
+	[__NR_write - SYSCALL_TABLE_ID0] =                      {UF_USED, PPME_SYSCALL_WRITE_E, PPME_SYSCALL_WRITE_X},
+	[__NR_execve - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_EXECVE_18_E, PPME_SYSCALL_EXECVE_18_X},
+	[__NR_clone - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_CLONE_20_E, PPME_SYSCALL_CLONE_20_X},
+	[__NR_fork - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_FORK_20_E, PPME_SYSCALL_FORK_20_X},
+	[__NR_vfork - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_VFORK_20_E, PPME_SYSCALL_VFORK_20_X},
+	[__NR_pipe - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_PIPE_E, PPME_SYSCALL_PIPE_X},
+	[__NR_pipe2 - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_PIPE_E, PPME_SYSCALL_PIPE_X},
+	[__NR_eventfd - SYSCALL_TABLE_ID0] =                    {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_EVENTFD_E, PPME_SYSCALL_EVENTFD_X},
+	[__NR_eventfd2 - SYSCALL_TABLE_ID0] =                   {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_EVENTFD_E, PPME_SYSCALL_EVENTFD_X},
+	[__NR_futex - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_FUTEX_E, PPME_SYSCALL_FUTEX_X},
+	[__NR_stat - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_STAT_E, PPME_SYSCALL_STAT_X},
+	[__NR_lstat - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_LSTAT_E, PPME_SYSCALL_LSTAT_X},
+	[__NR_fstat - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_FSTAT_E, PPME_SYSCALL_FSTAT_X},
+	[__NR_epoll_wait - SYSCALL_TABLE_ID0] =                 {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_EPOLLWAIT_E, PPME_SYSCALL_EPOLLWAIT_X},
+	[__NR_poll - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_POLL_E, PPME_SYSCALL_POLL_X},
+#ifdef __NR_select
+	[__NR_select - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_SELECT_E, PPME_SYSCALL_SELECT_X},
+#endif
+	[__NR_lseek - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_LSEEK_E, PPME_SYSCALL_LSEEK_X},
+	[__NR_ioctl - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_IOCTL_3_E, PPME_SYSCALL_IOCTL_3_X},
+	[__NR_getcwd - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_GETCWD_E, PPME_SYSCALL_GETCWD_X},
+	[__NR_chdir - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_CHDIR_E, PPME_SYSCALL_CHDIR_X},
+	[__NR_fchdir - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_FCHDIR_E, PPME_SYSCALL_FCHDIR_X},
+	[__NR_mkdir - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_MKDIR_2_E, PPME_SYSCALL_MKDIR_2_X},
+	[__NR_rmdir - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_RMDIR_2_E, PPME_SYSCALL_RMDIR_2_X},
+	[__NR_openat - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_OPENAT_E, PPME_SYSCALL_OPENAT_X},
+	[__NR_link - SYSCALL_TABLE_ID0] =                       {UF_USED, PPME_SYSCALL_LINK_E, PPME_SYSCALL_LINK_X},
+	[__NR_linkat - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_LINKAT_E, PPME_SYSCALL_LINKAT_X},
+	[__NR_unlink - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_UNLINK_E, PPME_SYSCALL_UNLINK_X},
+	[__NR_unlinkat - SYSCALL_TABLE_ID0] =                   {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_UNLINKAT_E, PPME_SYSCALL_UNLINKAT_X},
+	[__NR_pread64 - SYSCALL_TABLE_ID0] =                    {UF_USED, PPME_SYSCALL_PREAD_E, PPME_SYSCALL_PREAD_X},
+	[__NR_pwrite64 - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SYSCALL_PWRITE_E, PPME_SYSCALL_PWRITE_X},
+	[__NR_readv - SYSCALL_TABLE_ID0] =                      {UF_USED, PPME_SYSCALL_READV_E, PPME_SYSCALL_READV_X},
+	[__NR_writev - SYSCALL_TABLE_ID0] =                     {UF_USED, PPME_SYSCALL_WRITEV_E, PPME_SYSCALL_WRITEV_X},
+	[__NR_preadv - SYSCALL_TABLE_ID0] =                     {UF_USED, PPME_SYSCALL_PREADV_E, PPME_SYSCALL_PREADV_X},
+	[__NR_pwritev - SYSCALL_TABLE_ID0] =                    {UF_USED, PPME_SYSCALL_PWRITEV_E, PPME_SYSCALL_PWRITEV_X},
+	[__NR_dup - SYSCALL_TABLE_ID0] =                        {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_DUP_E, PPME_SYSCALL_DUP_X},
+	[__NR_dup2 - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_DUP_E, PPME_SYSCALL_DUP_X},
+	[__NR_dup3 - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_DUP_E, PPME_SYSCALL_DUP_X},
+	[__NR_signalfd - SYSCALL_TABLE_ID0] =                   {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_SIGNALFD_E, PPME_SYSCALL_SIGNALFD_X},
+	[__NR_signalfd4 - SYSCALL_TABLE_ID0] =                  {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_SIGNALFD_E, PPME_SYSCALL_SIGNALFD_X},
+	[__NR_kill - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_KILL_E, PPME_SYSCALL_KILL_X},
+	[__NR_tkill - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_TKILL_E, PPME_SYSCALL_TKILL_X},
+	[__NR_tgkill - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_TGKILL_E, PPME_SYSCALL_TGKILL_X},
+	[__NR_nanosleep - SYSCALL_TABLE_ID0] =                  {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_NANOSLEEP_E, PPME_SYSCALL_NANOSLEEP_X},
+	[__NR_timerfd_create - SYSCALL_TABLE_ID0] =             {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_TIMERFD_CREATE_E, PPME_SYSCALL_TIMERFD_CREATE_X},
+	[__NR_inotify_init - SYSCALL_TABLE_ID0] =               {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_INOTIFY_INIT_E, PPME_SYSCALL_INOTIFY_INIT_X},
+	[__NR_inotify_init1 - SYSCALL_TABLE_ID0] =              {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_INOTIFY_INIT_E, PPME_SYSCALL_INOTIFY_INIT_X},
+#ifdef __NR_getrlimit
+	[__NR_getrlimit - SYSCALL_TABLE_ID0] =                  {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_GETRLIMIT_E, PPME_SYSCALL_GETRLIMIT_X},
+#endif
+	[__NR_setrlimit - SYSCALL_TABLE_ID0] =                  {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_SETRLIMIT_E, PPME_SYSCALL_SETRLIMIT_X},
+#ifdef __NR_prlimit64
+	[__NR_prlimit64 - SYSCALL_TABLE_ID0] =                  {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_PRLIMIT_E, PPME_SYSCALL_PRLIMIT_X},
+#endif
+#ifdef __NR_ugetrlimit
+	[__NR_ugetrlimit - SYSCALL_TABLE_ID0] =                 {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_GETRLIMIT_E, PPME_SYSCALL_GETRLIMIT_X},
+#endif
+	[__NR_fcntl - SYSCALL_TABLE_ID0] =                      {UF_USED, PPME_SYSCALL_FCNTL_E, PPME_SYSCALL_FCNTL_X},
+#ifdef __NR_fcntl64
+	[__NR_fcntl64 - SYSCALL_TABLE_ID0] =                    {UF_USED, PPME_SYSCALL_FCNTL_E, PPME_SYSCALL_FCNTL_X},
+#endif
+/* [__NR_old_select - SYSCALL_TABLE_ID0] =	{UF_USED, PPME_GENERIC_E, PPME_GENERIC_X}, */
+	[__NR_pselect6 - SYSCALL_TABLE_ID0] =                   {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_epoll_create - SYSCALL_TABLE_ID0] =               {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_epoll_ctl - SYSCALL_TABLE_ID0] =                  {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_uselib - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_sched_setparam - SYSCALL_TABLE_ID0] =             {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_sched_getparam - SYSCALL_TABLE_ID0] =             {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_syslog - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_chmod - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_lchown - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+#ifdef __NR_utime
+	[__NR_utime - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+#endif
+	[__NR_mount - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_MOUNT_E, PPME_SYSCALL_MOUNT_X},
+	[__NR_umount2 - SYSCALL_TABLE_ID0] =                    {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_UMOUNT_E, PPME_SYSCALL_UMOUNT_X},
+	[__NR_ptrace - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_PTRACE_E, PPME_SYSCALL_PTRACE_X},
+#ifdef __NR_alarm
+	[__NR_alarm - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+#endif
+	[__NR_pause - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+
+#ifndef __NR_socketcall
+	[__NR_socket - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_SIMPLEDRIVER_KEEP, PPME_SOCKET_SOCKET_E, PPME_SOCKET_SOCKET_X},
+	[__NR_bind - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_NEVER_DROP, PPME_SOCKET_BIND_E,  PPME_SOCKET_BIND_X},
+	[__NR_connect - SYSCALL_TABLE_ID0] =                    {UF_USED | UF_SIMPLEDRIVER_KEEP, PPME_SOCKET_CONNECT_E, PPME_SOCKET_CONNECT_X},
+	[__NR_listen - SYSCALL_TABLE_ID0] =                     {UF_USED, PPME_SOCKET_LISTEN_E, PPME_SOCKET_LISTEN_X},
+	[__NR_accept - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_SIMPLEDRIVER_KEEP, PPME_SOCKET_ACCEPT_5_E, PPME_SOCKET_ACCEPT_5_X},
+	[__NR_getsockname - SYSCALL_TABLE_ID0] =                {UF_USED | UF_ALWAYS_DROP, PPME_SOCKET_GETSOCKNAME_E, PPME_SOCKET_GETSOCKNAME_X},
+	[__NR_getpeername - SYSCALL_TABLE_ID0] =                {UF_USED | UF_ALWAYS_DROP, PPME_SOCKET_GETPEERNAME_E, PPME_SOCKET_GETPEERNAME_X},
+	[__NR_socketpair - SYSCALL_TABLE_ID0] =                 {UF_USED | UF_NEVER_DROP, PPME_SOCKET_SOCKETPAIR_E, PPME_SOCKET_SOCKETPAIR_X},
+	[__NR_sendto - SYSCALL_TABLE_ID0] =                     {UF_USED, PPME_SOCKET_SENDTO_E, PPME_SOCKET_SENDTO_X},
+	[__NR_recvfrom - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SOCKET_RECVFROM_E, PPME_SOCKET_RECVFROM_X},
+	[__NR_shutdown - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SOCKET_SHUTDOWN_E, PPME_SOCKET_SHUTDOWN_X},
+	[__NR_setsockopt - SYSCALL_TABLE_ID0] =                 {UF_USED | UF_ALWAYS_DROP, PPME_SOCKET_SETSOCKOPT_E, PPME_SOCKET_SETSOCKOPT_X},
+	[__NR_getsockopt - SYSCALL_TABLE_ID0] =                 {UF_USED | UF_ALWAYS_DROP, PPME_SOCKET_GETSOCKOPT_E, PPME_SOCKET_GETSOCKOPT_X},
+	[__NR_sendmsg - SYSCALL_TABLE_ID0] =                    {UF_USED, PPME_SOCKET_SENDMSG_E, PPME_SOCKET_SENDMSG_X},
+	[__NR_accept4 - SYSCALL_TABLE_ID0] =                    {UF_USED | UF_SIMPLEDRIVER_KEEP, PPME_SOCKET_ACCEPT4_5_E, PPME_SOCKET_ACCEPT4_5_X},
+#endif
+
+#ifdef __NR_sendmmsg
+	[__NR_sendmmsg - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SOCKET_SENDMMSG_E, PPME_SOCKET_SENDMMSG_X},
+#endif
+#ifdef __NR_recvmsg
+	[__NR_recvmsg - SYSCALL_TABLE_ID0] =                    {UF_USED, PPME_SOCKET_RECVMSG_E, PPME_SOCKET_RECVMSG_X},
+#endif
+#ifdef __NR_recvmmsg
+	[__NR_recvmmsg - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SOCKET_RECVMMSG_E, PPME_SOCKET_RECVMMSG_X},
+#endif
+#ifdef __NR_stat64
+	[__NR_stat64 - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_STAT64_E, PPME_SYSCALL_STAT64_X},
+#endif
+#ifdef __NR_fstat64
+	[__NR_fstat64 - SYSCALL_TABLE_ID0] =                    {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_FSTAT64_E, PPME_SYSCALL_FSTAT64_X},
+#endif
+#ifdef __NR__llseek
+	[__NR__llseek - SYSCALL_TABLE_ID0] =                    {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_LLSEEK_E, PPME_SYSCALL_LLSEEK_X},
+#endif
+#ifdef __NR_mmap
+	[__NR_mmap - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_MMAP_E, PPME_SYSCALL_MMAP_X},
+#endif
+#ifdef __NR_mmap2
+	[__NR_mmap2 - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_MMAP2_E, PPME_SYSCALL_MMAP2_X},
+#endif
+	[__NR_munmap - SYSCALL_TABLE_ID0] =						{UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_MUNMAP_E, PPME_SYSCALL_MUNMAP_X},
+	[__NR_splice - SYSCALL_TABLE_ID0] =                     {UF_USED, PPME_SYSCALL_SPLICE_E, PPME_SYSCALL_SPLICE_X},
+#ifdef __NR_process_vm_readv
+	[__NR_process_vm_readv - SYSCALL_TABLE_ID0] =           {UF_USED, PPME_GENERIC_E, PPME_GENERIC_X},
+#endif
+#ifdef __NR_process_vm_writev
+	[__NR_process_vm_writev - SYSCALL_TABLE_ID0] =          {UF_USED, PPME_GENERIC_E, PPME_GENERIC_X},
+#endif
+
+	[__NR_rename - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_RENAME_E, PPME_SYSCALL_RENAME_X},
+	[__NR_renameat - SYSCALL_TABLE_ID0] =                   {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_RENAMEAT_E, PPME_SYSCALL_RENAMEAT_X},
+	[__NR_symlink - SYSCALL_TABLE_ID0] =                    {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_SYMLINK_E, PPME_SYSCALL_SYMLINK_X},
+	[__NR_symlinkat - SYSCALL_TABLE_ID0] =                  {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_SYMLINKAT_E, PPME_SYSCALL_SYMLINKAT_X},
+	[__NR_sendfile - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SYSCALL_SENDFILE_E, PPME_SYSCALL_SENDFILE_X},
+#ifdef __NR_sendfile64
+	[__NR_sendfile64 - SYSCALL_TABLE_ID0] =                 {UF_USED, PPME_SYSCALL_SENDFILE_E, PPME_SYSCALL_SENDFILE_X},
+#endif
+#ifdef __NR_quotactl
+	[__NR_quotactl - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SYSCALL_QUOTACTL_E, PPME_SYSCALL_QUOTACTL_X},
+#endif
+#ifdef __NR_setresuid
+	[__NR_setresuid - SYSCALL_TABLE_ID0] =                  {UF_USED, PPME_SYSCALL_SETRESUID_E, PPME_SYSCALL_SETRESUID_X },
+#endif
+#ifdef __NR_setresuid32
+	[__NR_setresuid32 - SYSCALL_TABLE_ID0] =                {UF_USED, PPME_SYSCALL_SETRESUID_E, PPME_SYSCALL_SETRESUID_X },
+#endif
+#ifdef __NR_setresgid
+	[__NR_setresgid - SYSCALL_TABLE_ID0] =                  {UF_USED, PPME_SYSCALL_SETRESGID_E, PPME_SYSCALL_SETRESGID_X },
+#endif
+#ifdef __NR_setresgid32
+	[__NR_setresgid32 - SYSCALL_TABLE_ID0] =                {UF_USED, PPME_SYSCALL_SETRESGID_E, PPME_SYSCALL_SETRESGID_X },
+#endif
+#ifdef __NR_setuid
+	[__NR_setuid - SYSCALL_TABLE_ID0] =                     {UF_USED, PPME_SYSCALL_SETUID_E, PPME_SYSCALL_SETUID_X },
+#endif
+#ifdef __NR_setuid32
+	[__NR_setuid32 - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SYSCALL_SETUID_E, PPME_SYSCALL_SETUID_X },
+#endif
+#ifdef __NR_setgid
+	[__NR_setgid - SYSCALL_TABLE_ID0] =                     {UF_USED, PPME_SYSCALL_SETGID_E, PPME_SYSCALL_SETGID_X },
+#endif
+#ifdef __NR_setgid32
+	[__NR_setgid32 - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SYSCALL_SETGID_E, PPME_SYSCALL_SETGID_X },
+#endif
+#ifdef __NR_getuid
+	[__NR_getuid - SYSCALL_TABLE_ID0] =                     {UF_USED, PPME_SYSCALL_GETUID_E, PPME_SYSCALL_GETUID_X },
+#endif
+#ifdef __NR_getuid32
+	[__NR_getuid32 - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SYSCALL_GETUID_E, PPME_SYSCALL_GETUID_X },
+#endif
+#ifdef __NR_geteuid
+	[__NR_geteuid - SYSCALL_TABLE_ID0] =                    {UF_USED, PPME_SYSCALL_GETEUID_E, PPME_SYSCALL_GETEUID_X },
+#endif
+#ifdef __NR_geteuid32
+	[__NR_geteuid32 - SYSCALL_TABLE_ID0] =                  {UF_USED, PPME_SYSCALL_GETEUID_E, PPME_SYSCALL_GETEUID_X },
+#endif
+#ifdef __NR_getgid
+	[__NR_getgid - SYSCALL_TABLE_ID0] =                     {UF_USED, PPME_SYSCALL_GETGID_E, PPME_SYSCALL_GETGID_X },
+#endif
+#ifdef __NR_getgid32
+	[__NR_getgid32 - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SYSCALL_GETGID_E, PPME_SYSCALL_GETGID_X },
+#endif
+#ifdef __NR_getegid
+	[__NR_getegid - SYSCALL_TABLE_ID0] =                    {UF_USED, PPME_SYSCALL_GETEGID_E, PPME_SYSCALL_GETEGID_X },
+#endif
+#ifdef __NR_getegid32
+	[__NR_getegid32 - SYSCALL_TABLE_ID0] =                  {UF_USED, PPME_SYSCALL_GETEGID_E, PPME_SYSCALL_GETEGID_X },
+#endif
+#ifdef __NR_getresuid
+	[__NR_getresuid - SYSCALL_TABLE_ID0] =                  {UF_USED, PPME_SYSCALL_GETRESUID_E, PPME_SYSCALL_GETRESUID_X },
+#endif
+#ifdef __NR_getresuid32
+	[__NR_getresuid32 - SYSCALL_TABLE_ID0] =                {UF_USED, PPME_SYSCALL_GETRESUID_E, PPME_SYSCALL_GETRESUID_X },
+#endif
+#ifdef __NR_getresgid
+	[__NR_getresgid - SYSCALL_TABLE_ID0] =                  {UF_USED, PPME_SYSCALL_GETRESGID_E, PPME_SYSCALL_GETRESGID_X },
+#endif
+#ifdef __NR_getresgid32
+	[__NR_getresgid32 - SYSCALL_TABLE_ID0] =                {UF_USED, PPME_SYSCALL_GETRESGID_E, PPME_SYSCALL_GETRESGID_X },
+#endif
+	[__NR_getdents - SYSCALL_TABLE_ID0] =                   {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_GETDENTS_E, PPME_SYSCALL_GETDENTS_X},
+	[__NR_getdents64 - SYSCALL_TABLE_ID0] =                 {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_GETDENTS64_E, PPME_SYSCALL_GETDENTS64_X},
+#ifdef __NR_setns
+	[__NR_setns - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_SETNS_E, PPME_SYSCALL_SETNS_X},
+#endif
+#ifdef __NR_unshare
+	[__NR_unshare - SYSCALL_TABLE_ID0] =                    {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_UNSHARE_E, PPME_SYSCALL_UNSHARE_X},
+#endif
+	[__NR_flock - SYSCALL_TABLE_ID0] =			{UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_FLOCK_E, PPME_SYSCALL_FLOCK_X},
+#ifdef __NR_semop
+	[__NR_semop - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_SEMOP_E, PPME_SYSCALL_SEMOP_X},
+#endif
+#ifdef __NR_semget
+	[__NR_semget - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_SEMGET_E, PPME_SYSCALL_SEMGET_X},
+#endif
+#ifdef __NR_semctl
+	[__NR_semctl - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_SEMCTL_E, PPME_SYSCALL_SEMCTL_X},
+#endif
+	[__NR_ppoll - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_PPOLL_E, PPME_SYSCALL_PPOLL_X},
+#ifdef __NR_access
+	[__NR_access - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_ACCESS_E, PPME_SYSCALL_ACCESS_X},
+#endif
+#ifdef __NR_chroot
+	[__NR_chroot - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_CHROOT_E, PPME_SYSCALL_CHROOT_X},
+#endif
+	[__NR_setsid - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_SETSID_E, PPME_SYSCALL_SETSID_X},
+#ifdef __NR_bpf
+	[__NR_bpf - SYSCALL_TABLE_ID0] =                        {UF_USED, PPME_SYSCALL_BPF_E, PPME_SYSCALL_BPF_X},
+#endif
+#ifdef __NR_seccomp
+	[__NR_seccomp - SYSCALL_TABLE_ID0] =                    {UF_USED, PPME_SYSCALL_SECCOMP_E, PPME_SYSCALL_SECCOMP_X},
+#endif
+};
+
+/*
+ * SYSCALL ROUTING TABLE
+ */
+const enum ppm_syscall_code g_syscall_code_routing_table[SYSCALL_TABLE_SIZE] = {
+	[__NR_restart_syscall - SYSCALL_TABLE_ID0] = PPM_SC_RESTART_SYSCALL,
+	[__NR_exit - SYSCALL_TABLE_ID0] = PPM_SC_EXIT,
+	[__NR_read - SYSCALL_TABLE_ID0] = PPM_SC_READ,
+	[__NR_write - SYSCALL_TABLE_ID0] = PPM_SC_WRITE,
+	[__NR_open - SYSCALL_TABLE_ID0] = PPM_SC_OPEN,
+	[__NR_close - SYSCALL_TABLE_ID0] = PPM_SC_CLOSE,
+	[__NR_creat - SYSCALL_TABLE_ID0] = PPM_SC_CREAT,
+	[__NR_link - SYSCALL_TABLE_ID0] = PPM_SC_LINK,
+	[__NR_unlink - SYSCALL_TABLE_ID0] = PPM_SC_UNLINK,
+	[__NR_chdir - SYSCALL_TABLE_ID0] = PPM_SC_CHDIR,
+#ifdef __NR_time
+	[__NR_time - SYSCALL_TABLE_ID0] = PPM_SC_TIME,
+#endif
+	[__NR_mknod - SYSCALL_TABLE_ID0] = PPM_SC_MKNOD,
+	[__NR_chmod - SYSCALL_TABLE_ID0] = PPM_SC_CHMOD,
+/* [__NR_lchown16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_LCHOWN16, */
+	[__NR_stat - SYSCALL_TABLE_ID0] = PPM_SC_STAT,
+	[__NR_lseek - SYSCALL_TABLE_ID0] = PPM_SC_LSEEK,
+	[__NR_getpid - SYSCALL_TABLE_ID0] = PPM_SC_GETPID,
+	[__NR_mount - SYSCALL_TABLE_ID0] = PPM_SC_MOUNT,
+/* [__NR_oldumount - SYSCALL_TABLE_ID0] = PPM_SC_NR_OLDUMOUNT, */
+/* [__NR_setuid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETUID16, */
+/* [__NR_getuid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_GETUID16, */
+	[__NR_ptrace - SYSCALL_TABLE_ID0] = PPM_SC_PTRACE,
+#ifdef __NR_alarm
+	[__NR_alarm - SYSCALL_TABLE_ID0] = PPM_SC_ALARM,
+#endif
+	[__NR_fstat - SYSCALL_TABLE_ID0] = PPM_SC_FSTAT,
+	[__NR_pause - SYSCALL_TABLE_ID0] = PPM_SC_PAUSE,
+#ifdef __NR_utime
+	[__NR_utime - SYSCALL_TABLE_ID0] = PPM_SC_UTIME,
+#endif
+	[__NR_access - SYSCALL_TABLE_ID0] = PPM_SC_ACCESS,
+	[__NR_sync - SYSCALL_TABLE_ID0] = PPM_SC_SYNC,
+	[__NR_kill - SYSCALL_TABLE_ID0] = PPM_SC_KILL,
+	[__NR_rename - SYSCALL_TABLE_ID0] = PPM_SC_RENAME,
+	[__NR_mkdir - SYSCALL_TABLE_ID0] = PPM_SC_MKDIR,
+	[__NR_rmdir - SYSCALL_TABLE_ID0] = PPM_SC_RMDIR,
+	[__NR_dup - SYSCALL_TABLE_ID0] = PPM_SC_DUP,
+	[__NR_pipe - SYSCALL_TABLE_ID0] = PPM_SC_PIPE,
+	[__NR_times - SYSCALL_TABLE_ID0] = PPM_SC_TIMES,
+	[__NR_brk - SYSCALL_TABLE_ID0] = PPM_SC_BRK,
+/* [__NR_setgid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETGID16, */
+/* [__NR_getgid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_GETGID16, */
+/* [__NR_geteuid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_GETEUID16, */
+/* [__NR_getegid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_GETEGID16, */
+	[__NR_acct - SYSCALL_TABLE_ID0] = PPM_SC_ACCT,
+	[__NR_ioctl - SYSCALL_TABLE_ID0] = PPM_SC_IOCTL,
+	[__NR_fcntl - SYSCALL_TABLE_ID0] = PPM_SC_FCNTL,
+	[__NR_setpgid - SYSCALL_TABLE_ID0] = PPM_SC_SETPGID,
+	[__NR_umask - SYSCALL_TABLE_ID0] = PPM_SC_UMASK,
+	[__NR_chroot - SYSCALL_TABLE_ID0] = PPM_SC_CHROOT,
+	[__NR_ustat - SYSCALL_TABLE_ID0] = PPM_SC_USTAT,
+	[__NR_dup2 - SYSCALL_TABLE_ID0] = PPM_SC_DUP2,
+	[__NR_getppid - SYSCALL_TABLE_ID0] = PPM_SC_GETPPID,
+	[__NR_getpgrp - SYSCALL_TABLE_ID0] = PPM_SC_GETPGRP,
+	[__NR_setsid - SYSCALL_TABLE_ID0] = PPM_SC_SETSID,
+	[__NR_sethostname - SYSCALL_TABLE_ID0] = PPM_SC_SETHOSTNAME,
+	[__NR_setrlimit - SYSCALL_TABLE_ID0] = PPM_SC_SETRLIMIT,
+/* [__NR_old_getrlimit - SYSCALL_TABLE_ID0] = PPM_SC_NR_OLD_GETRLIMIT, */
+	[__NR_getrusage - SYSCALL_TABLE_ID0] = PPM_SC_GETRUSAGE,
+	[__NR_gettimeofday - SYSCALL_TABLE_ID0] = PPM_SC_GETTIMEOFDAY,
+	[__NR_settimeofday - SYSCALL_TABLE_ID0] = PPM_SC_SETTIMEOFDAY,
+/* [__NR_getgroups16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_GETGROUPS16, */
+/* [__NR_setgroups16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETGROUPS16, */
+/* [__NR_old_select - SYSCALL_TABLE_ID0] = PPM_SC_NR_OLD_SELECT, */
+	[__NR_symlink - SYSCALL_TABLE_ID0] = PPM_SC_SYMLINK,
+	[__NR_lstat - SYSCALL_TABLE_ID0] = PPM_SC_LSTAT,
+	[__NR_readlink - SYSCALL_TABLE_ID0] = PPM_SC_READLINK,
+	[__NR_uselib - SYSCALL_TABLE_ID0] = PPM_SC_USELIB,
+	[__NR_swapon - SYSCALL_TABLE_ID0] = PPM_SC_SWAPON,
+	[__NR_reboot - SYSCALL_TABLE_ID0] = PPM_SC_REBOOT,
+/* [__NR_old_readdir - SYSCALL_TABLE_ID0] = PPM_SC_NR_OLD_READDIR, */
+/* [__NR_old_mmap - SYSCALL_TABLE_ID0] = PPM_SC_NR_OLD_MMAP, */
+#ifdef __NR_mmap
+	[__NR_mmap - SYSCALL_TABLE_ID0] = PPM_SC_MMAP,
+#endif
+	[__NR_munmap - SYSCALL_TABLE_ID0] = PPM_SC_MUNMAP,
+	[__NR_truncate - SYSCALL_TABLE_ID0] = PPM_SC_TRUNCATE,
+	[__NR_ftruncate - SYSCALL_TABLE_ID0] = PPM_SC_FTRUNCATE,
+	[__NR_fchmod - SYSCALL_TABLE_ID0] = PPM_SC_FCHMOD,
+/* [__NR_fchown16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_FCHOWN16, */
+	[__NR_getpriority - SYSCALL_TABLE_ID0] = PPM_SC_GETPRIORITY,
+	[__NR_setpriority - SYSCALL_TABLE_ID0] = PPM_SC_SETPRIORITY,
+	[__NR_statfs - SYSCALL_TABLE_ID0] = PPM_SC_STATFS,
+	[__NR_fstatfs - SYSCALL_TABLE_ID0] = PPM_SC_FSTATFS,
+	[__NR_syslog - SYSCALL_TABLE_ID0] = PPM_SC_SYSLOG,
+	[__NR_setitimer - SYSCALL_TABLE_ID0] = PPM_SC_SETITIMER,
+	[__NR_getitimer - SYSCALL_TABLE_ID0] = PPM_SC_GETITIMER,
+/* [__NR_newstat - SYSCALL_TABLE_ID0] = PPM_SC_NR_NEWSTAT, */
+/* [__NR_newlstat - SYSCALL_TABLE_ID0] = PPM_SC_NR_NEWLSTAT, */
+/* [__NR_newfstat - SYSCALL_TABLE_ID0] = PPM_SC_NR_NEWFSTAT, */
+	[__NR_uname - SYSCALL_TABLE_ID0] = PPM_SC_UNAME,
+	[__NR_vhangup - SYSCALL_TABLE_ID0] = PPM_SC_VHANGUP,
+	[__NR_wait4 - SYSCALL_TABLE_ID0] = PPM_SC_WAIT4,
+	[__NR_swapoff - SYSCALL_TABLE_ID0] = PPM_SC_SWAPOFF,
+	[__NR_sysinfo - SYSCALL_TABLE_ID0] = PPM_SC_SYSINFO,
+	[__NR_fsync - SYSCALL_TABLE_ID0] = PPM_SC_FSYNC,
+	[__NR_setdomainname - SYSCALL_TABLE_ID0] = PPM_SC_SETDOMAINNAME,
+/* [__NR_newuname - SYSCALL_TABLE_ID0] = PPM_SC_NR_NEWUNAME, */
+	[__NR_adjtimex - SYSCALL_TABLE_ID0] = PPM_SC_ADJTIMEX,
+	[__NR_mprotect - SYSCALL_TABLE_ID0] = PPM_SC_MPROTECT,
+	[__NR_init_module - SYSCALL_TABLE_ID0] = PPM_SC_INIT_MODULE,
+	[__NR_delete_module - SYSCALL_TABLE_ID0] = PPM_SC_DELETE_MODULE,
+	[__NR_quotactl - SYSCALL_TABLE_ID0] = PPM_SC_QUOTACTL,
+	[__NR_getpgid - SYSCALL_TABLE_ID0] = PPM_SC_GETPGID,
+	[__NR_fchdir - SYSCALL_TABLE_ID0] = PPM_SC_FCHDIR,
+	[__NR_sysfs - SYSCALL_TABLE_ID0] = PPM_SC_SYSFS,
+	[__NR_personality - SYSCALL_TABLE_ID0] = PPM_SC_PERSONALITY,
+/* [__NR_setfsuid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETFSUID16, */
+/* [__NR_setfsgid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETFSGID16, */
+/* [__NR_llseek - SYSCALL_TABLE_ID0] = PPM_SC_NR_LLSEEK, */
+	[__NR_getdents - SYSCALL_TABLE_ID0] = PPM_SC_GETDENTS,
+#ifdef __NR_select
+	[__NR_select - SYSCALL_TABLE_ID0] = PPM_SC_SELECT,
+#endif
+	[__NR_flock - SYSCALL_TABLE_ID0] = PPM_SC_FLOCK,
+	[__NR_msync - SYSCALL_TABLE_ID0] = PPM_SC_MSYNC,
+	[__NR_readv - SYSCALL_TABLE_ID0] = PPM_SC_READV,
+	[__NR_writev - SYSCALL_TABLE_ID0] = PPM_SC_WRITEV,
+	[__NR_getsid - SYSCALL_TABLE_ID0] = PPM_SC_GETSID,
+	[__NR_fdatasync - SYSCALL_TABLE_ID0] = PPM_SC_FDATASYNC,
+/* [__NR_sysctl - SYSCALL_TABLE_ID0] = PPM_SC_NR_SYSCTL, */
+	[__NR_mlock - SYSCALL_TABLE_ID0] = PPM_SC_MLOCK,
+	[__NR_munlock - SYSCALL_TABLE_ID0] = PPM_SC_MUNLOCK,
+	[__NR_mlockall - SYSCALL_TABLE_ID0] = PPM_SC_MLOCKALL,
+	[__NR_munlockall - SYSCALL_TABLE_ID0] = PPM_SC_MUNLOCKALL,
+	[__NR_sched_setparam - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_SETPARAM,
+	[__NR_sched_getparam - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_GETPARAM,
+	[__NR_sched_setscheduler - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_SETSCHEDULER,
+	[__NR_sched_getscheduler - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_GETSCHEDULER,
+	[__NR_sched_yield - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_YIELD,
+	[__NR_sched_get_priority_max - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_GET_PRIORITY_MAX,
+	[__NR_sched_get_priority_min - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_GET_PRIORITY_MIN,
+	[__NR_sched_rr_get_interval - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_RR_GET_INTERVAL,
+	[__NR_nanosleep - SYSCALL_TABLE_ID0] = PPM_SC_NANOSLEEP,
+	[__NR_mremap - SYSCALL_TABLE_ID0] = PPM_SC_MREMAP,
+/* [__NR_setresuid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETRESUID16, */
+/* [__NR_getresuid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_GETRESUID16, */
+	[__NR_poll - SYSCALL_TABLE_ID0] = PPM_SC_POLL,
+/* [__NR_setresgid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETRESGID16, */
+/* [__NR_getresgid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_GETRESGID16, */
+	[__NR_prctl - SYSCALL_TABLE_ID0] = PPM_SC_PRCTL,
+#ifdef __NR_arch_prctl
+	[__NR_arch_prctl - SYSCALL_TABLE_ID0] = PPM_SC_ARCH_PRCTL,
+#endif
+	[__NR_rt_sigaction - SYSCALL_TABLE_ID0] = PPM_SC_RT_SIGACTION,
+	[__NR_rt_sigprocmask - SYSCALL_TABLE_ID0] = PPM_SC_RT_SIGPROCMASK,
+	[__NR_rt_sigpending - SYSCALL_TABLE_ID0] = PPM_SC_RT_SIGPENDING,
+	[__NR_rt_sigtimedwait - SYSCALL_TABLE_ID0] = PPM_SC_RT_SIGTIMEDWAIT,
+	[__NR_rt_sigqueueinfo - SYSCALL_TABLE_ID0] = PPM_SC_RT_SIGQUEUEINFO,
+	[__NR_rt_sigsuspend - SYSCALL_TABLE_ID0] = PPM_SC_RT_SIGSUSPEND,
+/* [__NR_chown16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_CHOWN16, */
+	[__NR_getcwd - SYSCALL_TABLE_ID0] = PPM_SC_GETCWD,
+	[__NR_capget - SYSCALL_TABLE_ID0] = PPM_SC_CAPGET,
+	[__NR_capset - SYSCALL_TABLE_ID0] = PPM_SC_CAPSET,
+	[__NR_sendfile - SYSCALL_TABLE_ID0] = PPM_SC_SENDFILE,
+#ifdef __NR_getrlimit
+	[__NR_getrlimit - SYSCALL_TABLE_ID0] = PPM_SC_GETRLIMIT,
+#endif
+/* [__NR_mmap_pgoff - SYSCALL_TABLE_ID0] = PPM_SC_NR_MMAP_PGOFF, */
+	[__NR_lchown - SYSCALL_TABLE_ID0] = PPM_SC_LCHOWN,
+	[__NR_getuid - SYSCALL_TABLE_ID0] = PPM_SC_GETUID,
+	[__NR_getgid - SYSCALL_TABLE_ID0] = PPM_SC_GETGID,
+	[__NR_geteuid - SYSCALL_TABLE_ID0] = PPM_SC_GETEUID,
+	[__NR_getegid - SYSCALL_TABLE_ID0] = PPM_SC_GETEGID,
+	[__NR_setreuid - SYSCALL_TABLE_ID0] = PPM_SC_SETREUID,
+	[__NR_setregid - SYSCALL_TABLE_ID0] = PPM_SC_SETREGID,
+	[__NR_getgroups - SYSCALL_TABLE_ID0] = PPM_SC_GETGROUPS,
+	[__NR_setgroups - SYSCALL_TABLE_ID0] = PPM_SC_SETGROUPS,
+	[__NR_fchown - SYSCALL_TABLE_ID0] = PPM_SC_FCHOWN,
+	[__NR_setresuid - SYSCALL_TABLE_ID0] = PPM_SC_SETRESUID,
+	[__NR_getresuid - SYSCALL_TABLE_ID0] = PPM_SC_GETRESUID,
+	[__NR_setresgid - SYSCALL_TABLE_ID0] = PPM_SC_SETRESGID,
+	[__NR_getresgid - SYSCALL_TABLE_ID0] = PPM_SC_GETRESGID,
+	[__NR_chown - SYSCALL_TABLE_ID0] = PPM_SC_CHOWN,
+	[__NR_setuid - SYSCALL_TABLE_ID0] = PPM_SC_SETUID,
+	[__NR_setgid - SYSCALL_TABLE_ID0] = PPM_SC_SETGID,
+	[__NR_setfsuid - SYSCALL_TABLE_ID0] = PPM_SC_SETFSUID,
+	[__NR_setfsgid - SYSCALL_TABLE_ID0] = PPM_SC_SETFSGID,
+	[__NR_pivot_root - SYSCALL_TABLE_ID0] = PPM_SC_PIVOT_ROOT,
+	[__NR_mincore - SYSCALL_TABLE_ID0] = PPM_SC_MINCORE,
+	[__NR_madvise - SYSCALL_TABLE_ID0] = PPM_SC_MADVISE,
+	[__NR_gettid - SYSCALL_TABLE_ID0] = PPM_SC_GETTID,
+	[__NR_setxattr - SYSCALL_TABLE_ID0] = PPM_SC_SETXATTR,
+	[__NR_lsetxattr - SYSCALL_TABLE_ID0] = PPM_SC_LSETXATTR,
+	[__NR_fsetxattr - SYSCALL_TABLE_ID0] = PPM_SC_FSETXATTR,
+	[__NR_getxattr - SYSCALL_TABLE_ID0] = PPM_SC_GETXATTR,
+	[__NR_lgetxattr - SYSCALL_TABLE_ID0] = PPM_SC_LGETXATTR,
+	[__NR_fgetxattr - SYSCALL_TABLE_ID0] = PPM_SC_FGETXATTR,
+	[__NR_listxattr - SYSCALL_TABLE_ID0] = PPM_SC_LISTXATTR,
+	[__NR_llistxattr - SYSCALL_TABLE_ID0] = PPM_SC_LLISTXATTR,
+	[__NR_flistxattr - SYSCALL_TABLE_ID0] = PPM_SC_FLISTXATTR,
+	[__NR_removexattr - SYSCALL_TABLE_ID0] = PPM_SC_REMOVEXATTR,
+	[__NR_lremovexattr - SYSCALL_TABLE_ID0] = PPM_SC_LREMOVEXATTR,
+	[__NR_fremovexattr - SYSCALL_TABLE_ID0] = PPM_SC_FREMOVEXATTR,
+	[__NR_tkill - SYSCALL_TABLE_ID0] = PPM_SC_TKILL,
+	[__NR_futex - SYSCALL_TABLE_ID0] = PPM_SC_FUTEX,
+	[__NR_sched_setaffinity - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_SETAFFINITY,
+	[__NR_sched_getaffinity - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_GETAFFINITY,
+#ifdef __NR_set_thread_area
+	[__NR_set_thread_area - SYSCALL_TABLE_ID0] = PPM_SC_SET_THREAD_AREA,
+#endif
+#ifdef __NR_get_thread_area
+	[__NR_get_thread_area - SYSCALL_TABLE_ID0] = PPM_SC_GET_THREAD_AREA,
+#endif
+	[__NR_io_setup - SYSCALL_TABLE_ID0] = PPM_SC_IO_SETUP,
+	[__NR_io_destroy - SYSCALL_TABLE_ID0] = PPM_SC_IO_DESTROY,
+	[__NR_io_getevents - SYSCALL_TABLE_ID0] = PPM_SC_IO_GETEVENTS,
+	[__NR_io_submit - SYSCALL_TABLE_ID0] = PPM_SC_IO_SUBMIT,
+	[__NR_io_cancel - SYSCALL_TABLE_ID0] = PPM_SC_IO_CANCEL,
+	[__NR_exit_group - SYSCALL_TABLE_ID0] = PPM_SC_EXIT_GROUP,
+	[__NR_epoll_create - SYSCALL_TABLE_ID0] = PPM_SC_EPOLL_CREATE,
+	[__NR_epoll_ctl - SYSCALL_TABLE_ID0] = PPM_SC_EPOLL_CTL,
+	[__NR_epoll_wait - SYSCALL_TABLE_ID0] = PPM_SC_EPOLL_WAIT,
+	[__NR_remap_file_pages - SYSCALL_TABLE_ID0] = PPM_SC_REMAP_FILE_PAGES,
+	[__NR_set_tid_address - SYSCALL_TABLE_ID0] = PPM_SC_SET_TID_ADDRESS,
+	[__NR_timer_create - SYSCALL_TABLE_ID0] = PPM_SC_TIMER_CREATE,
+	[__NR_timer_settime - SYSCALL_TABLE_ID0] = PPM_SC_TIMER_SETTIME,
+	[__NR_timer_gettime - SYSCALL_TABLE_ID0] = PPM_SC_TIMER_GETTIME,
+	[__NR_timer_getoverrun - SYSCALL_TABLE_ID0] = PPM_SC_TIMER_GETOVERRUN,
+	[__NR_timer_delete - SYSCALL_TABLE_ID0] = PPM_SC_TIMER_DELETE,
+	[__NR_clock_settime - SYSCALL_TABLE_ID0] = PPM_SC_CLOCK_SETTIME,
+	[__NR_clock_gettime - SYSCALL_TABLE_ID0] = PPM_SC_CLOCK_GETTIME,
+	[__NR_clock_getres - SYSCALL_TABLE_ID0] = PPM_SC_CLOCK_GETRES,
+	[__NR_clock_nanosleep - SYSCALL_TABLE_ID0] = PPM_SC_CLOCK_NANOSLEEP,
+	[__NR_tgkill - SYSCALL_TABLE_ID0] = PPM_SC_TGKILL,
+	[__NR_utimes - SYSCALL_TABLE_ID0] = PPM_SC_UTIMES,
+	[__NR_mq_open - SYSCALL_TABLE_ID0] = PPM_SC_MQ_OPEN,
+	[__NR_mq_unlink - SYSCALL_TABLE_ID0] = PPM_SC_MQ_UNLINK,
+	[__NR_mq_timedsend - SYSCALL_TABLE_ID0] = PPM_SC_MQ_TIMEDSEND,
+	[__NR_mq_timedreceive - SYSCALL_TABLE_ID0] = PPM_SC_MQ_TIMEDRECEIVE,
+	[__NR_mq_notify - SYSCALL_TABLE_ID0] = PPM_SC_MQ_NOTIFY,
+	[__NR_mq_getsetattr - SYSCALL_TABLE_ID0] = PPM_SC_MQ_GETSETATTR,
+	[__NR_kexec_load - SYSCALL_TABLE_ID0] = PPM_SC_KEXEC_LOAD,
+	[__NR_waitid - SYSCALL_TABLE_ID0] = PPM_SC_WAITID,
+	[__NR_add_key - SYSCALL_TABLE_ID0] = PPM_SC_ADD_KEY,
+	[__NR_request_key - SYSCALL_TABLE_ID0] = PPM_SC_REQUEST_KEY,
+	[__NR_keyctl - SYSCALL_TABLE_ID0] = PPM_SC_KEYCTL,
+	[__NR_ioprio_set - SYSCALL_TABLE_ID0] = PPM_SC_IOPRIO_SET,
+	[__NR_ioprio_get - SYSCALL_TABLE_ID0] = PPM_SC_IOPRIO_GET,
+	[__NR_inotify_init - SYSCALL_TABLE_ID0] = PPM_SC_INOTIFY_INIT,
+	[__NR_inotify_add_watch - SYSCALL_TABLE_ID0] = PPM_SC_INOTIFY_ADD_WATCH,
+	[__NR_inotify_rm_watch - SYSCALL_TABLE_ID0] = PPM_SC_INOTIFY_RM_WATCH,
+	[__NR_openat - SYSCALL_TABLE_ID0] = PPM_SC_OPENAT,
+	[__NR_mkdirat - SYSCALL_TABLE_ID0] = PPM_SC_MKDIRAT,
+	[__NR_mknodat - SYSCALL_TABLE_ID0] = PPM_SC_MKNODAT,
+	[__NR_fchownat - SYSCALL_TABLE_ID0] = PPM_SC_FCHOWNAT,
+	[__NR_futimesat - SYSCALL_TABLE_ID0] = PPM_SC_FUTIMESAT,
+	[__NR_unlinkat - SYSCALL_TABLE_ID0] = PPM_SC_UNLINKAT,
+	[__NR_renameat - SYSCALL_TABLE_ID0] = PPM_SC_RENAMEAT,
+	[__NR_linkat - SYSCALL_TABLE_ID0] = PPM_SC_LINKAT,
+	[__NR_symlinkat - SYSCALL_TABLE_ID0] = PPM_SC_SYMLINKAT,
+	[__NR_readlinkat - SYSCALL_TABLE_ID0] = PPM_SC_READLINKAT,
+	[__NR_fchmodat - SYSCALL_TABLE_ID0] = PPM_SC_FCHMODAT,
+	[__NR_faccessat - SYSCALL_TABLE_ID0] = PPM_SC_FACCESSAT,
+	[__NR_pselect6 - SYSCALL_TABLE_ID0] = PPM_SC_PSELECT6,
+	[__NR_ppoll - SYSCALL_TABLE_ID0] = PPM_SC_PPOLL,
+	[__NR_unshare - SYSCALL_TABLE_ID0] = PPM_SC_UNSHARE,
+	[__NR_set_robust_list - SYSCALL_TABLE_ID0] = PPM_SC_SET_ROBUST_LIST,
+	[__NR_get_robust_list - SYSCALL_TABLE_ID0] = PPM_SC_GET_ROBUST_LIST,
+	[__NR_splice - SYSCALL_TABLE_ID0] = PPM_SC_SPLICE,
+	[__NR_tee - SYSCALL_TABLE_ID0] = PPM_SC_TEE,
+	[__NR_vmsplice - SYSCALL_TABLE_ID0] = PPM_SC_VMSPLICE,
+#ifdef __NR_getcpu
+	[__NR_getcpu - SYSCALL_TABLE_ID0] = PPM_SC_GETCPU,
+#endif
+	[__NR_epoll_pwait - SYSCALL_TABLE_ID0] = PPM_SC_EPOLL_PWAIT,
+	[__NR_utimensat - SYSCALL_TABLE_ID0] = PPM_SC_UTIMENSAT,
+	[__NR_signalfd - SYSCALL_TABLE_ID0] = PPM_SC_SIGNALFD,
+	[__NR_timerfd_create - SYSCALL_TABLE_ID0] = PPM_SC_TIMERFD_CREATE,
+	[__NR_eventfd - SYSCALL_TABLE_ID0] = PPM_SC_EVENTFD,
+	[__NR_timerfd_settime - SYSCALL_TABLE_ID0] = PPM_SC_TIMERFD_SETTIME,
+	[__NR_timerfd_gettime - SYSCALL_TABLE_ID0] = PPM_SC_TIMERFD_GETTIME,
+	[__NR_signalfd4 - SYSCALL_TABLE_ID0] = PPM_SC_SIGNALFD4,
+	[__NR_eventfd2 - SYSCALL_TABLE_ID0] = PPM_SC_EVENTFD2,
+	[__NR_epoll_create1 - SYSCALL_TABLE_ID0] = PPM_SC_EPOLL_CREATE1,
+	[__NR_dup3 - SYSCALL_TABLE_ID0] = PPM_SC_DUP3,
+	[__NR_pipe2 - SYSCALL_TABLE_ID0] = PPM_SC_PIPE2,
+	[__NR_inotify_init1 - SYSCALL_TABLE_ID0] = PPM_SC_INOTIFY_INIT1,
+	[__NR_preadv - SYSCALL_TABLE_ID0] = PPM_SC_PREADV,
+	[__NR_pwritev - SYSCALL_TABLE_ID0] = PPM_SC_PWRITEV,
+	[__NR_rt_tgsigqueueinfo - SYSCALL_TABLE_ID0] = PPM_SC_RT_TGSIGQUEUEINFO,
+	[__NR_perf_event_open - SYSCALL_TABLE_ID0] = PPM_SC_PERF_EVENT_OPEN,
+#ifdef __NR_fanotify_init
+	[__NR_fanotify_init - SYSCALL_TABLE_ID0] = PPM_SC_FANOTIFY_INIT,
+#endif
+#ifdef __NR_prlimit64
+	[__NR_prlimit64 - SYSCALL_TABLE_ID0] = PPM_SC_PRLIMIT64,
+#endif
+#ifdef __NR_clock_adjtime
+	[__NR_clock_adjtime - SYSCALL_TABLE_ID0] = PPM_SC_CLOCK_ADJTIME,
+#endif
+#ifdef __NR_syncfs
+	[__NR_syncfs - SYSCALL_TABLE_ID0] = PPM_SC_SYNCFS,
+#endif
+#ifdef __NR_setns
+	[__NR_setns - SYSCALL_TABLE_ID0] = PPM_SC_SETNS,
+#endif
+	[__NR_getdents64 - SYSCALL_TABLE_ID0] =  PPM_SC_GETDENTS64,
+#ifndef __NR_socketcall
+	/*
+	 * Non-multiplexed socket family
+	 */
+	[__NR_socket - SYSCALL_TABLE_ID0] =  PPM_SC_SOCKET,
+	[__NR_bind - SYSCALL_TABLE_ID0] =	PPM_SC_BIND,
+	[__NR_connect - SYSCALL_TABLE_ID0] =  PPM_SC_CONNECT,
+	[__NR_listen - SYSCALL_TABLE_ID0] =  PPM_SC_LISTEN,
+	[__NR_accept - SYSCALL_TABLE_ID0] =  PPM_SC_ACCEPT,
+	[__NR_getsockname - SYSCALL_TABLE_ID0] = PPM_SC_GETSOCKNAME,
+	[__NR_getpeername - SYSCALL_TABLE_ID0] = PPM_SC_GETPEERNAME,
+	[__NR_socketpair - SYSCALL_TABLE_ID0] = PPM_SC_SOCKETPAIR,
+/* [__NR_send - SYSCALL_TABLE_ID0] =	PPM_SC_NR_SEND, */
+	[__NR_sendto - SYSCALL_TABLE_ID0] =  PPM_SC_SENDTO,
+/* [__NR_recv - SYSCALL_TABLE_ID0] =	PPM_SC_NR_RECV, */
+	[__NR_recvfrom - SYSCALL_TABLE_ID0] =  PPM_SC_RECVFROM,
+	[__NR_shutdown - SYSCALL_TABLE_ID0] =  PPM_SC_SHUTDOWN,
+	[__NR_setsockopt - SYSCALL_TABLE_ID0] = PPM_SC_SETSOCKOPT,
+	[__NR_getsockopt - SYSCALL_TABLE_ID0] = PPM_SC_GETSOCKOPT,
+	[__NR_sendmsg - SYSCALL_TABLE_ID0] =  PPM_SC_SENDMSG,
+	[__NR_recvmsg - SYSCALL_TABLE_ID0] =  PPM_SC_RECVMSG,
+	[__NR_accept4 - SYSCALL_TABLE_ID0] =  PPM_SC_ACCEPT4,
+#else
+	[__NR_socketcall - SYSCALL_TABLE_ID0] = PPM_SC_SOCKETCALL,
+#endif
+
+
+#ifdef __NR_sendmmsg
+	[__NR_sendmmsg - SYSCALL_TABLE_ID0] =  PPM_SC_SENDMMSG,
+#endif
+#ifdef __NR_recvmmsg
+	[__NR_recvmmsg - SYSCALL_TABLE_ID0] =  PPM_SC_RECVMMSG,
+#endif
+	/*
+	 * Non-multiplexed IPC family
+	 */
+#ifdef __NR_semop
+	[__NR_semop - SYSCALL_TABLE_ID0] =  PPM_SC_SEMOP,
+#endif
+#ifdef __NR_semget
+	[__NR_semget - SYSCALL_TABLE_ID0] =  PPM_SC_SEMGET,
+#endif
+#ifdef __NR_semctl
+	[__NR_semctl - SYSCALL_TABLE_ID0] =  PPM_SC_SEMCTL,
+#endif
+#ifdef __NR_msgsnd
+	[__NR_msgsnd - SYSCALL_TABLE_ID0] =  PPM_SC_MSGSND,
+#endif
+#ifdef __NR_msgrcv
+	[__NR_msgrcv - SYSCALL_TABLE_ID0] =  PPM_SC_MSGRCV,
+#endif
+#ifdef __NR_msgget
+	[__NR_msgget - SYSCALL_TABLE_ID0] =  PPM_SC_MSGGET,
+#endif
+#ifdef __NR_msgctl
+	[__NR_msgctl - SYSCALL_TABLE_ID0] =  PPM_SC_MSGCTL,
+#endif
+/* [__NR_shmatcall - SYSCALL_TABLE_ID0] =  PPM_SC_NR_SHMATCALL, */
+#ifdef __NR_shmdt
+	[__NR_shmdt - SYSCALL_TABLE_ID0] =  PPM_SC_SHMDT,
+#endif
+#ifdef __NR_shmget
+	[__NR_shmget - SYSCALL_TABLE_ID0] =  PPM_SC_SHMGET,
+#endif
+#ifdef __NR_shmctl
+	[__NR_shmctl - SYSCALL_TABLE_ID0] =  PPM_SC_SHMCTL,
+#endif
+/* [__NR_fcntl64 - SYSCALL_TABLE_ID0] =  PPM_SC_NR_FCNTL64, */
+#ifdef __NR_statfs64
+	[__NR_statfs64 - SYSCALL_TABLE_ID0] = PPM_SC_STATFS64,
+#endif
+#ifdef __NR_fstatfs64
+	[__NR_fstatfs64 - SYSCALL_TABLE_ID0] = PPM_SC_FSTATFS64,
+#endif
+#ifdef __NR_fstatat64
+	[__NR_fstatat64 - SYSCALL_TABLE_ID0] = PPM_SC_FSTATAT64,
+#endif
+#ifdef __NR_sendfile64
+	[__NR_sendfile64 - SYSCALL_TABLE_ID0] = PPM_SC_SENDFILE64,
+#endif
+#ifdef __NR_ugetrlimit
+	[__NR_ugetrlimit - SYSCALL_TABLE_ID0] = PPM_SC_UGETRLIMIT,
+#endif
+#ifdef __NR_bdflush
+	[__NR_bdflush - SYSCALL_TABLE_ID0] = PPM_SC_BDFLUSH,
+#endif
+#ifdef __NR_sigprocmask
+	[__NR_sigprocmask - SYSCALL_TABLE_ID0] = PPM_SC_SIGPROCMASK,
+#endif
+#ifdef __NR_ipc
+	[__NR_ipc - SYSCALL_TABLE_ID0] = PPM_SC_IPC,
+#endif
+#ifdef __NR_stat64
+	[__NR_stat64 - SYSCALL_TABLE_ID0] = PPM_SC_STAT64,
+#endif
+#ifdef __NR_lstat64
+	[__NR_lstat64 - SYSCALL_TABLE_ID0] = PPM_SC_LSTAT64,
+#endif
+#ifdef __NR_fstat64
+	[__NR_fstat64 - SYSCALL_TABLE_ID0] = PPM_SC_FSTAT64,
+#endif
+#ifdef __NR_fcntl64
+	[__NR_fcntl64 - SYSCALL_TABLE_ID0] = PPM_SC_FCNTL64,
+#endif
+#ifdef __NR_mmap2
+	[__NR_mmap2 - SYSCALL_TABLE_ID0] = PPM_SC_MMAP2,
+#endif
+#ifdef __NR__newselect
+	[__NR__newselect - SYSCALL_TABLE_ID0] = PPM_SC__NEWSELECT,
+#endif
+#ifdef __NR_sgetmask
+	[__NR_sgetmask - SYSCALL_TABLE_ID0] = PPM_SC_SGETMASK,
+#endif
+#ifdef __NR_ssetmask
+	[__NR_ssetmask - SYSCALL_TABLE_ID0] = PPM_SC_SSETMASK,
+#endif
+
+/* [__NR_setreuid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETREUID16, */
+/* [__NR_setregid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETREGID16, */
+#ifdef __NR_sigpending
+	[__NR_sigpending - SYSCALL_TABLE_ID0] = PPM_SC_SIGPENDING,
+#endif
+#ifdef __NR_olduname
+	[__NR_olduname - SYSCALL_TABLE_ID0] = PPM_SC_OLDUNAME,
+#endif
+#ifdef __NR_umount
+	[__NR_umount - SYSCALL_TABLE_ID0] = PPM_SC_UMOUNT,
+#endif
+#ifdef __NR_signal
+	[__NR_signal - SYSCALL_TABLE_ID0] = PPM_SC_SIGNAL,
+#endif
+#ifdef __NR_nice
+	[__NR_nice - SYSCALL_TABLE_ID0] = PPM_SC_NICE,
+#endif
+#ifdef __NR_stime
+	[__NR_stime - SYSCALL_TABLE_ID0] = PPM_SC_STIME,
+#endif
+#ifdef __NR__llseek
+	[__NR__llseek - SYSCALL_TABLE_ID0] = PPM_SC__LLSEEK,
+#endif
+#ifdef __NR_waitpid
+	[__NR_waitpid - SYSCALL_TABLE_ID0] = PPM_SC_WAITPID,
+#endif
+#ifdef __NR_pread64
+	[__NR_pread64 - SYSCALL_TABLE_ID0] = PPM_SC_PREAD64,
+#endif
+#ifdef __NR_pwrite64
+	[__NR_pwrite64 - SYSCALL_TABLE_ID0] = PPM_SC_PWRITE64,
+#endif
+#ifdef __NR_shmat
+	[__NR_shmat - SYSCALL_TABLE_ID0] = PPM_SC_SHMAT,
+#endif
+#ifdef __NR_rt_sigreturn
+	[__NR_rt_sigreturn - SYSCALL_TABLE_ID0] = PPM_SC_SIGRETURN,
+#endif
+#ifdef __NR_fallocate
+	[__NR_fallocate - SYSCALL_TABLE_ID0] = PPM_SC_FALLOCATE,
+#endif
+#ifdef __NR_newfstatat
+	[__NR_newfstatat - SYSCALL_TABLE_ID0] = PPM_SC_NEWFSSTAT,
+#endif
+#ifdef __NR_process_vm_readv
+	[__NR_process_vm_readv - SYSCALL_TABLE_ID0] = PPM_SC_PROCESS_VM_READV,
+#endif
+#ifdef __NR_process_vm_writev
+	[__NR_process_vm_writev - SYSCALL_TABLE_ID0] = PPM_SC_PROCESS_VM_WRITEV,
+#endif
+#ifdef __NR_fork
+	[__NR_fork - SYSCALL_TABLE_ID0] = PPM_SC_FORK,
+#endif
+#ifdef __NR_vfork
+	[__NR_vfork - SYSCALL_TABLE_ID0] = PPM_SC_VFORK,
+#endif
+#ifdef __NR_quotactl
+	[__NR_quotactl - SYSCALL_TABLE_ID0] = PPM_SC_QUOTACTL,
+#endif
+#ifdef __NR_setresuid
+	[__NR_setresuid - SYSCALL_TABLE_ID0] = PPM_SC_SETRESUID,
+#endif
+#ifdef __NR_setresuid32
+	[__NR_setresuid32 - SYSCALL_TABLE_ID0] = PPM_SC_SETRESUID,
+#endif
+#ifdef __NR_setresgid
+	[__NR_setresgid - SYSCALL_TABLE_ID0] = PPM_SC_SETRESGID,
+#endif
+#ifdef __NR_setresgid32
+	[__NR_setresgid32 - SYSCALL_TABLE_ID0] = PPM_SC_SETRESGID,
+#endif
+#ifdef __NR_setuid
+	[__NR_setuid - SYSCALL_TABLE_ID0] = PPM_SC_SETUID,
+#endif
+#ifdef __NR_setuid32
+	[__NR_setuid32 - SYSCALL_TABLE_ID0] = PPM_SC_SETUID32,
+#endif
+#ifdef __NR_setgid
+	[__NR_setgid - SYSCALL_TABLE_ID0] = PPM_SC_SETGID,
+#endif
+#ifdef __NR_setgid32
+	[__NR_setgid32 - SYSCALL_TABLE_ID0] = PPM_SC_SETGID32,
+#endif
+#ifdef __NR_getuid
+	[__NR_getuid - SYSCALL_TABLE_ID0] = PPM_SC_GETUID,
+#endif
+#ifdef __NR_getuid32
+	[__NR_getuid32 - SYSCALL_TABLE_ID0] = PPM_SC_GETUID32,
+#endif
+#ifdef __NR_geteuid
+	[__NR_geteuid - SYSCALL_TABLE_ID0] = PPM_SC_GETEUID,
+#endif
+#ifdef __NR_geteuid32
+	[__NR_geteuid32 - SYSCALL_TABLE_ID0] = PPM_SC_GETEUID,
+#endif
+#ifdef __NR_getgid
+	[__NR_getgid - SYSCALL_TABLE_ID0] = PPM_SC_GETGID,
+#endif
+#ifdef __NR_getgid32
+	[__NR_getgid32 - SYSCALL_TABLE_ID0] = PPM_SC_GETGID,
+#endif
+#ifdef __NR_getegid
+	[__NR_getegid - SYSCALL_TABLE_ID0] = PPM_SC_GETEGID,
+#endif
+#ifdef __NR_getegid32
+	[__NR_getegid32 - SYSCALL_TABLE_ID0] = PPM_SC_GETEGID,
+#endif
+#ifdef __NR_getresuid
+	[__NR_getresuid - SYSCALL_TABLE_ID0] = PPM_SC_GETRESUID,
+#endif
+#ifdef __NR_getresuid32
+	[__NR_getresuid32 - SYSCALL_TABLE_ID0] = PPM_SC_GETRESUID32,
+#endif
+#ifdef __NR_getresgid
+	[__NR_getresgid - SYSCALL_TABLE_ID0] = PPM_SC_GETRESGID,
+#endif
+#ifdef __NR_getresgid32
+	[__NR_getresgid32 - SYSCALL_TABLE_ID0] = PPM_SC_GETRESGID32,
+#endif
+#ifdef __NR_setns
+	[__NR_setns - SYSCALL_TABLE_ID0] = PPM_SC_SETNS,
+#endif
+#ifdef __NR_access
+	[__NR_access - SYSCALL_TABLE_ID0] = PPM_SC_ACCESS,
+#endif
+#ifdef __NR_finit_module
+	[__NR_finit_module - SYSCALL_TABLE_ID0] = PPM_SC_FINIT_MODULE,
+#endif
+#ifdef __NR_bpf
+	[__NR_bpf - SYSCALL_TABLE_ID0] = PPM_SC_BPF,
+#endif
+#ifdef __NR_seccomp
+	[__NR_seccomp - SYSCALL_TABLE_ID0] = PPM_SC_SECCOMP,
+#endif
+};
+
+#ifdef CONFIG_IA32_EMULATION
+const struct syscall_evt_pair g_syscall_ia32_table[SYSCALL_TABLE_SIZE] = {
+	[__NR_ia32_open - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_OPEN_E, PPME_SYSCALL_OPEN_X},
+	[__NR_ia32_creat - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_CREAT_E, PPME_SYSCALL_CREAT_X},
+	[__NR_ia32_close - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_CLOSE_E, PPME_SYSCALL_CLOSE_X},
+	[__NR_ia32_brk - SYSCALL_TABLE_ID0] =                        {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_BRK_4_E, PPME_SYSCALL_BRK_4_X},
+	[__NR_ia32_read - SYSCALL_TABLE_ID0] =                       {UF_USED, PPME_SYSCALL_READ_E, PPME_SYSCALL_READ_X},
+	[__NR_ia32_write - SYSCALL_TABLE_ID0] =                      {UF_USED, PPME_SYSCALL_WRITE_E, PPME_SYSCALL_WRITE_X},
+	[__NR_ia32_execve - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_EXECVE_18_E, PPME_SYSCALL_EXECVE_18_X},
+	[__NR_ia32_clone - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_CLONE_20_E, PPME_SYSCALL_CLONE_20_X},
+	[__NR_ia32_fork - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_FORK_20_E, PPME_SYSCALL_FORK_20_X},
+	[__NR_ia32_vfork - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_VFORK_20_E, PPME_SYSCALL_VFORK_20_X},
+	[__NR_ia32_pipe - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_PIPE_E, PPME_SYSCALL_PIPE_X},
+	[__NR_ia32_pipe2 - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_PIPE_E, PPME_SYSCALL_PIPE_X},
+	[__NR_ia32_eventfd - SYSCALL_TABLE_ID0] =                    {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_EVENTFD_E, PPME_SYSCALL_EVENTFD_X},
+	[__NR_ia32_eventfd2 - SYSCALL_TABLE_ID0] =                   {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_EVENTFD_E, PPME_SYSCALL_EVENTFD_X},
+	[__NR_ia32_futex - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_FUTEX_E, PPME_SYSCALL_FUTEX_X},
+	[__NR_ia32_stat - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_STAT_E, PPME_SYSCALL_STAT_X},
+	[__NR_ia32_lstat - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_LSTAT_E, PPME_SYSCALL_LSTAT_X},
+	[__NR_ia32_fstat - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_FSTAT_E, PPME_SYSCALL_FSTAT_X},
+	[__NR_ia32_epoll_wait - SYSCALL_TABLE_ID0] =                 {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_EPOLLWAIT_E, PPME_SYSCALL_EPOLLWAIT_X},
+	[__NR_ia32_poll - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_POLL_E, PPME_SYSCALL_POLL_X},
+#ifdef __NR_ia32_select
+	[__NR_ia32_select - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_SELECT_E, PPME_SYSCALL_SELECT_X},
+#endif
+	[__NR_ia32_lseek - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_LSEEK_E, PPME_SYSCALL_LSEEK_X},
+	[__NR_ia32_ioctl - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_IOCTL_3_E, PPME_SYSCALL_IOCTL_3_X},
+	[__NR_ia32_getcwd - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_GETCWD_E, PPME_SYSCALL_GETCWD_X},
+	[__NR_ia32_chdir - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_CHDIR_E, PPME_SYSCALL_CHDIR_X},
+	[__NR_ia32_fchdir - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_FCHDIR_E, PPME_SYSCALL_FCHDIR_X},
+	[__NR_ia32_mkdir - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_MKDIR_2_E, PPME_SYSCALL_MKDIR_2_X},
+	[__NR_ia32_rmdir - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_RMDIR_2_E, PPME_SYSCALL_RMDIR_2_X},
+	[__NR_ia32_openat - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_OPENAT_E, PPME_SYSCALL_OPENAT_X},
+	[__NR_ia32_link - SYSCALL_TABLE_ID0] =                       {UF_USED, PPME_SYSCALL_LINK_E, PPME_SYSCALL_LINK_X},
+	[__NR_ia32_linkat - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_LINKAT_E, PPME_SYSCALL_LINKAT_X},
+	[__NR_ia32_unlink - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_UNLINK_E, PPME_SYSCALL_UNLINK_X},
+	[__NR_ia32_unlinkat - SYSCALL_TABLE_ID0] =                   {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_UNLINKAT_E, PPME_SYSCALL_UNLINKAT_X},
+	[__NR_ia32_pread64 - SYSCALL_TABLE_ID0] =                    {UF_USED, PPME_SYSCALL_PREAD_E, PPME_SYSCALL_PREAD_X},
+	[__NR_ia32_pwrite64 - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SYSCALL_PWRITE_E, PPME_SYSCALL_PWRITE_X},
+	[__NR_ia32_readv - SYSCALL_TABLE_ID0] =                      {UF_USED, PPME_SYSCALL_READV_E, PPME_SYSCALL_READV_X},
+	[__NR_ia32_writev - SYSCALL_TABLE_ID0] =                     {UF_USED, PPME_SYSCALL_WRITEV_E, PPME_SYSCALL_WRITEV_X},
+	[__NR_ia32_preadv - SYSCALL_TABLE_ID0] =                     {UF_USED, PPME_SYSCALL_PREADV_E, PPME_SYSCALL_PREADV_X},
+	[__NR_ia32_pwritev - SYSCALL_TABLE_ID0] =                    {UF_USED, PPME_SYSCALL_PWRITEV_E, PPME_SYSCALL_PWRITEV_X},
+	[__NR_ia32_dup - SYSCALL_TABLE_ID0] =                        {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_DUP_E, PPME_SYSCALL_DUP_X},
+	[__NR_ia32_dup2 - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_DUP_E, PPME_SYSCALL_DUP_X},
+	[__NR_ia32_dup3 - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_NEVER_DROP | UF_SIMPLEDRIVER_KEEP, PPME_SYSCALL_DUP_E, PPME_SYSCALL_DUP_X},
+	[__NR_ia32_signalfd - SYSCALL_TABLE_ID0] =                   {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_SIGNALFD_E, PPME_SYSCALL_SIGNALFD_X},
+	[__NR_ia32_signalfd4 - SYSCALL_TABLE_ID0] =                  {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_SIGNALFD_E, PPME_SYSCALL_SIGNALFD_X},
+	[__NR_ia32_kill - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_KILL_E, PPME_SYSCALL_KILL_X},
+	[__NR_ia32_tkill - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_TKILL_E, PPME_SYSCALL_TKILL_X},
+	[__NR_ia32_tgkill - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_TGKILL_E, PPME_SYSCALL_TGKILL_X},
+	[__NR_ia32_nanosleep - SYSCALL_TABLE_ID0] =                  {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_NANOSLEEP_E, PPME_SYSCALL_NANOSLEEP_X},
+	[__NR_ia32_timerfd_create - SYSCALL_TABLE_ID0] =             {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_TIMERFD_CREATE_E, PPME_SYSCALL_TIMERFD_CREATE_X},
+	[__NR_ia32_inotify_init - SYSCALL_TABLE_ID0] =               {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_INOTIFY_INIT_E, PPME_SYSCALL_INOTIFY_INIT_X},
+	[__NR_ia32_inotify_init1 - SYSCALL_TABLE_ID0] =              {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_INOTIFY_INIT_E, PPME_SYSCALL_INOTIFY_INIT_X},
+	[__NR_ia32_getrlimit - SYSCALL_TABLE_ID0] =                  {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_GETRLIMIT_E, PPME_SYSCALL_GETRLIMIT_X},
+	[__NR_ia32_setrlimit - SYSCALL_TABLE_ID0] =                  {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_SETRLIMIT_E, PPME_SYSCALL_SETRLIMIT_X},
+#ifdef __NR_ia32_prlimit64
+	[__NR_ia32_prlimit64 - SYSCALL_TABLE_ID0] =                  {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_PRLIMIT_E, PPME_SYSCALL_PRLIMIT_X},
+#endif
+#ifdef __NR_ia32_ugetrlimit
+	[__NR_ia32_ugetrlimit - SYSCALL_TABLE_ID0] =                 {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_GETRLIMIT_E, PPME_SYSCALL_GETRLIMIT_X},
+#endif
+	[__NR_ia32_fcntl - SYSCALL_TABLE_ID0] =                      {UF_USED, PPME_SYSCALL_FCNTL_E, PPME_SYSCALL_FCNTL_X},
+#ifdef __NR_ia32_fcntl64
+	[__NR_ia32_fcntl64 - SYSCALL_TABLE_ID0] =                    {UF_USED, PPME_SYSCALL_FCNTL_E, PPME_SYSCALL_FCNTL_X},
+#endif
+	[__NR_ia32_ppoll - SYSCALL_TABLE_ID0] =			             {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_PPOLL_E, PPME_SYSCALL_PPOLL_X},
+/* [__NR_ia32_old_select - SYSCALL_TABLE_ID0] =	{UF_USED, PPME_GENERIC_E, PPME_GENERIC_X}, */
+	[__NR_ia32_pselect6 - SYSCALL_TABLE_ID0] =                   {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_ia32_epoll_create - SYSCALL_TABLE_ID0] =               {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_ia32_epoll_ctl - SYSCALL_TABLE_ID0] =                  {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_ia32_uselib - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_ia32_sched_setparam - SYSCALL_TABLE_ID0] =             {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_ia32_sched_getparam - SYSCALL_TABLE_ID0] =             {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_ia32_syslog - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_ia32_chmod - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_ia32_lchown - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_ia32_utime - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_ia32_mount - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_ia32_umount2 - SYSCALL_TABLE_ID0] =                    {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_ia32_ptrace - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_PTRACE_E, PPME_SYSCALL_PTRACE_X},
+	[__NR_ia32_alarm - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+	[__NR_ia32_pause - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_GENERIC_E, PPME_GENERIC_X},
+
+#ifndef __NR_ia32_socketcall
+	[__NR_ia32_socket - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_SIMPLEDRIVER_KEEP, PPME_SOCKET_SOCKET_E, PPME_SOCKET_SOCKET_X},
+	[__NR_ia32_bind - SYSCALL_TABLE_ID0] =                       {UF_USED, PPME_SOCKET_BIND_E,  PPME_SOCKET_BIND_X},
+	[__NR_ia32_connect - SYSCALL_TABLE_ID0] =                    {UF_USED | UF_SIMPLEDRIVER_KEEP, PPME_SOCKET_CONNECT_E, PPME_SOCKET_CONNECT_X},
+	[__NR_ia32_listen - SYSCALL_TABLE_ID0] =                     {UF_USED, PPME_SOCKET_LISTEN_E, PPME_SOCKET_LISTEN_X},
+	[__NR_ia32_accept - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_SIMPLEDRIVER_KEEP, PPME_SOCKET_ACCEPT_E, PPME_SOCKET_ACCEPT_X},
+	[__NR_ia32_getsockname - SYSCALL_TABLE_ID0] =                {UF_USED | UF_ALWAYS_DROP, PPME_SOCKET_GETSOCKNAME_E, PPME_SOCKET_GETSOCKNAME_X},
+	[__NR_ia32_getpeername - SYSCALL_TABLE_ID0] =                {UF_USED | UF_ALWAYS_DROP, PPME_SOCKET_GETPEERNAME_E, PPME_SOCKET_GETPEERNAME_X},
+	[__NR_ia32_socketpair - SYSCALL_TABLE_ID0] =                 {UF_USED | UF_NEVER_DROP, PPME_SOCKET_SOCKETPAIR_E, PPME_SOCKET_SOCKETPAIR_X},
+	[__NR_ia32_sendto - SYSCALL_TABLE_ID0] =                     {UF_USED, PPME_SOCKET_SENDTO_E, PPME_SOCKET_SENDTO_X},
+	[__NR_ia32_recvfrom - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SOCKET_RECVFROM_E, PPME_SOCKET_RECVFROM_X},
+	[__NR_ia32_shutdown - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SOCKET_SHUTDOWN_E, PPME_SOCKET_SHUTDOWN_X},
+	[__NR_ia32_setsockopt - SYSCALL_TABLE_ID0] =                 {UF_USED | UF_ALWAYS_DROP, PPME_SOCKET_SETSOCKOPT_E, PPME_SOCKET_SETSOCKOPT_X},
+	[__NR_ia32_getsockopt - SYSCALL_TABLE_ID0] =                 {UF_USED | UF_ALWAYS_DROP, PPME_SOCKET_GETSOCKOPT_E, PPME_SOCKET_GETSOCKOPT_X},
+	[__NR_ia32_sendmsg - SYSCALL_TABLE_ID0] =                    {UF_USED, PPME_SOCKET_SENDMSG_E, PPME_SOCKET_SENDMSG_X},
+	[__NR_ia32_accept4 - SYSCALL_TABLE_ID0] =                    {UF_USED | UF_SIMPLEDRIVER_KEEP, PPME_SOCKET_ACCEPT4_E, PPME_SOCKET_ACCEPT4_X},
+#endif
+
+#ifdef __NR_ia32_sendmmsg
+	[__NR_ia32_sendmmsg - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SOCKET_SENDMMSG_E, PPME_SOCKET_SENDMMSG_X},
+#endif
+#ifdef __NR_ia32_recvmsg
+	[__NR_ia32_recvmsg - SYSCALL_TABLE_ID0] =                    {UF_USED, PPME_SOCKET_RECVMSG_E, PPME_SOCKET_RECVMSG_X},
+#endif
+#ifdef __NR_ia32_recvmmsg
+	[__NR_ia32_recvmmsg - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SOCKET_RECVMMSG_E, PPME_SOCKET_RECVMMSG_X},
+#endif
+#ifdef __NR_ia32_stat64
+	[__NR_ia32_stat64 - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_STAT64_E, PPME_SYSCALL_STAT64_X},
+#endif
+#ifdef __NR_ia32_fstat64
+	[__NR_ia32_fstat64 - SYSCALL_TABLE_ID0] =                    {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_FSTAT64_E, PPME_SYSCALL_FSTAT64_X},
+#endif
+#ifdef __NR_ia32__llseek
+	[__NR_ia32__llseek - SYSCALL_TABLE_ID0] =                    {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_LLSEEK_E, PPME_SYSCALL_LLSEEK_X},
+#endif
+	[__NR_ia32_mmap - SYSCALL_TABLE_ID0] =                       {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_MMAP_E, PPME_SYSCALL_MMAP_X},
+#ifdef __NR_ia32_mmap2
+	[__NR_ia32_mmap2 - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_MMAP2_E, PPME_SYSCALL_MMAP2_X},
+#endif
+	[__NR_ia32_munmap - SYSCALL_TABLE_ID0] =						{UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_MUNMAP_E, PPME_SYSCALL_MUNMAP_X},
+	[__NR_ia32_splice - SYSCALL_TABLE_ID0] =                     {UF_USED, PPME_SYSCALL_SPLICE_E, PPME_SYSCALL_SPLICE_X},
+#ifdef __NR_ia32_process_vm_readv
+	[__NR_ia32_process_vm_readv - SYSCALL_TABLE_ID0] =           {UF_USED, PPME_GENERIC_E, PPME_GENERIC_X},
+#endif
+#ifdef __NR_ia32_process_vm_writev
+	[__NR_ia32_process_vm_writev - SYSCALL_TABLE_ID0] =          {UF_USED, PPME_GENERIC_E, PPME_GENERIC_X},
+#endif
+
+	[__NR_ia32_rename - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_RENAME_E, PPME_SYSCALL_RENAME_X},
+	[__NR_ia32_renameat - SYSCALL_TABLE_ID0] =                   {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_RENAMEAT_E, PPME_SYSCALL_RENAMEAT_X},
+	[__NR_ia32_symlink - SYSCALL_TABLE_ID0] =                    {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_SYMLINK_E, PPME_SYSCALL_SYMLINK_X},
+	[__NR_ia32_symlinkat - SYSCALL_TABLE_ID0] =                  {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_SYMLINKAT_E, PPME_SYSCALL_SYMLINKAT_X},
+	[__NR_ia32_sendfile - SYSCALL_TABLE_ID0] =                   {UF_USED, PPME_SYSCALL_SENDFILE_E, PPME_SYSCALL_SENDFILE_X},
+#ifdef __NR_ia32_sendfile64
+	[__NR_ia32_sendfile64 - SYSCALL_TABLE_ID0] =                 {UF_USED, PPME_SYSCALL_SENDFILE_E, PPME_SYSCALL_SENDFILE_X},
+#endif
+#ifdef __NR_ia32_quotactl
+	[__NR_ia32_quotactl - SYSCALL_TABLE_ID0] = {UF_USED, PPME_SYSCALL_QUOTACTL_E, PPME_SYSCALL_QUOTACTL_X},
+#endif
+#ifdef __NR_ia32_setresuid
+	[__NR_ia32_setresuid - SYSCALL_TABLE_ID0] = {UF_USED, PPME_SYSCALL_SETRESUID_E, PPME_SYSCALL_SETRESUID_X },
+#endif
+#ifdef __NR_ia32_setresuid32
+	[__NR_ia32_setresuid32 - SYSCALL_TABLE_ID0] = {UF_USED, PPME_SYSCALL_SETRESUID_E, PPME_SYSCALL_SETRESUID_X },
+#endif
+#ifdef __NR_ia32_setresgid
+	[__NR_ia32_setresgid - SYSCALL_TABLE_ID0] = {UF_USED, PPME_SYSCALL_SETRESGID_E, PPME_SYSCALL_SETRESGID_X },
+#endif
+#ifdef __NR_ia32_setresgid32
+	[__NR_ia32_setresgid32 - SYSCALL_TABLE_ID0] = {UF_USED, PPME_SYSCALL_SETRESGID_E, PPME_SYSCALL_SETRESGID_X },
+#endif
+#ifdef __NR_ia32_setuid
+	[__NR_ia32_setuid - SYSCALL_TABLE_ID0] = { UF_USED, PPME_SYSCALL_SETUID_E, PPME_SYSCALL_SETUID_X },
+#endif
+#ifdef __NR_ia32_setuid32
+	[__NR_ia32_setuid32 - SYSCALL_TABLE_ID0] = { UF_USED, PPME_SYSCALL_SETUID_E, PPME_SYSCALL_SETUID_X },
+#endif
+#ifdef __NR_ia32_setgid
+	[__NR_ia32_setgid - SYSCALL_TABLE_ID0] = { UF_USED, PPME_SYSCALL_SETGID_E, PPME_SYSCALL_SETGID_X },
+#endif
+#ifdef __NR_ia32_setgid32
+	[__NR_ia32_setgid32 - SYSCALL_TABLE_ID0] = { UF_USED, PPME_SYSCALL_SETGID_E, PPME_SYSCALL_SETGID_X },
+#endif
+#ifdef __NR_ia32_getuid
+	[__NR_ia32_getuid - SYSCALL_TABLE_ID0] = { UF_USED, PPME_SYSCALL_GETUID_E, PPME_SYSCALL_GETUID_X },
+#endif
+#ifdef __NR_ia32_getuid32
+	[__NR_ia32_getuid32 - SYSCALL_TABLE_ID0] = { UF_USED, PPME_SYSCALL_GETUID_E, PPME_SYSCALL_GETUID_X },
+#endif
+#ifdef __NR_ia32_geteuid
+	[__NR_ia32_geteuid - SYSCALL_TABLE_ID0] = { UF_USED, PPME_SYSCALL_GETEUID_E, PPME_SYSCALL_GETEUID_X },
+#endif
+#ifdef __NR_ia32_geteuid32
+	[__NR_ia32_geteuid32 - SYSCALL_TABLE_ID0] = { UF_USED, PPME_SYSCALL_GETEUID_E, PPME_SYSCALL_GETEUID_X },
+#endif
+#ifdef __NR_ia32_getgid
+	[__NR_ia32_getgid - SYSCALL_TABLE_ID0] = { UF_USED, PPME_SYSCALL_GETGID_E, PPME_SYSCALL_GETGID_X },
+#endif
+#ifdef __NR_ia32_getgid32
+	[__NR_ia32_getgid32 - SYSCALL_TABLE_ID0] = { UF_USED, PPME_SYSCALL_GETGID_E, PPME_SYSCALL_GETGID_X },
+#endif
+#ifdef __NR_ia32_getegid
+	[__NR_ia32_getegid - SYSCALL_TABLE_ID0] = { UF_USED, PPME_SYSCALL_GETEGID_E, PPME_SYSCALL_GETEGID_X },
+#endif
+#ifdef __NR_ia32_getegid32
+	[__NR_ia32_getegid32 - SYSCALL_TABLE_ID0] = { UF_USED, PPME_SYSCALL_GETEGID_E, PPME_SYSCALL_GETEGID_X },
+#endif
+#ifdef __NR_ia32_getresuid
+	[__NR_ia32_getresuid - SYSCALL_TABLE_ID0] = { UF_USED, PPME_SYSCALL_GETRESUID_E, PPME_SYSCALL_GETRESUID_X },
+#endif
+#ifdef __NR_ia32_getresuid32
+	[__NR_ia32_getresuid32 - SYSCALL_TABLE_ID0] = { UF_USED, PPME_SYSCALL_GETRESUID_E, PPME_SYSCALL_GETRESUID_X },
+#endif
+#ifdef __NR_ia32_getresgid
+	[__NR_ia32_getresgid - SYSCALL_TABLE_ID0] = { UF_USED, PPME_SYSCALL_GETRESGID_E, PPME_SYSCALL_GETRESGID_X },
+#endif
+#ifdef __NR_ia32_getresgid32
+	[__NR_ia32_getresgid32 - SYSCALL_TABLE_ID0] = { UF_USED, PPME_SYSCALL_GETRESGID_E, PPME_SYSCALL_GETRESGID_X },
+#endif
+#ifdef __NR_ia32_semop
+	[__NR_ia32_semop - SYSCALL_TABLE_ID0] =                      {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_SEMOP_E, PPME_SYSCALL_SEMOP_X},
+#endif
+#ifdef __NR_ia32_semget
+	[__NR_ia32_semget - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_SEMGET_E, PPME_SYSCALL_SEMGET_X},
+#endif
+#ifdef __NR_ia32_semctl
+	[__NR_ia32_semctl - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_SEMCTL_E, PPME_SYSCALL_SEMCTL_X},
+#endif
+#ifdef __NR_ia32_access
+	[__NR_ia32_access - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_ACCESS_E, PPME_SYSCALL_ACCESS_X},
+#endif
+#ifdef __NR_ia32_chroot
+	[__NR_ia32_chroot - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_NEVER_DROP, PPME_SYSCALL_CHROOT_E, PPME_SYSCALL_CHROOT_X},
+#endif
+	[__NR_ia32_setsid - SYSCALL_TABLE_ID0] =                     {UF_USED | UF_ALWAYS_DROP, PPME_SYSCALL_SETSID_E, PPME_SYSCALL_SETSID_X},
+#ifdef __NR_ia32_bpf
+	[__NR_ia32_bpf - SYSCALL_TABLE_ID0] =                        {UF_USED, PPME_SYSCALL_BPF_E, PPME_SYSCALL_BPF_X},
+#endif
+#ifdef __NR_ia32_seccomp
+	[__NR_ia32_seccomp - SYSCALL_TABLE_ID0] =                    {UF_USED, PPME_SYSCALL_SECCOMP_E, PPME_SYSCALL_SECCOMP_X},
+#endif
+};
+
+/*
+ * SYSCALL ROUTING TABLE
+ */
+const enum ppm_syscall_code g_syscall_ia32_code_routing_table[SYSCALL_TABLE_SIZE] = {
+	[__NR_ia32_restart_syscall - SYSCALL_TABLE_ID0] = PPM_SC_RESTART_SYSCALL,
+	[__NR_ia32_exit - SYSCALL_TABLE_ID0] = PPM_SC_EXIT,
+	[__NR_ia32_read - SYSCALL_TABLE_ID0] = PPM_SC_READ,
+	[__NR_ia32_write - SYSCALL_TABLE_ID0] = PPM_SC_WRITE,
+	[__NR_ia32_open - SYSCALL_TABLE_ID0] = PPM_SC_OPEN,
+	[__NR_ia32_close - SYSCALL_TABLE_ID0] = PPM_SC_CLOSE,
+	[__NR_ia32_creat - SYSCALL_TABLE_ID0] = PPM_SC_CREAT,
+	[__NR_ia32_link - SYSCALL_TABLE_ID0] = PPM_SC_LINK,
+	[__NR_ia32_unlink - SYSCALL_TABLE_ID0] = PPM_SC_UNLINK,
+	[__NR_ia32_chdir - SYSCALL_TABLE_ID0] = PPM_SC_CHDIR,
+	[__NR_ia32_time - SYSCALL_TABLE_ID0] = PPM_SC_TIME,
+	[__NR_ia32_mknod - SYSCALL_TABLE_ID0] = PPM_SC_MKNOD,
+	[__NR_ia32_chmod - SYSCALL_TABLE_ID0] = PPM_SC_CHMOD,
+/* [__NR_ia32_lchown16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_LCHOWN16, */
+	[__NR_ia32_stat - SYSCALL_TABLE_ID0] = PPM_SC_STAT,
+	[__NR_ia32_lseek - SYSCALL_TABLE_ID0] = PPM_SC_LSEEK,
+	[__NR_ia32_getpid - SYSCALL_TABLE_ID0] = PPM_SC_GETPID,
+	[__NR_ia32_mount - SYSCALL_TABLE_ID0] = PPM_SC_MOUNT,
+/* [__NR_ia32_oldumount - SYSCALL_TABLE_ID0] = PPM_SC_NR_OLDUMOUNT, */
+/* [__NR_ia32_setuid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETUID16, */
+/* [__NR_ia32_getuid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_GETUID16, */
+	[__NR_ia32_ptrace - SYSCALL_TABLE_ID0] = PPM_SC_PTRACE,
+	[__NR_ia32_alarm - SYSCALL_TABLE_ID0] = PPM_SC_ALARM,
+	[__NR_ia32_fstat - SYSCALL_TABLE_ID0] = PPM_SC_FSTAT,
+	[__NR_ia32_pause - SYSCALL_TABLE_ID0] = PPM_SC_PAUSE,
+	[__NR_ia32_utime - SYSCALL_TABLE_ID0] = PPM_SC_UTIME,
+	[__NR_ia32_access - SYSCALL_TABLE_ID0] = PPM_SC_ACCESS,
+	[__NR_ia32_sync - SYSCALL_TABLE_ID0] = PPM_SC_SYNC,
+	[__NR_ia32_kill - SYSCALL_TABLE_ID0] = PPM_SC_KILL,
+	[__NR_ia32_rename - SYSCALL_TABLE_ID0] = PPM_SC_RENAME,
+	[__NR_ia32_mkdir - SYSCALL_TABLE_ID0] = PPM_SC_MKDIR,
+	[__NR_ia32_rmdir - SYSCALL_TABLE_ID0] = PPM_SC_RMDIR,
+	[__NR_ia32_dup - SYSCALL_TABLE_ID0] = PPM_SC_DUP,
+	[__NR_ia32_pipe - SYSCALL_TABLE_ID0] = PPM_SC_PIPE,
+	[__NR_ia32_times - SYSCALL_TABLE_ID0] = PPM_SC_TIMES,
+	[__NR_ia32_brk - SYSCALL_TABLE_ID0] = PPM_SC_BRK,
+/* [__NR_ia32_setgid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETGID16, */
+/* [__NR_ia32_getgid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_GETGID16, */
+/* [__NR_ia32_geteuid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_GETEUID16, */
+/* [__NR_ia32_getegid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_GETEGID16, */
+	[__NR_ia32_acct - SYSCALL_TABLE_ID0] = PPM_SC_ACCT,
+	[__NR_ia32_ioctl - SYSCALL_TABLE_ID0] = PPM_SC_IOCTL,
+	[__NR_ia32_fcntl - SYSCALL_TABLE_ID0] = PPM_SC_FCNTL,
+	[__NR_ia32_setpgid - SYSCALL_TABLE_ID0] = PPM_SC_SETPGID,
+	[__NR_ia32_umask - SYSCALL_TABLE_ID0] = PPM_SC_UMASK,
+	[__NR_ia32_chroot - SYSCALL_TABLE_ID0] = PPM_SC_CHROOT,
+	[__NR_ia32_ustat - SYSCALL_TABLE_ID0] = PPM_SC_USTAT,
+	[__NR_ia32_dup2 - SYSCALL_TABLE_ID0] = PPM_SC_DUP2,
+	[__NR_ia32_getppid - SYSCALL_TABLE_ID0] = PPM_SC_GETPPID,
+	[__NR_ia32_getpgrp - SYSCALL_TABLE_ID0] = PPM_SC_GETPGRP,
+	[__NR_ia32_setsid - SYSCALL_TABLE_ID0] = PPM_SC_SETSID,
+	[__NR_ia32_sethostname - SYSCALL_TABLE_ID0] = PPM_SC_SETHOSTNAME,
+	[__NR_ia32_setrlimit - SYSCALL_TABLE_ID0] = PPM_SC_SETRLIMIT,
+/* [__NR_ia32_old_getrlimit - SYSCALL_TABLE_ID0] = PPM_SC_NR_OLD_GETRLIMIT, */
+	[__NR_ia32_getrusage - SYSCALL_TABLE_ID0] = PPM_SC_GETRUSAGE,
+	[__NR_ia32_gettimeofday - SYSCALL_TABLE_ID0] = PPM_SC_GETTIMEOFDAY,
+	[__NR_ia32_settimeofday - SYSCALL_TABLE_ID0] = PPM_SC_SETTIMEOFDAY,
+/* [__NR_ia32_getgroups16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_GETGROUPS16, */
+/* [__NR_ia32_setgroups16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETGROUPS16, */
+/* [__NR_ia32_old_select - SYSCALL_TABLE_ID0] = PPM_SC_NR_OLD_SELECT, */
+	[__NR_ia32_symlink - SYSCALL_TABLE_ID0] = PPM_SC_SYMLINK,
+	[__NR_ia32_lstat - SYSCALL_TABLE_ID0] = PPM_SC_LSTAT,
+	[__NR_ia32_readlink - SYSCALL_TABLE_ID0] = PPM_SC_READLINK,
+	[__NR_ia32_uselib - SYSCALL_TABLE_ID0] = PPM_SC_USELIB,
+	[__NR_ia32_swapon - SYSCALL_TABLE_ID0] = PPM_SC_SWAPON,
+	[__NR_ia32_reboot - SYSCALL_TABLE_ID0] = PPM_SC_REBOOT,
+/* [__NR_ia32_old_readdir - SYSCALL_TABLE_ID0] = PPM_SC_NR_OLD_READDIR, */
+/* [__NR_ia32_old_mmap - SYSCALL_TABLE_ID0] = PPM_SC_NR_OLD_MMAP, */
+	[__NR_ia32_mmap - SYSCALL_TABLE_ID0] = PPM_SC_MMAP,
+	[__NR_ia32_munmap - SYSCALL_TABLE_ID0] = PPM_SC_MUNMAP,
+	[__NR_ia32_truncate - SYSCALL_TABLE_ID0] = PPM_SC_TRUNCATE,
+	[__NR_ia32_ftruncate - SYSCALL_TABLE_ID0] = PPM_SC_FTRUNCATE,
+	[__NR_ia32_fchmod - SYSCALL_TABLE_ID0] = PPM_SC_FCHMOD,
+/* [__NR_ia32_fchown16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_FCHOWN16, */
+	[__NR_ia32_getpriority - SYSCALL_TABLE_ID0] = PPM_SC_GETPRIORITY,
+	[__NR_ia32_setpriority - SYSCALL_TABLE_ID0] = PPM_SC_SETPRIORITY,
+	[__NR_ia32_statfs - SYSCALL_TABLE_ID0] = PPM_SC_STATFS,
+	[__NR_ia32_fstatfs - SYSCALL_TABLE_ID0] = PPM_SC_FSTATFS,
+	[__NR_ia32_syslog - SYSCALL_TABLE_ID0] = PPM_SC_SYSLOG,
+	[__NR_ia32_setitimer - SYSCALL_TABLE_ID0] = PPM_SC_SETITIMER,
+	[__NR_ia32_getitimer - SYSCALL_TABLE_ID0] = PPM_SC_GETITIMER,
+/* [__NR_ia32_newstat - SYSCALL_TABLE_ID0] = PPM_SC_NR_NEWSTAT, */
+/* [__NR_ia32_newlstat - SYSCALL_TABLE_ID0] = PPM_SC_NR_NEWLSTAT, */
+/* [__NR_ia32_newfstat - SYSCALL_TABLE_ID0] = PPM_SC_NR_NEWFSTAT, */
+	[__NR_ia32_uname - SYSCALL_TABLE_ID0] = PPM_SC_UNAME,
+	[__NR_ia32_vhangup - SYSCALL_TABLE_ID0] = PPM_SC_VHANGUP,
+	[__NR_ia32_wait4 - SYSCALL_TABLE_ID0] = PPM_SC_WAIT4,
+	[__NR_ia32_swapoff - SYSCALL_TABLE_ID0] = PPM_SC_SWAPOFF,
+	[__NR_ia32_sysinfo - SYSCALL_TABLE_ID0] = PPM_SC_SYSINFO,
+	[__NR_ia32_fsync - SYSCALL_TABLE_ID0] = PPM_SC_FSYNC,
+	[__NR_ia32_setdomainname - SYSCALL_TABLE_ID0] = PPM_SC_SETDOMAINNAME,
+/* [__NR_ia32_newuname - SYSCALL_TABLE_ID0] = PPM_SC_NR_NEWUNAME, */
+	[__NR_ia32_adjtimex - SYSCALL_TABLE_ID0] = PPM_SC_ADJTIMEX,
+	[__NR_ia32_mprotect - SYSCALL_TABLE_ID0] = PPM_SC_MPROTECT,
+	[__NR_ia32_init_module - SYSCALL_TABLE_ID0] = PPM_SC_INIT_MODULE,
+	[__NR_ia32_delete_module - SYSCALL_TABLE_ID0] = PPM_SC_DELETE_MODULE,
+	[__NR_ia32_quotactl - SYSCALL_TABLE_ID0] = PPM_SC_QUOTACTL,
+	[__NR_ia32_getpgid - SYSCALL_TABLE_ID0] = PPM_SC_GETPGID,
+	[__NR_ia32_fchdir - SYSCALL_TABLE_ID0] = PPM_SC_FCHDIR,
+	[__NR_ia32_sysfs - SYSCALL_TABLE_ID0] = PPM_SC_SYSFS,
+	[__NR_ia32_personality - SYSCALL_TABLE_ID0] = PPM_SC_PERSONALITY,
+/* [__NR_ia32_setfsuid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETFSUID16, */
+/* [__NR_ia32_setfsgid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETFSGID16, */
+/* [__NR_ia32_llseek - SYSCALL_TABLE_ID0] = PPM_SC_NR_LLSEEK, */
+	[__NR_ia32_getdents - SYSCALL_TABLE_ID0] = PPM_SC_GETDENTS,
+#ifdef __NR_ia32_select
+	[__NR_ia32_select - SYSCALL_TABLE_ID0] = PPM_SC_SELECT,
+#endif
+	[__NR_ia32_flock - SYSCALL_TABLE_ID0] = PPM_SC_FLOCK,
+	[__NR_ia32_msync - SYSCALL_TABLE_ID0] = PPM_SC_MSYNC,
+	[__NR_ia32_readv - SYSCALL_TABLE_ID0] = PPM_SC_READV,
+	[__NR_ia32_writev - SYSCALL_TABLE_ID0] = PPM_SC_WRITEV,
+	[__NR_ia32_getsid - SYSCALL_TABLE_ID0] = PPM_SC_GETSID,
+	[__NR_ia32_fdatasync - SYSCALL_TABLE_ID0] = PPM_SC_FDATASYNC,
+/* [__NR_ia32_sysctl - SYSCALL_TABLE_ID0] = PPM_SC_NR_SYSCTL, */
+	[__NR_ia32_mlock - SYSCALL_TABLE_ID0] = PPM_SC_MLOCK,
+	[__NR_ia32_munlock - SYSCALL_TABLE_ID0] = PPM_SC_MUNLOCK,
+	[__NR_ia32_mlockall - SYSCALL_TABLE_ID0] = PPM_SC_MLOCKALL,
+	[__NR_ia32_munlockall - SYSCALL_TABLE_ID0] = PPM_SC_MUNLOCKALL,
+	[__NR_ia32_sched_setparam - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_SETPARAM,
+	[__NR_ia32_sched_getparam - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_GETPARAM,
+	[__NR_ia32_sched_setscheduler - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_SETSCHEDULER,
+	[__NR_ia32_sched_getscheduler - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_GETSCHEDULER,
+	[__NR_ia32_sched_yield - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_YIELD,
+	[__NR_ia32_sched_get_priority_max - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_GET_PRIORITY_MAX,
+	[__NR_ia32_sched_get_priority_min - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_GET_PRIORITY_MIN,
+	[__NR_ia32_sched_rr_get_interval - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_RR_GET_INTERVAL,
+	[__NR_ia32_nanosleep - SYSCALL_TABLE_ID0] = PPM_SC_NANOSLEEP,
+	[__NR_ia32_mremap - SYSCALL_TABLE_ID0] = PPM_SC_MREMAP,
+/* [__NR_ia32_setresuid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETRESUID16, */
+/* [__NR_ia32_getresuid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_GETRESUID16, */
+	[__NR_ia32_poll - SYSCALL_TABLE_ID0] = PPM_SC_POLL,
+/* [__NR_ia32_setresgid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETRESGID16, */
+/* [__NR_ia32_getresgid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_GETRESGID16, */
+	[__NR_ia32_prctl - SYSCALL_TABLE_ID0] = PPM_SC_PRCTL,
+#ifdef __NR_ia32_arch_prctl
+	[__NR_ia32_arch_prctl - SYSCALL_TABLE_ID0] = PPM_SC_ARCH_PRCTL,
+#endif
+	[__NR_ia32_rt_sigaction - SYSCALL_TABLE_ID0] = PPM_SC_RT_SIGACTION,
+	[__NR_ia32_rt_sigprocmask - SYSCALL_TABLE_ID0] = PPM_SC_RT_SIGPROCMASK,
+	[__NR_ia32_rt_sigpending - SYSCALL_TABLE_ID0] = PPM_SC_RT_SIGPENDING,
+	[__NR_ia32_rt_sigtimedwait - SYSCALL_TABLE_ID0] = PPM_SC_RT_SIGTIMEDWAIT,
+	[__NR_ia32_rt_sigqueueinfo - SYSCALL_TABLE_ID0] = PPM_SC_RT_SIGQUEUEINFO,
+	[__NR_ia32_rt_sigsuspend - SYSCALL_TABLE_ID0] = PPM_SC_RT_SIGSUSPEND,
+/* [__NR_ia32_chown16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_CHOWN16, */
+	[__NR_ia32_getcwd - SYSCALL_TABLE_ID0] = PPM_SC_GETCWD,
+	[__NR_ia32_capget - SYSCALL_TABLE_ID0] = PPM_SC_CAPGET,
+	[__NR_ia32_capset - SYSCALL_TABLE_ID0] = PPM_SC_CAPSET,
+	[__NR_ia32_sendfile - SYSCALL_TABLE_ID0] = PPM_SC_SENDFILE,
+	[__NR_ia32_getrlimit - SYSCALL_TABLE_ID0] = PPM_SC_GETRLIMIT,
+/* [__NR_ia32_mmap_pgoff - SYSCALL_TABLE_ID0] = PPM_SC_NR_MMAP_PGOFF, */
+	[__NR_ia32_lchown - SYSCALL_TABLE_ID0] = PPM_SC_LCHOWN,
+	[__NR_ia32_getuid - SYSCALL_TABLE_ID0] = PPM_SC_GETUID,
+	[__NR_ia32_getgid - SYSCALL_TABLE_ID0] = PPM_SC_GETGID,
+	[__NR_ia32_geteuid - SYSCALL_TABLE_ID0] = PPM_SC_GETEUID,
+	[__NR_ia32_getegid - SYSCALL_TABLE_ID0] = PPM_SC_GETEGID,
+	[__NR_ia32_setreuid - SYSCALL_TABLE_ID0] = PPM_SC_SETREUID,
+	[__NR_ia32_setregid - SYSCALL_TABLE_ID0] = PPM_SC_SETREGID,
+	[__NR_ia32_getgroups - SYSCALL_TABLE_ID0] = PPM_SC_GETGROUPS,
+	[__NR_ia32_setgroups - SYSCALL_TABLE_ID0] = PPM_SC_SETGROUPS,
+	[__NR_ia32_fchown - SYSCALL_TABLE_ID0] = PPM_SC_FCHOWN,
+	[__NR_ia32_setresuid - SYSCALL_TABLE_ID0] = PPM_SC_SETRESUID,
+	[__NR_ia32_getresuid - SYSCALL_TABLE_ID0] = PPM_SC_GETRESUID,
+	[__NR_ia32_setresgid - SYSCALL_TABLE_ID0] = PPM_SC_SETRESGID,
+	[__NR_ia32_getresgid - SYSCALL_TABLE_ID0] = PPM_SC_GETRESGID,
+	[__NR_ia32_chown - SYSCALL_TABLE_ID0] = PPM_SC_CHOWN,
+	[__NR_ia32_setuid - SYSCALL_TABLE_ID0] = PPM_SC_SETUID,
+	[__NR_ia32_setgid - SYSCALL_TABLE_ID0] = PPM_SC_SETGID,
+	[__NR_ia32_setfsuid - SYSCALL_TABLE_ID0] = PPM_SC_SETFSUID,
+	[__NR_ia32_setfsgid - SYSCALL_TABLE_ID0] = PPM_SC_SETFSGID,
+	[__NR_ia32_pivot_root - SYSCALL_TABLE_ID0] = PPM_SC_PIVOT_ROOT,
+	[__NR_ia32_mincore - SYSCALL_TABLE_ID0] = PPM_SC_MINCORE,
+	[__NR_ia32_madvise - SYSCALL_TABLE_ID0] = PPM_SC_MADVISE,
+	[__NR_ia32_gettid - SYSCALL_TABLE_ID0] = PPM_SC_GETTID,
+	[__NR_ia32_setxattr - SYSCALL_TABLE_ID0] = PPM_SC_SETXATTR,
+	[__NR_ia32_lsetxattr - SYSCALL_TABLE_ID0] = PPM_SC_LSETXATTR,
+	[__NR_ia32_fsetxattr - SYSCALL_TABLE_ID0] = PPM_SC_FSETXATTR,
+	[__NR_ia32_getxattr - SYSCALL_TABLE_ID0] = PPM_SC_GETXATTR,
+	[__NR_ia32_lgetxattr - SYSCALL_TABLE_ID0] = PPM_SC_LGETXATTR,
+	[__NR_ia32_fgetxattr - SYSCALL_TABLE_ID0] = PPM_SC_FGETXATTR,
+	[__NR_ia32_listxattr - SYSCALL_TABLE_ID0] = PPM_SC_LISTXATTR,
+	[__NR_ia32_llistxattr - SYSCALL_TABLE_ID0] = PPM_SC_LLISTXATTR,
+	[__NR_ia32_flistxattr - SYSCALL_TABLE_ID0] = PPM_SC_FLISTXATTR,
+	[__NR_ia32_removexattr - SYSCALL_TABLE_ID0] = PPM_SC_REMOVEXATTR,
+	[__NR_ia32_lremovexattr - SYSCALL_TABLE_ID0] = PPM_SC_LREMOVEXATTR,
+	[__NR_ia32_fremovexattr - SYSCALL_TABLE_ID0] = PPM_SC_FREMOVEXATTR,
+	[__NR_ia32_tkill - SYSCALL_TABLE_ID0] = PPM_SC_TKILL,
+	[__NR_ia32_futex - SYSCALL_TABLE_ID0] = PPM_SC_FUTEX,
+	[__NR_ia32_sched_setaffinity - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_SETAFFINITY,
+	[__NR_ia32_sched_getaffinity - SYSCALL_TABLE_ID0] = PPM_SC_SCHED_GETAFFINITY,
+#ifdef __NR_ia32_set_thread_area
+	[__NR_ia32_set_thread_area - SYSCALL_TABLE_ID0] = PPM_SC_SET_THREAD_AREA,
+#endif
+#ifdef __NR_ia32_get_thread_area
+	[__NR_ia32_get_thread_area - SYSCALL_TABLE_ID0] = PPM_SC_GET_THREAD_AREA,
+#endif
+	[__NR_ia32_io_setup - SYSCALL_TABLE_ID0] = PPM_SC_IO_SETUP,
+	[__NR_ia32_io_destroy - SYSCALL_TABLE_ID0] = PPM_SC_IO_DESTROY,
+	[__NR_ia32_io_getevents - SYSCALL_TABLE_ID0] = PPM_SC_IO_GETEVENTS,
+	[__NR_ia32_io_submit - SYSCALL_TABLE_ID0] = PPM_SC_IO_SUBMIT,
+	[__NR_ia32_io_cancel - SYSCALL_TABLE_ID0] = PPM_SC_IO_CANCEL,
+	[__NR_ia32_exit_group - SYSCALL_TABLE_ID0] = PPM_SC_EXIT_GROUP,
+	[__NR_ia32_epoll_create - SYSCALL_TABLE_ID0] = PPM_SC_EPOLL_CREATE,
+	[__NR_ia32_epoll_ctl - SYSCALL_TABLE_ID0] = PPM_SC_EPOLL_CTL,
+	[__NR_ia32_epoll_wait - SYSCALL_TABLE_ID0] = PPM_SC_EPOLL_WAIT,
+	[__NR_ia32_remap_file_pages - SYSCALL_TABLE_ID0] = PPM_SC_REMAP_FILE_PAGES,
+	[__NR_ia32_set_tid_address - SYSCALL_TABLE_ID0] = PPM_SC_SET_TID_ADDRESS,
+	[__NR_ia32_timer_create - SYSCALL_TABLE_ID0] = PPM_SC_TIMER_CREATE,
+	[__NR_ia32_timer_settime - SYSCALL_TABLE_ID0] = PPM_SC_TIMER_SETTIME,
+	[__NR_ia32_timer_gettime - SYSCALL_TABLE_ID0] = PPM_SC_TIMER_GETTIME,
+	[__NR_ia32_timer_getoverrun - SYSCALL_TABLE_ID0] = PPM_SC_TIMER_GETOVERRUN,
+	[__NR_ia32_timer_delete - SYSCALL_TABLE_ID0] = PPM_SC_TIMER_DELETE,
+	[__NR_ia32_clock_settime - SYSCALL_TABLE_ID0] = PPM_SC_CLOCK_SETTIME,
+	[__NR_ia32_clock_gettime - SYSCALL_TABLE_ID0] = PPM_SC_CLOCK_GETTIME,
+	[__NR_ia32_clock_getres - SYSCALL_TABLE_ID0] = PPM_SC_CLOCK_GETRES,
+	[__NR_ia32_clock_nanosleep - SYSCALL_TABLE_ID0] = PPM_SC_CLOCK_NANOSLEEP,
+	[__NR_ia32_tgkill - SYSCALL_TABLE_ID0] = PPM_SC_TGKILL,
+	[__NR_ia32_utimes - SYSCALL_TABLE_ID0] = PPM_SC_UTIMES,
+	[__NR_ia32_mq_open - SYSCALL_TABLE_ID0] = PPM_SC_MQ_OPEN,
+	[__NR_ia32_mq_unlink - SYSCALL_TABLE_ID0] = PPM_SC_MQ_UNLINK,
+	[__NR_ia32_mq_timedsend - SYSCALL_TABLE_ID0] = PPM_SC_MQ_TIMEDSEND,
+	[__NR_ia32_mq_timedreceive - SYSCALL_TABLE_ID0] = PPM_SC_MQ_TIMEDRECEIVE,
+	[__NR_ia32_mq_notify - SYSCALL_TABLE_ID0] = PPM_SC_MQ_NOTIFY,
+	[__NR_ia32_mq_getsetattr - SYSCALL_TABLE_ID0] = PPM_SC_MQ_GETSETATTR,
+	[__NR_ia32_kexec_load - SYSCALL_TABLE_ID0] = PPM_SC_KEXEC_LOAD,
+	[__NR_ia32_waitid - SYSCALL_TABLE_ID0] = PPM_SC_WAITID,
+	[__NR_ia32_add_key - SYSCALL_TABLE_ID0] = PPM_SC_ADD_KEY,
+	[__NR_ia32_request_key - SYSCALL_TABLE_ID0] = PPM_SC_REQUEST_KEY,
+	[__NR_ia32_keyctl - SYSCALL_TABLE_ID0] = PPM_SC_KEYCTL,
+	[__NR_ia32_ioprio_set - SYSCALL_TABLE_ID0] = PPM_SC_IOPRIO_SET,
+	[__NR_ia32_ioprio_get - SYSCALL_TABLE_ID0] = PPM_SC_IOPRIO_GET,
+	[__NR_ia32_inotify_init - SYSCALL_TABLE_ID0] = PPM_SC_INOTIFY_INIT,
+	[__NR_ia32_inotify_add_watch - SYSCALL_TABLE_ID0] = PPM_SC_INOTIFY_ADD_WATCH,
+	[__NR_ia32_inotify_rm_watch - SYSCALL_TABLE_ID0] = PPM_SC_INOTIFY_RM_WATCH,
+	[__NR_ia32_openat - SYSCALL_TABLE_ID0] = PPM_SC_OPENAT,
+	[__NR_ia32_mkdirat - SYSCALL_TABLE_ID0] = PPM_SC_MKDIRAT,
+	[__NR_ia32_mknodat - SYSCALL_TABLE_ID0] = PPM_SC_MKNODAT,
+	[__NR_ia32_fchownat - SYSCALL_TABLE_ID0] = PPM_SC_FCHOWNAT,
+	[__NR_ia32_futimesat - SYSCALL_TABLE_ID0] = PPM_SC_FUTIMESAT,
+	[__NR_ia32_unlinkat - SYSCALL_TABLE_ID0] = PPM_SC_UNLINKAT,
+	[__NR_ia32_renameat - SYSCALL_TABLE_ID0] = PPM_SC_RENAMEAT,
+	[__NR_ia32_linkat - SYSCALL_TABLE_ID0] = PPM_SC_LINKAT,
+	[__NR_ia32_symlinkat - SYSCALL_TABLE_ID0] = PPM_SC_SYMLINKAT,
+	[__NR_ia32_readlinkat - SYSCALL_TABLE_ID0] = PPM_SC_READLINKAT,
+	[__NR_ia32_fchmodat - SYSCALL_TABLE_ID0] = PPM_SC_FCHMODAT,
+	[__NR_ia32_faccessat - SYSCALL_TABLE_ID0] = PPM_SC_FACCESSAT,
+	[__NR_ia32_pselect6 - SYSCALL_TABLE_ID0] = PPM_SC_PSELECT6,
+	[__NR_ia32_ppoll - SYSCALL_TABLE_ID0] = PPM_SC_PPOLL,
+	[__NR_ia32_unshare - SYSCALL_TABLE_ID0] = PPM_SC_UNSHARE,
+	[__NR_ia32_set_robust_list - SYSCALL_TABLE_ID0] = PPM_SC_SET_ROBUST_LIST,
+	[__NR_ia32_get_robust_list - SYSCALL_TABLE_ID0] = PPM_SC_GET_ROBUST_LIST,
+	[__NR_ia32_splice - SYSCALL_TABLE_ID0] = PPM_SC_SPLICE,
+	[__NR_ia32_tee - SYSCALL_TABLE_ID0] = PPM_SC_TEE,
+	[__NR_ia32_vmsplice - SYSCALL_TABLE_ID0] = PPM_SC_VMSPLICE,
+#ifdef __NR_ia32_getcpu
+	[__NR_ia32_getcpu - SYSCALL_TABLE_ID0] = PPM_SC_GETCPU,
+#endif
+	[__NR_ia32_epoll_pwait - SYSCALL_TABLE_ID0] = PPM_SC_EPOLL_PWAIT,
+	[__NR_ia32_utimensat - SYSCALL_TABLE_ID0] = PPM_SC_UTIMENSAT,
+	[__NR_ia32_signalfd - SYSCALL_TABLE_ID0] = PPM_SC_SIGNALFD,
+	[__NR_ia32_timerfd_create - SYSCALL_TABLE_ID0] = PPM_SC_TIMERFD_CREATE,
+	[__NR_ia32_eventfd - SYSCALL_TABLE_ID0] = PPM_SC_EVENTFD,
+	[__NR_ia32_timerfd_settime - SYSCALL_TABLE_ID0] = PPM_SC_TIMERFD_SETTIME,
+	[__NR_ia32_timerfd_gettime - SYSCALL_TABLE_ID0] = PPM_SC_TIMERFD_GETTIME,
+	[__NR_ia32_signalfd4 - SYSCALL_TABLE_ID0] = PPM_SC_SIGNALFD4,
+	[__NR_ia32_eventfd2 - SYSCALL_TABLE_ID0] = PPM_SC_EVENTFD2,
+	[__NR_ia32_epoll_create1 - SYSCALL_TABLE_ID0] = PPM_SC_EPOLL_CREATE1,
+	[__NR_ia32_dup3 - SYSCALL_TABLE_ID0] = PPM_SC_DUP3,
+	[__NR_ia32_pipe2 - SYSCALL_TABLE_ID0] = PPM_SC_PIPE2,
+	[__NR_ia32_inotify_init1 - SYSCALL_TABLE_ID0] = PPM_SC_INOTIFY_INIT1,
+	[__NR_ia32_preadv - SYSCALL_TABLE_ID0] = PPM_SC_PREADV,
+	[__NR_ia32_pwritev - SYSCALL_TABLE_ID0] = PPM_SC_PWRITEV,
+	[__NR_ia32_rt_tgsigqueueinfo - SYSCALL_TABLE_ID0] = PPM_SC_RT_TGSIGQUEUEINFO,
+	[__NR_ia32_perf_event_open - SYSCALL_TABLE_ID0] = PPM_SC_PERF_EVENT_OPEN,
+#ifdef __NR_ia32_fanotify_init
+	[__NR_ia32_fanotify_init - SYSCALL_TABLE_ID0] = PPM_SC_FANOTIFY_INIT,
+#endif
+#ifdef __NR_ia32_prlimit64
+	[__NR_ia32_prlimit64 - SYSCALL_TABLE_ID0] = PPM_SC_PRLIMIT64,
+#endif
+#ifdef __NR_ia32_clock_adjtime
+	[__NR_ia32_clock_adjtime - SYSCALL_TABLE_ID0] = PPM_SC_CLOCK_ADJTIME,
+#endif
+#ifdef __NR_ia32_syncfs
+	[__NR_ia32_syncfs - SYSCALL_TABLE_ID0] = PPM_SC_SYNCFS,
+#endif
+#ifdef __NR_ia32_setns
+	[__NR_ia32_setns - SYSCALL_TABLE_ID0] = PPM_SC_SETNS,
+#endif
+	[__NR_ia32_getdents64 - SYSCALL_TABLE_ID0] =  PPM_SC_GETDENTS64,
+#ifndef __NR_ia32_socketcall
+	/*
+	 * Non-multiplexed socket family
+	 */
+	[__NR_ia32_socket - SYSCALL_TABLE_ID0] =  PPM_SC_SOCKET,
+	[__NR_ia32_bind - SYSCALL_TABLE_ID0] =	PPM_SC_BIND,
+	[__NR_ia32_connect - SYSCALL_TABLE_ID0] =  PPM_SC_CONNECT,
+	[__NR_ia32_listen - SYSCALL_TABLE_ID0] =  PPM_SC_LISTEN,
+	[__NR_ia32_accept - SYSCALL_TABLE_ID0] =  PPM_SC_ACCEPT,
+	[__NR_ia32_getsockname - SYSCALL_TABLE_ID0] = PPM_SC_GETSOCKNAME,
+	[__NR_ia32_getpeername - SYSCALL_TABLE_ID0] = PPM_SC_GETPEERNAME,
+	[__NR_ia32_socketpair - SYSCALL_TABLE_ID0] = PPM_SC_SOCKETPAIR,
+/* [__NR_ia32_send - SYSCALL_TABLE_ID0] =	PPM_SC_NR_SEND, */
+	[__NR_ia32_sendto - SYSCALL_TABLE_ID0] =  PPM_SC_SENDTO,
+/* [__NR_ia32_recv - SYSCALL_TABLE_ID0] =	PPM_SC_NR_RECV, */
+	[__NR_ia32_recvfrom - SYSCALL_TABLE_ID0] =  PPM_SC_RECVFROM,
+	[__NR_ia32_shutdown - SYSCALL_TABLE_ID0] =  PPM_SC_SHUTDOWN,
+	[__NR_ia32_setsockopt - SYSCALL_TABLE_ID0] = PPM_SC_SETSOCKOPT,
+	[__NR_ia32_getsockopt - SYSCALL_TABLE_ID0] = PPM_SC_GETSOCKOPT,
+	[__NR_ia32_sendmsg - SYSCALL_TABLE_ID0] =  PPM_SC_SENDMSG,
+	[__NR_ia32_recvmsg - SYSCALL_TABLE_ID0] =  PPM_SC_RECVMSG,
+	[__NR_ia32_accept4 - SYSCALL_TABLE_ID0] =  PPM_SC_ACCEPT4,
+#else
+	[__NR_ia32_socketcall - SYSCALL_TABLE_ID0] = PPM_SC_SOCKETCALL,
+#endif
+
+
+#ifdef __NR_ia32_sendmmsg
+	[__NR_ia32_sendmmsg - SYSCALL_TABLE_ID0] =  PPM_SC_SENDMMSG,
+#endif
+#ifdef __NR_ia32_recvmmsg
+	[__NR_ia32_recvmmsg - SYSCALL_TABLE_ID0] =  PPM_SC_RECVMMSG,
+#endif
+	/*
+	 * Non-multiplexed IPC family
+	 */
+#ifdef __NR_ia32_semop
+	[__NR_ia32_semop - SYSCALL_TABLE_ID0] =  PPM_SC_SEMOP,
+#endif
+#ifdef __NR_ia32_semget
+	[__NR_ia32_semget - SYSCALL_TABLE_ID0] =  PPM_SC_SEMGET,
+#endif
+#ifdef __NR_ia32_semctl
+	[__NR_ia32_semctl - SYSCALL_TABLE_ID0] =  PPM_SC_SEMCTL,
+#endif
+#ifdef __NR_ia32_semget
+	[__NR_ia32_semget - SYSCALL_TABLE_ID0] =  PPM_SC_SEMGET,
+#endif
+#ifdef __NR_ia32_msgsnd
+	[__NR_ia32_msgsnd - SYSCALL_TABLE_ID0] =  PPM_SC_MSGSND,
+#endif
+#ifdef __NR_ia32_msgrcv
+	[__NR_ia32_msgrcv - SYSCALL_TABLE_ID0] =  PPM_SC_MSGRCV,
+#endif
+#ifdef __NR_ia32_msgget
+	[__NR_ia32_msgget - SYSCALL_TABLE_ID0] =  PPM_SC_MSGGET,
+#endif
+#ifdef __NR_ia32_msgctl
+	[__NR_ia32_msgctl - SYSCALL_TABLE_ID0] =  PPM_SC_MSGCTL,
+#endif
+/* [__NR_ia32_shmatcall - SYSCALL_TABLE_ID0] =  PPM_SC_NR_SHMATCALL, */
+#ifdef __NR_ia32_shmdt
+	[__NR_ia32_shmdt - SYSCALL_TABLE_ID0] =  PPM_SC_SHMDT,
+#endif
+#ifdef __NR_ia32_shmget
+	[__NR_ia32_shmget - SYSCALL_TABLE_ID0] =  PPM_SC_SHMGET,
+#endif
+#ifdef __NR_ia32_shmctl
+	[__NR_ia32_shmctl - SYSCALL_TABLE_ID0] =  PPM_SC_SHMCTL,
+#endif
+/* [__NR_ia32_fcntl64 - SYSCALL_TABLE_ID0] =  PPM_SC_NR_FCNTL64, */
+#ifdef __NR_ia32_statfs64
+	[__NR_ia32_statfs64 - SYSCALL_TABLE_ID0] = PPM_SC_STATFS64,
+#endif
+#ifdef __NR_ia32_fstatfs64
+	[__NR_ia32_fstatfs64 - SYSCALL_TABLE_ID0] = PPM_SC_FSTATFS64,
+#endif
+#ifdef __NR_ia32_fstatat64
+	[__NR_ia32_fstatat64 - SYSCALL_TABLE_ID0] = PPM_SC_FSTATAT64,
+#endif
+#ifdef __NR_ia32_sendfile64
+	[__NR_ia32_sendfile64 - SYSCALL_TABLE_ID0] = PPM_SC_SENDFILE64,
+#endif
+#ifdef __NR_ia32_ugetrlimit
+	[__NR_ia32_ugetrlimit - SYSCALL_TABLE_ID0] = PPM_SC_UGETRLIMIT,
+#endif
+#ifdef __NR_ia32_bdflush
+	[__NR_ia32_bdflush - SYSCALL_TABLE_ID0] = PPM_SC_BDFLUSH,
+#endif
+#ifdef __NR_ia32_sigprocmask
+	[__NR_ia32_sigprocmask - SYSCALL_TABLE_ID0] = PPM_SC_SIGPROCMASK,
+#endif
+#ifdef __NR_ia32_ipc
+	[__NR_ia32_ipc - SYSCALL_TABLE_ID0] = PPM_SC_IPC,
+#endif
+#ifdef __NR_ia32_stat64
+	[__NR_ia32_stat64 - SYSCALL_TABLE_ID0] = PPM_SC_STAT64,
+#endif
+#ifdef __NR_ia32_lstat64
+	[__NR_ia32_lstat64 - SYSCALL_TABLE_ID0] = PPM_SC_LSTAT64,
+#endif
+#ifdef __NR_ia32_fstat64
+	[__NR_ia32_fstat64 - SYSCALL_TABLE_ID0] = PPM_SC_FSTAT64,
+#endif
+#ifdef __NR_ia32_fcntl64
+	[__NR_ia32_fcntl64 - SYSCALL_TABLE_ID0] = PPM_SC_FCNTL64,
+#endif
+#ifdef __NR_ia32_mmap2
+	[__NR_ia32_mmap2 - SYSCALL_TABLE_ID0] = PPM_SC_MMAP2,
+#endif
+#ifdef __NR_ia32__newselect
+	[__NR_ia32__newselect - SYSCALL_TABLE_ID0] = PPM_SC__NEWSELECT,
+#endif
+#ifdef __NR_ia32_sgetmask
+	[__NR_ia32_sgetmask - SYSCALL_TABLE_ID0] = PPM_SC_SGETMASK,
+#endif
+#ifdef __NR_ia32_ssetmask
+	[__NR_ia32_ssetmask - SYSCALL_TABLE_ID0] = PPM_SC_SSETMASK,
+#endif
+
+/* [__NR_ia32_setreuid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETREUID16, */
+/* [__NR_ia32_setregid16 - SYSCALL_TABLE_ID0] = PPM_SC_NR_SETREGID16, */
+#ifdef __NR_ia32_sigpending
+	[__NR_ia32_sigpending - SYSCALL_TABLE_ID0] = PPM_SC_SIGPENDING,
+#endif
+#ifdef __NR_ia32_olduname
+	[__NR_ia32_olduname - SYSCALL_TABLE_ID0] = PPM_SC_OLDUNAME,
+#endif
+#ifdef __NR_ia32_umount
+	[__NR_ia32_umount - SYSCALL_TABLE_ID0] = PPM_SC_UMOUNT,
+#endif
+#ifdef __NR_ia32_signal
+	[__NR_ia32_signal - SYSCALL_TABLE_ID0] = PPM_SC_SIGNAL,
+#endif
+#ifdef __NR_ia32_nice
+	[__NR_ia32_nice - SYSCALL_TABLE_ID0] = PPM_SC_NICE,
+#endif
+#ifdef __NR_ia32_stime
+	[__NR_ia32_stime - SYSCALL_TABLE_ID0] = PPM_SC_STIME,
+#endif
+#ifdef __NR_ia32__llseek
+	[__NR_ia32__llseek - SYSCALL_TABLE_ID0] = PPM_SC__LLSEEK,
+#endif
+#ifdef __NR_ia32_waitpid
+	[__NR_ia32_waitpid - SYSCALL_TABLE_ID0] = PPM_SC_WAITPID,
+#endif
+#ifdef __NR_ia32_pread64
+	[__NR_ia32_pread64 - SYSCALL_TABLE_ID0] = PPM_SC_PREAD64,
+#endif
+#ifdef __NR_ia32_pwrite64
+	[__NR_ia32_pwrite64 - SYSCALL_TABLE_ID0] = PPM_SC_PWRITE64,
+#endif
+#ifdef __NR_ia32_shmat
+	[__NR_ia32_shmat - SYSCALL_TABLE_ID0] = PPM_SC_SHMAT,
+#endif
+#ifdef __NR_ia32_rt_sigreturn
+	[__NR_ia32_rt_sigreturn - SYSCALL_TABLE_ID0] = PPM_SC_SIGRETURN,
+#endif
+#ifdef __NR_ia32_fallocate
+	[__NR_ia32_fallocate - SYSCALL_TABLE_ID0] = PPM_SC_FALLOCATE,
+#endif
+#ifdef __NR_ia32_newfstatat
+	[__NR_ia32_newfstatat - SYSCALL_TABLE_ID0] = PPM_SC_NEWFSSTAT,
+#endif
+#ifdef __NR_ia32_process_vm_readv
+	[__NR_ia32_process_vm_readv - SYSCALL_TABLE_ID0] = PPM_SC_PROCESS_VM_READV,
+#endif
+#ifdef __NR_ia32_process_vm_writev
+	[__NR_ia32_process_vm_writev - SYSCALL_TABLE_ID0] = PPM_SC_PROCESS_VM_WRITEV,
+#endif
+#ifdef __NR_ia32_fork
+	[__NR_ia32_fork - SYSCALL_TABLE_ID0] = PPM_SC_FORK,
+#endif
+#ifdef __NR_ia32_vfork
+	[__NR_ia32_vfork - SYSCALL_TABLE_ID0] = PPM_SC_VFORK,
+#endif
+#ifdef __NR_ia32_quotactl
+	[__NR_ia32_quotactl - SYSCALL_TABLE_ID0] = PPM_SC_QUOTACTL,
+#endif
+#ifdef __NR_ia32_setresuid
+	[__NR_ia32_setresuid - SYSCALL_TABLE_ID0] = PPM_SC_SETRESUID,
+#endif
+#ifdef __NR_ia32_setresuid32
+	[__NR_ia32_setresuid32 - SYSCALL_TABLE_ID0] = PPM_SC_SETRESUID,
+#endif
+#ifdef __NR_ia32_setresgid
+	[__NR_ia32_setresgid - SYSCALL_TABLE_ID0] = PPM_SC_SETRESGID,
+#endif
+#ifdef __NR_ia32_setresgid32
+	[__NR_ia32_setresgid32 - SYSCALL_TABLE_ID0] = PPM_SC_SETRESGID,
+#endif
+#ifdef __NR_ia32_setuid
+	[__NR_ia32_setuid - SYSCALL_TABLE_ID0] = PPM_SC_SETUID,
+#endif
+#ifdef __NR_ia32_setuid32
+	[__NR_ia32_setuid32 - SYSCALL_TABLE_ID0] = PPM_SC_SETUID32,
+#endif
+#ifdef __NR_ia32_setgid
+	[__NR_ia32_setgid - SYSCALL_TABLE_ID0] = PPM_SC_SETGID,
+#endif
+#ifdef __NR_ia32_setgid32
+	[__NR_ia32_setgid32 - SYSCALL_TABLE_ID0] = PPM_SC_SETGID32,
+#endif
+#ifdef __NR_ia32_getuid
+	[__NR_ia32_getuid - SYSCALL_TABLE_ID0] = PPM_SC_GETUID,
+#endif
+#ifdef __NR_ia32_getuid32
+	[__NR_ia32_getuid32 - SYSCALL_TABLE_ID0] = PPM_SC_GETUID32,
+#endif
+#ifdef __NR_ia32_geteuid
+	[__NR_ia32_geteuid - SYSCALL_TABLE_ID0] = PPM_SC_GETEUID,
+#endif
+#ifdef __NR_ia32_geteuid32
+	[__NR_ia32_geteuid32 - SYSCALL_TABLE_ID0] = PPM_SC_GETEUID,
+#endif
+#ifdef __NR_ia32_getgid
+	[__NR_ia32_getgid - SYSCALL_TABLE_ID0] = PPM_SC_GETGID,
+#endif
+#ifdef __NR_ia32_getgid32
+	[__NR_ia32_getgid32 - SYSCALL_TABLE_ID0] = PPM_SC_GETGID,
+#endif
+#ifdef __NR_ia32_getegid
+	[__NR_ia32_getegid - SYSCALL_TABLE_ID0] = PPM_SC_GETEGID,
+#endif
+#ifdef __NR_ia32_getegid32
+	[__NR_ia32_getegid32 - SYSCALL_TABLE_ID0] = PPM_SC_GETEGID,
+#endif
+#ifdef __NR_ia32_getresuid
+	[__NR_ia32_getresuid - SYSCALL_TABLE_ID0] = PPM_SC_GETRESUID,
+#endif
+#ifdef __NR_ia32_getresuid32
+	[__NR_ia32_getresuid32 - SYSCALL_TABLE_ID0] = PPM_SC_GETRESUID32,
+#endif
+#ifdef __NR_ia32_getresgid
+	[__NR_ia32_getresgid - SYSCALL_TABLE_ID0] = PPM_SC_GETRESGID,
+#endif
+#ifdef __NR_ia32_getresgid32
+	[__NR_ia32_getresgid32 - SYSCALL_TABLE_ID0] = PPM_SC_GETRESGID32,
+#endif
+#ifdef __NR_ia32_finit_module
+	[__NR_ia32_finit_module - SYSCALL_TABLE_ID0] = PPM_SC_FINIT_MODULE,
+#endif
+#ifdef __NR_ia32_bpf
+	[__NR_ia32_bpf - SYSCALL_TABLE_ID0] = PPM_SC_BPF,
+#endif
+#ifdef __NR_ia32_seccomp
+	[__NR_ia32_seccomp - SYSCALL_TABLE_ID0] = PPM_SC_SECCOMP,
+#endif
+};
+
+#endif /* CONFIG_IA32_EMULATION */
-- 
2.16.2

