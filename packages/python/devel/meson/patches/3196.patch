From 3d1267387fa8e972a5e553bb9daeaeb87f8322ed Mon Sep 17 00:00:00 2001
From: Thierry Reding <treding@nvidia.com>
Date: Wed, 7 Mar 2018 12:51:25 +0100
Subject: [PATCH 1/2] Support data types larger than 128 bytes

Recent versions of systemd (starting with v238) started to check for the
existence of the statx structure using the cc.sizeof() operation. The cc
compiler implementation fails to detect this structure because it's size
limit is 128, meaning it will fail for any type larger than 128 bytes in
the following way during cross-compilation checks:

        meson.build:10:2: ERROR: Cross-compile check overflowed

Increase the size limit for data types to 1024 bytes, which should give
plenty of room for even large data structures. This is obviously not
guaranteed to be an upper bound, but given the binary search algorithm
implemented in the cross-compile check, raising the limit too high may
significantly increase the time required for this check on smaller data
types.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 mesonbuild/compilers/c.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/mesonbuild/compilers/c.py b/mesonbuild/compilers/c.py
index 2d141160e..81c664aae 100644
--- a/mesonbuild/compilers/c.py
+++ b/mesonbuild/compilers/c.py
@@ -416,7 +416,7 @@ def cross_sizeof(self, typename, prefix, env, extra_args=None, dependencies=None
         }}'''
         if not self.compiles(t.format(**fargs), env, extra_args, dependencies):
             return -1
-        return self.cross_compute_int('sizeof(%s)' % typename, 1, 128, None, prefix, env, extra_args, dependencies)
+        return self.cross_compute_int('sizeof(%s)' % typename, 1, 1024, None, prefix, env, extra_args, dependencies)
 
     def sizeof(self, typename, prefix, env, extra_args=None, dependencies=None):
         if extra_args is None:

From 18634b0a3fd96a083227c3a28fbfa3cba2915bbc Mon Sep 17 00:00:00 2001
From: Thierry Reding <treding@nvidia.com>
Date: Fri, 16 Mar 2018 00:41:26 +0100
Subject: [PATCH 2/2] Use dependencies for cc.find_library()

Allows the `dependencies' keyword argument to be used with the
cc.find_library() command. This has the effect of adding the compile and
link arguments of each dependency to the command-line which may be
necessary to find the library. The `dirs' keyword argument can still be
used to specify a list of search directories that overrides any of the
dependencies specified.

Note that specifying the list of search directories is not safe unless
you know exactly what you are doing because it will not attempt to link
to the library. Instead it will return the path to the library if it
exists, but that does not automatically guarantee that the library can
really be linked against (for example during cross-compilation). This
can lead the configuration step to succeed but give an error during
linking. Attempting to link against the library using the library paths
provided by the dependencies should therefore be the preferred method.

Signed-off-by: Thierry Reding <treding@nvidia.com>
---
 docs/markdown/Reference-manual.md | 8 ++++++--
 mesonbuild/compilers/c.py         | 4 ++--
 mesonbuild/compilers/vala.py      | 2 +-
 mesonbuild/interpreter.py         | 3 ++-
 4 files changed, 11 insertions(+), 6 deletions(-)

diff --git a/mesonbuild/compilers/c.py b/mesonbuild/compilers/c.py
index 81c664aae..d4c3a7c46 100644
--- a/mesonbuild/compilers/c.py
+++ b/mesonbuild/compilers/c.py
@@ -766,7 +766,7 @@ def get_library_naming(self, env, libtype):
             raise AssertionError('BUG: unknown libtype {!r}'.format(libtype))
         return prefixes, suffixes
 
-    def find_library(self, libname, env, extra_dirs, libtype='default'):
+    def find_library(self, libname, env, dependencies, extra_dirs, libtype='default'):
         # These libraries are either built-in or invalid
         if libname in self.ignore_libs:
             return []
@@ -778,7 +778,7 @@ def find_library(self, libname, env, extra_dirs, libtype='default'):
         # Only try to find std libs if no extra dirs specified.
         if not extra_dirs and libtype == 'default':
             args = ['-l' + libname]
-            if self.links(code, env, extra_args=args):
+            if self.links(code, env, extra_args=args, dependencies=dependencies):
                 return args
         # Ensure that we won't modify the list that was passed to us
         extra_dirs = extra_dirs[:]
diff --git a/mesonbuild/compilers/vala.py b/mesonbuild/compilers/vala.py
index 9ab5c8a1f..1bc2a0d8d 100644
--- a/mesonbuild/compilers/vala.py
+++ b/mesonbuild/compilers/vala.py
@@ -74,7 +74,7 @@ def get_buildtype_args(self, buildtype):
             return ['--debug']
         return []
 
-    def find_library(self, libname, env, extra_dirs):
+    def find_library(self, libname, env, dependencies, extra_dirs):
         if extra_dirs and isinstance(extra_dirs, str):
             extra_dirs = [extra_dirs]
         # Valac always looks in the default vapi dir, so only search there if
diff --git a/mesonbuild/interpreter.py b/mesonbuild/interpreter.py
index cab8bf383..bcdd948a9 100644
--- a/mesonbuild/interpreter.py
+++ b/mesonbuild/interpreter.py
@@ -1147,7 +1147,8 @@ def find_library_method(self, args, kwargs):
         for i in search_dirs:
             if not os.path.isabs(i):
                 raise InvalidCode('Search directory %s is not an absolute path.' % i)
-        linkargs = self.compiler.find_library(libname, self.environment, search_dirs)
+        deps = self.determine_dependencies(kwargs)
+        linkargs = self.compiler.find_library(libname, self.environment, deps, search_dirs)
         if required and not linkargs:
             raise InterpreterException('{} library {!r} not found'.format(self.compiler.get_display_language(), libname))
         lib = dependencies.ExternalLibrary(libname, linkargs, self.environment,
