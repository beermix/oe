diff -Naur chromium-67.0.3396.87/base/numerics/safe_math_shared_impl.h chromium-67.0.3396.87-patched/base/numerics/safe_math_shared_impl.h
--- chromium-67.0.3396.87/base/numerics/safe_math_shared_impl.h	2018-06-13 01:10:01.000000000 +0300
+++ chromium-67.0.3396.87-patched/base/numerics/safe_math_shared_impl.h	2018-07-06 16:13:45.464524647 +0300
@@ -21,8 +21,7 @@
 #if !defined(__native_client__) &&                         \
     ((defined(__clang__) &&                                \
       ((__clang_major__ > 3) ||                            \
-       (__clang_major__ == 3 && __clang_minor__ >= 4))) || \
-     (defined(__GNUC__) && __GNUC__ >= 5))
+       (__clang_major__ == 3 && __clang_minor__ >= 4))))
 #include "base/numerics/safe_math_clang_gcc_impl.h"
 #define BASE_HAS_OPTIMIZED_SAFE_MATH (1)
 #else
diff -Naur chromium-67.0.3396.87/build/config/compiler/BUILD.gn chromium-67.0.3396.87-patched/build/config/compiler/BUILD.gn
--- chromium-67.0.3396.87/build/config/compiler/BUILD.gn	2018-06-13 01:10:02.000000000 +0300
+++ chromium-67.0.3396.87-patched/build/config/compiler/BUILD.gn	2018-07-06 16:13:55.771191198 +0300
@@ -464,18 +464,6 @@
     cflags += [ "-fcolor-diagnostics" ]
   }
 
-  # TODO(hans): Remove this once Clang generates better optimized debug info by
-  # default. https://crbug.com/765793
-  if (is_clang && !is_nacl && current_toolchain == host_toolchain &&
-      target_os != "chromeos") {
-    cflags += [
-      "-Xclang",
-      "-mllvm",
-      "-Xclang",
-      "-instcombine-lower-dbg-declare=0",
-    ]
-  }
-
   # Print absolute paths in diagnostics. There is no precedent for doing this
   # on Linux/Mac (GCC doesn't support it), but MSVC does this with /FC and
   # Windows developers rely on it (crbug.com/636109) so only do this on Windows.
diff -Naur chromium-67.0.3396.87/build/config/compiler/BUILD.gn.orig chromium-67.0.3396.87-patched/build/config/compiler/BUILD.gn.orig
diff -Naur chromium-67.0.3396.87/build/config/posix/BUILD.gn chromium-67.0.3396.87-patched/build/config/posix/BUILD.gn
--- chromium-67.0.3396.87/build/config/posix/BUILD.gn	2018-06-13 01:10:02.000000000 +0300
+++ chromium-67.0.3396.87-patched/build/config/posix/BUILD.gn	2018-07-06 16:13:55.767857865 +0300
@@ -74,6 +74,8 @@
         "rt",
       ]
     }
+  } else {
+    libs += [ "stdc++" ]
   }
 
   if (!is_mac && !is_ios && sysroot != "") {
diff -Naur chromium-67.0.3396.87/build/linux/unbundle/libusb.gn chromium-67.0.3396.87-patched/build/linux/unbundle/libusb.gn
--- chromium-67.0.3396.87/build/linux/unbundle/libusb.gn	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/build/linux/unbundle/libusb.gn	2018-07-06 16:13:44.001191337 +0300
@@ -0,0 +1,24 @@
+# Copyright 2016 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/linux/pkg_config.gni")
+import("//build/shim_headers.gni")
+
+pkg_config("system_libusb") {
+  packages = [ "libusb-1.0" ]
+}
+
+shim_headers("libusb_shim") {
+  root_path = "src/libusb"
+  headers = [
+    "libusb.h",
+  ]
+}
+
+source_set("libusb") {
+  deps = [
+    ":libusb_shim",
+  ]
+  public_configs = [ ":system_libusb" ]
+}
diff -Naur chromium-67.0.3396.87/build/linux/unbundle/opus.gn chromium-67.0.3396.87-patched/build/linux/unbundle/opus.gn
--- chromium-67.0.3396.87/build/linux/unbundle/opus.gn	2018-06-13 01:10:02.000000000 +0300
+++ chromium-67.0.3396.87-patched/build/linux/unbundle/opus.gn	2018-07-06 16:13:44.004524670 +0300
@@ -1,3 +1,164 @@
+# Copyright 2016 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/linux/pkg_config.gni")
+import("//build/shim_headers.gni")
+import("//testing/test.gni")
+
+pkg_config("system_opus") {
+  packages = [ "opus" ]
+}
+
+shim_headers("opus_shim") {
+  root_path = "src/include"
+  headers = [
+    "opus_custom.h",
+    "opus_defines.h",
+    "opus_multistream.h",
+    "opus_types.h",
+    "opus.h",
+  ]
+}
+
+source_set("opus") {
+  deps = [
+    ":opus_shim",
+  ]
+  public_configs = [ ":system_opus" ]
+}
+
+config("opus_test_config") {
+  include_dirs = [
+    "src/celt",
+    "src/silk",
+  ]
+
+  if (is_win) {
+    defines = [ "inline=__inline" ]
+  }
+  if (is_android) {
+    libs = [ "log" ]
+  }
+  if (is_clang) {
+    cflags = [ "-Wno-absolute-value" ]
+  }
+}
+
+executable("opus_compare") {
+  sources = [
+    "src/src/opus_compare.c",
+  ]
+
+  configs -= [ "//build/config/compiler:chromium_code" ]
+  configs += [
+    "//build/config/compiler:no_chromium_code",
+    ":opus_test_config",
+  ]
+
+  deps = [
+    ":opus",
+    "//build/config/sanitizers:deps",
+    "//build/win:default_exe_manifest",
+  ]
+}
+
+executable("opus_demo") {
+  sources = [
+    "src/src/opus_demo.c",
+  ]
+
+  configs -= [ "//build/config/compiler:chromium_code" ]
+  configs += [
+    "//build/config/compiler:no_chromium_code",
+    ":opus_test_config",
+  ]
+
+  deps = [
+    ":opus",
+    "//build/config/sanitizers:deps",
+    "//build/win:default_exe_manifest",
+  ]
+}
+
+test("test_opus_api") {
+  sources = [
+    "src/tests/test_opus_api.c",
+  ]
+
+  configs -= [ "//build/config/compiler:chromium_code" ]
+  configs += [
+    "//build/config/compiler:no_chromium_code",
+    ":opus_test_config",
+  ]
+
+  deps = [
+    ":opus",
+  ]
+}
+
+test("test_opus_encode") {
+  sources = [
+    "src/tests/test_opus_encode.c",
+  ]
+
+  configs -= [ "//build/config/compiler:chromium_code" ]
+  configs += [
+    "//build/config/compiler:no_chromium_code",
+    ":opus_test_config",
+  ]
+
+  deps = [
+    ":opus",
+  ]
+}
+
+# GN orders flags on a target before flags from configs. The default config
+# adds -Wall, and this flag have to be after -Wall -- so they need to
+# come from a config and can't be on the target directly.
+config("test_opus_decode_config") {
+  # test_opus_decode passes a null pointer to opus_decode() for an argument
+  # marked as requiring a non-null value by the nonnull function attribute,
+  # and expects opus_decode() to fail. Disable the -Wnonnull option to avoid
+  # a compilation error if -Werror is specified.
+  if (is_posix) {
+    cflags = [ "-Wno-nonnull" ]
+  }
+}
+
+test("test_opus_decode") {
+  sources = [
+    "src/tests/test_opus_decode.c",
+  ]
+
+  configs -= [ "//build/config/compiler:chromium_code" ]
+  configs += [
+    "//build/config/compiler:no_chromium_code",
+    ":opus_test_config",
+    ":test_opus_decode_config",
+  ]
+
+  deps = [
+    ":opus",
+  ]
+}
+
+test("test_opus_padding") {
+  sources = [
+    "src/tests/test_opus_padding.c",
+  ]
+
+  configs -= [ "//build/config/compiler:chromium_code" ]
+  configs += [
+    "//build/config/compiler:no_chromium_code",
+    ":opus_test_config",
+  ]
+
+  deps = [
+    ":opus",
+  ]
+}
+
 # Copyright 2017 The Chromium Authors. All rights reserved.
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
diff -Naur chromium-67.0.3396.87/build/linux/unbundle/replace_gn_files.py chromium-67.0.3396.87-patched/build/linux/unbundle/replace_gn_files.py
--- chromium-67.0.3396.87/build/linux/unbundle/replace_gn_files.py	2018-06-13 01:10:02.000000000 +0300
+++ chromium-67.0.3396.87-patched/build/linux/unbundle/replace_gn_files.py	2018-07-06 16:13:44.004524670 +0300
@@ -27,6 +27,7 @@
   'libevent': 'base/third_party/libevent/BUILD.gn',
   'libjpeg': 'third_party/libjpeg.gni',
   'libpng': 'third_party/libpng/BUILD.gn',
+  'libusb': 'third_party/libusb/BUILD.gn',
   'libvpx': 'third_party/libvpx/BUILD.gn',
   'libwebp': 'third_party/libwebp/BUILD.gn',
   'libxml': 'third_party/libxml/BUILD.gn',
diff -Naur chromium-67.0.3396.87/build/toolchain/linux/BUILD.gn chromium-67.0.3396.87-patched/build/toolchain/linux/BUILD.gn
--- chromium-67.0.3396.87/build/toolchain/linux/BUILD.gn	2018-06-13 01:10:02.000000000 +0300
+++ chromium-67.0.3396.87-patched/build/toolchain/linux/BUILD.gn	2018-07-06 16:13:44.014524669 +0300
@@ -31,6 +31,7 @@
   ld = cxx
   readelf = "${toolprefix}readelf"
   nm = "${toolprefix}nm"
+  extra_cppflags = "-fno-delete-null-pointer-checks"
 
   toolchain_args = {
     current_cpu = "arm64"
@@ -49,6 +50,7 @@
   ld = cxx
   readelf = "${toolprefix}readelf"
   nm = "${toolprefix}nm"
+  extra_cppflags = "-fno-delete-null-pointer-checks"
 
   toolchain_args = {
     current_cpu = "arm"
@@ -99,6 +101,7 @@
   nm = "nm"
   ar = "ar"
   ld = cxx
+  extra_cppflags = "-fno-delete-null-pointer-checks -g1"
 
   # Output linker map files for binary size analysis.
   enable_linker_map = true
@@ -152,6 +155,7 @@
   nm = "nm"
   ar = "ar"
   ld = cxx
+  extra_cppflags = "-fno-delete-null-pointer-checks"
 
   # Output linker map files for binary size analysis.
   enable_linker_map = true
@@ -186,6 +190,7 @@
   ld = cxx
   readelf = "${toolprefix}readelf"
   nm = "${toolprefix}nm"
+  extra_cppflags = "-fno-delete-null-pointer-checks"
 
   toolchain_args = {
     cc_wrapper = ""
diff -Naur chromium-67.0.3396.87/cc/blink/web_layer_impl.h chromium-67.0.3396.87-patched/cc/blink/web_layer_impl.h
--- chromium-67.0.3396.87/cc/blink/web_layer_impl.h	2018-06-13 01:10:02.000000000 +0300
+++ chromium-67.0.3396.87-patched/cc/blink/web_layer_impl.h	2018-07-06 16:13:44.014524669 +0300
@@ -67,7 +67,7 @@
   void SetIsRootForIsolatedGroup(bool root) override;
   bool IsRootForIsolatedGroup() override;
   void SetHitTestableWithoutDrawsContent(bool should_hit_test) override;
-  void SetOpaque(bool opaque) override;
+  CC_BLINK_EXPORT void SetOpaque(bool opaque) override;
   bool Opaque() const override;
   void SetPosition(const blink::WebFloatPoint& position) override;
   blink::WebFloatPoint GetPosition() const override;
diff -Naur chromium-67.0.3396.87/cc/paint/paint_op_buffer.cc chromium-67.0.3396.87-patched/cc/paint/paint_op_buffer.cc
--- chromium-67.0.3396.87/cc/paint/paint_op_buffer.cc	2018-06-13 01:10:02.000000000 +0300
+++ chromium-67.0.3396.87-patched/cc/paint/paint_op_buffer.cc	2018-07-06 16:13:44.041191335 +0300
@@ -206,7 +206,7 @@
 #undef TYPES
 
 const SkRect PaintOp::kUnsetRect = {SK_ScalarInfinity, 0, 0, 0};
-const size_t PaintOp::kMaxSkip;
+constexpr size_t PaintOp::kMaxSkip;
 
 std::string PaintOpTypeToString(PaintOpType type) {
   switch (type) {
diff -Naur chromium-67.0.3396.87/cc/paint/raw_memory_transfer_cache_entry.cc chromium-67.0.3396.87-patched/cc/paint/raw_memory_transfer_cache_entry.cc
--- chromium-67.0.3396.87/cc/paint/raw_memory_transfer_cache_entry.cc	2018-06-13 01:10:02.000000000 +0300
+++ chromium-67.0.3396.87-patched/cc/paint/raw_memory_transfer_cache_entry.cc	2018-07-06 16:13:46.501191306 +0300
@@ -3,7 +3,7 @@
 // found in the LICENSE file.
 
 #include "cc/paint/raw_memory_transfer_cache_entry.h"
-
+#include <memory.h>
 #include <string.h>
 
 namespace cc {
diff -Naur chromium-67.0.3396.87/cc/raster/playback_image_provider.cc.orig chromium-67.0.3396.87-patched/cc/raster/playback_image_provider.cc.orig
--- chromium-67.0.3396.87/cc/raster/playback_image_provider.cc.orig	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/cc/raster/playback_image_provider.cc.orig	2018-07-06 16:13:49.824524600 +0300
@@ -0,0 +1,78 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/raster/playback_image_provider.h"
+
+#include "cc/tiles/image_decode_cache.h"
+
+namespace cc {
+namespace {
+void UnrefImageFromCache(DrawImage draw_image,
+                         ImageDecodeCache* cache,
+                         DecodedDrawImage decoded_draw_image) {
+  cache->DrawWithImageFinished(draw_image, decoded_draw_image);
+}
+
+}  // namespace
+
+PlaybackImageProvider::PlaybackImageProvider(
+    ImageDecodeCache* cache,
+    const gfx::ColorSpace& target_color_space,
+    base::Optional<Settings>&& settings)
+    : cache_(cache),
+      target_color_space_(target_color_space),
+      settings_(std::move(settings)) {
+  DCHECK(cache_);
+}
+
+PlaybackImageProvider::~PlaybackImageProvider() = default;
+
+PlaybackImageProvider::PlaybackImageProvider(PlaybackImageProvider&& other) =
+    default;
+
+PlaybackImageProvider& PlaybackImageProvider::operator=(
+    PlaybackImageProvider&& other) = default;
+
+ImageProvider::ScopedDecodedDrawImage
+PlaybackImageProvider::GetDecodedDrawImage(const DrawImage& draw_image) {
+  // Return an empty decoded image if we are skipping all images during this
+  // raster.
+  if (!settings_.has_value())
+    return ScopedDecodedDrawImage();
+
+  const PaintImage& paint_image = draw_image.paint_image();
+  if (settings_->images_to_skip.count(paint_image.stable_id()) != 0) {
+    DCHECK(paint_image.GetSkImage()->isLazyGenerated());
+    return ScopedDecodedDrawImage();
+  }
+
+  if (paint_image.GetSkImage()->isTextureBacked()) {
+    return ScopedDecodedDrawImage(DecodedDrawImage(
+        paint_image.GetSkImage(), SkSize::Make(0, 0), SkSize::Make(1.f, 1.f),
+        draw_image.filter_quality(), true /* is_budgeted */));
+  }
+
+  const auto& it =
+      settings_->image_to_current_frame_index.find(paint_image.stable_id());
+  size_t frame_index = it == settings_->image_to_current_frame_index.end()
+                           ? paint_image.frame_index()
+                           : it->second;
+
+  DrawImage adjusted_image(draw_image, 1.f, frame_index, target_color_space_);
+  auto decoded_draw_image = cache_->GetDecodedImageForDraw(adjusted_image);
+
+  return ScopedDecodedDrawImage(
+      decoded_draw_image,
+      base::BindOnce(&UnrefImageFromCache, std::move(adjusted_image), cache_,
+                     decoded_draw_image));
+}
+
+PlaybackImageProvider::Settings::Settings() = default;
+PlaybackImageProvider::Settings::Settings(PlaybackImageProvider::Settings&&) =
+    default;
+PlaybackImageProvider::Settings::~Settings() = default;
+PlaybackImageProvider::Settings& PlaybackImageProvider::Settings::operator=(
+    PlaybackImageProvider::Settings&&) = default;
+
+}  // namespace cc
diff -Naur chromium-67.0.3396.87/cc/raster/playback_image_provider.cc.rej chromium-67.0.3396.87-patched/cc/raster/playback_image_provider.cc.rej
--- chromium-67.0.3396.87/cc/raster/playback_image_provider.cc.rej	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/cc/raster/playback_image_provider.cc.rej	2018-07-06 16:13:49.824524600 +0300
@@ -0,0 +1,10 @@
+--- cc/raster/playback_image_provider.cc.pipcc	2018-03-13 22:47:00.271322726 -0400
++++ cc/raster/playback_image_provider.cc	2018-03-13 22:47:53.127300060 -0400
+@@ -92,7 +92,6 @@ PlaybackImageProvider::GetDecodedDrawIma
+ }
+ 
+ PlaybackImageProvider::Settings::Settings() = default;
+-PlaybackImageProvider::Settings::Settings(const Settings& other) = default;
+ PlaybackImageProvider::Settings::~Settings() = default;
+ 
+ }  // namespace cc
diff -Naur chromium-67.0.3396.87/cc/raster/playback_image_provider.h.orig chromium-67.0.3396.87-patched/cc/raster/playback_image_provider.h.orig
--- chromium-67.0.3396.87/cc/raster/playback_image_provider.h.orig	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/cc/raster/playback_image_provider.h.orig	2018-07-06 16:13:49.824524600 +0300
@@ -0,0 +1,59 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_RASTER_PLAYBACK_IMAGE_PROVIDER_H_
+#define CC_RASTER_PLAYBACK_IMAGE_PROVIDER_H_
+
+#include "base/containers/flat_map.h"
+#include "cc/cc_export.h"
+#include "cc/paint/image_id.h"
+#include "cc/paint/image_provider.h"
+#include "ui/gfx/color_space.h"
+
+namespace cc {
+class ImageDecodeCache;
+
+// PlaybackImageProvider is used to replace lazy generated PaintImages with
+// decoded images for raster from the ImageDecodeCache.
+class CC_EXPORT PlaybackImageProvider : public ImageProvider {
+ public:
+  struct CC_EXPORT Settings {
+    Settings();
+    Settings(const Settings&) = delete;
+    Settings(Settings&&);
+    ~Settings();
+    Settings& operator=(Settings&&);
+
+    // The set of image ids to skip during raster.
+    PaintImageIdFlatSet images_to_skip;
+
+    // The frame index to use for the given image id. If no index is provided,
+    // the frame index provided in the PaintImage will be used.
+    base::flat_map<PaintImage::Id, size_t> image_to_current_frame_index;
+  };
+
+  // If no settings are provided, all images are skipped during rasterization.
+  PlaybackImageProvider(ImageDecodeCache* cache,
+                        const gfx::ColorSpace& target_color_space,
+                        base::Optional<Settings>&& settings);
+  ~PlaybackImageProvider() override;
+
+  PlaybackImageProvider(PlaybackImageProvider&& other);
+  PlaybackImageProvider& operator=(PlaybackImageProvider&& other);
+
+  // ImageProvider implementation.
+  ScopedDecodedDrawImage GetDecodedDrawImage(
+      const DrawImage& draw_image) override;
+
+ private:
+  ImageDecodeCache* cache_;
+  gfx::ColorSpace target_color_space_;
+  base::Optional<Settings> settings_;
+
+  DISALLOW_COPY_AND_ASSIGN(PlaybackImageProvider);
+};
+
+}  // namespace cc
+
+#endif  // CC_RASTER_PLAYBACK_IMAGE_PROVIDER_H_
diff -Naur chromium-67.0.3396.87/cc/raster/playback_image_provider.h.rej chromium-67.0.3396.87-patched/cc/raster/playback_image_provider.h.rej
--- chromium-67.0.3396.87/cc/raster/playback_image_provider.h.rej	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/cc/raster/playback_image_provider.h.rej	2018-07-06 16:13:49.824524600 +0300
@@ -0,0 +1,10 @@
+--- cc/raster/playback_image_provider.h.pipcc	2018-03-13 22:48:00.673153629 -0400
++++ cc/raster/playback_image_provider.h	2018-03-13 22:48:12.726920597 -0400
+@@ -20,7 +20,6 @@ class CC_EXPORT PlaybackImageProvider :
+  public:
+   struct CC_EXPORT Settings {
+     Settings();
+-    Settings(const Settings& other);
+     ~Settings();
+ 
+     // The set of image ids to skip during raster.
diff -Naur chromium-67.0.3396.87/chrome/browser/first_run/first_run_internal_linux.cc chromium-67.0.3396.87-patched/chrome/browser/first_run/first_run_internal_linux.cc
--- chromium-67.0.3396.87/chrome/browser/first_run/first_run_internal_linux.cc	2018-06-13 01:10:06.000000000 +0300
+++ chromium-67.0.3396.87-patched/chrome/browser/first_run/first_run_internal_linux.cc	2018-07-06 16:13:42.407858022 +0300
@@ -19,9 +19,9 @@
 
 base::FilePath MasterPrefsPath() {
   // The standard location of the master prefs is next to the chrome binary.
+  // ...but we patch it to use /etc/chromium
   base::FilePath master_prefs;
-  if (!PathService::Get(base::DIR_EXE, &master_prefs))
-    return base::FilePath();
+  master_prefs = base::FilePath("/etc/chromium");
   return master_prefs.AppendASCII(installer::kDefaultMasterPrefs);
 }
 
diff -Naur chromium-67.0.3396.87/chrome/browser/vr/sample_queue.cc.rej chromium-67.0.3396.87-patched/chrome/browser/vr/sample_queue.cc.rej
--- chromium-67.0.3396.87/chrome/browser/vr/sample_queue.cc.rej	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/chrome/browser/vr/sample_queue.cc.rej	2018-07-06 16:13:49.824524600 +0300
@@ -0,0 +1,11 @@
+--- chrome/browser/vr/sample_queue.cc
++++ chrome/browser/vr/sample_queue.cc
+@@ -2,6 +2,8 @@
+ // Use of this source code is governed by a BSD-style license that can be
+ // found in the LICENSE file.
+ 
++#include <stdint.h>
++
+ #include "chrome/browser/vr/sample_queue.h"
+ 
+ namespace vr {
diff -Naur chromium-67.0.3396.87/chrome/test/data/webui_test_resources.grd chromium-67.0.3396.87-patched/chrome/test/data/webui_test_resources.grd
--- chromium-67.0.3396.87/chrome/test/data/webui_test_resources.grd	2018-06-13 01:10:12.000000000 +0300
+++ chromium-67.0.3396.87-patched/chrome/test/data/webui_test_resources.grd	2018-07-06 16:13:38.104524741 +0300
@@ -8,7 +8,6 @@
   </outputs>
   <release seq="1">
     <includes>
-      <include name="IDR_WEBUI_TEST_I18N_PROCESS_CSS_TEST" file="webui/i18n_process_css_test.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" />
     </includes>
   </release>
 </grit>
diff -Naur chromium-67.0.3396.87/components/assist_ranker/ranker_example_util.cc.rej chromium-67.0.3396.87-patched/components/assist_ranker/ranker_example_util.cc.rej
--- chromium-67.0.3396.87/components/assist_ranker/ranker_example_util.cc.rej	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/components/assist_ranker/ranker_example_util.cc.rej	2018-07-06 16:13:48.704524611 +0300
@@ -0,0 +1,11 @@
+--- components/assist_ranker/ranker_example_util.cc
++++ components/assist_ranker/ranker_example_util.cc
+@@ -2,6 +2,8 @@
+ // Use of this source code is governed by a BSD-style license that can be
+ // found in the LICENSE file.
+ 
++#include <math.h>
++
+ #include "components/assist_ranker/ranker_example_util.h"
+ #include "base/bit_cast.h"
+ #include "base/format_macros.h"
diff -Naur chromium-67.0.3396.87/components/nacl/loader/sandbox_linux/nacl_sandbox_linux.cc chromium-67.0.3396.87-patched/components/nacl/loader/sandbox_linux/nacl_sandbox_linux.cc
--- chromium-67.0.3396.87/components/nacl/loader/sandbox_linux/nacl_sandbox_linux.cc	2018-06-13 01:10:13.000000000 +0300
+++ chromium-67.0.3396.87-patched/components/nacl/loader/sandbox_linux/nacl_sandbox_linux.cc	2018-07-06 16:13:42.394524686 +0300
@@ -156,6 +156,14 @@
 }
 
 void NaClSandbox::CheckForExpectedNumberOfOpenFds() {
+  // Whatever logic this code is using is wrong more often than it is right.
+  // If you set expected_num_fds to 6, it finds 7.
+  // If you set expected_num_fds to 7, it finds 6.
+  // Code like this makes a packager drink. And not the good stuff either.
+  // Instead, we're just going to smile and tell it to never care about the
+  // number of FDs open. Stupid code. We hates it.
+
+#if 0  
   // We expect to have the following FDs open:
   //  1-3) stdin, stdout, stderr.
   //  4) The /dev/urandom FD used by base::GetUrandomFD().
@@ -174,6 +182,8 @@
   }
 
   CHECK_EQ(expected_num_fds, sandbox::ProcUtil::CountOpenFds(proc_fd_.get()));
+#endif
+
 }
 
 void NaClSandbox::InitializeLayerTwoSandbox(bool uses_nonsfi_mode) {
diff -Naur chromium-67.0.3396.87/components/nacl/loader/sandbox_linux/nacl_sandbox_linux.cc.orig chromium-67.0.3396.87-patched/components/nacl/loader/sandbox_linux/nacl_sandbox_linux.cc.orig
--- chromium-67.0.3396.87/components/nacl/loader/sandbox_linux/nacl_sandbox_linux.cc.orig	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/components/nacl/loader/sandbox_linux/nacl_sandbox_linux.cc.orig	2018-06-13 01:10:13.000000000 +0300
@@ -0,0 +1,249 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/nacl/loader/sandbox_linux/nacl_sandbox_linux.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdint.h>
+#include <sys/prctl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <limits>
+#include <memory>
+#include <utility>
+
+#include "base/callback.h"
+#include "base/command_line.h"
+#include "base/compiler_specific.h"
+#include "base/files/scoped_file.h"
+#include "base/logging.h"
+#include "base/posix/eintr_wrapper.h"
+#include "build/build_config.h"
+#include "components/nacl/common/nacl_switches.h"
+#include "components/nacl/loader/nonsfi/nonsfi_sandbox.h"
+#include "components/nacl/loader/sandbox_linux/nacl_bpf_sandbox_linux.h"
+#include "content/public/common/content_switches.h"
+#include "sandbox/linux/seccomp-bpf/sandbox_bpf.h"
+#include "sandbox/linux/services/credentials.h"
+#include "sandbox/linux/services/namespace_sandbox.h"
+#include "sandbox/linux/services/proc_util.h"
+#include "sandbox/linux/services/resource_limits.h"
+#include "sandbox/linux/services/thread_helpers.h"
+#include "sandbox/linux/suid/client/setuid_sandbox_client.h"
+#include "services/service_manager/sandbox/switches.h"
+
+namespace nacl {
+
+namespace {
+
+// This is a simplistic check of whether we are sandboxed.
+bool IsSandboxed() {
+  int proc_fd = open("/proc/self/exe", O_RDONLY);
+  if (proc_fd >= 0) {
+    PCHECK(0 == IGNORE_EINTR(close(proc_fd)));
+    return false;
+  }
+  return true;
+}
+
+bool MaybeSetProcessNonDumpable() {
+  const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  if (command_line.HasSwitch(
+          service_manager::switches::kAllowSandboxDebugging)) {
+    return true;
+  }
+
+  if (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) != 0) {
+    PLOG(ERROR) << "Failed to set non-dumpable flag";
+    return false;
+  }
+
+  return prctl(PR_GET_DUMPABLE) == 0;
+}
+
+void RestrictAddressSpaceUsage() {
+#if defined(ADDRESS_SANITIZER) || defined(MEMORY_SANITIZER) || \
+    defined(THREAD_SANITIZER)
+  // Sanitizers need to reserve huge chunks of the address space.
+  return;
+#endif
+
+  // Add a limit to the brk() heap that would prevent allocations that can't be
+  // indexed by an int. This helps working around typical security bugs.
+  // This could almost certainly be set to zero. GLibc's allocator and others
+  // would fall-back to mmap if brk() fails.
+  const rlim_t kNewDataSegmentMaxSize = std::numeric_limits<int>::max();
+  CHECK(sandbox::ResourceLimits::Lower(RLIMIT_DATA, kNewDataSegmentMaxSize));
+
+#if defined(ARCH_CPU_64_BITS)
+  // NaCl's x86-64 sandbox allocated 88GB address of space during startup:
+  // - The main sandbox is 4GB
+  // - There are two guard regions of 40GB each.
+  // - 4GB are allocated extra to have a 4GB-aligned address.
+  // See https://crbug.com/455839
+  //
+  // Set the limit to 128 GB and have some margin.
+  const rlim_t kNewAddressSpaceLimit = 1UL << 37;
+#else
+  // Some architectures such as X86 allow 32 bits processes to switch to 64
+  // bits when running under 64 bits kernels. Set a limit in case this happens.
+  const rlim_t kNewAddressSpaceLimit = std::numeric_limits<uint32_t>::max();
+#endif
+  CHECK(sandbox::ResourceLimits::Lower(RLIMIT_AS, kNewAddressSpaceLimit));
+}
+
+}  // namespace
+
+NaClSandbox::NaClSandbox()
+    : layer_one_enabled_(false),
+      layer_one_sealed_(false),
+      layer_two_enabled_(false),
+      layer_two_is_nonsfi_(false),
+      proc_fd_(-1),
+      setuid_sandbox_client_(sandbox::SetuidSandboxClient::Create()) {
+  proc_fd_.reset(
+      HANDLE_EINTR(open("/proc", O_DIRECTORY | O_RDONLY | O_CLOEXEC)));
+  PCHECK(proc_fd_.is_valid());
+}
+
+NaClSandbox::~NaClSandbox() {
+}
+
+bool NaClSandbox::IsSingleThreaded() {
+  CHECK(proc_fd_.is_valid());
+  return sandbox::ThreadHelpers::IsSingleThreaded(proc_fd_.get());
+}
+
+bool NaClSandbox::HasOpenDirectory() {
+  CHECK(proc_fd_.is_valid());
+  return sandbox::ProcUtil::HasOpenDirectory(proc_fd_.get());
+}
+
+void NaClSandbox::InitializeLayerOneSandbox() {
+  // Check that IsSandboxed() works. We should not be sandboxed at this point.
+  CHECK(!IsSandboxed()) << "Unexpectedly sandboxed!";
+
+  if (setuid_sandbox_client_->IsSuidSandboxChild()) {
+    setuid_sandbox_client_->CloseDummyFile();
+
+    // Make sure that no directory file descriptor is open, as it would bypass
+    // the setuid sandbox model.
+    CHECK(!HasOpenDirectory());
+
+    // Get sandboxed.
+    CHECK(setuid_sandbox_client_->ChrootMe());
+    CHECK(MaybeSetProcessNonDumpable());
+    CHECK(IsSandboxed());
+    layer_one_enabled_ = true;
+  } else if (sandbox::NamespaceSandbox::InNewUserNamespace()) {
+    CHECK(sandbox::Credentials::MoveToNewUserNS());
+    CHECK(sandbox::Credentials::DropFileSystemAccess(proc_fd_.get()));
+
+    // We do not drop CAP_SYS_ADMIN because we need it to place each child
+    // process in its own PID namespace later on.
+    std::vector<sandbox::Credentials::Capability> caps;
+    caps.push_back(sandbox::Credentials::Capability::SYS_ADMIN);
+    CHECK(sandbox::Credentials::SetCapabilities(proc_fd_.get(), caps));
+
+    CHECK(IsSandboxed());
+    layer_one_enabled_ = true;
+  }
+}
+
+void NaClSandbox::CheckForExpectedNumberOfOpenFds() {
+  // We expect to have the following FDs open:
+  //  1-3) stdin, stdout, stderr.
+  //  4) The /dev/urandom FD used by base::GetUrandomFD().
+  //  5) A dummy pipe FD used to overwrite kSandboxIPCChannel.
+  //  6) The socket for the Chrome IPC channel that's connected to the
+  //     browser process, kPrimaryIPCChannel.
+  // We also have an fd for /proc (proc_fd_), but CountOpenFds excludes this.
+  //
+  // This sanity check ensures that dynamically loaded libraries don't
+  // leave any FDs open before we enable the sandbox.
+  int expected_num_fds = 6;
+  if (setuid_sandbox_client_->IsSuidSandboxChild()) {
+    // When using the setuid sandbox, there is one additional socket used for
+    // ChrootMe(). After ChrootMe(), it is no longer connected to anything.
+    ++expected_num_fds;
+  }
+
+  CHECK_EQ(expected_num_fds, sandbox::ProcUtil::CountOpenFds(proc_fd_.get()));
+}
+
+void NaClSandbox::InitializeLayerTwoSandbox(bool uses_nonsfi_mode) {
+  // seccomp-bpf only applies to the current thread, so it's critical to only
+  // have a single thread running here.
+  DCHECK(!layer_one_sealed_);
+  CHECK(IsSingleThreaded());
+  CheckForExpectedNumberOfOpenFds();
+
+  RestrictAddressSpaceUsage();
+
+  // Pass proc_fd_ ownership to the BPF sandbox, which guarantees it will
+  // be closed. There is no point in keeping it around since the BPF policy
+  // will prevent its usage.
+#if defined(OS_NACL_NONSFI)
+  CHECK(uses_nonsfi_mode);
+  layer_two_enabled_ = nacl::nonsfi::InitializeBPFSandbox(std::move(proc_fd_));
+  layer_two_is_nonsfi_ = true;
+#else
+  CHECK(!uses_nonsfi_mode);
+  layer_two_enabled_ = nacl::InitializeBPFSandbox(std::move(proc_fd_));
+#endif
+}
+
+void NaClSandbox::SealLayerOneSandbox() {
+  if (proc_fd_.is_valid() && !layer_two_enabled_) {
+    // If nothing prevents us, check that there is no superfluous directory
+    // open.
+    CHECK(!HasOpenDirectory());
+  }
+  proc_fd_.reset();
+  layer_one_sealed_ = true;
+}
+
+void NaClSandbox::CheckSandboxingStateWithPolicy() {
+  static const char kItIsDangerousMsg[] = " this is dangerous.";
+  static const char kItIsNotAllowedMsg[] =
+      " this is not allowed in this configuration.";
+
+  const bool no_sandbox_for_nonsfi_ok =
+#if defined(ADDRESS_SANITIZER) || defined(THREAD_SANITIZER) || \
+    defined(MEMORY_SANITIZER) || defined(LEAK_SANITIZER)
+      // Sanitizer tests run with --no-sandbox, but without
+      // --nacl-dangerous-no-sandbox-nonsfi. Allow that case.
+      true;
+#else
+      base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kNaClDangerousNoSandboxNonSfi);
+#endif
+
+  const bool can_be_no_sandbox =
+      !layer_two_is_nonsfi_ || no_sandbox_for_nonsfi_ok;
+
+  if (!layer_one_enabled_ || !layer_one_sealed_) {
+    static const char kNoSuidMsg[] =
+        "The SUID sandbox is not engaged for NaCl:";
+    if (can_be_no_sandbox)
+      LOG(ERROR) << kNoSuidMsg << kItIsDangerousMsg;
+    else
+      LOG(FATAL) << kNoSuidMsg << kItIsNotAllowedMsg;
+  }
+
+  if (!layer_two_enabled_) {
+    static const char kNoBpfMsg[] =
+        "The seccomp-bpf sandbox is not engaged for NaCl:";
+    if (can_be_no_sandbox)
+      LOG(ERROR) << kNoBpfMsg << kItIsDangerousMsg;
+    else
+      LOG(FATAL) << kNoBpfMsg << kItIsNotAllowedMsg;
+  }
+}
+
+}  // namespace nacl
diff -Naur chromium-67.0.3396.87/content/browser/appcache/appcache_request_handler.cc.rej chromium-67.0.3396.87-patched/content/browser/appcache/appcache_request_handler.cc.rej
--- chromium-67.0.3396.87/content/browser/appcache/appcache_request_handler.cc.rej	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/content/browser/appcache/appcache_request_handler.cc.rej	2018-07-06 16:13:50.847857923 +0300
@@ -0,0 +1,11 @@
+--- content/browser/appcache/appcache_request_handler.cc.explicit-std-move	2018-03-13 22:50:41.346043716 -0400
++++ content/browser/appcache/appcache_request_handler.cc	2018-03-13 22:51:21.428267583 -0400
+@@ -639,7 +639,7 @@ AppCacheRequestHandler::MaybeCreateSubre
+ 
+   SubresourceLoaderParams params;
+   params.loader_factory_info = factory_ptr.PassInterface();
+-  return params;
++  return base::Optional<SubresourceLoaderParams>(std::move(params));
+ }
+ 
+ void AppCacheRequestHandler::MaybeCreateSubresourceLoader(
diff -Naur chromium-67.0.3396.87/content/browser/service_worker/service_worker_controllee_request_handler.cc.rej chromium-67.0.3396.87-patched/content/browser/service_worker/service_worker_controllee_request_handler.cc.rej
--- chromium-67.0.3396.87/content/browser/service_worker/service_worker_controllee_request_handler.cc.rej	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/content/browser/service_worker/service_worker_controllee_request_handler.cc.rej	2018-07-06 16:13:51.807857910 +0300
@@ -0,0 +1,11 @@
+--- content/browser/service_worker/service_worker_controllee_request_handler.cc.explicit-std-move	2018-03-13 22:51:38.133943776 -0400
++++ content/browser/service_worker/service_worker_controllee_request_handler.cc	2018-03-13 22:51:57.658566347 -0400
+@@ -271,7 +271,7 @@ ServiceWorkerControlleeRequestHandler::M
+   controller_info->object_info = provider_host_->GetOrCreateServiceWorkerHandle(
+       provider_host_->controller());
+   params.controller_service_worker_info = std::move(controller_info);
+-  return params;
++  return base::Optional<SubresourceLoaderParams>(std::move(params));
+ }
+ 
+ void ServiceWorkerControlleeRequestHandler::PrepareForMainResource(
diff -Naur chromium-67.0.3396.87/content/common/user_agent.cc chromium-67.0.3396.87-patched/content/common/user_agent.cc
--- chromium-67.0.3396.87/content/common/user_agent.cc	2018-06-13 01:10:17.000000000 +0300
+++ chromium-67.0.3396.87-patched/content/common/user_agent.cc	2018-07-06 16:13:55.771191198 +0300
@@ -141,7 +141,7 @@
 #elif defined(OS_MACOSX)
       "Macintosh; ";
 #elif defined(USE_X11) || defined(USE_OZONE)
-      "X11; ";           // strange, but that's what Firefox uses
+      "X11; Russian Fedora; ";           // strange, but that's what Firefox uses
 #elif defined(OS_ANDROID)
       "Linux; ";
 #else
diff -Naur chromium-67.0.3396.87/device/usb/usb_context.cc chromium-67.0.3396.87-patched/device/usb/usb_context.cc
--- chromium-67.0.3396.87/device/usb/usb_context.cc	2018-06-13 01:10:18.000000000 +0300
+++ chromium-67.0.3396.87-patched/device/usb/usb_context.cc	2018-07-06 16:13:42.397858020 +0300
@@ -58,7 +58,11 @@
 
 void UsbContext::UsbEventHandler::Stop() {
   base::subtle::Release_Store(&running_, 0);
+#ifdef LIBUSB_API_VERSION >= 0x01000105
+  libusb_interrupt_event_handler(context_);
+#else
   libusb_interrupt_handle_event(context_);
+#endif
 }
 
 UsbContext::UsbContext(PlatformUsbContext context) : context_(context) {
diff -Naur chromium-67.0.3396.87/device/usb/usb_context.cc.orig chromium-67.0.3396.87-patched/device/usb/usb_context.cc.orig
--- chromium-67.0.3396.87/device/usb/usb_context.cc.orig	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/device/usb/usb_context.cc.orig	2018-06-13 01:10:18.000000000 +0300
@@ -0,0 +1,75 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "device/usb/usb_context.h"
+
+#include "base/atomicops.h"
+#include "base/logging.h"
+#include "base/macros.h"
+#include "base/threading/simple_thread.h"
+#include "device/usb/usb_error.h"
+#include "third_party/libusb/src/libusb/interrupt.h"
+#include "third_party/libusb/src/libusb/libusb.h"
+
+namespace device {
+
+// The UsbEventHandler works around a design flaw in the libusb interface. There
+// is currently no way to signal to libusb that any caller into one of the event
+// handler calls should return without handling any events.
+class UsbContext::UsbEventHandler : public base::SimpleThread {
+ public:
+  explicit UsbEventHandler(libusb_context* context);
+  ~UsbEventHandler() override;
+
+  // base::SimpleThread
+  void Run() override;
+
+  void Stop();
+
+ private:
+  base::subtle::Atomic32 running_;
+  libusb_context* context_;
+  DISALLOW_COPY_AND_ASSIGN(UsbEventHandler);
+};
+
+UsbContext::UsbEventHandler::UsbEventHandler(libusb_context* context)
+    : base::SimpleThread("UsbEventHandler"), context_(context) {
+  base::subtle::Release_Store(&running_, 1);
+}
+
+UsbContext::UsbEventHandler::~UsbEventHandler() {
+  libusb_exit(context_);
+}
+
+void UsbContext::UsbEventHandler::Run() {
+  VLOG(1) << "UsbEventHandler started.";
+
+  while (base::subtle::Acquire_Load(&running_)) {
+    const int rv = libusb_handle_events(context_);
+    if (rv != LIBUSB_SUCCESS) {
+      VLOG(1) << "Failed to handle events: "
+              << ConvertPlatformUsbErrorToString(rv);
+    }
+  }
+
+  VLOG(1) << "UsbEventHandler shutting down.";
+}
+
+void UsbContext::UsbEventHandler::Stop() {
+  base::subtle::Release_Store(&running_, 0);
+  libusb_interrupt_handle_event(context_);
+}
+
+UsbContext::UsbContext(PlatformUsbContext context) : context_(context) {
+  // Ownership of the PlatformUsbContext is passed to the event handler thread.
+  event_handler_.reset(new UsbEventHandler(context_));
+  event_handler_->Start();
+}
+
+UsbContext::~UsbContext() {
+  event_handler_->Stop();
+  event_handler_->Join();
+}
+
+}  // namespace device
diff -Naur chromium-67.0.3396.87/gpu/ipc/common/mailbox_struct_traits.h chromium-67.0.3396.87-patched/gpu/ipc/common/mailbox_struct_traits.h
--- chromium-67.0.3396.87/gpu/ipc/common/mailbox_struct_traits.h	2018-06-13 01:10:19.000000000 +0300
+++ chromium-67.0.3396.87-patched/gpu/ipc/common/mailbox_struct_traits.h	2018-07-06 16:13:45.477857981 +0300
@@ -15,7 +15,7 @@
 template <>
 struct StructTraits<gpu::mojom::MailboxDataView, gpu::Mailbox> {
   static base::span<const int8_t> name(const gpu::Mailbox& mailbox) {
-    return mailbox.name;
+    return base::make_span(mailbox.name);
   }
   static bool Read(gpu::mojom::MailboxDataView data, gpu::Mailbox* out);
 };
diff -Naur chromium-67.0.3396.87/mojo/public/c/system/macros.h chromium-67.0.3396.87-patched/mojo/public/c/system/macros.h
--- chromium-67.0.3396.87/mojo/public/c/system/macros.h	2018-06-13 01:10:21.000000000 +0300
+++ chromium-67.0.3396.87-patched/mojo/public/c/system/macros.h	2018-07-06 16:13:55.767857865 +0300
@@ -18,7 +18,13 @@
 #endif
 
 // Like the C++11 |alignof| operator.
-#if __cplusplus >= 201103L
+#if defined(__GNUC__) && __GNUC__ >= 8
+// GCC 8 has changed the alignof operator to return the minimal alignment
+// required by the target ABI, instead of the preferred alignment.
+// This means that on 32-bit x86, it will return 4 instead of 8.
+// Use __alignof__ instead to avoid this.
+#define MOJO_ALIGNOF(type) __alignof__(type)
+#elif __cplusplus >= 201103L
 #define MOJO_ALIGNOF(type) alignof(type)
 #elif defined(__GNUC__)
 #define MOJO_ALIGNOF(type) __alignof__(type)
diff -Naur chromium-67.0.3396.87/mojo/public/cpp/bindings/associated_interface_ptr_info.h chromium-67.0.3396.87-patched/mojo/public/cpp/bindings/associated_interface_ptr_info.h
--- chromium-67.0.3396.87/mojo/public/cpp/bindings/associated_interface_ptr_info.h	2018-06-13 01:10:21.000000000 +0300
+++ chromium-67.0.3396.87-patched/mojo/public/cpp/bindings/associated_interface_ptr_info.h	2018-07-06 16:13:55.761191198 +0300
@@ -45,7 +45,7 @@
 
   bool is_valid() const { return handle_.is_valid(); }
 
-  explicit operator bool() const { return handle_; }
+  explicit operator bool() const { return (bool) handle_; }
 
   ScopedInterfaceEndpointHandle PassHandle() {
     return std::move(handle_);
diff -Naur chromium-67.0.3396.87/mojo/public/cpp/bindings/associated_interface_request.h chromium-67.0.3396.87-patched/mojo/public/cpp/bindings/associated_interface_request.h
--- chromium-67.0.3396.87/mojo/public/cpp/bindings/associated_interface_request.h	2018-06-13 01:10:21.000000000 +0300
+++ chromium-67.0.3396.87-patched/mojo/public/cpp/bindings/associated_interface_request.h	2018-07-06 16:13:55.761191198 +0300
@@ -50,7 +50,7 @@
   // handle.
   bool is_pending() const { return handle_.is_valid(); }
 
-  explicit operator bool() const { return handle_; }
+  explicit operator bool() const { return (bool) handle_; }
 
   ScopedInterfaceEndpointHandle PassHandle() { return std::move(handle_); }
 
diff -Naur chromium-67.0.3396.87/mojo/public/cpp/bindings/interface_request.h chromium-67.0.3396.87-patched/mojo/public/cpp/bindings/interface_request.h
--- chromium-67.0.3396.87/mojo/public/cpp/bindings/interface_request.h	2018-06-13 01:10:21.000000000 +0300
+++ chromium-67.0.3396.87-patched/mojo/public/cpp/bindings/interface_request.h	2018-07-06 16:13:55.761191198 +0300
@@ -54,7 +54,7 @@
   // Indicates whether the request currently contains a valid message pipe.
   bool is_pending() const { return handle_.is_valid(); }
 
-  explicit operator bool() const { return handle_.is_valid(); }
+  explicit operator bool() const { return (bool) handle_.is_valid(); }
 
   // Removes the message pipe from the request and returns it.
   ScopedMessagePipeHandle PassMessagePipe() { return std::move(handle_); }
diff -Naur chromium-67.0.3396.87/native_client/src/untrusted/nacl/getcwd.c chromium-67.0.3396.87-patched/native_client/src/untrusted/nacl/getcwd.c
--- chromium-67.0.3396.87/native_client/src/untrusted/nacl/getcwd.c	2018-06-13 01:12:05.000000000 +0300
+++ chromium-67.0.3396.87-patched/native_client/src/untrusted/nacl/getcwd.c	2018-07-06 16:13:38.097858076 +0300
@@ -11,6 +11,10 @@
 
 #include <errno.h>
 #include <limits.h>
+/* Needed for PATH_MAX */
+#ifndef PATH_MAX
+#define PATH_MAX 4096
+#endif
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
diff -Naur chromium-67.0.3396.87/native_client_sdk/src/libraries/nacl_io/path.h chromium-67.0.3396.87-patched/native_client_sdk/src/libraries/nacl_io/path.h
--- chromium-67.0.3396.87/native_client_sdk/src/libraries/nacl_io/path.h	2018-06-13 01:10:21.000000000 +0300
+++ chromium-67.0.3396.87-patched/native_client_sdk/src/libraries/nacl_io/path.h	2018-07-06 16:13:38.097858076 +0300
@@ -12,6 +12,11 @@
 
 #include "sdk_util/macros.h"
 
+/* Needed for PATH_MAX */
+#ifndef PATH_MAX
+#define PATH_MAX 4096
+#endif
+
 namespace nacl_io {
 
 class Path {
diff -Naur chromium-67.0.3396.87/native_client_sdk/src/libraries/nacl_io/syscalls/realpath.c chromium-67.0.3396.87-patched/native_client_sdk/src/libraries/nacl_io/syscalls/realpath.c
--- chromium-67.0.3396.87/native_client_sdk/src/libraries/nacl_io/syscalls/realpath.c	2018-06-13 01:10:21.000000000 +0300
+++ chromium-67.0.3396.87-patched/native_client_sdk/src/libraries/nacl_io/syscalls/realpath.c	2018-07-06 16:13:38.097858076 +0300
@@ -13,6 +13,11 @@
 
 #include "sdk_util/macros.h"
 
+/* Needed for PATH_MAX */
+#ifndef PATH_MAX
+#define PATH_MAX 4096
+#endif
+
 EXTERN_C_BEGIN
 
 #if defined(__native_client__)
diff -Naur chromium-67.0.3396.87/printing/backend/print_backend_cups.cc chromium-67.0.3396.87-patched/printing/backend/print_backend_cups.cc
--- chromium-67.0.3396.87/printing/backend/print_backend_cups.cc	2018-06-13 01:10:23.000000000 +0300
+++ chromium-67.0.3396.87-patched/printing/backend/print_backend_cups.cc	2018-07-06 16:13:42.401191354 +0300
@@ -18,6 +18,7 @@
 #include "base/synchronization/lock.h"
 #include "base/values.h"
 #include "printing/backend/cups_helper.h"
+#include <cups/ppd.h>
 #include "printing/backend/print_backend_consts.h"
 #include "url/gurl.h"
 
diff -Naur chromium-67.0.3396.87/printing/backend/print_backend_cups.cc.orig chromium-67.0.3396.87-patched/printing/backend/print_backend_cups.cc.orig
--- chromium-67.0.3396.87/printing/backend/print_backend_cups.cc.orig	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/printing/backend/print_backend_cups.cc.orig	2018-06-13 01:10:23.000000000 +0300
@@ -0,0 +1,286 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "printing/backend/print_backend_cups.h"
+
+#include <cups/ppd.h>
+#include <dlfcn.h>
+#include <errno.h>
+#include <pthread.h>
+
+#include <string>
+
+#include "base/files/file_util.h"
+#include "base/lazy_instance.h"
+#include "base/logging.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/synchronization/lock.h"
+#include "base/values.h"
+#include "printing/backend/cups_helper.h"
+#include "printing/backend/print_backend_consts.h"
+#include "url/gurl.h"
+
+namespace printing {
+
+namespace {
+
+const char kCUPSPrinterInfoOpt[] = "printer-info";
+const char kCUPSPrinterStateOpt[] = "printer-state";
+const char kCUPSPrinterTypeOpt[] = "printer-type";
+
+bool PrinterBasicInfoFromCUPS(const cups_dest_t& printer,
+                              PrinterBasicInfo* printer_info) {
+  // CUPS can have 'printers' that are actually scanners. (not MFC)
+  // At least on Mac. Check for scanners and skip them.
+  const char* type_str =
+      cupsGetOption(kCUPSPrinterTypeOpt, printer.num_options, printer.options);
+  if (type_str) {
+    int type;
+    if (base::StringToInt(type_str, &type) && (type & CUPS_PRINTER_SCANNER))
+      return false;
+  }
+
+  printer_info->printer_name = printer.name;
+  printer_info->is_default = printer.is_default;
+
+  const char* info =
+      cupsGetOption(kCUPSPrinterInfoOpt, printer.num_options, printer.options);
+  if (info)
+    printer_info->printer_description = info;
+
+  const char* state =
+      cupsGetOption(kCUPSPrinterStateOpt, printer.num_options, printer.options);
+  if (state)
+    base::StringToInt(state, &printer_info->printer_status);
+
+  const char* drv_info = cupsGetOption(kDriverNameTagName,
+                                       printer.num_options, printer.options);
+  if (drv_info)
+    printer_info->options[kDriverInfoTagName] = *drv_info;
+
+  // Store printer options.
+  for (int opt_index = 0; opt_index < printer.num_options; ++opt_index) {
+    printer_info->options[printer.options[opt_index].name] =
+        printer.options[opt_index].value;
+  }
+  return true;
+}
+
+}  // namespace
+
+PrintBackendCUPS::PrintBackendCUPS(const GURL& print_server_url,
+                                   http_encryption_t encryption,
+                                   bool blocking)
+    : print_server_url_(print_server_url),
+      cups_encryption_(encryption),
+      blocking_(blocking) {
+}
+
+bool PrintBackendCUPS::EnumeratePrinters(PrinterList* printer_list) {
+  DCHECK(printer_list);
+  printer_list->clear();
+
+  cups_dest_t* destinations = nullptr;
+  int num_dests = GetDests(&destinations);
+  if (!num_dests && cupsLastError() > IPP_OK_EVENTS_COMPLETE) {
+    VLOG(1) << "CUPS: Error getting printers from CUPS server"
+            << ", server: " << print_server_url_
+            << ", error: " << static_cast<int>(cupsLastError());
+    return false;
+  }
+
+  for (int printer_index = 0; printer_index < num_dests; ++printer_index) {
+    const cups_dest_t& printer = destinations[printer_index];
+
+    PrinterBasicInfo printer_info;
+    if (PrinterBasicInfoFromCUPS(printer, &printer_info))
+      printer_list->push_back(printer_info);
+  }
+
+  cupsFreeDests(num_dests, destinations);
+
+  VLOG(1) << "CUPS: Enumerated printers, server: " << print_server_url_
+          << ", # of printers: " << printer_list->size();
+  return true;
+}
+
+std::string PrintBackendCUPS::GetDefaultPrinterName() {
+  // Not using cupsGetDefault() because it lies about the default printer.
+  cups_dest_t* dests;
+  int num_dests = GetDests(&dests);
+  cups_dest_t* dest = cupsGetDest(nullptr, nullptr, num_dests, dests);
+  std::string name = dest ? std::string(dest->name) : std::string();
+  cupsFreeDests(num_dests, dests);
+  return name;
+}
+
+bool PrintBackendCUPS::GetPrinterBasicInfo(const std::string& printer_name,
+                                           PrinterBasicInfo* printer_info) {
+  cups_dest_t* dest = GetNamedDest(printer_name);
+  if (!dest)
+    return false;
+
+  DCHECK_EQ(printer_name, dest->name);
+  bool ret = PrinterBasicInfoFromCUPS(*dest, printer_info);
+  cupsFreeDests(1, dest);
+  return ret;
+}
+
+bool PrintBackendCUPS::GetPrinterSemanticCapsAndDefaults(
+    const std::string& printer_name,
+    PrinterSemanticCapsAndDefaults* printer_info) {
+  PrinterCapsAndDefaults info;
+  if (!GetPrinterCapsAndDefaults(printer_name, &info) )
+    return false;
+
+  return ParsePpdCapabilities(
+      printer_name, info.printer_capabilities, printer_info);
+}
+
+bool PrintBackendCUPS::GetPrinterCapsAndDefaults(
+    const std::string& printer_name,
+    PrinterCapsAndDefaults* printer_info) {
+  DCHECK(printer_info);
+
+  VLOG(1) << "CUPS: Getting caps and defaults, printer name: " << printer_name;
+
+  base::FilePath ppd_path(GetPPD(printer_name.c_str()));
+  // In some cases CUPS failed to get ppd file.
+  if (ppd_path.empty()) {
+    LOG(ERROR) << "CUPS: Failed to get PPD, printer name: " << printer_name;
+    return false;
+  }
+
+  std::string content;
+  bool res = base::ReadFileToString(ppd_path, &content);
+
+  base::DeleteFile(ppd_path, false);
+
+  if (res) {
+    printer_info->printer_capabilities.swap(content);
+    printer_info->caps_mime_type = "application/pagemaker";
+    // In CUPS, printer defaults is a part of PPD file. Nothing to upload here.
+    printer_info->printer_defaults.clear();
+    printer_info->defaults_mime_type.clear();
+  }
+
+  return res;
+}
+
+std::string PrintBackendCUPS::GetPrinterDriverInfo(
+    const std::string& printer_name) {
+  std::string result;
+
+  cups_dest_t* dest = GetNamedDest(printer_name);
+  if (!dest)
+    return result;
+
+  DCHECK_EQ(printer_name, dest->name);
+  const char* info =
+      cupsGetOption(kDriverNameTagName, dest->num_options, dest->options);
+  if (info)
+    result = *info;
+  cupsFreeDests(1, dest);
+  return result;
+}
+
+bool PrintBackendCUPS::IsValidPrinter(const std::string& printer_name) {
+  cups_dest_t* dest = GetNamedDest(printer_name);
+  if (!dest)
+    return false;
+
+  cupsFreeDests(1, dest);
+  return true;
+}
+
+#if !defined(OS_CHROMEOS)
+scoped_refptr<PrintBackend> PrintBackend::CreateInstanceImpl(
+    const base::DictionaryValue* print_backend_settings) {
+  std::string print_server_url_str, cups_blocking;
+  int encryption = HTTP_ENCRYPT_NEVER;
+  if (print_backend_settings) {
+    print_backend_settings->GetString(kCUPSPrintServerURL,
+                                      &print_server_url_str);
+
+    print_backend_settings->GetString(kCUPSBlocking,
+                                      &cups_blocking);
+
+    print_backend_settings->GetInteger(kCUPSEncryption, &encryption);
+  }
+  GURL print_server_url(print_server_url_str);
+  return new PrintBackendCUPS(print_server_url,
+                              static_cast<http_encryption_t>(encryption),
+                              cups_blocking == kValueTrue);
+}
+#endif  // !defined(OS_CHROMEOS)
+
+int PrintBackendCUPS::GetDests(cups_dest_t** dests) {
+  if (print_server_url_.is_empty())  // Use default (local) print server.
+    return cupsGetDests(dests);
+
+  HttpConnectionCUPS http(print_server_url_, cups_encryption_);
+  http.SetBlocking(blocking_);
+  return cupsGetDests2(http.http(), dests);
+}
+
+base::FilePath PrintBackendCUPS::GetPPD(const char* name) {
+  // cupsGetPPD returns a filename stored in a static buffer in CUPS.
+  // Protect this code with lock.
+  CR_DEFINE_STATIC_LOCAL(base::Lock, ppd_lock, ());
+  base::AutoLock ppd_autolock(ppd_lock);
+  base::FilePath ppd_path;
+  const char* ppd_file_path = nullptr;
+  if (print_server_url_.is_empty()) {  // Use default (local) print server.
+    ppd_file_path = cupsGetPPD(name);
+    if (ppd_file_path)
+      ppd_path = base::FilePath(ppd_file_path);
+  } else {
+    // cupsGetPPD2 gets stuck sometimes in an infinite time due to network
+    // configuration/issues. To prevent that, use non-blocking http connection
+    // here.
+    // Note: After looking at CUPS sources, it looks like non-blocking
+    // connection will timeout after 10 seconds of no data period. And it will
+    // return the same way as if data was completely and successfully
+    // downloaded.
+    HttpConnectionCUPS http(print_server_url_, cups_encryption_);
+    http.SetBlocking(blocking_);
+    ppd_file_path = cupsGetPPD2(http.http(), name);
+    // Check if the get full PPD, since non-blocking call may simply return
+    // normally after timeout expired.
+    if (ppd_file_path) {
+      // There is no reliable way right now to detect full and complete PPD
+      // get downloaded. If we reach http timeout, it may simply return
+      // downloaded part as a full response. It might be good enough to check
+      // http->data_remaining or http->_data_remaining, unfortunately http_t
+      // is an internal structure and fields are not exposed in CUPS headers.
+      // httpGetLength or httpGetLength2 returning the full content size.
+      // Comparing file size against that content length might be unreliable
+      // since some http reponses are encoded and content_length > file size.
+      // Let's just check for the obvious CUPS and http errors here.
+      ppd_path = base::FilePath(ppd_file_path);
+      ipp_status_t error_code = cupsLastError();
+      int http_error = httpError(http.http());
+      if (error_code > IPP_OK_EVENTS_COMPLETE || http_error != 0) {
+        LOG(ERROR) << "Error downloading PPD file, name: " << name
+                   << ", CUPS error: " << static_cast<int>(error_code)
+                   << ", HTTP error: " << http_error;
+        base::DeleteFile(ppd_path, false);
+        ppd_path.clear();
+      }
+    }
+  }
+  return ppd_path;
+}
+
+cups_dest_t* PrintBackendCUPS::GetNamedDest(const std::string& printer_name) {
+  // Use default (local) print server.
+  if (print_server_url_.is_empty())
+    return cupsGetNamedDest(CUPS_HTTP_DEFAULT, printer_name.c_str(), nullptr);
+
+  HttpConnectionCUPS http(print_server_url_, cups_encryption_);
+  http.SetBlocking(blocking_);
+  return cupsGetNamedDest(http.http(), printer_name.c_str(), nullptr);
+}
+
+}  // namespace printing
diff -Naur chromium-67.0.3396.87/printing/BUILD.gn chromium-67.0.3396.87-patched/printing/BUILD.gn
--- chromium-67.0.3396.87/printing/BUILD.gn	2018-06-13 01:10:23.000000000 +0300
+++ chromium-67.0.3396.87-patched/printing/BUILD.gn	2018-07-06 16:13:42.401191354 +0300
@@ -150,12 +150,13 @@
                                  ],
                                  "trim string")
 
-      if (cups_version == "1.6" || cups_version == "1.7") {
+      if (cups_version == "1.6" || cups_version == "1.7" || cups_version == "2.2") {
         cflags += [
           # CUPS 1.6 deprecated the PPD APIs, but we will stay with this
           # API for now as supported Linux and Mac OS'es are still using
           # older versions of CUPS. More info: crbug.com/226176
           "-Wno-deprecated-declarations",
+          "-D_PPD_DEPRECATED=",
           # CUPS 1.7 deprecates httpConnectEncrypt(), see the mac section
           # below.
         ]
diff -Naur chromium-67.0.3396.87/printing/BUILD.gn.orig chromium-67.0.3396.87-patched/printing/BUILD.gn.orig
--- chromium-67.0.3396.87/printing/BUILD.gn.orig	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/printing/BUILD.gn.orig	2018-06-13 01:10:23.000000000 +0300
@@ -0,0 +1,351 @@
+# Copyright 2014 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/features.gni")
+import("//build/config/sysroot.gni")
+import("//build/config/ui.gni")
+import("//pdf/features.gni")
+import("//printing/buildflags/buildflags.gni")
+import("//testing/test.gni")
+if (is_mac) {
+  import("//build/config/mac/mac_sdk.gni")
+}
+if (is_android) {
+  import("//build/config/android/rules.gni")
+}
+
+if ((enable_basic_printing && is_win) || enable_print_preview) {
+  # Windows basic printing or print preview requires pdf enabled.
+  assert(enable_pdf,
+         "Windows basic printing or print preview needs pdf: " +
+             "set enable_pdf=true.")
+}
+
+component("printing") {
+  sources = [
+    "backend/print_backend.cc",
+    "backend/print_backend.h",
+    "backend/print_backend_consts.cc",
+    "backend/print_backend_consts.h",
+    "backend/print_backend_dummy.cc",
+    "backend/printing_info_win.cc",
+    "backend/printing_info_win.h",
+    "emf_win.cc",
+    "emf_win.h",
+    "metafile.cc",
+    "metafile.h",
+    "metafile_skia_wrapper.cc",
+    "metafile_skia_wrapper.h",
+    "native_drawing_context.h",
+    "page_number.cc",
+    "page_number.h",
+    "page_range.cc",
+    "page_range.h",
+    "page_setup.cc",
+    "page_setup.h",
+    "page_size_margins.h",
+    "pdf_metafile_cg_mac.cc",
+    "pdf_metafile_cg_mac.h",
+    "pdf_metafile_skia.cc",
+    "pdf_metafile_skia.h",
+    "pdf_render_settings.h",
+    "print_dialog_gtk_interface.h",
+    "print_job_constants.cc",
+    "print_job_constants.h",
+    "print_settings.cc",
+    "print_settings.h",
+    "print_settings_conversion.cc",
+    "print_settings_conversion.h",
+    "print_settings_initializer_mac.cc",
+    "print_settings_initializer_mac.h",
+    "print_settings_initializer_win.cc",
+    "print_settings_initializer_win.h",
+    "printed_document.cc",
+    "printed_document.h",
+    "printed_document_mac.cc",
+    "printed_document_win.cc",
+    "printing_context.cc",
+    "printing_context.h",
+    "printing_export.h",
+    "printing_utils.cc",
+    "printing_utils.h",
+    "pwg_raster_settings.h",
+    "units.cc",
+    "units.h",
+  ]
+
+  cflags = []
+  defines = [ "PRINTING_IMPLEMENTATION" ]
+
+  public_deps = [
+    "//printing/buildflags",
+  ]
+  deps = [
+    "//base",
+    "//base:i18n",
+    "//base/third_party/dynamic_annotations",
+    "//cc/paint",
+    "//printing/common",
+    "//skia",
+    "//third_party/icu",
+    "//ui/gfx",
+    "//ui/gfx/geometry",
+    "//url",
+  ]
+
+  if (use_aura) {
+    deps += [ "//ui/aura" ]
+  }
+
+  if (is_mac) {
+    # Mac-Aura does not support printing.
+    if (use_aura) {
+      sources -= [ "printed_document_mac.cc" ]
+    } else {
+      sources += [
+        "printing_context_mac.h",
+        "printing_context_mac.mm",
+      ]
+    }
+    libs = [
+      "AppKit.framework",
+      "ApplicationServices.framework",
+      "CoreFoundation.framework",
+      "CoreGraphics.framework",
+    ]
+  }
+
+  if (is_win) {
+    # PRINT_BACKEND_AVAILABLE disables the default dummy implementation of the
+    # print backend and enables a custom implementation instead.
+    defines += [ "PRINT_BACKEND_AVAILABLE" ]
+    sources += [
+      "backend/print_backend_win.cc",
+      "backend/win_helper.cc",
+      "backend/win_helper.h",
+      "printed_page_win.cc",
+      "printed_page_win.h",
+      "printing_context_system_dialog_win.cc",
+      "printing_context_system_dialog_win.h",
+      "printing_context_win.cc",
+      "printing_context_win.h",
+    ]
+  }
+
+  if (use_cups) {
+    configs += [ ":cups" ]
+
+    if (is_linux) {
+      # rebase_path does not accept an empty string
+      if (use_sysroot) {
+        cups_sysroot = rebase_path(sysroot)
+      } else {
+        cups_sysroot = ""
+      }
+      cups_version = exec_script("cups_config_helper.py",
+                                 [
+                                   "--api-version",
+                                   cups_sysroot,
+                                 ],
+                                 "trim string")
+
+      if (cups_version == "1.6" || cups_version == "1.7") {
+        cflags += [
+          # CUPS 1.6 deprecated the PPD APIs, but we will stay with this
+          # API for now as supported Linux and Mac OS'es are still using
+          # older versions of CUPS. More info: crbug.com/226176
+          "-Wno-deprecated-declarations",
+          # CUPS 1.7 deprecates httpConnectEncrypt(), see the mac section
+          # below.
+        ]
+      }
+    }
+
+    if (is_mac) {
+      # The 10.9 SDK includes cups 1.7, which deprecates
+      # httpConnectEncrypt() in favor of httpConnect2(). hhttpConnect2()
+      # is new in 1.7, so it doesn't exist on OS X 10.6-10.8 and we
+      # can't use it until 10.9 is our minimum system version.
+      # (cups_version isn't reliable on OS X, so key the check off of
+      # mac_sdk).
+      # With a 10.8 deployment target, several other APIs are deprecated.
+      # We're still on CUPS 1.4 until Linux no longer needs to support it, see
+      # comment above.
+      cflags += [ "-Wno-deprecated-declarations" ]
+    }
+
+    # PRINT_BACKEND_AVAILABLE disables the default dummy implementation
+    # of the print backend and enables a custom implementation instead.
+    defines += [ "PRINT_BACKEND_AVAILABLE" ]
+
+    if (is_chromeos) {
+      sources += [
+        "backend/cups_connection.cc",
+        "backend/cups_connection.h",
+        "backend/cups_deleters.cc",
+        "backend/cups_deleters.h",
+        "backend/cups_ipp_util.cc",
+        "backend/cups_ipp_util.h",
+        "backend/cups_jobs.cc",
+        "backend/cups_jobs.h",
+        "backend/cups_printer.cc",
+        "backend/cups_printer.h",
+        "backend/print_backend_cups_ipp.cc",
+        "backend/print_backend_cups_ipp.h",
+        "printing_context_chromeos.cc",
+        "printing_context_chromeos.h",
+      ]
+    } else {
+      sources += [
+        "backend/cups_helper.cc",
+        "backend/cups_helper.h",
+        "backend/print_backend_cups.cc",
+        "backend/print_backend_cups.h",
+      ]
+    }
+  }
+
+  if (is_chromeos) {
+    defines += [ "PRINT_BACKEND_AVAILABLE" ]
+
+    sources += [
+      "backend/print_backend_chromeos.cc",
+      "printed_document_chromeos.cc",
+      "printing_context_no_system_dialog.cc",
+      "printing_context_no_system_dialog.h",
+    ]
+  } else if (is_android) {
+    sources += [
+      "printing_context_android.cc",
+      "printing_context_android.h",
+    ]
+
+    deps += [ ":printing_jni_headers" ]
+  } else if (is_linux) {  # Desktop Linux.
+    sources += [
+      "printed_document_linux.cc",
+      "printing_context_linux.cc",
+      "printing_context_linux.h",
+    ]
+  }
+}
+
+static_library("test_support") {
+  testonly = true
+  sources = [
+    "backend/test_print_backend.cc",
+    "backend/test_print_backend.h",
+    "image.cc",
+    "image.h",
+    "image_android.cc",
+    "image_linux.cc",
+    "image_mac.cc",
+    "image_win.cc",
+  ]
+  if (is_fuchsia) {
+    sources += [ "image_fuchsia.cc" ]
+  }
+
+  public_deps = [
+    "//printing",
+    "//ui/gfx/geometry",
+  ]
+  deps = [
+    "//base",
+    "//skia",
+    "//ui/gfx",
+  ]
+}
+
+test("printing_unittests") {
+  sources = [
+    "emf_win_unittest.cc",
+    "page_number_unittest.cc",
+    "page_range_unittest.cc",
+    "page_setup_unittest.cc",
+    "pdf_metafile_cg_mac_unittest.cc",
+    "printing_context_win_unittest.cc",
+    "printing_test.h",
+    "printing_utils_unittest.cc",
+    "units_unittest.cc",
+  ]
+
+  deps = [
+    ":printing",
+    "//base/test:run_all_unittests",
+    "//base/test:test_support",
+    "//testing/gtest",
+    "//ui/base",
+    "//ui/gfx",
+    "//ui/gfx:test_support",
+    "//ui/gfx/geometry",
+  ]
+
+  if (is_win || is_mac) {
+    sources += [ "printed_document_unittest.cc" ]
+  }
+
+  if (is_win) {
+    sources += [ "printed_page_win_unittest.cc" ]
+  }
+
+  if (use_cups) {
+    configs += [ ":cups" ]
+
+    if (is_chromeos) {
+      sources += [ "backend/cups_ipp_util_unittest.cc" ]
+    } else {
+      sources += [ "backend/cups_helper_unittest.cc" ]
+    }
+  }
+}
+
+if (use_cups) {
+  config("cups") {
+    defines = [ "USE_CUPS" ]
+
+    if (is_mac) {
+      libs = [ "cups" ]
+      lib_dirs = [ "$mac_sdk_path/usr/lib" ]
+    } else {
+      # rebase_path does not accept an empty string
+      if (use_sysroot) {
+        cups_sysroot = rebase_path(sysroot)
+      } else {
+        cups_sysroot = ""
+      }
+      libs = exec_script("cups_config_helper.py",
+                         [
+                           "--libs-for-gn",
+                           cups_sysroot,
+                         ],
+                         "value")
+    }
+  }
+}
+
+if (is_android) {
+  generate_jni("printing_jni_headers") {
+    sources = [
+      "android/java/src/org/chromium/printing/PrintingContext.java",
+    ]
+    jni_package = "printing"
+  }
+
+  android_library("printing_java") {
+    deps = [
+      "//base:base_java",
+    ]
+    java_files = [
+      "android/java/src/org/chromium/printing/PrintDocumentAdapterWrapper.java",
+      "android/java/src/org/chromium/printing/PrintManagerDelegate.java",
+      "android/java/src/org/chromium/printing/PrintManagerDelegateImpl.java",
+      "android/java/src/org/chromium/printing/Printable.java",
+      "android/java/src/org/chromium/printing/PrintingContext.java",
+      "android/java/src/org/chromium/printing/PrintingContextInterface.java",
+      "android/java/src/org/chromium/printing/PrintingController.java",
+      "android/java/src/org/chromium/printing/PrintingControllerImpl.java",
+    ]
+  }
+}
diff -Naur chromium-67.0.3396.87/sandbox/linux/BUILD.gn chromium-67.0.3396.87-patched/sandbox/linux/BUILD.gn
--- chromium-67.0.3396.87/sandbox/linux/BUILD.gn	2018-06-13 01:10:23.000000000 +0300
+++ chromium-67.0.3396.87-patched/sandbox/linux/BUILD.gn	2018-07-06 16:13:42.401191354 +0300
@@ -315,11 +315,17 @@
       # For ULLONG_MAX
       "-std=gnu99",
 
+      "-fPIE",
+
       # These files have a suspicious comparison.
       # TODO fix this and re-enable this warning.
       "-Wno-sign-compare",
     ]
 
+    ldflags = [
+      "-pie",
+    ]
+
     import("//build/config/compiler/compiler.gni")
     import("//build/config/sanitizers/sanitizers.gni")
     if (is_component_build || using_sanitizer) {
@@ -329,7 +335,7 @@
       # other flags that executable_config might have.
       configs -= [ "//build/config:executable_config" ]
       if (!use_gold) {
-        ldflags = [ "-Wl,--disable-new-dtags" ]
+        ldflags += [ "-Wl,--disable-new-dtags" ]
       }
     }
 
diff -Naur chromium-67.0.3396.87/sandbox/linux/BUILD.gn.orig chromium-67.0.3396.87-patched/sandbox/linux/BUILD.gn.orig
--- chromium-67.0.3396.87/sandbox/linux/BUILD.gn.orig	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/sandbox/linux/BUILD.gn.orig	2018-06-13 01:10:23.000000000 +0300
@@ -0,0 +1,485 @@
+# Copyright 2014 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/features.gni")
+import("//build/config/nacl/config.gni")
+import("//sandbox/features.gni")
+import("//testing/test.gni")
+
+if (is_android) {
+  import("//build/config/android/rules.gni")
+}
+
+declare_args() {
+  compile_suid_client = is_linux
+
+  compile_credentials = is_linux
+
+  # On Android, use plain GTest.
+  use_base_test_suite = is_linux
+}
+
+if (is_nacl_nonsfi) {
+  config("nacl_nonsfi_warnings") {
+    # There are number of platform specific functions in
+    # seccomp-bpf syscall helpers, which are not being used.
+    cflags = [ "-Wno-unused-function" ]
+  }
+}
+
+# We have two principal targets: sandbox and sandbox_linux_unittests
+# All other targets are listed as dependencies.
+# There is one notable exception: for historical reasons, chrome_sandbox is
+# the setuid sandbox and is its own target.
+
+group("sandbox") {
+  public_deps = [
+    ":sandbox_services",
+  ]
+  if (compile_suid_client || is_nacl_nonsfi) {
+    public_deps += [ ":suid_sandbox_client" ]
+  }
+  if (use_seccomp_bpf || is_nacl_nonsfi) {
+    public_deps += [ ":seccomp_bpf" ]
+  }
+  if (is_android) {
+    public_deps += [ ":seccomp_starter_android" ]
+  }
+}
+
+source_set("sandbox_linux_test_utils") {
+  testonly = true
+  sources = [
+    "tests/sandbox_test_runner.cc",
+    "tests/sandbox_test_runner.h",
+    "tests/sandbox_test_runner_function_pointer.cc",
+    "tests/sandbox_test_runner_function_pointer.h",
+    "tests/unit_tests.cc",
+    "tests/unit_tests.h",
+  ]
+
+  deps = [
+    "//testing/gtest",
+  ]
+
+  if (!is_nacl_nonsfi) {
+    sources += [
+      "tests/test_utils.cc",
+      "tests/test_utils.h",
+    ]
+  }
+
+  if (use_seccomp_bpf || is_nacl_nonsfi) {
+    sources += [
+      "seccomp-bpf/bpf_tester_compatibility_delegate.h",
+      "seccomp-bpf/bpf_tests.h",
+      "seccomp-bpf/sandbox_bpf_test_runner.cc",
+      "seccomp-bpf/sandbox_bpf_test_runner.h",
+    ]
+    deps += [ ":seccomp_bpf" ]
+  }
+
+  if (use_base_test_suite) {
+    deps += [ "//base/test:test_support" ]
+    defines = [ "SANDBOX_USES_BASE_TEST_SUITE" ]
+  }
+}
+
+# Sources for sandbox_linux_unittests.
+source_set("sandbox_linux_unittests_sources") {
+  testonly = true
+
+  sources = [
+    "services/proc_util_unittest.cc",
+    "services/resource_limits_unittests.cc",
+    "services/scoped_process_unittest.cc",
+    "services/syscall_wrappers_unittest.cc",
+    "services/thread_helpers_unittests.cc",
+    "services/yama_unittests.cc",
+    "syscall_broker/broker_file_permission_unittest.cc",
+    "syscall_broker/broker_process_unittest.cc",
+    "tests/main.cc",
+    "tests/scoped_temporary_file.cc",
+    "tests/scoped_temporary_file.h",
+    "tests/scoped_temporary_file_unittest.cc",
+    "tests/test_utils_unittest.cc",
+    "tests/unit_tests_unittest.cc",
+  ]
+
+  deps = [
+    ":sandbox",
+    ":sandbox_linux_test_utils",
+    "//base",
+    "//base/third_party/dynamic_annotations",
+    "//testing/gtest",
+  ]
+
+  if (use_base_test_suite) {
+    deps += [ "//base/test:test_support" ]
+    defines = [ "SANDBOX_USES_BASE_TEST_SUITE" ]
+  }
+
+  if (compile_suid_client) {
+    sources += [
+      "suid/client/setuid_sandbox_client_unittest.cc",
+      "suid/client/setuid_sandbox_host_unittest.cc",
+    ]
+  }
+  if (use_seccomp_bpf) {
+    sources += [
+      "bpf_dsl/bpf_dsl_unittest.cc",
+      "bpf_dsl/codegen_unittest.cc",
+      "bpf_dsl/cons_unittest.cc",
+      "bpf_dsl/dump_bpf.cc",
+      "bpf_dsl/dump_bpf.h",
+      "bpf_dsl/syscall_set_unittest.cc",
+      "bpf_dsl/test_trap_registry.cc",
+      "bpf_dsl/test_trap_registry.h",
+      "bpf_dsl/test_trap_registry_unittest.cc",
+      "bpf_dsl/verifier.cc",
+      "bpf_dsl/verifier.h",
+      "integration_tests/bpf_dsl_seccomp_unittest.cc",
+      "integration_tests/seccomp_broker_process_unittest.cc",
+      "seccomp-bpf-helpers/baseline_policy_unittest.cc",
+      "seccomp-bpf-helpers/syscall_parameters_restrictions_unittests.cc",
+      "seccomp-bpf/bpf_tests_unittest.cc",
+      "seccomp-bpf/sandbox_bpf_unittest.cc",
+      "seccomp-bpf/syscall_unittest.cc",
+      "seccomp-bpf/trap_unittest.cc",
+    ]
+    deps += [ ":bpf_dsl_golden" ]
+
+    if (is_android) {
+      sources += [ "seccomp-bpf-helpers/baseline_policy_android_unittest.cc" ]
+    }
+  }
+  if (compile_credentials) {
+    sources += [
+      "integration_tests/namespace_unix_domain_socket_unittest.cc",
+      "services/credentials_unittest.cc",
+      "services/namespace_utils_unittest.cc",
+    ]
+
+    if (use_base_test_suite) {
+      # Tests that use advanced features not available in stock GTest.
+      sources += [ "services/namespace_sandbox_unittest.cc" ]
+    }
+
+    # For credentials_unittest.cc
+    configs += [ "//build/config/linux:libcap" ]
+  }
+}
+
+action("bpf_dsl_golden") {
+  script = "bpf_dsl/golden/generate.py"
+  inputs = [
+    "bpf_dsl/golden/i386/ArgSizePolicy.txt",
+    "bpf_dsl/golden/i386/BasicPolicy.txt",
+    "bpf_dsl/golden/i386/ElseIfPolicy.txt",
+    "bpf_dsl/golden/i386/MaskingPolicy.txt",
+    "bpf_dsl/golden/i386/MoreBooleanLogicPolicy.txt",
+    "bpf_dsl/golden/i386/NegativeConstantsPolicy.txt",
+    "bpf_dsl/golden/i386/SwitchPolicy.txt",
+    "bpf_dsl/golden/x86-64/ArgSizePolicy.txt",
+    "bpf_dsl/golden/x86-64/BasicPolicy.txt",
+    "bpf_dsl/golden/x86-64/BooleanLogicPolicy.txt",
+    "bpf_dsl/golden/x86-64/ElseIfPolicy.txt",
+    "bpf_dsl/golden/x86-64/MaskingPolicy.txt",
+    "bpf_dsl/golden/x86-64/MoreBooleanLogicPolicy.txt",
+    "bpf_dsl/golden/x86-64/NegativeConstantsPolicy.txt",
+    "bpf_dsl/golden/x86-64/SwitchPolicy.txt",
+  ]
+  outputs = [
+    "$target_gen_dir/bpf_dsl/golden/golden_files.h",
+  ]
+  args =
+      rebase_path(outputs, root_build_dir) + rebase_path(inputs, root_build_dir)
+}
+
+test("sandbox_linux_unittests") {
+  deps = [
+    ":sandbox_linux_unittests_sources",
+    "//build/config:exe_and_shlib_deps",
+  ]
+  if (is_android) {
+    use_raw_android_executable = true
+  }
+}
+
+component("seccomp_bpf") {
+  sources = [
+    "bpf_dsl/bpf_dsl.cc",
+    "bpf_dsl/bpf_dsl.h",
+    "bpf_dsl/bpf_dsl_forward.h",
+    "bpf_dsl/bpf_dsl_impl.h",
+    "bpf_dsl/codegen.cc",
+    "bpf_dsl/codegen.h",
+    "bpf_dsl/cons.h",
+    "bpf_dsl/errorcode.h",
+    "bpf_dsl/linux_syscall_ranges.h",
+    "bpf_dsl/policy.cc",
+    "bpf_dsl/policy.h",
+    "bpf_dsl/policy_compiler.cc",
+    "bpf_dsl/policy_compiler.h",
+    "bpf_dsl/seccomp_macros.h",
+    "bpf_dsl/syscall_set.cc",
+    "bpf_dsl/syscall_set.h",
+    "bpf_dsl/trap_registry.h",
+    "seccomp-bpf-helpers/baseline_policy.cc",
+    "seccomp-bpf-helpers/baseline_policy.h",
+    "seccomp-bpf-helpers/baseline_policy_android.cc",
+    "seccomp-bpf-helpers/baseline_policy_android.h",
+    "seccomp-bpf-helpers/sigsys_handlers.cc",
+    "seccomp-bpf-helpers/sigsys_handlers.h",
+    "seccomp-bpf-helpers/syscall_parameters_restrictions.cc",
+    "seccomp-bpf-helpers/syscall_parameters_restrictions.h",
+    "seccomp-bpf-helpers/syscall_sets.cc",
+    "seccomp-bpf-helpers/syscall_sets.h",
+    "seccomp-bpf/die.cc",
+    "seccomp-bpf/die.h",
+    "seccomp-bpf/sandbox_bpf.cc",
+    "seccomp-bpf/sandbox_bpf.h",
+    "seccomp-bpf/syscall.cc",
+    "seccomp-bpf/syscall.h",
+    "seccomp-bpf/trap.cc",
+    "seccomp-bpf/trap.h",
+  ]
+  defines = [ "SANDBOX_IMPLEMENTATION" ]
+
+  public_deps = [
+    ":sandbox_services_headers",
+    "//sandbox:sandbox_export",
+  ]
+  deps = [
+    ":sandbox_services",
+    "//base",
+    "//base/third_party/dynamic_annotations",
+  ]
+
+  if (is_nacl_nonsfi) {
+    cflags = [ "-fgnu-inline-asm" ]
+    sources -= [
+      "bpf_dsl/bpf_dsl_forward.h",
+      "bpf_dsl/bpf_dsl_impl.h",
+      "bpf_dsl/cons.h",
+      "bpf_dsl/errorcode.h",
+      "bpf_dsl/linux_syscall_ranges.h",
+      "bpf_dsl/seccomp_macros.h",
+      "bpf_dsl/trap_registry.h",
+      "seccomp-bpf-helpers/baseline_policy.cc",
+      "seccomp-bpf-helpers/baseline_policy.h",
+      "seccomp-bpf-helpers/syscall_sets.cc",
+      "seccomp-bpf-helpers/syscall_sets.h",
+    ]
+    configs += [ ":nacl_nonsfi_warnings" ]
+  }
+}
+
+if (is_android) {
+  # This target is available even if use_seccomp_bpf is disabled, but it also
+  # works when it is enabled.
+  component("seccomp_starter_android") {
+    sources = [
+      "seccomp-bpf-helpers/seccomp_starter_android.cc",
+      "seccomp-bpf-helpers/seccomp_starter_android.h",
+    ]
+
+    defines = [ "SANDBOX_IMPLEMENTATION" ]
+
+    deps = [
+      "//base",
+      "//sandbox:sandbox_buildflags",
+    ]
+
+    if (use_seccomp_bpf) {
+      deps += [ ":seccomp_bpf" ]
+    }
+
+    visibility = [ ":*" ]
+  }
+}
+
+if (is_linux) {
+  # The setuid sandbox for Linux.
+  executable("chrome_sandbox") {
+    sources = [
+      "suid/common/sandbox.h",
+      "suid/common/suid_unsafe_environment_variables.h",
+      "suid/process_util.h",
+      "suid/process_util_linux.c",
+      "suid/sandbox.c",
+    ]
+
+    cflags = [
+      # For ULLONG_MAX
+      "-std=gnu99",
+
+      # These files have a suspicious comparison.
+      # TODO fix this and re-enable this warning.
+      "-Wno-sign-compare",
+    ]
+
+    import("//build/config/compiler/compiler.gni")
+    import("//build/config/sanitizers/sanitizers.gni")
+    if (is_component_build || using_sanitizer) {
+      # WARNING! We remove this config so that we don't accidentally
+      # pick up the //build/config:rpath_for_built_shared_libraries
+      # sub-config. However, this means that we need to duplicate any
+      # other flags that executable_config might have.
+      configs -= [ "//build/config:executable_config" ]
+      if (!use_gold) {
+        ldflags = [ "-Wl,--disable-new-dtags" ]
+      }
+    }
+
+    # We also do not want to pick up any of the other sanitizer
+    # flags (i.e. we do not want to build w/ the sanitizers at all).
+    # This is safe to delete unconditionally, because it is part of the
+    # default configs and empty when not using the sanitizers.
+    configs -= [ "//build/config/sanitizers:default_sanitizer_flags" ]
+  }
+}
+
+component("sandbox_services") {
+  sources = [
+    "services/init_process_reaper.cc",
+    "services/init_process_reaper.h",
+    "services/proc_util.cc",
+    "services/proc_util.h",
+    "services/resource_limits.cc",
+    "services/resource_limits.h",
+    "services/scoped_process.cc",
+    "services/scoped_process.h",
+    "services/syscall_wrappers.cc",
+    "services/syscall_wrappers.h",
+    "services/thread_helpers.cc",
+    "services/thread_helpers.h",
+    "services/yama.cc",
+    "services/yama.h",
+    "syscall_broker/broker_channel.cc",
+    "syscall_broker/broker_channel.h",
+    "syscall_broker/broker_client.cc",
+    "syscall_broker/broker_client.h",
+    "syscall_broker/broker_command.cc",
+    "syscall_broker/broker_command.h",
+    "syscall_broker/broker_file_permission.cc",
+    "syscall_broker/broker_file_permission.h",
+    "syscall_broker/broker_host.cc",
+    "syscall_broker/broker_host.h",
+    "syscall_broker/broker_permission_list.cc",
+    "syscall_broker/broker_permission_list.h",
+    "syscall_broker/broker_process.cc",
+    "syscall_broker/broker_process.h",
+  ]
+
+  defines = [ "SANDBOX_IMPLEMENTATION" ]
+
+  public_deps = [
+    "//sandbox:sandbox_export",
+  ]
+  deps = [
+    "//base",
+    "//base/third_party/dynamic_annotations",
+  ]
+
+  if (compile_credentials || is_nacl_nonsfi) {
+    sources += [
+      "services/credentials.cc",
+      "services/credentials.h",
+      "services/namespace_sandbox.cc",
+      "services/namespace_sandbox.h",
+      "services/namespace_utils.cc",
+      "services/namespace_utils.h",
+    ]
+
+    public_deps += [ ":sandbox_services_headers" ]
+  }
+
+  if (is_nacl_nonsfi) {
+    cflags = [ "-fgnu-inline-asm" ]
+
+    sources -= [
+      "services/init_process_reaper.cc",
+      "services/init_process_reaper.h",
+      "services/scoped_process.cc",
+      "services/scoped_process.h",
+      "services/yama.cc",
+      "services/yama.h",
+      "syscall_broker/broker_channel.cc",
+      "syscall_broker/broker_channel.h",
+      "syscall_broker/broker_client.cc",
+      "syscall_broker/broker_client.h",
+      "syscall_broker/broker_command.cc",
+      "syscall_broker/broker_command.h",
+      "syscall_broker/broker_file_permission.cc",
+      "syscall_broker/broker_file_permission.h",
+      "syscall_broker/broker_host.cc",
+      "syscall_broker/broker_host.h",
+      "syscall_broker/broker_permission_list.cc",
+      "syscall_broker/broker_permission_list.h",
+      "syscall_broker/broker_process.cc",
+      "syscall_broker/broker_process.h",
+    ]
+  } else if (!is_android) {
+    sources += [
+      "services/libc_interceptor.cc",
+      "services/libc_interceptor.h",
+    ]
+  }
+}
+
+source_set("sandbox_services_headers") {
+  sources = [
+    "system_headers/arm64_linux_syscalls.h",
+    "system_headers/arm64_linux_ucontext.h",
+    "system_headers/arm_linux_syscalls.h",
+    "system_headers/arm_linux_ucontext.h",
+    "system_headers/i386_linux_ucontext.h",
+    "system_headers/linux_filter.h",
+    "system_headers/linux_futex.h",
+    "system_headers/linux_seccomp.h",
+    "system_headers/linux_signal.h",
+    "system_headers/linux_syscalls.h",
+    "system_headers/linux_time.h",
+    "system_headers/linux_ucontext.h",
+    "system_headers/mips64_linux_syscalls.h",
+    "system_headers/mips64_linux_ucontext.h",
+    "system_headers/mips_linux_syscalls.h",
+    "system_headers/mips_linux_ucontext.h",
+    "system_headers/x86_32_linux_syscalls.h",
+    "system_headers/x86_64_linux_syscalls.h",
+    "system_headers/x86_64_linux_ucontext.h",
+  ]
+}
+
+if (compile_suid_client || is_nacl_nonsfi) {
+  component("suid_sandbox_client") {
+    sources = [
+      "suid/client/setuid_sandbox_client.cc",
+      "suid/client/setuid_sandbox_client.h",
+      "suid/client/setuid_sandbox_host.cc",
+      "suid/client/setuid_sandbox_host.h",
+      "suid/common/sandbox.h",
+      "suid/common/suid_unsafe_environment_variables.h",
+    ]
+    defines = [ "SANDBOX_IMPLEMENTATION" ]
+    public_deps = [
+      "//sandbox:sandbox_export",
+    ]
+    deps = [
+      ":sandbox_services",
+      "//base",
+      "//base/third_party/dynamic_annotations",
+    ]
+
+    if (is_nacl_nonsfi) {
+      sources -= [
+        "suid/client/setuid_sandbox_host.cc",
+        "suid/client/setuid_sandbox_host.h",
+        "suid/common/sandbox.h",
+        "suid/common/suid_unsafe_environment_variables.h",
+      ]
+    }
+  }
+}
diff -Naur chromium-67.0.3396.87/services/viz/public/cpp/compositing/filter_operation_struct_traits.h.orig chromium-67.0.3396.87-patched/services/viz/public/cpp/compositing/filter_operation_struct_traits.h.orig
--- chromium-67.0.3396.87/services/viz/public/cpp/compositing/filter_operation_struct_traits.h.orig	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/services/viz/public/cpp/compositing/filter_operation_struct_traits.h.orig	2018-07-06 16:13:45.477857981 +0300
@@ -0,0 +1,238 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_VIZ_PUBLIC_CPP_COMPOSITING_FILTER_OPERATION_STRUCT_TRAITS_H_
+#define SERVICES_VIZ_PUBLIC_CPP_COMPOSITING_FILTER_OPERATION_STRUCT_TRAITS_H_
+
+#include "base/containers/span.h"
+#include "base/memory/aligned_memory.h"
+#include "base/optional.h"
+#include "cc/paint/filter_operation.h"
+#include "cc/paint/paint_filter.h"
+#include "services/viz/public/cpp/compositing/paint_filter_struct_traits.h"
+#include "services/viz/public/interfaces/compositing/filter_operation.mojom-shared.h"
+#include "skia/public/interfaces/blur_image_filter_tile_mode_struct_traits.h"
+#include "ui/gfx/geometry/mojo/geometry_struct_traits.h"
+
+namespace mojo {
+
+namespace {
+viz::mojom::FilterType CCFilterTypeToMojo(
+    const cc::FilterOperation::FilterType& type) {
+  switch (type) {
+    case cc::FilterOperation::GRAYSCALE:
+      return viz::mojom::FilterType::GRAYSCALE;
+    case cc::FilterOperation::SEPIA:
+      return viz::mojom::FilterType::SEPIA;
+    case cc::FilterOperation::SATURATE:
+      return viz::mojom::FilterType::SATURATE;
+    case cc::FilterOperation::HUE_ROTATE:
+      return viz::mojom::FilterType::HUE_ROTATE;
+    case cc::FilterOperation::INVERT:
+      return viz::mojom::FilterType::INVERT;
+    case cc::FilterOperation::BRIGHTNESS:
+      return viz::mojom::FilterType::BRIGHTNESS;
+    case cc::FilterOperation::CONTRAST:
+      return viz::mojom::FilterType::CONTRAST;
+    case cc::FilterOperation::OPACITY:
+      return viz::mojom::FilterType::OPACITY;
+    case cc::FilterOperation::BLUR:
+      return viz::mojom::FilterType::BLUR;
+    case cc::FilterOperation::DROP_SHADOW:
+      return viz::mojom::FilterType::DROP_SHADOW;
+    case cc::FilterOperation::COLOR_MATRIX:
+      return viz::mojom::FilterType::COLOR_MATRIX;
+    case cc::FilterOperation::ZOOM:
+      return viz::mojom::FilterType::ZOOM;
+    case cc::FilterOperation::REFERENCE:
+      return viz::mojom::FilterType::REFERENCE;
+    case cc::FilterOperation::SATURATING_BRIGHTNESS:
+      return viz::mojom::FilterType::SATURATING_BRIGHTNESS;
+    case cc::FilterOperation::ALPHA_THRESHOLD:
+      return viz::mojom::FilterType::ALPHA_THRESHOLD;
+  }
+  NOTREACHED();
+  return viz::mojom::FilterType::FILTER_TYPE_LAST;
+}
+
+cc::FilterOperation::FilterType MojoFilterTypeToCC(
+    const viz::mojom::FilterType& type) {
+  switch (type) {
+    case viz::mojom::FilterType::GRAYSCALE:
+      return cc::FilterOperation::GRAYSCALE;
+    case viz::mojom::FilterType::SEPIA:
+      return cc::FilterOperation::SEPIA;
+    case viz::mojom::FilterType::SATURATE:
+      return cc::FilterOperation::SATURATE;
+    case viz::mojom::FilterType::HUE_ROTATE:
+      return cc::FilterOperation::HUE_ROTATE;
+    case viz::mojom::FilterType::INVERT:
+      return cc::FilterOperation::INVERT;
+    case viz::mojom::FilterType::BRIGHTNESS:
+      return cc::FilterOperation::BRIGHTNESS;
+    case viz::mojom::FilterType::CONTRAST:
+      return cc::FilterOperation::CONTRAST;
+    case viz::mojom::FilterType::OPACITY:
+      return cc::FilterOperation::OPACITY;
+    case viz::mojom::FilterType::BLUR:
+      return cc::FilterOperation::BLUR;
+    case viz::mojom::FilterType::DROP_SHADOW:
+      return cc::FilterOperation::DROP_SHADOW;
+    case viz::mojom::FilterType::COLOR_MATRIX:
+      return cc::FilterOperation::COLOR_MATRIX;
+    case viz::mojom::FilterType::ZOOM:
+      return cc::FilterOperation::ZOOM;
+    case viz::mojom::FilterType::REFERENCE:
+      return cc::FilterOperation::REFERENCE;
+    case viz::mojom::FilterType::SATURATING_BRIGHTNESS:
+      return cc::FilterOperation::SATURATING_BRIGHTNESS;
+    case viz::mojom::FilterType::ALPHA_THRESHOLD:
+      return cc::FilterOperation::ALPHA_THRESHOLD;
+  }
+  NOTREACHED();
+  return cc::FilterOperation::FILTER_TYPE_LAST;
+}
+
+}  // namespace
+
+template <>
+struct StructTraits<viz::mojom::FilterOperationDataView, cc::FilterOperation> {
+  static viz::mojom::FilterType type(const cc::FilterOperation& op) {
+    return CCFilterTypeToMojo(op.type());
+  }
+
+  static float amount(const cc::FilterOperation& operation) {
+    if (operation.type() == cc::FilterOperation::COLOR_MATRIX ||
+        operation.type() == cc::FilterOperation::REFERENCE) {
+      return 0.f;
+    }
+    return operation.amount();
+  }
+
+  static float outer_threshold(const cc::FilterOperation& operation) {
+    if (operation.type() != cc::FilterOperation::ALPHA_THRESHOLD)
+      return 0.f;
+    return operation.outer_threshold();
+  }
+
+  static gfx::Point drop_shadow_offset(const cc::FilterOperation& operation) {
+    if (operation.type() != cc::FilterOperation::DROP_SHADOW)
+      return gfx::Point();
+    return operation.drop_shadow_offset();
+  }
+
+  static uint32_t drop_shadow_color(const cc::FilterOperation& operation) {
+    if (operation.type() != cc::FilterOperation::DROP_SHADOW)
+      return 0;
+    return operation.drop_shadow_color();
+  }
+
+  static sk_sp<cc::PaintFilter> image_filter(
+      const cc::FilterOperation& operation) {
+    if (operation.type() != cc::FilterOperation::REFERENCE)
+      return nullptr;
+    if (!operation.image_filter())
+      return nullptr;
+    return operation.image_filter();
+  }
+
+  static base::Optional<base::span<const float>> matrix(
+      const cc::FilterOperation& operation) {
+    if (operation.type() != cc::FilterOperation::COLOR_MATRIX)
+      return base::nullopt;
+    return base::make_span(operation.matrix());
+  }
+
+  static base::span<const gfx::Rect> shape(
+      const cc::FilterOperation& operation) {
+    if (operation.type() != cc::FilterOperation::ALPHA_THRESHOLD)
+      return base::span<gfx::Rect>();
+    return operation.shape();
+  }
+
+  static int32_t zoom_inset(const cc::FilterOperation& operation) {
+    if (operation.type() != cc::FilterOperation::ZOOM)
+      return 0;
+    return operation.zoom_inset();
+  }
+
+  static skia::mojom::BlurTileMode blur_tile_mode(
+      const cc::FilterOperation& operation) {
+    if (operation.type() != cc::FilterOperation::BLUR)
+      return skia::mojom::BlurTileMode::CLAMP_TO_BLACK;
+    return EnumTraits<skia::mojom::BlurTileMode, SkBlurImageFilter::TileMode>::
+        ToMojom(operation.blur_tile_mode());
+  }
+
+  static bool Read(viz::mojom::FilterOperationDataView data,
+                   cc::FilterOperation* out) {
+    out->set_type(MojoFilterTypeToCC(data.type()));
+    switch (out->type()) {
+      case cc::FilterOperation::GRAYSCALE:
+      case cc::FilterOperation::SEPIA:
+      case cc::FilterOperation::SATURATE:
+      case cc::FilterOperation::HUE_ROTATE:
+      case cc::FilterOperation::INVERT:
+      case cc::FilterOperation::BRIGHTNESS:
+      case cc::FilterOperation::SATURATING_BRIGHTNESS:
+      case cc::FilterOperation::CONTRAST:
+      case cc::FilterOperation::OPACITY:
+        out->set_amount(data.amount());
+        return true;
+      case cc::FilterOperation::BLUR:
+        out->set_amount(data.amount());
+        SkBlurImageFilter::TileMode tile_mode;
+        if (!data.ReadBlurTileMode(&tile_mode))
+          return false;
+        out->set_blur_tile_mode(tile_mode);
+        return true;
+      case cc::FilterOperation::DROP_SHADOW: {
+        out->set_amount(data.amount());
+        gfx::Point offset;
+        if (!data.ReadDropShadowOffset(&offset))
+          return false;
+        out->set_drop_shadow_offset(offset);
+        out->set_drop_shadow_color(data.drop_shadow_color());
+        return true;
+      }
+      case cc::FilterOperation::COLOR_MATRIX: {
+        // TODO(fsamuel): It would be nice to modify cc::FilterOperation to
+        // avoid this extra copy.
+        cc::FilterOperation::Matrix matrix_buffer = {};
+        base::span<float> matrix(matrix_buffer);
+        if (!data.ReadMatrix(&matrix))
+          return false;
+        out->set_matrix(matrix_buffer);
+        return true;
+      }
+      case cc::FilterOperation::ZOOM: {
+        if (data.amount() < 0.f || data.zoom_inset() < 0)
+          return false;
+        out->set_amount(data.amount());
+        out->set_zoom_inset(data.zoom_inset());
+        return true;
+      }
+      case cc::FilterOperation::REFERENCE: {
+        sk_sp<cc::PaintFilter> filter;
+        if (!data.ReadImageFilter(&filter))
+          return false;
+        out->set_image_filter(std::move(filter));
+        return true;
+      }
+      case cc::FilterOperation::ALPHA_THRESHOLD:
+        out->set_amount(data.amount());
+        out->set_outer_threshold(data.outer_threshold());
+        cc::FilterOperation::ShapeRects shape;
+        if (!data.ReadShape(&shape))
+          return false;
+        out->set_shape(shape);
+        return true;
+    }
+    return false;
+  }
+};
+
+}  // namespace mojo
+
+#endif  // SERVICES_VIZ_PUBLIC_CPP_COMPOSITING_FILTER_OPERATION_STRUCT_TRAITS_H_
diff -Naur chromium-67.0.3396.87/services/viz/public/cpp/compositing/filter_operation_struct_traits.h.rej chromium-67.0.3396.87-patched/services/viz/public/cpp/compositing/filter_operation_struct_traits.h.rej
--- chromium-67.0.3396.87/services/viz/public/cpp/compositing/filter_operation_struct_traits.h.rej	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/services/viz/public/cpp/compositing/filter_operation_struct_traits.h.rej	2018-07-06 16:13:45.477857981 +0300
@@ -0,0 +1,11 @@
+--- services/viz/public/cpp/compositing/filter_operation_struct_traits.h.gcc5-r3	2018-03-06 18:04:37.000000000 -0500
++++ services/viz/public/cpp/compositing/filter_operation_struct_traits.h	2018-03-07 10:42:07.198179638 -0500
+@@ -138,7 +138,7 @@ struct StructTraits<viz::mojom::FilterOp
+   static base::span<const float> matrix(const cc::FilterOperation& operation) {
+     if (operation.type() != cc::FilterOperation::COLOR_MATRIX)
+       return base::span<const float>();
+-    return operation.matrix();
++    return base::make_span(operation.matrix());
+   }
+ 
+   static base::span<const gfx::Rect> shape(
diff -Naur chromium-67.0.3396.87/services/viz/public/cpp/compositing/quads_struct_traits.h chromium-67.0.3396.87-patched/services/viz/public/cpp/compositing/quads_struct_traits.h
--- chromium-67.0.3396.87/services/viz/public/cpp/compositing/quads_struct_traits.h	2018-06-13 01:10:24.000000000 +0300
+++ chromium-67.0.3396.87-patched/services/viz/public/cpp/compositing/quads_struct_traits.h	2018-07-06 16:13:45.477857981 +0300
@@ -308,7 +308,7 @@
   static base::span<const float> vertex_opacity(const viz::DrawQuad& input) {
     const viz::TextureDrawQuad* quad =
         viz::TextureDrawQuad::MaterialCast(&input);
-    return quad->vertex_opacity;
+    return base::make_span(quad->vertex_opacity);
   }
 
   static bool y_flipped(const viz::DrawQuad& input) {
diff -Naur chromium-67.0.3396.87/third_party/boringssl/BUILD.gn chromium-67.0.3396.87-patched/third_party/boringssl/BUILD.gn
--- chromium-67.0.3396.87/third_party/boringssl/BUILD.gn	2018-06-13 01:11:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/boringssl/BUILD.gn	2018-07-06 16:13:38.101191408 +0300
@@ -26,6 +26,7 @@
     "BORINGSSL_IMPLEMENTATION",
     "BORINGSSL_NO_STATIC_INITIALIZER",
     "OPENSSL_SMALL",
+    "_POSIX_C_SOURCE=200112L",
   ]
   configs = [
     # TODO(davidben): Fix size_t truncations in BoringSSL.
diff -Naur chromium-67.0.3396.87/third_party/boringssl/BUILD.gn.orig chromium-67.0.3396.87-patched/third_party/boringssl/BUILD.gn.orig
--- chromium-67.0.3396.87/third_party/boringssl/BUILD.gn.orig	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/boringssl/BUILD.gn.orig	2018-06-13 01:11:00.000000000 +0300
@@ -0,0 +1,294 @@
+# Copyright 2014 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/android/config.gni")
+import("//build/config/arm.gni")
+import("//build/config/sanitizers/sanitizers.gni")
+import("//build_overrides/build.gni")
+import("//testing/libfuzzer/fuzzer_test.gni")
+import("BUILD.generated.gni")
+import("BUILD.generated_tests.gni")
+
+# Config for us and everybody else depending on BoringSSL.
+config("external_config") {
+  include_dirs = [ "src/include" ]
+  if (is_component_build) {
+    defines = [ "BORINGSSL_SHARED_LIBRARY" ]
+  }
+}
+
+# Config internal to this build file, shared by boringssl and boringssl_fuzzer.
+config("internal_config") {
+  visibility = [ ":*" ]  # Only targets in this file can depend on this.
+  defines = [
+    "BORINGSSL_ALLOW_CXX_RUNTIME",
+    "BORINGSSL_IMPLEMENTATION",
+    "BORINGSSL_NO_STATIC_INITIALIZER",
+    "OPENSSL_SMALL",
+  ]
+  configs = [
+    # TODO(davidben): Fix size_t truncations in BoringSSL.
+    # https://crbug.com/boringssl/22
+    "//build/config/compiler:no_size_t_to_int_warning",
+    "//build/config/sanitizers:cfi_icall_generalize_pointers",
+  ]
+  if (is_posix || is_fuchsia) {
+    cflags_c = [ "-std=c99" ]
+    defines += [ "_XOPEN_SOURCE=700" ]
+  }
+}
+
+config("no_asm_config") {
+  visibility = [ ":*" ]  # Only targets in this file can depend on this.
+  defines = [ "OPENSSL_NO_ASM" ]
+}
+
+all_sources = crypto_sources + ssl_sources
+
+# Windows' assembly is built with Yasm. The other platforms use the platform
+# assembler.
+if (is_win && !is_msan) {
+  import("//third_party/yasm/yasm_assemble.gni")
+  yasm_assemble("boringssl_asm") {
+    if (current_cpu == "x64") {
+      sources = crypto_sources_win_x86_64
+    } else if (current_cpu == "x86") {
+      sources = crypto_sources_win_x86
+    }
+  }
+} else {
+  # This has no sources on some platforms so must be a source_set.
+  source_set("boringssl_asm") {
+    visibility = [ ":*" ]  # Only targets in this file can depend on this.
+
+    sources = []
+    asmflags = []
+    include_dirs = [ "src/include" ]
+
+    if (is_msan) {
+      public_configs = [ ":no_asm_config" ]
+    } else if (current_cpu == "x64") {
+      if (is_mac) {
+        sources += crypto_sources_mac_x86_64
+      } else if (is_linux || is_android) {
+        sources += crypto_sources_linux_x86_64
+      } else {
+        public_configs = [ ":no_asm_config" ]
+      }
+    } else if (current_cpu == "x86") {
+      if (is_mac) {
+        sources += crypto_sources_mac_x86
+      } else if (is_linux || is_android) {
+        sources += crypto_sources_linux_x86
+      } else {
+        public_configs = [ ":no_asm_config" ]
+      }
+    } else if (current_cpu == "arm") {
+      if (is_linux || is_android) {
+        sources += crypto_sources_linux_arm
+      } else if (is_ios) {
+        sources += crypto_sources_ios_arm
+      } else {
+        public_configs = [ ":no_asm_config" ]
+      }
+    } else if (current_cpu == "arm64") {
+      if (is_linux || is_android) {
+        sources += crypto_sources_linux_aarch64
+      } else if (is_ios) {
+        sources += crypto_sources_ios_aarch64
+      } else {
+        public_configs = [ ":no_asm_config" ]
+      }
+    } else {
+      public_configs = [ ":no_asm_config" ]
+    }
+  }
+}
+
+component("boringssl") {
+  sources = all_sources
+  deps = [
+    ":boringssl_asm",
+    "//third_party/boringssl/src/third_party/fiat:fiat_license",
+  ]
+
+  public_configs = [ ":external_config" ]
+  configs += [ ":internal_config" ]
+
+  configs -= [ "//build/config/compiler:chromium_code" ]
+  configs += [ "//build/config/compiler:no_chromium_code" ]
+
+  if (is_nacl) {
+    deps += [ "//native_client_sdk/src/libraries/nacl_io" ]
+  }
+}
+
+# These targets are named "_tests" rather than "_test" to avoid colliding with a
+# historical "boringssl_ssl_test" target. This works around a bug with the iOS
+# build rules.
+
+test("boringssl_crypto_tests") {
+  sources = crypto_test_sources + test_support_sources
+  deps = [
+    ":boringssl",
+    "//testing/gtest",
+  ]
+
+  configs -= [ "//build/config/compiler:chromium_code" ]
+  configs += [
+    ":internal_config",
+    "//build/config/compiler:no_chromium_code",
+  ]
+
+  # Chromium infrastructure does not support GTest, only the //base wrapper.
+  if (build_with_chromium) {
+    sources -= [
+      "src/crypto/test/gtest_main.cc",
+
+      # //base includes its own conflicting malloc shim.
+      "src/crypto/test/malloc.cc",
+    ]
+    sources += [ "gtest_main_chromium.cc" ]
+    deps += [ "//base/test:test_support" ]
+  }
+}
+
+test("boringssl_ssl_tests") {
+  sources = ssl_test_sources + test_support_sources
+  deps = [
+    ":boringssl",
+    "//testing/gtest",
+  ]
+
+  configs -= [ "//build/config/compiler:chromium_code" ]
+  configs += [
+    ":internal_config",
+    "//build/config/compiler:no_chromium_code",
+  ]
+
+  # Chromium infrastructure does not support GTest, only the //base wrapper.
+  if (build_with_chromium) {
+    sources -= [
+      "src/crypto/test/gtest_main.cc",
+
+      # //base includes its own conflicting malloc shim.
+      "src/crypto/test/malloc.cc",
+    ]
+    sources += [ "gtest_main_chromium.cc" ]
+    deps += [ "//base/test:test_support" ]
+  }
+}
+
+if (build_with_chromium) {
+  config("fuzzer_config") {
+    visibility = [ ":*" ]  # Only targets in this file can depend on this.
+    defines = [
+      "BORINGSSL_UNSAFE_FUZZER_MODE",
+      "BORINGSSL_UNSAFE_DETERMINISTIC_MODE",
+    ]
+  }
+
+  # The same as boringssl, but builds with BORINGSSL_UNSAFE_FUZZER_MODE.
+  component("boringssl_fuzzer") {
+    visibility = [ ":*" ]  # Only targets in this file can depend on this.
+
+    sources = all_sources
+    deps = [
+      ":boringssl_asm",
+    ]
+
+    public_configs = [
+      ":external_config",
+      ":fuzzer_config",
+    ]
+    configs += [ ":internal_config" ]
+
+    configs -= [ "//build/config/compiler:chromium_code" ]
+    configs += [ "//build/config/compiler:no_chromium_code" ]
+
+    if (is_nacl) {
+      deps += [ "//native_client_sdk/src/libraries/nacl_io" ]
+    }
+  }
+
+  foreach(fuzzer, fuzzers) {
+    fuzzer_test("boringssl_${fuzzer}_fuzzer") {
+      sources = [
+        "src/fuzz/${fuzzer}.cc",
+      ]
+      deps = [
+        ":boringssl_fuzzer",
+      ]
+      seed_corpus = "src/fuzz/${fuzzer}_corpus"
+
+      if ("cert" == fuzzer) {
+        libfuzzer_options = [ "max_len=3072" ]
+      } else if ("client" == fuzzer) {
+        libfuzzer_options = [ "max_len=20000" ]
+      } else if ("pkcs8" == fuzzer) {
+        libfuzzer_options = [ "max_len=2048" ]
+      } else if ("privkey" == fuzzer) {
+        libfuzzer_options = [ "max_len=2048" ]
+      } else if ("read_pem" == fuzzer) {
+        libfuzzer_options = [ "max_len=512" ]
+      } else if ("session" == fuzzer) {
+        libfuzzer_options = [ "max_len=8192" ]
+      } else if ("server" == fuzzer) {
+        libfuzzer_options = [ "max_len=4096" ]
+      } else if ("spki" == fuzzer) {
+        libfuzzer_options = [ "max_len=1024" ]
+      } else if ("ssl_ctx_api" == fuzzer) {
+        libfuzzer_options = [ "max_len=256" ]
+      }
+    }
+  }
+
+  config("fuzzer_no_fuzzer_mode_config") {
+    visibility = [ ":*" ]  # Only targets in this file can depend on this.
+    defines = [ "BORINGSSL_UNSAFE_DETERMINISTIC_MODE" ]
+  }
+
+  # The same as boringssl, but builds with BORINGSSL_UNSAFE_DETERMINISTIC_MODE.
+  component("boringssl_fuzzer_no_fuzzer_mode") {
+    visibility = [ ":*" ]  # Only targets in this file can depend on this.
+
+    sources = all_sources
+    deps = [
+      ":boringssl_asm",
+    ]
+
+    public_configs = [
+      ":external_config",
+      ":fuzzer_no_fuzzer_mode_config",
+    ]
+    configs += [ ":internal_config" ]
+
+    configs -= [ "//build/config/compiler:chromium_code" ]
+    configs += [ "//build/config/compiler:no_chromium_code" ]
+
+    if (is_nacl) {
+      deps += [ "//native_client_sdk/src/libraries/nacl_io" ]
+    }
+  }
+
+  fuzzer_test("boringssl_client_no_fuzzer_mode_fuzzer") {
+    sources = [
+      "src/fuzz/client.cc",
+    ]
+    deps = [
+      ":boringssl_fuzzer_no_fuzzer_mode",
+    ]
+    seed_corpus = "src/fuzz/client_corpus_no_fuzzer_mode"
+  }
+
+  fuzzer_test("boringssl_server_no_fuzzer_mode_fuzzer") {
+    sources = [
+      "src/fuzz/server.cc",
+    ]
+    deps = [
+      ":boringssl_fuzzer_no_fuzzer_mode",
+    ]
+    seed_corpus = "src/fuzz/server_corpus_no_fuzzer_mode"
+  }
+}
diff -Naur chromium-67.0.3396.87/third_party/boringssl/src/crypto/x509/by_dir.c chromium-67.0.3396.87-patched/third_party/boringssl/src/crypto/x509/by_dir.c
--- chromium-67.0.3396.87/third_party/boringssl/src/crypto/x509/by_dir.c	2018-06-13 01:12:04.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/boringssl/src/crypto/x509/by_dir.c	2018-07-06 16:13:44.011191336 +0300
@@ -56,6 +56,7 @@
  * [including the GNU Public Licence.] */
 
 #include <string.h>
+#include <time.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 
diff -Naur chromium-67.0.3396.87/third_party/BUILD.gn chromium-67.0.3396.87-patched/third_party/BUILD.gn
--- chromium-67.0.3396.87/third_party/BUILD.gn	2018-06-13 01:10:24.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/BUILD.gn	2018-07-06 16:13:44.014524669 +0300
@@ -11,6 +11,7 @@
 config("system_libjpeg_config") {
   libs = [ "jpeg" ]
   defines = [ "USE_SYSTEM_LIBJPEG" ]
+  include_dirs = [ "/usr/include/" ]
 }
 
 config("libjpeg_turbo_config") {
diff -Naur chromium-67.0.3396.87/third_party/BUILD.gn.orig chromium-67.0.3396.87-patched/third_party/BUILD.gn.orig
--- chromium-67.0.3396.87/third_party/BUILD.gn.orig	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/BUILD.gn.orig	2018-06-13 01:10:24.000000000 +0300
@@ -0,0 +1,68 @@
+# Copyright 2014 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/freetype/freetype.gni")
+import("//third_party/harfbuzz-ng/harfbuzz.gni")
+import("//third_party/libjpeg.gni")
+
+assert(!is_ios, "This is not used on iOS, don't drag it in unintentionally")
+
+config("system_libjpeg_config") {
+  libs = [ "jpeg" ]
+  defines = [ "USE_SYSTEM_LIBJPEG" ]
+}
+
+config("libjpeg_turbo_config") {
+  defines = [ "USE_LIBJPEG_TURBO=1" ]
+}
+
+# This is a meta target that forwards to the system's libjpeg,
+# third_party/libjpeg, or third_party/libjpeg_turbo depending on the build args
+# declared in this file.
+group("jpeg") {
+  if (use_system_libjpeg) {
+    public_configs = [ ":system_libjpeg_config" ]
+  } else if (use_libjpeg_turbo) {
+    public_deps = [
+      "//third_party/libjpeg_turbo:libjpeg",
+    ]
+    public_configs = [ ":libjpeg_turbo_config" ]
+  } else {
+    public_deps = [
+      "//third_party/libjpeg:libjpeg",
+    ]
+  }
+}
+
+# This is a meta target that forwards include paths only to the system's
+# libjpeg, third_party/libjpeg, or third_party/libjpeg_turbo depending on the
+# build args declared in this file. This is needed, rarely, for targets that
+# need to reference libjpeg without explicitly building it.
+group("jpeg_includes") {
+  if (use_system_libjpeg) {
+    public_configs = [ ":system_libjpeg_config" ]
+  } else if (use_libjpeg_turbo) {
+    public_configs = [ "//third_party/libjpeg_turbo:libjpeg_config" ]
+  } else {
+    public_configs = [ "//third_party/libjpeg:libjpeg_config" ]
+  }
+}
+
+# FreeType and HarfBuzz libraries are dependent on each other. This component
+# will depend on the appropriate source sets or export the system packages
+# for both FreeType and HarfBuzz.
+component("freetype_harfbuzz") {
+  public_configs = []
+  public_deps = []
+  if (use_system_freetype) {
+    public_configs += [ "//build/linux:freetype_from_pkgconfig" ]
+  } else {
+    public_deps += [ "//third_party/freetype:freetype_source" ]
+  }
+  if (use_system_harfbuzz) {
+    public_configs += [ "//third_party/harfbuzz-ng:harfbuzz_from_pkgconfig" ]
+  } else {
+    public_deps += [ "//third_party/harfbuzz-ng:harfbuzz_source" ]
+  }
+}
diff -Naur chromium-67.0.3396.87/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py chromium-67.0.3396.87-patched/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py
--- chromium-67.0.3396.87/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py	2018-06-13 01:12:05.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py	2018-07-06 16:13:56.031191196 +0300
@@ -640,18 +640,8 @@
   if 'win' not in target_os:
     configure_flags['Common'].extend([
         '--enable-pic',
-        '--cc=clang',
-        '--cxx=clang++',
-        '--ld=clang',
     ])
 
-    # Clang Linux will use the first 'ld' it finds on the path, which will
-    # typically be the system one, so explicitly configure use of Clang's
-    # ld.lld, to ensure that things like cross-compilation and LTO work.
-    # This does not work for arm64, ia32 and is always used on mac.
-    if target_arch not in ['arm64', 'ia32', 'mipsel'] and target_os != 'mac':
-      configure_flags['Common'].append('--extra-ldflags=-fuse-ld=lld')
-
   # Should be run on Mac.
   if target_os == 'mac':
     if host_os != 'mac':
diff -Naur chromium-67.0.3396.87/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py.orig chromium-67.0.3396.87-patched/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py.orig
--- chromium-67.0.3396.87/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py.orig	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py.orig	2018-06-13 01:12:05.000000000 +0300
@@ -0,0 +1,769 @@
+#!/usr/bin/env python
+#
+# Copyright 2014 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+from __future__ import print_function
+
+import collections
+import functools
+import multiprocessing
+import optparse
+import os
+import platform
+import re
+import shutil
+import signal
+import subprocess
+import sys
+
+SCRIPTS_DIR = os.path.abspath(os.path.dirname(__file__))
+FFMPEG_DIR = os.path.abspath(os.path.join(SCRIPTS_DIR, '..', '..'))
+CHROMIUM_ROOT_DIR = os.path.abspath(os.path.join(FFMPEG_DIR, '..', '..'))
+NDK_ROOT_DIR = os.path.abspath(
+    os.path.join(CHROMIUM_ROOT_DIR, 'third_party', 'android_ndk'))
+
+BRANDINGS = [
+    'Chrome',
+    'ChromeOS',
+    'Chromium',
+]
+
+ARCH_MAP = {
+    'android': ['ia32', 'x64', 'mipsel', 'mips64el', 'arm-neon', 'arm64'],
+    'linux': ['ia32', 'x64', 'mipsel', 'mips64el', 'noasm-x64', 'arm', 'arm-neon', 'arm64'],
+    'mac': ['x64'],
+    'win': ['ia32', 'x64'],
+}
+
+USAGE_BEGIN = """Usage: %prog TARGET_OS TARGET_ARCH [options] -- [configure_args]"""
+USAGE_END = """
+Valid combinations are android     [%(android)s]
+                       linux       [%(linux)s]
+                       mac         [%(mac)s]
+                       win         [%(win)s]
+
+If no target architecture is specified all will be built.
+
+Platform specific build notes:
+  android:
+    Script can be run on a normal x64 Ubuntu box with an Android-ready Chromium
+    checkout: https://chromium.googlesource.com/chromium/src/+/master/docs/android_build_instructions.md
+
+  linux ia32/x64:
+    Script can run on a normal Ubuntu box.
+
+  linux arm/arm-neon/arm64/mipsel/mips64el:
+    Script can run on a normal Ubuntu with ARM/ARM64 or MIPS32/MIPS64 ready Chromium checkout:
+      build/linux/sysroot_scripts/install-sysroot.py --arch=arm
+      build/linux/sysroot_scripts/install-sysroot.py --arch=arm64
+      build/linux/sysroot_scripts/install-sysroot.py --arch=mips
+      build/linux/sysroot_scripts/install-sysroot.py --arch=mips64el
+
+  mac:
+    Script must be run on OSX.  Additionally, ensure the Chromium (not Apple)
+    version of clang is in the path; usually found under
+    src/third_party/llvm-build/Release+Asserts/bin
+
+  win:
+    Script must be run on Windows with VS2015 or higher under Cygwin (or MinGW,
+    but as of 1.0.11, it has serious performance issues with make which makes
+    building take hours).
+
+    Additionally, ensure you have the correct toolchain environment for building.
+    The x86 toolchain environment is required for ia32 builds and the x64 one
+    for x64 builds.  This can be verified by running "cl.exe" and checking if
+    the version string ends with "for x64" or "for x86."
+
+    Building on Windows also requires some additional Cygwin packages plus a
+    wrapper script for converting Cygwin paths to DOS paths.
+      - Add these packages at install time: diffutils, yasm, make, python.
+      - Copy chromium/scripts/cygwin-wrapper to /usr/local/bin
+
+Resulting binaries will be placed in:
+  build.TARGET_ARCH.TARGET_OS/Chrome/out/
+  build.TARGET_ARCH.TARGET_OS/ChromeOS/out/
+  build.TARGET_ARCH.TARGET_OS/Chromium/out/
+  """
+
+
+def PrintAndCheckCall(argv, *args, **kwargs):
+  print('Running %s' % '\n '.join(argv))
+  subprocess.check_call(argv, *args, **kwargs)
+
+
+def DetermineHostOsAndArch():
+  if platform.system() == 'Linux':
+    host_os = 'linux'
+  elif platform.system() == 'Darwin':
+    host_os = 'mac'
+  elif platform.system() == 'Windows' or 'CYGWIN_NT' in platform.system():
+    host_os = 'win'
+  else:
+    return None
+
+  if re.match(r'i.86', platform.machine()):
+    host_arch = 'ia32'
+  elif platform.machine() == 'x86_64' or platform.machine() == 'AMD64':
+    host_arch = 'x64'
+  elif platform.machine() == 'aarch64':
+    host_arch = 'arm64'
+  elif platform.machine() == 'mips32':
+    host_arch = 'mipsel'
+  elif platform.machine() == 'mips64':
+    host_arch = 'mips64el'
+  elif platform.machine().startswith('arm'):
+    host_arch = 'arm'
+  else:
+    return None
+
+  return (host_os, host_arch)
+
+
+def GetDsoName(target_os, dso_name, dso_version):
+  if target_os in ('linux', 'linux-noasm', 'android'):
+    return 'lib%s.so.%s' % (dso_name, dso_version)
+  elif target_os == 'mac':
+    return 'lib%s.%s.dylib' % (dso_name, dso_version)
+  elif target_os == 'win':
+    return '%s-%s.dll' % (dso_name, dso_version)
+  else:
+    raise ValueError('Unexpected target_os %s' % target_os)
+
+
+def RewriteFile(path, search, replace):
+  with open(path) as f:
+    contents = f.read()
+  with open(path, 'w') as f:
+    f.write(re.sub(search, replace, contents))
+
+
+# Extracts the Android toolchain version and api level from the Android
+# config.gni.  Returns (api level, api 64 level, toolchain version).
+def GetAndroidApiLevelAndToolchainVersion():
+  android_config_gni = os.path.join(CHROMIUM_ROOT_DIR, 'build', 'config',
+                                    'android', 'config.gni')
+  with open(android_config_gni, 'r') as f:
+    gni_contents = f.read()
+    api64_match = re.search('android64_ndk_api_level\s*=\s*(\d{2})',
+                            gni_contents)
+    api_match = re.search('android32_ndk_api_level\s*=\s*(\d{2})', gni_contents)
+    toolchain_match = re.search('_android_toolchain_version\s*=\s*"([.\d]+)"',
+                                gni_contents)
+    if not api_match or not toolchain_match or not api64_match:
+      raise Exception('Failed to find the android api level or toolchain '
+                      'version in ' + android_config_gni)
+
+    return (api_match.group(1), api64_match.group(1), toolchain_match.group(1))
+
+
+# Sets up cross-compilation (regardless of host arch) for compiling Android.
+# Returns the necessary configure flags as a list.
+def SetupAndroidToolchain(target_arch):
+  api_level, api64_level, toolchain_version = (
+      GetAndroidApiLevelAndToolchainVersion())
+
+  # Toolchain prefix misery, for when just one pattern is not enough :/
+  toolchain_level = api_level
+  sysroot_arch = target_arch
+  toolchain_dir_prefix = target_arch
+  toolchain_bin_prefix = target_arch
+  if target_arch == 'arm-neon' or target_arch == 'arm':
+    toolchain_bin_prefix = toolchain_dir_prefix = 'arm-linux-androideabi'
+    sysroot_arch = 'arm'
+  elif target_arch == 'arm64':
+    toolchain_level = api64_level
+    toolchain_bin_prefix = toolchain_dir_prefix = 'aarch64-linux-android'
+  elif target_arch == 'ia32':
+    toolchain_dir_prefix = sysroot_arch = 'x86'
+    toolchain_bin_prefix = 'i686-linux-android'
+  elif target_arch == 'x64':
+    toolchain_level = api64_level
+    toolchain_dir_prefix = sysroot_arch = 'x86_64'
+    toolchain_bin_prefix = 'x86_64-linux-android'
+  elif target_arch == 'mipsel':
+    sysroot_arch = 'mips'
+    toolchain_bin_prefix = toolchain_dir_prefix = 'mipsel-linux-android'
+  elif target_arch == 'mips64el':
+    toolchain_level = api64_level
+    sysroot_arch = 'mips64'
+    toolchain_bin_prefix = toolchain_dir_prefix = 'mips64el-linux-android'
+
+  sysroot = (
+      NDK_ROOT_DIR + '/platforms/android-' + toolchain_level + '/arch-' +
+      sysroot_arch)
+  gcc_toolchain = (
+      NDK_ROOT_DIR + '/toolchains/' + toolchain_dir_prefix + '-' +
+      toolchain_version + '/prebuilt/linux-x86_64/')
+
+  return [
+      '--enable-cross-compile',
+      '--sysroot=' + sysroot,
+
+      # Android sysroot includes are now split out; try to cobble together the
+      # correct tree.
+      '--extra-cflags=-I' + NDK_ROOT_DIR + '/sysroot/usr/include',
+      '--extra-cflags=-I' + NDK_ROOT_DIR + '/sysroot/usr/include/' +
+          toolchain_bin_prefix,
+
+      '--extra-cflags=--target=' + toolchain_bin_prefix,
+      '--extra-ldflags=--target=' + toolchain_bin_prefix,
+      '--extra-ldflags=--gcc-toolchain=' + gcc_toolchain,
+      '--target-os=android',
+  ]
+
+
+def BuildFFmpeg(target_os, target_arch, host_os, host_arch, parallel_jobs,
+                config_only, config, configure_flags):
+  config_dir = 'build.%s.%s/%s' % (target_arch, target_os, config)
+  shutil.rmtree(config_dir, ignore_errors=True)
+  os.makedirs(os.path.join(config_dir, 'out'))
+
+  PrintAndCheckCall(
+      [os.path.join(FFMPEG_DIR, 'configure')] + configure_flags, cwd=config_dir)
+
+  RewriteFile(
+      os.path.join(config_dir,
+                   'config.h'), r'(#define HAVE_VALGRIND_VALGRIND_H [01])',
+      (r'#define HAVE_VALGRIND_VALGRIND_H 0 /* \1 -- forced to 0. See https://crbug.com/590440 */'
+      ))
+
+  if target_os == 'android':
+    RewriteFile(
+        os.path.join(config_dir,
+                     'config.h'), r'(#define HAVE_POSIX_MEMALIGN [01])',
+        (r'#define HAVE_POSIX_MEMALIGN 0 /* \1 -- forced to 0. See https://crbug.com/604451 */'
+        ))
+
+  # Linux configs is also used on Fuchsia. They are mostly compatible with
+  # Fuchsia except that Fuchsia doesn't support sysctl(). On Linux sysctl()
+  # isn't actually used, so it's safe to set HAVE_SYSCTL to 0.
+  if target_os == 'linux':
+    RewriteFile(
+        os.path.join(config_dir, 'config.h'), r'(#define HAVE_SYSCTL [01])',
+        (r'#define HAVE_SYSCTL 0 /* \1 -- forced to 0 for Fuchsia */'))
+
+  # Windows linking resolves external symbols. Since generate_gn.py does not
+  # need a functioning set of libraries, ignore unresolved symbols here.
+  # This is especially useful here to avoid having to build a local libopus for
+  # windows. We munge the output of configure here to avoid this LDFLAGS setting
+  # triggering mis-detection during configure execution.
+  if target_os == 'win':
+    RewriteFile(
+        os.path.join(config_dir, 'ffbuild/config.mak'), r'(LDFLAGS=.*)',
+        (r'\1 -FORCE:UNRESOLVED'))
+
+  if target_os in (host_os, host_os + '-noasm', 'android') and not config_only:
+    libraries = [
+        os.path.join('libavcodec', GetDsoName(target_os, 'avcodec', 58)),
+        os.path.join('libavformat', GetDsoName(target_os, 'avformat', 58)),
+        os.path.join('libavutil', GetDsoName(target_os, 'avutil', 56)),
+    ]
+    PrintAndCheckCall(
+        ['make', '-j%d' % parallel_jobs] + libraries, cwd=config_dir)
+    for lib in libraries:
+      shutil.copy(
+          os.path.join(config_dir, lib), os.path.join(config_dir, 'out'))
+  elif config_only:
+    print('Skipping build step as requested.')
+  else:
+    print('Skipping compile as host configuration differs from target.\n'
+          'Please compare the generated config.h with the previous version.\n'
+          'You may also patch the script to properly cross-compile.\n'
+          'Host OS : %s\n'
+          'Target OS : %s\n'
+          'Host arch : %s\n'
+          'Target arch : %s\n' % (host_os, target_os, host_arch, target_arch))
+
+  # Sanitizers can't compile the h264 code when EBP is used.
+  if target_os != 'win' and target_arch == 'ia32':
+    RewriteFile(
+        os.path.join(config_dir, 'config.h'), r'(#define HAVE_EBP_AVAILABLE [01])',
+        (r'/* \1 -- ebp selection is done by the chrome build */'))
+
+  if target_arch in ('arm', 'arm-neon', 'arm64'):
+    RewriteFile(
+        os.path.join(config_dir, 'config.h'), r'(#define HAVE_VFP_ARGS [01])',
+        (r'/* \1 -- softfp/hardfp selection is done by the chrome build */'))
+  if target_os == 'win':
+    RewriteFile(
+        os.path.join(config_dir, 'config.h'), r'(#define HAVE_INLINE_ASM [01])',
+        (r'/* \1 -- inline asm selection is done by the chrome build */'))
+
+
+def main(argv):
+  clean_arch_map = {k: '|'.join(v) for k, v in ARCH_MAP.items()}
+  formatted_usage_end = USAGE_END % clean_arch_map
+  parser = optparse.OptionParser(usage=USAGE_BEGIN + formatted_usage_end)
+  parser.add_option(
+      '--branding',
+      action='append',
+      dest='brandings',
+      choices=BRANDINGS,
+      help='Branding to build; determines e.g. supported codecs')
+  parser.add_option(
+      '--config-only',
+      action='store_true',
+      help='Skip the build step. Useful when a given platform '
+      'is not necessary for generate_gn.py')
+  options, args = parser.parse_args(argv)
+
+  if len(args) < 1:
+    parser.print_help()
+    return 1
+
+  target_os = args[0]
+  target_arch = ''
+  if len(args) >= 2:
+    target_arch = args[1]
+  configure_args = args[2:]
+
+  if target_os not in ('android', 'linux', 'linux-noasm', 'mac', 'win'):
+    parser.print_help()
+    return 1
+
+  host_tuple = DetermineHostOsAndArch()
+  if not host_tuple:
+    print('Unrecognized host OS and architecture.', file=sys.stderr)
+    return 1
+
+  host_os, host_arch = host_tuple
+  parallel_jobs = multiprocessing.cpu_count()
+
+  if target_os == 'android' and host_os != 'linux' and host_arch != 'x64':
+    print('Android cross compilation can only be done from a linux x64 host.')
+    return 1
+
+  if target_arch:
+    print('System information:\n'
+          'Host OS       : %s\n'
+          'Target OS     : %s\n'
+          'Host arch     : %s\n'
+          'Target arch   : %s\n'
+          'Parallel jobs : %d\n' % (host_os, target_os, host_arch, target_arch,
+                                    parallel_jobs))
+    ConfigureAndBuild(target_arch, target_os, host_os, host_arch, parallel_jobs,
+                      configure_args, options=options)
+    return
+
+  pool_size = len(ARCH_MAP[target_os])
+  parallel_jobs = parallel_jobs / pool_size
+  print('System information:\n'
+        'Host OS       : %s\n'
+        'Target OS     : %s\n'
+        'Host arch     : %s\n'
+        'Target arch   : %s\n'
+        'Parallel jobs : %d\n' % (host_os, target_os, host_arch,
+                                  ARCH_MAP[target_os], parallel_jobs))
+
+  # Setup signal handles such that Ctrl+C works to terminate; will still result
+  # in triggering a bunch of Python2 bugs and log spam, but will exit versus
+  # hanging indefinitely.
+  original_sigint_handler = signal.signal(signal.SIGINT, signal.SIG_IGN)
+  p = multiprocessing.Pool(pool_size)
+  signal.signal(signal.SIGINT, original_sigint_handler)
+  try:
+    result = p.map_async(
+        functools.partial(
+            ConfigureAndBuild,
+            target_os=target_os,
+            host_os=host_os,
+            host_arch=host_arch,
+            parallel_jobs=parallel_jobs,
+            configure_args=configure_args,
+            options=options), ARCH_MAP[target_os])
+    # Timeout required or Ctrl+C is ignored; choose a ridiculous value so that
+    # it doesn't trigger accidentally.
+    result.get(1000)
+  except Exception as e:
+    p.terminate()
+
+
+def ConfigureAndBuild(target_arch, target_os, host_os, host_arch, parallel_jobs,
+                      configure_args, options):
+  if target_os == 'linux' and target_arch == 'noasm-x64':
+    target_os = 'linux-noasm'
+    target_arch = 'x64'
+
+  configure_flags = collections.defaultdict(list)
+
+  # Common configuration.  Note: --disable-everything does not in fact disable
+  # everything, just non-library components such as decoders and demuxers.
+  configure_flags['Common'].extend([
+      '--disable-everything',
+      '--disable-all',
+      '--disable-doc',
+      '--disable-htmlpages',
+      '--disable-manpages',
+      '--disable-podpages',
+      '--disable-txtpages',
+      '--disable-static',
+      '--enable-avcodec',
+      '--enable-avformat',
+      '--enable-avutil',
+      '--enable-fft',
+      '--enable-rdft',
+      '--enable-static',
+      '--enable-libopus',
+
+      # Disable features.
+      '--disable-bzlib',
+      '--disable-error-resilience',
+      '--disable-iconv',
+      '--disable-lzo',
+      '--disable-network',
+      '--disable-schannel',
+      '--disable-sdl2',
+      '--disable-symver',
+      '--disable-xlib',
+      '--disable-zlib',
+      '--disable-securetransport',
+      '--disable-faan',
+      '--disable-alsa',
+
+      # Disable automatically detected external libraries. This prevents
+      # automatic inclusion of things like hardware decoders. Each roll should
+      # audit new [autodetect] configure options and add any desired options to
+      # this file.
+      '--disable-autodetect',
+
+      # Common codecs.
+      '--enable-decoder=vorbis,libopus,flac',
+      '--enable-decoder=pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3',
+      '--enable-decoder=pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw',
+      '--enable-demuxer=ogg,matroska,wav,flac,mp3,mov',
+      '--enable-parser=opus,vorbis,flac,mpegaudio',
+
+      # Setup include path so Chromium's libopus can be used.
+      '--extra-cflags=-I' +
+      os.path.join(CHROMIUM_ROOT_DIR, 'third_party/opus/src/include'),
+
+      # Disable usage of Linux Performance API. Not used in production code, but
+      # missing system headers break some Android builds.
+      '--disable-linux-perf',
+
+      # Force usage of yasm
+      '--x86asmexe=yasm',
+  ])
+
+  if target_os == 'android':
+    configure_flags['Common'].extend([
+        # This replaces --optflags="-Os" since it implies it and since if it is
+        # also specified, configure ends up dropping all optflags :/
+        '--enable-small',
+    ])
+
+    configure_flags['Common'].extend(SetupAndroidToolchain(target_arch))
+  else:
+    configure_flags['Common'].extend([
+        # --optflags doesn't append multiple entries, so set all at once.
+        '--optflags="-O2"',
+        '--enable-decoder=theora,vp8',
+        '--enable-parser=vp3,vp8',
+    ])
+
+  if target_os in ('linux', 'linux-noasm', 'android'):
+    if target_arch == 'x64':
+      if target_os == 'android':
+        configure_flags['Common'].extend([
+            '--arch=x86_64',
+        ])
+      if target_os != 'android':
+        configure_flags['Common'].extend(['--enable-lto'])
+      pass
+    elif target_arch == 'ia32':
+      configure_flags['Common'].extend([
+          '--arch=i686',
+          '--extra-cflags="-m32"',
+          '--extra-ldflags="-m32"',
+      ])
+      # Android ia32 can't handle textrels and ffmpeg can't compile without
+      # them.  http://crbug.com/559379
+      if target_os == 'android':
+        configure_flags['Common'].extend([
+          '--disable-x86asm',
+        ])
+    elif target_arch == 'arm' or target_arch == 'arm-neon':
+      # TODO(ihf): ARM compile flags are tricky. The final options
+      # overriding everything live in chroot /build/*/etc/make.conf
+      # (some of them coming from src/overlays/overlay-<BOARD>/make.conf).
+      # We try to follow these here closely. In particular we need to
+      # set ffmpeg internal #defines to conform to make.conf.
+      # TODO(ihf): For now it is not clear if thumb or arm settings would be
+      # faster. I ran experiments in other contexts and performance seemed
+      # to be close and compiler version dependent. In practice thumb builds are
+      # much smaller than optimized arm builds, hence we go with the global
+      # CrOS settings.
+      configure_flags['Common'].extend([
+          '--arch=arm',
+          '--enable-armv6',
+          '--enable-armv6t2',
+          '--enable-vfp',
+          '--enable-thumb',
+          '--extra-cflags=-march=armv7-a',
+      ])
+
+      if target_os == 'android':
+        configure_flags['Common'].extend([
+            # Runtime neon detection requires /proc/cpuinfo access, so ensure
+            # av_get_cpu_flags() is run outside of the sandbox when enabled.
+            '--enable-neon',
+            '--extra-cflags=-mtune=generic-armv7-a',
+            # Enabling softfp lets us choose either softfp or hardfp when doing
+            # the chrome build.
+            '--extra-cflags=-mfloat-abi=softfp',
+        ])
+        if target_arch == 'arm':
+          print('arm-neon is the only supported arm arch for Android.\n')
+          return 1
+
+        if target_arch == 'arm-neon':
+          configure_flags['Common'].extend([
+              '--extra-cflags=-mfpu=neon',
+          ])
+        else:
+          configure_flags['Common'].extend([
+              '--extra-cflags=-mfpu=vfpv3-d16',
+          ])
+      else:
+        if host_arch != 'arm':
+          configure_flags['Common'].extend([
+              '--enable-cross-compile',
+              '--target-os=linux',
+              '--extra-cflags=--target=arm-linux-gnueabihf',
+              '--extra-ldflags=--target=arm-linux-gnueabihf',
+              '--sysroot=' + os.path.join(
+                  CHROMIUM_ROOT_DIR, 'build/linux/debian_sid_arm-sysroot'),
+              '--extra-cflags=-mtune=cortex-a8',
+              # NOTE: we don't need softfp for this hardware.
+              '--extra-cflags=-mfloat-abi=hard',
+              # For some reason configure drops this...
+              '--extra-cflags=-O2',
+          ])
+
+        if target_arch == 'arm-neon':
+          configure_flags['Common'].extend([
+              '--enable-neon',
+              '--extra-cflags=-mfpu=neon',
+          ])
+        else:
+          configure_flags['Common'].extend([
+              '--disable-neon',
+              '--extra-cflags=-mfpu=vfpv3-d16',
+          ])
+    elif target_arch == 'arm64':
+      if target_os != 'android':
+        configure_flags['Common'].extend([
+            '--enable-cross-compile',
+            '--cross-prefix=/usr/bin/aarch64-linux-gnu-',
+            '--target-os=linux',
+            '--extra-cflags=--target=aarch64-linux-gnu',
+            '--extra-ldflags=--target=aarch64-linux-gnu',
+            '--sysroot=' + os.path.join(
+                CHROMIUM_ROOT_DIR, 'build/linux/debian_sid_arm64-sysroot'),
+        ])
+      configure_flags['Common'].extend([
+          '--arch=aarch64',
+          '--enable-armv8',
+          '--extra-cflags=-march=armv8-a',
+      ])
+    elif target_arch == 'mipsel':
+      # These flags taken from android chrome build with target_cpu='mipsel'
+      configure_flags['Common'].extend([
+        '--arch=mipsel',
+        '--disable-mips32r6',
+        '--disable-mips32r5',
+        '--disable-mips32r2',
+        '--disable-mipsdsp',
+        '--disable-mipsdspr2',
+        '--disable-msa',
+        '--enable-mipsfpu',
+        '--extra-cflags=-march=mipsel',
+        '--extra-cflags=-mcpu=mips32',
+        # Required to avoid errors about dynamic relocation w/o -fPIC.
+        '--extra-ldflags=-z notext',
+      ])
+      if target_os == 'linux':
+        configure_flags['Common'].extend([
+            '--enable-cross-compile',
+            '--target-os=linux',
+            '--sysroot=' + os.path.join(
+                CHROMIUM_ROOT_DIR, 'build/linux/debian_sid_mips-sysroot'),
+            '--extra-cflags=--target=mipsel-linux-gnu',
+            '--extra-ldflags=--target=mipsel-linux-gnu',
+        ])
+    elif target_arch == 'mips64el':
+      # These flags taken from android chrome build with target_cpu='mips64el'
+      configure_flags['Common'].extend([
+          '--arch=mips64el',
+          '--enable-mipsfpu',
+          '--disable-mipsdsp',
+          '--disable-mipsdspr2',
+          '--extra-cflags=-march=mips64el',
+          # Required to avoid errors about dynamic relocation w/o -fPIC.
+          '--extra-ldflags=-z notext',
+      ])
+      if target_os == 'android':
+        configure_flags['Common'].extend([
+            '--enable-mips64r6',
+            '--extra-cflags=-mcpu=mips64r6',
+            '--disable-mips64r2',
+            '--enable-msa',
+        ])
+      if target_os == 'linux':
+        configure_flags['Common'].extend([
+            '--enable-cross-compile',
+            '--target-os=linux',
+            '--sysroot=' + os.path.join(
+                CHROMIUM_ROOT_DIR, 'build/linux/debian_sid_mips64el-sysroot'),
+            '--enable-mips64r2',
+            '--disable-mips64r6',
+            '--disable-msa',
+            '--extra-cflags=-mcpu=mips64r2',
+            '--extra-cflags=--target=mips64el-linux-gnuabi64',
+            '--extra-ldflags=--target=mips64el-linux-gnuabi64',
+        ])
+    else:
+      print(
+          'Error: Unknown target arch %r for target OS %r!' % (target_arch,
+                                                               target_os),
+          file=sys.stderr)
+      return 1
+
+  if target_os == 'linux-noasm':
+    configure_flags['Common'].extend([
+        '--disable-asm',
+        '--disable-inline-asm',
+    ])
+
+  if 'win' not in target_os:
+    configure_flags['Common'].extend([
+        '--enable-pic',
+        '--cc=clang',
+        '--cxx=clang++',
+        '--ld=clang',
+    ])
+
+    # Clang Linux will use the first 'ld' it finds on the path, which will
+    # typically be the system one, so explicitly configure use of Clang's
+    # ld.lld, to ensure that things like cross-compilation and LTO work.
+    # This does not work for arm64, ia32 and is always used on mac.
+    if target_arch not in ['arm64', 'ia32', 'mipsel'] and target_os != 'mac':
+      configure_flags['Common'].append('--extra-ldflags=-fuse-ld=lld')
+
+  # Should be run on Mac.
+  if target_os == 'mac':
+    if host_os != 'mac':
+      print(
+          'Script should be run on a Mac host. If this is not possible\n'
+          'try a merge of config files with new linux ia32 config.h\n'
+          'by hand.\n',
+          file=sys.stderr)
+      return 1
+
+    # Mac dylib building resolves external symbols. We need to explicitly
+    # include -lopus to point to the system libopus so we can build
+    # libavcodec.XX.dylib.
+    configure_flags['Common'].extend([
+        '--extra-libs=-lopus',
+    ])
+
+    if target_arch == 'x64':
+      configure_flags['Common'].extend([
+          '--arch=x86_64',
+          '--extra-cflags=-m64',
+          '--extra-ldflags=-m64',
+      ])
+    else:
+      print(
+          'Error: Unknown target arch %r for target OS %r!' % (target_arch,
+                                                               target_os),
+          file=sys.stderr)
+
+  # Should be run on Windows.
+  if target_os == 'win':
+    if host_os != 'win':
+      print('Script should be run on a Windows host.\n', file=sys.stderr)
+      return 1
+
+    configure_flags['Common'].extend([
+        '--toolchain=msvc',
+        '--extra-cflags=-I' + os.path.join(FFMPEG_DIR, 'chromium/include/win'),
+    ])
+
+    if 'CYGWIN_NT' in platform.system():
+      configure_flags['Common'].extend([
+          '--cc=cygwin-wrapper cl',
+          '--ld=cygwin-wrapper link',
+          '--nm=cygwin-wrapper dumpbin -symbols',
+          '--ar=cygwin-wrapper lib',
+      ])
+
+  # Google Chrome & ChromeOS specific configuration.
+  configure_flags['Chrome'].extend([
+      '--enable-decoder=aac,h264',
+      '--enable-demuxer=aac',
+      '--enable-parser=aac,h264',
+  ])
+
+  # Google ChromeOS specific configuration.
+  # We want to make sure to play everything Android generates and plays.
+  # http://developer.android.com/guide/appendix/media-formats.html
+  configure_flags['ChromeOS'].extend([
+      # Enable playing avi files.
+      '--enable-decoder=mpeg4',
+      '--enable-parser=h263,mpeg4video',
+      '--enable-demuxer=avi',
+      # Enable playing Android 3gp files.
+      '--enable-demuxer=amr',
+      '--enable-decoder=amrnb,amrwb',
+      # Wav files for playing phone messages.
+      '--enable-decoder=gsm_ms',
+      '--enable-parser=gsm',
+  ])
+
+  configure_flags['ChromeAndroid'].extend([
+      '--enable-demuxer=aac',
+      '--enable-parser=aac',
+      '--enable-decoder=aac',
+
+      # TODO(dalecurtis, watk): Figure out if we need h264 parser for now?
+  ])
+
+  def do_build_ffmpeg(branding, configure_flags):
+    if options.brandings and branding not in options.brandings:
+      print('%s skipped' % branding)
+      return
+
+    print('%s configure/build:' % branding)
+    BuildFFmpeg(target_os, target_arch, host_os, host_arch, parallel_jobs,
+                options.config_only, branding, configure_flags)
+
+  # Only build Chromium, Chrome for ia32, x86 non-android platforms.
+  if target_os != 'android':
+    do_build_ffmpeg('Chromium', configure_flags['Common'] +
+                    configure_flags['Chromium'] + configure_args)
+    do_build_ffmpeg(
+        'Chrome',
+        configure_flags['Common'] + configure_flags['Chrome'] + configure_args)
+  else:
+    do_build_ffmpeg('Chromium', configure_flags['Common'] + configure_args)
+    do_build_ffmpeg('Chrome', configure_flags['Common'] +
+                    configure_flags['ChromeAndroid'] + configure_args)
+
+  if target_os in ['linux', 'linux-noasm']:
+    # ChromeOS enables MPEG4 which requires error resilience :(
+    chrome_os_flags = (
+        configure_flags['Common'] + configure_flags['Chrome'] +
+        configure_flags['ChromeOS'] + configure_args)
+    chrome_os_flags.remove('--disable-error-resilience')
+    do_build_ffmpeg('ChromeOS', chrome_os_flags)
+
+  print('Done. If desired you may copy config.h/config.asm into the '
+        'source/config tree using copy_config.sh.')
+  return 0
+
+
+if __name__ == '__main__':
+  sys.exit(main(sys.argv[1:]))
diff -Naur chromium-67.0.3396.87/third_party/ffmpeg/libavutil/cpu.c chromium-67.0.3396.87-patched/third_party/ffmpeg/libavutil/cpu.c
--- chromium-67.0.3396.87/third_party/ffmpeg/libavutil/cpu.c	2018-06-13 01:12:06.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/ffmpeg/libavutil/cpu.c	2018-07-06 16:13:44.027858001 +0300
@@ -18,7 +18,13 @@
 
 #include <stddef.h>
 #include <stdint.h>
+// GCC 4.8 didn't have stdatomic, but was advertising it.
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58016
+#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ == 4 || (__GNUC__ == 4 && (__GNUC_MINOR__ == 8)))
+#include <compat/atomics/gcc/stdatomic.h>
+#else
 #include <stdatomic.h>
+#endif
 
 #include "attributes.h"
 #include "cpu.h"
diff -Naur chromium-67.0.3396.87/third_party/ffmpeg/libavutil/timer.h chromium-67.0.3396.87-patched/third_party/ffmpeg/libavutil/timer.h
--- chromium-67.0.3396.87/third_party/ffmpeg/libavutil/timer.h	2018-06-13 01:12:06.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/ffmpeg/libavutil/timer.h	2018-07-06 16:13:45.464524647 +0300
@@ -49,13 +49,13 @@
 #include "log.h"
 
 #if   ARCH_AARCH64
-#   include "aarch64/timer.h"
+#   include "libavutil/aarch64/timer.h"
 #elif ARCH_ARM
-#   include "arm/timer.h"
+#   include "libavutil/arm/timer.h"
 #elif ARCH_PPC
-#   include "ppc/timer.h"
+#   include "libavutil/ppc/timer.h"
 #elif ARCH_X86
-#   include "x86/timer.h"
+#   include "libavutil/x86/timer.h"
 #endif
 
 #if !defined(AV_READ_TIME)
diff -Naur chromium-67.0.3396.87/third_party/ffmpeg/libavutil/timer.h.orig chromium-67.0.3396.87-patched/third_party/ffmpeg/libavutil/timer.h.orig
--- chromium-67.0.3396.87/third_party/ffmpeg/libavutil/timer.h.orig	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/ffmpeg/libavutil/timer.h.orig	2018-06-13 01:12:06.000000000 +0300
@@ -0,0 +1,141 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * high precision timer, useful to profile code
+ */
+
+#ifndef AVUTIL_TIMER_H
+#define AVUTIL_TIMER_H
+
+#include "config.h"
+
+#if CONFIG_LINUX_PERF
+# ifndef _GNU_SOURCE
+#  define _GNU_SOURCE
+# endif
+# include <unistd.h> // read(3)
+# include <sys/ioctl.h>
+# include <asm/unistd.h>
+# include <linux/perf_event.h>
+#endif
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <inttypes.h>
+
+#if HAVE_MACH_ABSOLUTE_TIME
+#include <mach/mach_time.h>
+#endif
+
+#include "log.h"
+
+#if   ARCH_AARCH64
+#   include "aarch64/timer.h"
+#elif ARCH_ARM
+#   include "arm/timer.h"
+#elif ARCH_PPC
+#   include "ppc/timer.h"
+#elif ARCH_X86
+#   include "x86/timer.h"
+#endif
+
+#if !defined(AV_READ_TIME)
+#   if HAVE_GETHRTIME
+#       define AV_READ_TIME gethrtime
+#   elif HAVE_MACH_ABSOLUTE_TIME
+#       define AV_READ_TIME mach_absolute_time
+#   endif
+#endif
+
+#ifndef FF_TIMER_UNITS
+#   define FF_TIMER_UNITS "UNITS"
+#endif
+
+#define TIMER_REPORT(id, tdiff)                                           \
+    {                                                                     \
+        static uint64_t tsum   = 0;                                       \
+        static int tcount      = 0;                                       \
+        static int tskip_count = 0;                                       \
+        static int thistogram[32] = {0};                                  \
+        thistogram[av_log2(tdiff)]++;                                     \
+        if (tcount < 2                ||                                  \
+            (tdiff) < 8 * tsum / tcount ||                                \
+            (tdiff) < 2000) {                                             \
+            tsum += (tdiff);                                              \
+            tcount++;                                                     \
+        } else                                                            \
+            tskip_count++;                                                \
+        if (((tcount + tskip_count) & (tcount + tskip_count - 1)) == 0) { \
+            int i;                                                        \
+            av_log(NULL, AV_LOG_ERROR,                                    \
+                   "%7"PRIu64" " FF_TIMER_UNITS " in %s,%8d runs,%7d skips",          \
+                   tsum * 10 / tcount, id, tcount, tskip_count);          \
+            for (i = 0; i < 32; i++)                                      \
+                av_log(NULL, AV_LOG_VERBOSE, " %2d", av_log2(2*thistogram[i]));\
+            av_log(NULL, AV_LOG_ERROR, "\n");                             \
+        }                                                                 \
+    }
+
+#if CONFIG_LINUX_PERF
+
+#define START_TIMER                                                         \
+    static int linux_perf_fd;                                               \
+    uint64_t tperf;                                                         \
+    if (!linux_perf_fd) {                                                   \
+        struct perf_event_attr attr = {                                     \
+            .type           = PERF_TYPE_HARDWARE,                           \
+            .size           = sizeof(struct perf_event_attr),               \
+            .config         = PERF_COUNT_HW_CPU_CYCLES,                     \
+            .disabled       = 1,                                            \
+            .exclude_kernel = 1,                                            \
+            .exclude_hv     = 1,                                            \
+        };                                                                  \
+        linux_perf_fd = syscall(__NR_perf_event_open, &attr,                \
+                                0, -1, -1, 0);                              \
+    }                                                                       \
+    if (linux_perf_fd == -1) {                                              \
+        av_log(NULL, AV_LOG_ERROR, "perf_event_open failed: %s\n",          \
+               av_err2str(AVERROR(errno)));                                 \
+    } else {                                                                \
+        ioctl(linux_perf_fd, PERF_EVENT_IOC_RESET, 0);                      \
+        ioctl(linux_perf_fd, PERF_EVENT_IOC_ENABLE, 0);                     \
+    }
+
+#define STOP_TIMER(id)                                                      \
+    ioctl(linux_perf_fd, PERF_EVENT_IOC_DISABLE, 0);                        \
+    read(linux_perf_fd, &tperf, sizeof(tperf));                             \
+    TIMER_REPORT(id, tperf)
+
+#elif defined(AV_READ_TIME)
+#define START_TIMER                             \
+    uint64_t tend;                              \
+    uint64_t tstart = AV_READ_TIME();           \
+
+#define STOP_TIMER(id)                                                    \
+    tend = AV_READ_TIME();                                                \
+    TIMER_REPORT(id, tend - tstart)
+#else
+#define START_TIMER
+#define STOP_TIMER(id) { }
+#endif
+
+#endif /* AVUTIL_TIMER_H */
diff -Naur chromium-67.0.3396.87/third_party/libjpeg_turbo/jpeglib.h chromium-67.0.3396.87-patched/third_party/libjpeg_turbo/jpeglib.h
--- chromium-67.0.3396.87/third_party/libjpeg_turbo/jpeglib.h	2018-06-13 01:12:06.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/libjpeg_turbo/jpeglib.h	2018-07-06 16:13:44.037858001 +0300
@@ -18,10 +18,6 @@
 #ifndef JPEGLIB_H
 #define JPEGLIB_H
 
-/* Begin chromium edits */
-#include "jpeglibmangler.h"
-/* End chromium edits */
-
 /*
  * First we include the configuration files that record how this
  * installation of the JPEG library is set up.  jconfig.h can be
diff -Naur chromium-67.0.3396.87/third_party/libpng/pnglibconf.h chromium-67.0.3396.87-patched/third_party/libpng/pnglibconf.h
--- chromium-67.0.3396.87/third_party/libpng/pnglibconf.h	2018-06-13 01:11:03.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/libpng/pnglibconf.h	2018-07-06 16:13:44.037858001 +0300
@@ -225,13 +225,4 @@
 #define PNG_USER_CHUNK_MALLOC_MAX 4000000L
 /* end of chromium settings */
 
-/* chromium prefixing */
-/*
- * This is necessary to build multiple copies of libpng.  We need this while pdfium builds
- * its own copy of libpng.
- */
-#define PNG_PREFIX
-#include "pngprefix.h"
-/* end of chromium prefixing */
-
 #endif /* PNGLCONF_H */
diff -Naur chromium-67.0.3396.87/third_party/webgl/src/specs/latest/2.0/webgl2.idl chromium-67.0.3396.87-patched/third_party/webgl/src/specs/latest/2.0/webgl2.idl
--- chromium-67.0.3396.87/third_party/webgl/src/specs/latest/2.0/webgl2.idl	2018-06-13 01:12:10.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/webgl/src/specs/latest/2.0/webgl2.idl	2018-07-06 16:13:17.981191641 +0300
@@ -262,7 +262,7 @@
   const GLenum UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES          = 0x8A43;
   const GLenum UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER     = 0x8A44;
   const GLenum UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER   = 0x8A46;
-  const GLenum INVALID_INDEX                                 = 0xFFFFFFFF;
+  const GLenum INVALID_INDEX                                 = 256;
   const GLenum MAX_VERTEX_OUTPUT_COMPONENTS                  = 0x9122;
   const GLenum MAX_FRAGMENT_INPUT_COMPONENTS                 = 0x9125;
   const GLenum MAX_SERVER_WAIT_TIMEOUT                       = 0x9111;
diff -Naur chromium-67.0.3396.87/third_party/webrtc/modules/audio_processing/aec3/aec_state.cc chromium-67.0.3396.87-patched/third_party/webrtc/modules/audio_processing/aec3/aec_state.cc
--- chromium-67.0.3396.87/third_party/webrtc/modules/audio_processing/aec3/aec_state.cc	2018-06-13 01:12:10.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/webrtc/modules/audio_processing/aec3/aec_state.cc	2018-07-06 16:13:46.497857972 +0300
@@ -10,7 +10,7 @@
 
 #include "modules/audio_processing/aec3/aec_state.h"
 
-#include <math.h>
+#include <cmath>
 
 #include <numeric>
 #include <vector>
diff -Naur chromium-67.0.3396.87/third_party/webrtc/p2p/base/port.cc chromium-67.0.3396.87-patched/third_party/webrtc/p2p/base/port.cc
--- chromium-67.0.3396.87/third_party/webrtc/p2p/base/port.cc	2018-06-13 01:12:10.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/webrtc/p2p/base/port.cc	2018-07-06 16:13:46.497857972 +0300
@@ -10,7 +10,7 @@
 
 #include "p2p/base/port.h"
 
-#include <math.h>
+#include <cmath>
 
 #include <algorithm>
 #include <utility>
diff -Naur chromium-67.0.3396.87/third_party/widevine/cdm/BUILD.gn chromium-67.0.3396.87-patched/third_party/widevine/cdm/BUILD.gn
--- chromium-67.0.3396.87/third_party/widevine/cdm/BUILD.gn	2018-06-13 01:11:08.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/widevine/cdm/BUILD.gn	2018-07-06 16:13:55.767857865 +0300
@@ -11,7 +11,7 @@
 # Internal Cast builds set enable_widevine=true to bring in Widevine support.
 # TODO(xhwang): Support component updated CDM on other platforms and remove this
 # assert.
-assert(!enable_widevine || is_win || is_mac || is_chromecast,
+assert(!enable_widevine || is_win || is_mac || is_chromecast || is_linux,
        "Component updated CDM only supported on Windows and Mac for now.")
 
 widevine_arch = current_cpu
diff -Naur chromium-67.0.3396.87/third_party/widevine/cdm/stub/widevine_cdm_version.h chromium-67.0.3396.87-patched/third_party/widevine/cdm/stub/widevine_cdm_version.h
--- chromium-67.0.3396.87/third_party/widevine/cdm/stub/widevine_cdm_version.h	2018-06-13 01:11:08.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/widevine/cdm/stub/widevine_cdm_version.h	2018-07-06 16:13:55.767857865 +0300
@@ -10,6 +10,7 @@
 
 #include "third_party/widevine/cdm/widevine_cdm_common.h"
 
+#define WIDEVINE_CDM_VERSION_STRING "unknown"
 #define WIDEVINE_CDM_AVAILABLE
 
 #endif  // WIDEVINE_CDM_VERSION_H_
diff -Naur chromium-67.0.3396.87/third_party/zlib/zconf.h chromium-67.0.3396.87-patched/third_party/zlib/zconf.h
--- chromium-67.0.3396.87/third_party/zlib/zconf.h	2018-06-13 01:11:08.000000000 +0300
+++ chromium-67.0.3396.87-patched/third_party/zlib/zconf.h	2018-07-06 16:13:44.041191335 +0300
@@ -8,9 +8,6 @@
 #ifndef ZCONF_H
 #define ZCONF_H
 
-/* This include does prefixing as below, but with an updated set of names */
-#include "names.h"
-
 /*
  * If you *really* need a unique prefix for all types and library functions,
  * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
diff -Naur chromium-67.0.3396.87/tools/gn/bootstrap/bootstrap.py chromium-67.0.3396.87-patched/tools/gn/bootstrap/bootstrap.py
--- chromium-67.0.3396.87/tools/gn/bootstrap/bootstrap.py	2018-06-13 01:11:08.000000000 +0300
+++ chromium-67.0.3396.87-patched/tools/gn/bootstrap/bootstrap.py	2018-07-06 16:13:55.767857865 +0300
@@ -112,7 +112,7 @@
 
     _globals = {"__builtins__":None}
     _locals = {}
-    exec(response, _globals, _locals)
+    exec response in _globals, _locals
 
     return _locals
 
@@ -399,6 +399,11 @@
   cflags = os.environ.get('CFLAGS', '').split()
   cflags_cc = os.environ.get('CXXFLAGS', '').split()
   ldflags = os.environ.get('LDFLAGS', '').split()
+
+  # Work around GCC8 bug gcc#84286
+  cflags.extend(['-fabi-version=11'])
+  cflags_cc.extend(['-fabi-version=11'])
+
   include_dirs = [root_gen_dir, SRC_ROOT]
   libs = []
 
diff -Naur chromium-67.0.3396.87/tools/gn/bootstrap/bootstrap.py.orig chromium-67.0.3396.87-patched/tools/gn/bootstrap/bootstrap.py.orig
--- chromium-67.0.3396.87/tools/gn/bootstrap/bootstrap.py.orig	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/tools/gn/bootstrap/bootstrap.py.orig	2018-06-13 01:11:08.000000000 +0300
@@ -0,0 +1,1009 @@
+#!/usr/bin/env python
+# Copyright 2014 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+# This file isn't officially supported by the Chromium project. It's maintained
+# on a best-effort basis by volunteers, so some things may be broken from time
+# to time. If you encounter errors, it's most often due to files in base that
+# have been added or moved since somebody last tried this script. Generally
+# such errors are easy to diagnose.
+
+"""Bootstraps gn.
+
+It is done by first building it manually in a temporary directory, then building
+it with its own BUILD.gn to the final destination.
+"""
+
+import contextlib
+import errno
+import logging
+import optparse
+import os
+import platform
+import shutil
+import subprocess
+import sys
+import tempfile
+
+BOOTSTRAP_DIR = os.path.dirname(os.path.abspath(__file__))
+GN_ROOT = os.path.dirname(BOOTSTRAP_DIR)
+SRC_ROOT = os.path.dirname(os.path.dirname(GN_ROOT))
+
+is_win = sys.platform.startswith('win')
+is_linux = sys.platform.startswith('linux')
+is_mac = sys.platform.startswith('darwin')
+is_aix = sys.platform.startswith('aix')
+is_posix = is_linux or is_mac or is_aix
+
+def check_call(cmd, **kwargs):
+  logging.debug('Running: %s', ' '.join(cmd))
+
+  subprocess.check_call(cmd, cwd=GN_ROOT, **kwargs)
+
+def check_output(cmd, cwd=GN_ROOT, **kwargs):
+  logging.debug('Running: %s', ' '.join(cmd))
+
+  return subprocess.check_output(cmd, cwd=cwd, **kwargs)
+
+def mkdir_p(path):
+  try:
+    os.makedirs(path)
+  except OSError as e:
+    if e.errno == errno.EEXIST and os.path.isdir(path):
+      pass
+    else: raise
+
+@contextlib.contextmanager
+def scoped_tempdir():
+  path = tempfile.mkdtemp()
+  try:
+    yield path
+  finally:
+    shutil.rmtree(path)
+
+
+def run_build(tempdir, options):
+  if options.build_path:
+    build_rel = options.build_path
+  elif options.debug:
+    build_rel = os.path.join('out', 'Debug')
+  else:
+    build_rel = os.path.join('out', 'Release')
+  build_root = os.path.join(SRC_ROOT, build_rel)
+
+  windows_x64_toolchain = None
+  if is_win:
+    windows_x64_toolchain = windows_prepare_toolchain(tempdir)
+    os.environ["PATH"] = windows_x64_toolchain["paths"]
+
+  print 'Building gn manually in a temporary directory for bootstrapping...'
+  build_gn_with_ninja_manually(tempdir, options, windows_x64_toolchain)
+  temp_gn = os.path.join(tempdir, 'gn')
+  out_gn = os.path.join(build_root, 'gn')
+
+  if is_win:
+    temp_gn += '.exe'
+    out_gn += '.exe'
+
+  if options.no_rebuild:
+    mkdir_p(build_root)
+    shutil.copy2(temp_gn, out_gn)
+  else:
+    print 'Building gn using itself to %s...' % build_rel
+    build_gn_with_gn(temp_gn, build_root, options)
+
+  if options.output:
+    # Preserve the executable permission bit.
+    shutil.copy2(out_gn, options.output)
+
+def windows_target_build_arch():
+    # Target build architecture set by vcvarsall.bat
+    target_arch = os.environ.get('Platform')
+    if target_arch in ['x64', 'x86']: return target_arch
+
+    if platform.machine().lower() in ['x86_64', 'amd64']: return 'x64'
+    return 'x86'
+
+def windows_prepare_toolchain(tempdir):
+
+  def CallPythonScopeScript(command, **kwargs):
+    response = check_output(command, **kwargs)
+
+    _globals = {"__builtins__":None}
+    _locals = {}
+    exec(response, _globals, _locals)
+
+    return _locals
+
+  toolchain_paths = CallPythonScopeScript(
+      [sys.executable,
+       os.path.join(SRC_ROOT, "build", "vs_toolchain.py"),
+      "get_toolchain_dir"],
+      cwd=tempdir)
+
+  windows_x64_toolchain =  CallPythonScopeScript(
+      [sys.executable,
+       os.path.join(SRC_ROOT, "build", "toolchain",
+                    "win", "setup_toolchain.py"),
+       toolchain_paths["vs_path"],
+       toolchain_paths["sdk_path"],
+       toolchain_paths["runtime_dirs"],
+       "x64",
+       "true"
+      ],
+      cwd=tempdir)
+
+  return windows_x64_toolchain
+
+def main(argv):
+  parser = optparse.OptionParser(description=sys.modules[__name__].__doc__)
+  parser.add_option('-d', '--debug', action='store_true',
+                    help='Do a debug build. Defaults to release build.')
+  parser.add_option('-o', '--output',
+                    help='place output in PATH', metavar='PATH')
+  parser.add_option('-s', '--no-rebuild', action='store_true',
+                    help='Do not rebuild GN with GN.')
+  parser.add_option('--no-clean', action='store_true',
+                    help='Re-used build directory instead of using new '
+                         'temporary location each time')
+  parser.add_option('--gn-gen-args', help='Args to pass to gn gen --args')
+  parser.add_option('--build-path', help='The directory in which to build gn, '
+                    'relative to the src directory. (eg. out/Release)'
+                    'In the no-clean mode an absolute path will also force '
+                    'the out_bootstrap to be located in the parent directory')
+  parser.add_option('-v', '--verbose', action='store_true',
+                    help='Log more details')
+  options, args = parser.parse_args(argv)
+
+  if args:
+    parser.error('Unrecognized command line arguments: %s.' % ', '.join(args))
+
+  logging.basicConfig(level=logging.DEBUG if options.verbose else logging.ERROR)
+
+  try:
+    if options.no_clean:
+      out_bootstrap_dir = SRC_ROOT
+      if options.build_path and os.path.isabs(options.build_path):
+        out_bootstrap_dir = os.path.dirname(options.build_path)
+      build_dir = os.path.join(out_bootstrap_dir, 'out_bootstrap')
+      if not os.path.exists(build_dir):
+        os.makedirs(build_dir)
+      return run_build(build_dir, options)
+    else:
+      with scoped_tempdir() as tempdir:
+        return run_build(tempdir, options)
+  except subprocess.CalledProcessError as e:
+    print >> sys.stderr, str(e)
+    return 1
+  return 0
+
+def write_compiled_message(root_gen_dir, source):
+  path = os.path.join(root_gen_dir, os.path.dirname(source))
+  mkdir_p(path)
+  check_call([
+      'mc.exe',
+      '-r', path, '-h', path,
+      '-u', '-um',
+      os.path.join(SRC_ROOT, source),
+  ])
+
+def write_buildflag_header_manually(root_gen_dir, header, flags):
+  mkdir_p(os.path.join(root_gen_dir, os.path.dirname(header)))
+
+  # Don't use tempfile.NamedTemporaryFile() here.
+  # It doesn't work correctly on Windows.
+  # see: http://bugs.python.org/issue14243
+  temp_path = os.path.join(root_gen_dir, header + '.tmp')
+  with open(temp_path, 'w') as f:
+    f.write('--flags')
+    for name,value in flags.items():
+      f.write(' ' + name + '=' + value)
+
+  check_call([
+      sys.executable,
+      os.path.join(SRC_ROOT, 'build', 'write_buildflag_header.py'),
+      '--output', header,
+      '--gen-dir', root_gen_dir,
+      '--definitions', temp_path,
+  ])
+
+  os.remove(temp_path)
+
+def write_build_date_header(root_gen_dir):
+  check_call([
+       sys.executable,
+       os.path.join(SRC_ROOT, 'build', 'write_build_date_header.py'),
+       os.path.join(root_gen_dir, 'base/generated_build_date.h'),
+       'default',
+  ])
+
+def build_gn_with_ninja_manually(tempdir, options, windows_x64_toolchain):
+  root_gen_dir = os.path.join(tempdir, 'gen')
+  mkdir_p(root_gen_dir)
+
+  write_buildflag_header_manually(
+      root_gen_dir,
+      'base/synchronization/synchronization_buildflags.h',
+      {'ENABLE_MUTEX_PRIORITY_INHERITANCE': 'false'})
+
+  write_buildflag_header_manually(root_gen_dir, 'base/allocator/buildflags.h',
+      {'USE_ALLOCATOR_SHIM': 'true' if is_linux else 'false'})
+
+  write_buildflag_header_manually(root_gen_dir,
+                                  'base/debug/debugging_buildflags.h',
+      {
+          'ENABLE_LOCATION_SOURCE': 'false',
+          'ENABLE_PROFILING': 'false',
+          'CAN_UNWIND_WITH_FRAME_POINTERS': 'false',
+          'UNSAFE_DEVELOPER_BUILD': 'false',
+          'CAN_UNWIND_WITH_CFI_TABLE': 'false',
+      })
+
+  write_buildflag_header_manually(root_gen_dir,
+                                  'base/memory/protected_memory_buildflags.h',
+                                  { 'USE_LLD': 'false' })
+
+  write_buildflag_header_manually(root_gen_dir, 'base/cfi_buildflags.h',
+      {
+          'CFI_CAST_CHECK': 'false',
+          'CFI_ICALL_CHECK': 'false',
+          'CFI_ENFORCEMENT_TRAP': 'false',
+          'CFI_ENFORCEMENT_DIAGNOSTIC': 'false'
+      })
+
+  write_build_date_header(root_gen_dir)
+
+  if is_mac:
+    # //base/build_time.cc needs base/generated_build_date.h,
+    # and this file is only included for Mac builds.
+    mkdir_p(os.path.join(root_gen_dir, 'base'))
+    check_call([
+        sys.executable,
+        os.path.join(SRC_ROOT, 'build', 'write_build_date_header.py'),
+        os.path.join(root_gen_dir, 'base', 'generated_build_date.h'),
+        'default'
+    ])
+
+  if is_win:
+    write_buildflag_header_manually(root_gen_dir,
+                                    'base/win/base_win_buildflags.h',
+        {'SINGLE_MODULE_MODE_HANDLE_VERIFIER': 'true'})
+
+    write_compiled_message(root_gen_dir,
+        'base/trace_event/etw_manifest/chrome_events_win.man')
+
+  write_buildflag_header_manually(
+      root_gen_dir, 'base/android/library_loader.h',
+      {'USE_LLD': 'false', 'SUPPORTS_CODE_ORDERING': 'false'})
+
+  write_gn_ninja(os.path.join(tempdir, 'build.ninja'),
+                 root_gen_dir, options, windows_x64_toolchain)
+  cmd = ['ninja', '-C', tempdir, '-w', 'dupbuild=err']
+  if options.verbose:
+    cmd.append('-v')
+
+  if is_win:
+    cmd.append('gn.exe')
+  else:
+    cmd.append('gn')
+
+  check_call(cmd)
+
+def write_generic_ninja(path, static_libraries, executables,
+                        cc, cxx, ar, ld,
+                        cflags=[], cflags_cc=[], ldflags=[],
+                        include_dirs=[], solibs=[]):
+  ninja_header_lines = [
+    'cc = ' + cc,
+    'cxx = ' + cxx,
+    'ar = ' + ar,
+    'ld = ' + ld,
+    '',
+  ]
+
+  if is_win:
+    template_filename = 'build_vs.ninja.template'
+  elif is_mac:
+    template_filename = 'build_mac.ninja.template'
+  elif is_aix:
+    template_filename = 'build_aix.ninja.template'
+  else:
+    template_filename = 'build.ninja.template'
+
+  with open(os.path.join(GN_ROOT, 'bootstrap', template_filename)) as f:
+    ninja_template = f.read()
+
+  if is_win:
+    executable_ext = '.exe'
+    library_ext = '.lib'
+    object_ext = '.obj'
+  else:
+    executable_ext = ''
+    library_ext = '.a'
+    object_ext = '.o'
+
+  def escape_path_ninja(path):
+      return path.replace('$ ', '$$ ').replace(' ', '$ ').replace(':', '$:')
+
+  def src_to_obj(path):
+    return escape_path_ninja('%s' % os.path.splitext(path)[0] + object_ext)
+
+  def library_to_a(library):
+    return '%s%s' % (library, library_ext)
+
+  ninja_lines = []
+  def build_source(src_file, settings):
+    ninja_lines.extend([
+        'build %s: %s %s' % (src_to_obj(src_file),
+                             settings['tool'],
+                             escape_path_ninja(
+                                 os.path.join(SRC_ROOT, src_file))),
+        '  includes = %s' % ' '.join(
+            ['-I' + escape_path_ninja(dirname) for dirname in
+             include_dirs + settings.get('include_dirs', [])]),
+        '  cflags = %s' % ' '.join(cflags + settings.get('cflags', [])),
+        '  cflags_cc = %s' %
+            ' '.join(cflags_cc + settings.get('cflags_cc', [])),
+    ])
+
+  for library, settings in static_libraries.iteritems():
+    for src_file in settings['sources']:
+      build_source(src_file, settings)
+
+    ninja_lines.append('build %s: alink_thin %s' % (
+        library_to_a(library),
+        ' '.join([src_to_obj(src_file) for src_file in settings['sources']])))
+
+  for executable, settings in executables.iteritems():
+    for src_file in settings['sources']:
+      build_source(src_file, settings)
+
+    ninja_lines.extend([
+      'build %s%s: link %s | %s' % (
+          executable, executable_ext,
+          ' '.join([src_to_obj(src_file) for src_file in settings['sources']]),
+          ' '.join([library_to_a(library) for library in settings['libs']])),
+      '  ldflags = %s' % ' '.join(ldflags),
+      '  solibs = %s' % ' '.join(solibs),
+      '  libs = %s' % ' '.join(
+          [library_to_a(library) for library in settings['libs']]),
+    ])
+
+  ninja_lines.append('')  # Make sure the file ends with a newline.
+
+  with open(path, 'w') as f:
+    f.write('\n'.join(ninja_header_lines))
+    f.write(ninja_template)
+    f.write('\n'.join(ninja_lines))
+
+def write_gn_ninja(path, root_gen_dir, options, windows_x64_toolchain):
+  if is_win:
+    CCPATH = windows_x64_toolchain["vc_bin_dir"]
+
+    cc = os.environ.get('CC', os.path.join(CCPATH, 'cl.exe'))
+    cxx = os.environ.get('CXX', os.path.join(CCPATH, 'cl.exe'))
+    ld = os.environ.get('LD', os.path.join(CCPATH, 'link.exe'))
+    ar = os.environ.get('AR', os.path.join(CCPATH, 'lib.exe'))
+  elif is_aix:
+    cc = os.environ.get('CC', 'gcc')
+    cxx = os.environ.get('CXX', 'c++')
+    ld = os.environ.get('LD', cxx)
+    ar = os.environ.get('AR', 'ar -X64')
+  else:
+    cc = os.environ.get('CC', 'cc')
+    cxx = os.environ.get('CXX', 'c++')
+    ld = cxx
+    ar = os.environ.get('AR', 'ar')
+
+  cflags = os.environ.get('CFLAGS', '').split()
+  cflags_cc = os.environ.get('CXXFLAGS', '').split()
+  ldflags = os.environ.get('LDFLAGS', '').split()
+  include_dirs = [root_gen_dir, SRC_ROOT]
+  libs = []
+
+  # //base/allocator/allocator_extension.cc needs this macro defined,
+  # otherwise there would be link errors.
+  cflags.extend(['-DNO_TCMALLOC', '-D__STDC_FORMAT_MACROS'])
+
+  if is_posix:
+    if options.debug:
+      cflags.extend(['-O0', '-g'])
+    else:
+      # The linux::ppc64 BE binary doesn't "work" when
+      # optimization level is set to 2 (0 works fine).
+      # Note that the current bootstrap script has no way to detect host_cpu.
+      # This can be easily fixed once we start building using a GN binary,
+      # as the optimization flag can then just be set using the
+      # logic inside //build/toolchain.
+      cflags.extend(['-O2', '-g0'])
+
+    cflags.extend([
+        '-D_FILE_OFFSET_BITS=64',
+        '-D__STDC_CONSTANT_MACROS', '-D__STDC_FORMAT_MACROS',
+        '-pthread',
+        '-pipe',
+        '-fno-exceptions'
+    ])
+    cflags_cc.extend(['-std=c++14', '-Wno-c++11-narrowing'])
+    if is_aix:
+     cflags.extend(['-maix64'])
+     ldflags.extend([ '-maix64 -Wl,-bbigtoc' ])
+  elif is_win:
+    if not options.debug:
+      cflags.extend(['/Ox', '/DNDEBUG', '/GL'])
+      ldflags.extend(['/LTCG', '/OPT:REF', '/OPT:ICF'])
+
+    cflags.extend([
+        '/FS',
+        '/Gy',
+        '/W3', '/wd4244',
+        '/Zi',
+        '/DWIN32_LEAN_AND_MEAN', '/DNOMINMAX',
+        '/D_CRT_SECURE_NO_DEPRECATE', '/D_SCL_SECURE_NO_DEPRECATE',
+        '/D_WIN32_WINNT=0x0A00', '/DWINVER=0x0A00',
+        '/DUNICODE', '/D_UNICODE',
+    ])
+    cflags_cc.extend([
+        '/GR-',
+        '/D_HAS_EXCEPTIONS=0',
+    ])
+
+    target_arch = windows_target_build_arch()
+    if target_arch == 'x64':
+        ldflags.extend(['/MACHINE:x64'])
+    else:
+        ldflags.extend(['/MACHINE:x86'])
+
+  static_libraries = {
+      'base': {'sources': [], 'tool': 'cxx', 'include_dirs': []},
+      'dynamic_annotations': {'sources': [], 'tool': 'cc', 'include_dirs': []},
+      'gn_lib': {'sources': [], 'tool': 'cxx', 'include_dirs': []},
+  }
+
+  executables = {
+      'gn': {'sources': ['tools/gn/gn_main.cc'],
+             'tool': 'cxx', 'include_dirs': [], 'libs': []},
+  }
+
+  for name in os.listdir(GN_ROOT):
+    if not name.endswith('.cc'):
+      continue
+    if name.endswith('_unittest.cc'):
+      continue
+    if name == 'run_all_unittests.cc':
+      continue
+    if name == 'test_with_scheduler.cc':
+      continue
+    if name == 'gn_main.cc':
+      continue
+    full_path = os.path.join(GN_ROOT, name)
+    static_libraries['gn_lib']['sources'].append(
+        os.path.relpath(full_path, SRC_ROOT))
+
+  static_libraries['dynamic_annotations']['sources'].extend([
+      'base/third_party/dynamic_annotations/dynamic_annotations.c',
+      'base/third_party/superfasthash/superfasthash.c',
+  ])
+  static_libraries['base']['sources'].extend([
+      'base/allocator/allocator_check.cc',
+      'base/allocator/allocator_extension.cc',
+      'base/at_exit.cc',
+      'base/base_paths.cc',
+      'base/base_switches.cc',
+      'base/build_time.cc',
+      'base/callback_helpers.cc',
+      'base/callback_internal.cc',
+      'base/command_line.cc',
+      'base/debug/activity_tracker.cc',
+      'base/debug/alias.cc',
+      'base/debug/crash_logging.cc',
+      'base/debug/dump_without_crashing.cc',
+      'base/debug/stack_trace.cc',
+      'base/debug/task_annotator.cc',
+      'base/debug/thread_heap_usage_tracker.cc',
+      'base/environment.cc',
+      'base/feature_list.cc',
+      'base/files/file.cc',
+      'base/files/file_enumerator.cc',
+      'base/files/file_path.cc',
+      'base/files/file_path_constants.cc',
+      'base/files/file_tracing.cc',
+      'base/files/file_util.cc',
+      'base/files/important_file_writer.cc',
+      'base/files/memory_mapped_file.cc',
+      'base/files/scoped_file.cc',
+      'base/hash.cc',
+      'base/json/json_parser.cc',
+      'base/json/json_reader.cc',
+      'base/json/json_string_value_serializer.cc',
+      'base/json/json_writer.cc',
+      'base/json/string_escape.cc',
+      'base/lazy_instance_helpers.cc',
+      'base/location.cc',
+      'base/logging.cc',
+      'base/md5.cc',
+      'base/memory/ref_counted.cc',
+      'base/memory/ref_counted_memory.cc',
+      'base/memory/shared_memory_handle.cc',
+      'base/memory/shared_memory_tracker.cc',
+      'base/memory/weak_ptr.cc',
+      'base/message_loop/incoming_task_queue.cc',
+      'base/message_loop/message_loop.cc',
+      'base/message_loop/message_loop_task_runner.cc',
+      'base/message_loop/message_pump.cc',
+      'base/message_loop/message_pump_default.cc',
+      'base/message_loop/watchable_io_message_pump_posix.cc',
+      'base/metrics/bucket_ranges.cc',
+      'base/metrics/dummy_histogram.cc',
+      'base/metrics/field_trial.cc',
+      'base/metrics/field_trial_param_associator.cc',
+      'base/metrics/field_trial_params.cc',
+      'base/metrics/histogram.cc',
+      'base/metrics/histogram_base.cc',
+      'base/metrics/histogram_functions.cc',
+      'base/metrics/histogram_samples.cc',
+      'base/metrics/histogram_snapshot_manager.cc',
+      'base/metrics/metrics_hashes.cc',
+      'base/metrics/persistent_histogram_allocator.cc',
+      'base/metrics/persistent_memory_allocator.cc',
+      'base/metrics/persistent_sample_map.cc',
+      'base/metrics/sample_map.cc',
+      'base/metrics/sample_vector.cc',
+      'base/metrics/sparse_histogram.cc',
+      'base/metrics/statistics_recorder.cc',
+      'base/observer_list_threadsafe.cc',
+      'base/path_service.cc',
+      'base/pending_task.cc',
+      'base/pickle.cc',
+      'base/process/kill.cc',
+      'base/process/memory.cc',
+      'base/process/process_handle.cc',
+      'base/process/process_iterator.cc',
+      'base/process/process_metrics.cc',
+      'base/rand_util.cc',
+      'base/run_loop.cc',
+      'base/sequence_token.cc',
+      'base/sequence_checker_impl.cc',
+      'base/sequenced_task_runner.cc',
+      'base/sha1.cc',
+      'base/strings/pattern.cc',
+      'base/strings/string_number_conversions.cc',
+      'base/strings/string_piece.cc',
+      'base/strings/string_split.cc',
+      'base/strings/string_util.cc',
+      'base/strings/string_util_constants.cc',
+      'base/strings/stringprintf.cc',
+      'base/strings/utf_string_conversion_utils.cc',
+      'base/strings/utf_string_conversions.cc',
+      'base/synchronization/atomic_flag.cc',
+      'base/synchronization/lock.cc',
+      'base/sys_info.cc',
+      'base/task_runner.cc',
+      'base/task_scheduler/delayed_task_manager.cc',
+      'base/task_scheduler/environment_config.cc',
+      'base/task_scheduler/post_task.cc',
+      'base/task_scheduler/priority_queue.cc',
+      'base/task_scheduler/scheduler_lock_impl.cc',
+      'base/task_scheduler/scheduler_single_thread_task_runner_manager.cc',
+      'base/task_scheduler/scheduler_worker.cc',
+      'base/task_scheduler/scheduler_worker_pool.cc',
+      'base/task_scheduler/scheduler_worker_pool_impl.cc',
+      'base/task_scheduler/scheduler_worker_pool_params.cc',
+      'base/task_scheduler/scheduler_worker_stack.cc',
+      'base/task_scheduler/scoped_set_task_priority_for_current_thread.cc',
+      'base/task_scheduler/sequence.cc',
+      'base/task_scheduler/sequence_sort_key.cc',
+      'base/task_scheduler/task.cc',
+      'base/task_scheduler/task_scheduler.cc',
+      'base/task_scheduler/task_scheduler_impl.cc',
+      'base/task_scheduler/task_tracker.cc',
+      'base/task_scheduler/task_traits.cc',
+      'base/third_party/dmg_fp/dtoa_wrapper.cc',
+      'base/third_party/dmg_fp/g_fmt.cc',
+      'base/third_party/icu/icu_utf.cc',
+      'base/third_party/nspr/prtime.cc',
+      'base/threading/post_task_and_reply_impl.cc',
+      'base/threading/scoped_blocking_call.cc',
+      'base/threading/sequence_local_storage_map.cc',
+      'base/threading/sequenced_task_runner_handle.cc',
+      'base/threading/simple_thread.cc',
+      'base/threading/thread.cc',
+      'base/threading/thread_checker_impl.cc',
+      'base/threading/thread_collision_warner.cc',
+      'base/threading/thread_id_name_manager.cc',
+      'base/threading/thread_local_storage.cc',
+      'base/threading/thread_restrictions.cc',
+      'base/threading/thread_task_runner_handle.cc',
+      'base/time/clock.cc',
+      'base/time/default_clock.cc',
+      'base/time/default_tick_clock.cc',
+      'base/time/tick_clock.cc',
+      'base/time/time.cc',
+      'base/timer/elapsed_timer.cc',
+      'base/timer/timer.cc',
+      'base/trace_event/category_registry.cc',
+      'base/trace_event/event_name_filter.cc',
+      'base/trace_event/heap_profiler_allocation_context.cc',
+      'base/trace_event/heap_profiler_allocation_context_tracker.cc',
+      'base/trace_event/heap_profiler_allocation_register.cc',
+      'base/trace_event/heap_profiler_event_filter.cc',
+      'base/trace_event/heap_profiler_heap_dump_writer.cc',
+      'base/trace_event/heap_profiler_serialization_state.cc',
+      'base/trace_event/heap_profiler_stack_frame_deduplicator.cc',
+      'base/trace_event/heap_profiler_type_name_deduplicator.cc',
+      'base/trace_event/malloc_dump_provider.cc',
+      'base/trace_event/memory_allocator_dump.cc',
+      'base/trace_event/memory_allocator_dump_guid.cc',
+      'base/trace_event/memory_dump_manager.cc',
+      'base/trace_event/memory_dump_provider_info.cc',
+      'base/trace_event/memory_dump_request_args.cc',
+      'base/trace_event/memory_dump_scheduler.cc',
+      'base/trace_event/memory_infra_background_whitelist.cc',
+      'base/trace_event/memory_peak_detector.cc',
+      'base/trace_event/memory_usage_estimator.cc',
+      'base/trace_event/process_memory_dump.cc',
+      'base/trace_event/sharded_allocation_register.cc',
+      'base/trace_event/trace_buffer.cc',
+      'base/trace_event/trace_config.cc',
+      'base/trace_event/trace_config_category_filter.cc',
+      'base/trace_event/trace_event_argument.cc',
+      'base/trace_event/trace_event_filter.cc',
+      'base/trace_event/trace_event_impl.cc',
+      'base/trace_event/trace_event_memory_overhead.cc',
+      'base/trace_event/trace_log.cc',
+      'base/trace_event/trace_log_constants.cc',
+      'base/trace_event/tracing_agent.cc',
+      'base/unguessable_token.cc',
+      'base/value_iterators.cc',
+      'base/values.cc',
+      'base/vlog.cc',
+  ])
+
+  if is_posix:
+    static_libraries['base']['sources'].extend([
+        'base/base_paths_posix.cc',
+        'base/debug/debugger_posix.cc',
+        'base/debug/stack_trace_posix.cc',
+        'base/files/file_enumerator_posix.cc',
+        'base/files/file_descriptor_watcher_posix.cc',
+        'base/files/file_posix.cc',
+        'base/files/file_util_posix.cc',
+        'base/files/memory_mapped_file_posix.cc',
+        'base/memory/shared_memory_helper.cc',
+        'base/message_loop/message_pump_libevent.cc',
+        'base/posix/file_descriptor_shuffle.cc',
+        'base/posix/global_descriptors.cc',
+        'base/posix/safe_strerror.cc',
+        'base/process/kill_posix.cc',
+        'base/process/process_handle_posix.cc',
+        'base/process/process_metrics_posix.cc',
+        'base/process/process_posix.cc',
+        'base/rand_util_posix.cc',
+        'base/strings/string16.cc',
+        'base/synchronization/condition_variable_posix.cc',
+        'base/synchronization/lock_impl_posix.cc',
+        'base/sys_info_posix.cc',
+        'base/task_scheduler/task_tracker_posix.cc',
+        'base/threading/platform_thread_internal_posix.cc',
+        'base/threading/platform_thread_posix.cc',
+        'base/threading/thread_local_storage_posix.cc',
+        'base/time/time_conversion_posix.cc',
+        'base/trace_event/heap_profiler_allocation_register_posix.cc',
+    ])
+    static_libraries['libevent'] = {
+        'sources': [
+            'base/third_party/libevent/buffer.c',
+            'base/third_party/libevent/evbuffer.c',
+            'base/third_party/libevent/evdns.c',
+            'base/third_party/libevent/event.c',
+            'base/third_party/libevent/event_tagging.c',
+            'base/third_party/libevent/evrpc.c',
+            'base/third_party/libevent/evutil.c',
+            'base/third_party/libevent/http.c',
+            'base/third_party/libevent/log.c',
+            'base/third_party/libevent/poll.c',
+            'base/third_party/libevent/select.c',
+            'base/third_party/libevent/signal.c',
+            'base/third_party/libevent/strlcpy.c',
+        ],
+        'tool': 'cc',
+        'include_dirs': [],
+        'cflags': cflags + ['-DHAVE_CONFIG_H'],
+    }
+
+  if is_linux or is_aix:
+    static_libraries['xdg_user_dirs'] = {
+        'sources': [
+            'base/third_party/xdg_user_dirs/xdg_user_dir_lookup.cc',
+        ],
+        'tool': 'cxx',
+    }
+    static_libraries['base']['sources'].extend([
+        'base/memory/shared_memory_handle_posix.cc',
+        'base/memory/shared_memory_posix.cc',
+        'base/nix/xdg_util.cc',
+        'base/process/internal_linux.cc',
+        'base/process/memory_linux.cc',
+        'base/process/process_handle_linux.cc',
+        'base/process/process_info_linux.cc',
+        'base/process/process_iterator_linux.cc',
+        'base/process/process_linux.cc',
+        'base/process/process_metrics_linux.cc',
+        'base/strings/sys_string_conversions_posix.cc',
+        'base/synchronization/waitable_event_posix.cc',
+        'base/sys_info_linux.cc',
+        'base/time/time_exploded_posix.cc',
+        'base/time/time_now_posix.cc',
+        'base/threading/platform_thread_linux.cc',
+    ])
+    if is_linux:
+      libcxx_root = SRC_ROOT + '/buildtools/third_party/libc++/trunk'
+      libcxxabi_root = SRC_ROOT + '/buildtools/third_party/libc++abi/trunk'
+      cflags_cc.extend([
+          '-nostdinc++',
+          '-isystem' + libcxx_root + '/include',
+          '-isystem' + libcxxabi_root + '/include',
+      ])
+      ldflags.extend(['-nodefaultlibs'])
+      libs.extend([
+          '-lc',
+          '-lgcc_s',
+          '-lm',
+          '-lpthread',
+      ])
+      static_libraries['libc++'] = {
+          'sources': [
+              libcxx_root + '/src/algorithm.cpp',
+              libcxx_root + '/src/any.cpp',
+              libcxx_root + '/src/bind.cpp',
+              libcxx_root + '/src/chrono.cpp',
+              libcxx_root + '/src/condition_variable.cpp',
+              libcxx_root + '/src/debug.cpp',
+              libcxx_root + '/src/exception.cpp',
+              libcxx_root + '/src/functional.cpp',
+              libcxx_root + '/src/future.cpp',
+              libcxx_root + '/src/hash.cpp',
+              libcxx_root + '/src/ios.cpp',
+              libcxx_root + '/src/iostream.cpp',
+              libcxx_root + '/src/locale.cpp',
+              libcxx_root + '/src/memory.cpp',
+              libcxx_root + '/src/mutex.cpp',
+              libcxx_root + '/src/new.cpp',
+              libcxx_root + '/src/optional.cpp',
+              libcxx_root + '/src/random.cpp',
+              libcxx_root + '/src/regex.cpp',
+              libcxx_root + '/src/shared_mutex.cpp',
+              libcxx_root + '/src/stdexcept.cpp',
+              libcxx_root + '/src/string.cpp',
+              libcxx_root + '/src/strstream.cpp',
+              libcxx_root + '/src/system_error.cpp',
+              libcxx_root + '/src/thread.cpp',
+              libcxx_root + '/src/typeinfo.cpp',
+              libcxx_root + '/src/utility.cpp',
+              libcxx_root + '/src/valarray.cpp',
+              libcxx_root + '/src/variant.cpp',
+              libcxx_root + '/src/vector.cpp',
+          ],
+          'tool': 'cxx',
+          'cflags': cflags + [
+              '-D_LIBCPP_NO_EXCEPTIONS',
+              '-D_LIBCPP_BUILDING_LIBRARY',
+              '-DLIBCXX_BUILDING_LIBCXXABI',
+          ]
+      }
+      static_libraries['libc++abi'] = {
+          'sources': [
+              libcxxabi_root + '/src/abort_message.cpp',
+              libcxxabi_root + '/src/cxa_aux_runtime.cpp',
+              libcxxabi_root + '/src/cxa_default_handlers.cpp',
+              libcxxabi_root + '/src/cxa_demangle.cpp',
+              libcxxabi_root + '/src/cxa_exception_storage.cpp',
+              libcxxabi_root + '/src/cxa_guard.cpp',
+              libcxxabi_root + '/src/cxa_handlers.cpp',
+              libcxxabi_root + '/src/cxa_noexception.cpp',
+              libcxxabi_root + '/src/cxa_unexpected.cpp',
+              libcxxabi_root + '/src/cxa_vector.cpp',
+              libcxxabi_root + '/src/cxa_virtual.cpp',
+              libcxxabi_root + '/src/fallback_malloc.cpp',
+              libcxxabi_root + '/src/private_typeinfo.cpp',
+              libcxxabi_root + '/src/stdlib_exception.cpp',
+              libcxxabi_root + '/src/stdlib_stdexcept.cpp',
+              libcxxabi_root + '/src/stdlib_typeinfo.cpp',
+          ],
+          'tool': 'cxx',
+          'cflags': cflags + [
+              '-DLIBCXXABI_SILENT_TERMINATE',
+              '-D_LIBCXXABI_NO_EXCEPTIONS',
+          ]
+      }
+      static_libraries['base']['sources'].extend([
+        'base/allocator/allocator_shim.cc',
+        'base/allocator/allocator_shim_default_dispatch_to_glibc.cc',
+      ])
+      libs.extend(['-lrt', '-latomic'])
+      static_libraries['libevent']['include_dirs'].extend([
+          os.path.join(SRC_ROOT, 'base', 'third_party', 'libevent', 'linux')
+      ])
+      static_libraries['libevent']['sources'].extend([
+         'base/third_party/libevent/epoll.c',
+      ])
+    else:
+      ldflags.extend(['-pthread'])
+      libs.extend(['-lrt'])
+      static_libraries['base']['sources'].extend([
+          'base/process/internal_aix.cc'
+      ])
+      static_libraries['libevent']['include_dirs'].extend([
+          os.path.join(SRC_ROOT, 'base', 'third_party', 'libevent', 'aix')
+      ])
+      static_libraries['libevent']['include_dirs'].extend([
+          os.path.join(SRC_ROOT, 'base', 'third_party', 'libevent', 'compat')
+      ])
+
+  if is_mac:
+    static_libraries['base']['sources'].extend([
+        'base/base_paths_mac.mm',
+        'base/files/file_util_mac.mm',
+        'base/mac/bundle_locations.mm',
+        'base/mac/call_with_eh_frame.cc',
+        'base/mac/call_with_eh_frame_asm.S',
+        'base/mac/foundation_util.mm',
+        'base/mac/mach_logging.cc',
+        'base/mac/scoped_mach_port.cc',
+        'base/mac/scoped_mach_vm.cc',
+        'base/mac/scoped_nsautorelease_pool.mm',
+        'base/memory/shared_memory_handle_mac.cc',
+        'base/memory/shared_memory_mac.cc',
+        'base/message_loop/message_pump_mac.mm',
+        'base/process/process_handle_mac.cc',
+        'base/process/process_info_mac.cc',
+        'base/process/process_iterator_mac.cc',
+        'base/process/process_metrics_mac.cc',
+        'base/strings/sys_string_conversions_mac.mm',
+        'base/synchronization/waitable_event_mac.cc',
+        'base/sys_info_mac.mm',
+        'base/time/time_exploded_posix.cc',
+        'base/time/time_mac.cc',
+        'base/threading/platform_thread_mac.mm',
+    ])
+    static_libraries['libevent']['include_dirs'].extend([
+        os.path.join(SRC_ROOT, 'base', 'third_party', 'libevent', 'mac')
+    ])
+    static_libraries['libevent']['sources'].extend([
+        'base/third_party/libevent/kqueue.c',
+    ])
+
+    libs.extend([
+        '-framework', 'AppKit',
+        '-framework', 'CoreFoundation',
+        '-framework', 'Foundation',
+        '-framework', 'Security',
+    ])
+
+  if is_win:
+    static_libraries['base']['sources'].extend([
+        "base/allocator/partition_allocator/address_space_randomization.cc",
+        'base/allocator/partition_allocator/page_allocator.cc',
+        "base/allocator/partition_allocator/spin_lock.cc",
+        'base/base_paths_win.cc',
+        'base/cpu.cc',
+        'base/debug/close_handle_hook_win.cc',
+        'base/debug/debugger.cc',
+        'base/debug/debugger_win.cc',
+        'base/debug/profiler.cc',
+        'base/debug/stack_trace_win.cc',
+        'base/file_version_info_win.cc',
+        'base/files/file_enumerator_win.cc',
+        'base/files/file_path_watcher_win.cc',
+        'base/files/file_util_win.cc',
+        'base/files/file_win.cc',
+        'base/files/memory_mapped_file_win.cc',
+        'base/guid.cc',
+        'base/logging_win.cc',
+        'base/memory/memory_pressure_monitor_win.cc',
+        'base/memory/shared_memory_handle_win.cc',
+        'base/memory/shared_memory_win.cc',
+        'base/message_loop/message_pump_win.cc',
+        'base/native_library_win.cc',
+        'base/power_monitor/power_monitor_device_source_win.cc',
+        'base/process/kill_win.cc',
+        'base/process/launch_win.cc',
+        'base/process/memory_win.cc',
+        'base/process/process_handle_win.cc',
+        'base/process/process_info_win.cc',
+        'base/process/process_iterator_win.cc',
+        'base/process/process_metrics_win.cc',
+        'base/process/process_win.cc',
+        'base/profiler/native_stack_sampler_win.cc',
+        'base/profiler/win32_stack_frame_unwinder.cc',
+        'base/rand_util_win.cc',
+        'base/strings/sys_string_conversions_win.cc',
+        'base/sync_socket_win.cc',
+        'base/synchronization/condition_variable_win.cc',
+        'base/synchronization/lock_impl_win.cc',
+        'base/synchronization/waitable_event_watcher_win.cc',
+        'base/synchronization/waitable_event_win.cc',
+        'base/sys_info_win.cc',
+        'base/threading/platform_thread_win.cc',
+        'base/threading/thread_local_storage_win.cc',
+        'base/time/time_win.cc',
+        'base/timer/hi_res_timer_manager_win.cc',
+        'base/trace_event/heap_profiler_allocation_register_win.cc',
+        'base/trace_event/trace_event_etw_export_win.cc',
+        'base/win/core_winrt_util.cc',
+        'base/win/enum_variant.cc',
+        'base/win/event_trace_controller.cc',
+        'base/win/event_trace_provider.cc',
+        'base/win/i18n.cc',
+        'base/win/iat_patch_function.cc',
+        'base/win/iunknown_impl.cc',
+        'base/win/message_window.cc',
+        'base/win/object_watcher.cc',
+        'base/win/pe_image.cc',
+        'base/win/process_startup_helper.cc',
+        'base/win/registry.cc',
+        'base/win/resource_util.cc',
+        'base/win/scoped_bstr.cc',
+        'base/win/scoped_com_initializer.cc',
+        'base/win/scoped_handle.cc',
+        'base/win/scoped_handle_verifier.cc',
+        'base/win/scoped_process_information.cc',
+        'base/win/scoped_variant.cc',
+        'base/win/scoped_winrt_initializer.cc',
+        'base/win/shortcut.cc',
+        'base/win/startup_information.cc',
+        'base/win/wait_chain.cc',
+        'base/win/win_util.cc',
+        'base/win/windows_version.cc',
+        'base/win/wrapped_window_proc.cc',
+    ])
+
+    libs.extend([
+        'advapi32.lib',
+        'dbghelp.lib',
+        'kernel32.lib',
+        'ole32.lib',
+        'shell32.lib',
+        'user32.lib',
+        'userenv.lib',
+        'version.lib',
+        'winmm.lib',
+        'ws2_32.lib',
+        'Shlwapi.lib',
+    ])
+
+  # we just build static libraries that GN needs
+  executables['gn']['libs'].extend(static_libraries.keys())
+
+  write_generic_ninja(path, static_libraries, executables, cc, cxx, ar, ld,
+                      cflags, cflags_cc, ldflags, include_dirs, libs)
+
+def build_gn_with_gn(temp_gn, build_dir, options):
+  gn_gen_args = options.gn_gen_args or ''
+  if not options.debug:
+    gn_gen_args += ' is_debug=false'
+  cmd = [temp_gn, 'gen', build_dir, '--args=%s' % gn_gen_args,
+          "--root="+SRC_ROOT
+         ]
+  check_call(cmd)
+
+  cmd = ['ninja', '-C', build_dir, '-w', 'dupbuild=err']
+  if options.verbose:
+    cmd.append('-v')
+  cmd.append('gn')
+  check_call(cmd)
+
+  # build.ninja currently refers back to gn from the temporary directory.
+  # Regenerate the build files using the gn we just built so that the reference
+  # gets updated to "./gn".
+  cmd = [os.path.join(build_dir, 'gn'), 'gen', build_dir,
+         '--args=%s' % gn_gen_args]
+  check_call(cmd)
+
+  if not options.debug and not is_win:
+    check_call(['strip', os.path.join(build_dir, 'gn')])
+
+
+if __name__ == '__main__':
+  sys.exit(main(sys.argv[1:]))
diff -Naur chromium-67.0.3396.87/tools/gn/BUILD.gn chromium-67.0.3396.87-patched/tools/gn/BUILD.gn
--- chromium-67.0.3396.87/tools/gn/BUILD.gn	2018-06-13 01:11:08.000000000 +0300
+++ chromium-67.0.3396.87-patched/tools/gn/BUILD.gn	2018-07-06 16:13:44.007858003 +0300
@@ -269,7 +269,6 @@
 
   deps = [
     ":gn_lib",
-    ":last_commit_position",
     "//base",
     "//build/config:exe_and_shlib_deps",
     "//build/win:default_exe_manifest",
diff -Naur chromium-67.0.3396.87/tools/gn/BUILD.gn.orig chromium-67.0.3396.87-patched/tools/gn/BUILD.gn.orig
--- chromium-67.0.3396.87/tools/gn/BUILD.gn.orig	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/tools/gn/BUILD.gn.orig	2018-06-13 01:11:08.000000000 +0300
@@ -0,0 +1,375 @@
+# Copyright (c) 2013 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/jumbo.gni")
+import("//testing/test.gni")
+import("//testing/libfuzzer/fuzzer_test.gni")
+
+defines = [ "GN_BUILD" ]
+
+jumbo_static_library("gn_lib") {
+  configs += [ "//build/config:precompiled_headers" ]
+
+  sources = [
+    "action_target_generator.cc",
+    "action_target_generator.h",
+    "action_values.cc",
+    "action_values.h",
+    "analyzer.cc",
+    "analyzer.h",
+    "args.cc",
+    "args.h",
+    "binary_target_generator.cc",
+    "binary_target_generator.h",
+    "build_settings.cc",
+    "build_settings.h",
+    "builder.cc",
+    "builder.h",
+    "builder_record.cc",
+    "builder_record.h",
+    "bundle_data.cc",
+    "bundle_data.h",
+    "bundle_data_target_generator.cc",
+    "bundle_data_target_generator.h",
+    "bundle_file_rule.cc",
+    "bundle_file_rule.h",
+    "c_include_iterator.cc",
+    "c_include_iterator.h",
+    "command_analyze.cc",
+    "command_args.cc",
+    "command_check.cc",
+    "command_clean.cc",
+    "command_desc.cc",
+    "command_format.cc",
+    "command_format.h",
+    "command_gen.cc",
+    "command_help.cc",
+    "command_ls.cc",
+    "command_path.cc",
+    "command_refs.cc",
+    "commands.cc",
+    "commands.h",
+    "config.cc",
+    "config.h",
+    "config_values.cc",
+    "config_values.h",
+    "config_values_extractors.cc",
+    "config_values_extractors.h",
+    "config_values_generator.cc",
+    "config_values_generator.h",
+    "copy_target_generator.cc",
+    "copy_target_generator.h",
+    "create_bundle_target_generator.cc",
+    "create_bundle_target_generator.h",
+    "deps_iterator.cc",
+    "deps_iterator.h",
+    "desc_builder.cc",
+    "desc_builder.h",
+    "eclipse_writer.cc",
+    "eclipse_writer.h",
+    "err.cc",
+    "err.h",
+    "escape.cc",
+    "escape.h",
+    "exec_process.cc",
+    "exec_process.h",
+    "filesystem_utils.cc",
+    "filesystem_utils.h",
+    "function_exec_script.cc",
+    "function_foreach.cc",
+    "function_forward_variables_from.cc",
+    "function_get_label_info.cc",
+    "function_get_path_info.cc",
+    "function_get_target_outputs.cc",
+    "function_process_file_template.cc",
+    "function_read_file.cc",
+    "function_rebase_path.cc",
+    "function_set_default_toolchain.cc",
+    "function_set_defaults.cc",
+    "function_template.cc",
+    "function_toolchain.cc",
+    "function_write_file.cc",
+    "functions.cc",
+    "functions.h",
+    "functions_target.cc",
+    "group_target_generator.cc",
+    "group_target_generator.h",
+    "header_checker.cc",
+    "header_checker.h",
+    "import_manager.cc",
+    "import_manager.h",
+    "inherited_libraries.cc",
+    "inherited_libraries.h",
+    "input_conversion.cc",
+    "input_conversion.h",
+    "input_file.cc",
+    "input_file.h",
+    "input_file_manager.cc",
+    "input_file_manager.h",
+    "item.cc",
+    "item.h",
+    "json_project_writer.cc",
+    "json_project_writer.h",
+    "label.cc",
+    "label.h",
+    "label_pattern.cc",
+    "label_pattern.h",
+    "label_ptr.h",
+    "lib_file.cc",
+    "lib_file.h",
+    "loader.cc",
+    "loader.h",
+    "location.cc",
+    "location.h",
+    "ninja_action_target_writer.cc",
+    "ninja_action_target_writer.h",
+    "ninja_binary_target_writer.cc",
+    "ninja_binary_target_writer.h",
+    "ninja_build_writer.cc",
+    "ninja_build_writer.h",
+    "ninja_bundle_data_target_writer.cc",
+    "ninja_bundle_data_target_writer.h",
+    "ninja_copy_target_writer.cc",
+    "ninja_copy_target_writer.h",
+    "ninja_create_bundle_target_writer.cc",
+    "ninja_create_bundle_target_writer.h",
+    "ninja_group_target_writer.cc",
+    "ninja_group_target_writer.h",
+    "ninja_target_writer.cc",
+    "ninja_target_writer.h",
+    "ninja_toolchain_writer.cc",
+    "ninja_toolchain_writer.h",
+    "ninja_utils.cc",
+    "ninja_utils.h",
+    "ninja_writer.cc",
+    "ninja_writer.h",
+    "operators.cc",
+    "operators.h",
+    "output_file.cc",
+    "output_file.h",
+    "parse_node_value_adapter.cc",
+    "parse_node_value_adapter.h",
+    "parse_tree.cc",
+    "parse_tree.h",
+    "parser.cc",
+    "parser.h",
+    "path_output.cc",
+    "path_output.h",
+    "pattern.cc",
+    "pattern.h",
+    "pool.cc",
+    "pool.h",
+    "qt_creator_writer.cc",
+    "qt_creator_writer.h",
+    "runtime_deps.cc",
+    "runtime_deps.h",
+    "scheduler.cc",
+    "scheduler.h",
+    "scope.cc",
+    "scope.h",
+    "scope_per_file_provider.cc",
+    "scope_per_file_provider.h",
+    "settings.cc",
+    "settings.h",
+    "setup.cc",
+    "setup.h",
+    "source_dir.cc",
+    "source_dir.h",
+    "source_file.cc",
+    "source_file.h",
+    "source_file_type.cc",
+    "source_file_type.h",
+    "standard_out.cc",
+    "standard_out.h",
+    "string_utils.cc",
+    "string_utils.h",
+    "substitution_list.cc",
+    "substitution_list.h",
+    "substitution_pattern.cc",
+    "substitution_pattern.h",
+    "substitution_type.cc",
+    "substitution_type.h",
+    "substitution_writer.cc",
+    "substitution_writer.h",
+    "switches.cc",
+    "switches.h",
+    "target.cc",
+    "target.h",
+    "target_generator.cc",
+    "target_generator.h",
+    "template.cc",
+    "template.h",
+    "token.cc",
+    "token.h",
+    "tokenizer.cc",
+    "tokenizer.h",
+    "tool.cc",
+    "tool.h",
+    "toolchain.cc",
+    "toolchain.h",
+    "trace.cc",
+    "trace.h",
+    "unique_vector.h",
+    "value.cc",
+    "value.h",
+    "value_extractors.cc",
+    "value_extractors.h",
+    "variables.cc",
+    "variables.h",
+    "visibility.cc",
+    "visibility.h",
+    "visual_studio_utils.cc",
+    "visual_studio_utils.h",
+    "visual_studio_writer.cc",
+    "visual_studio_writer.h",
+    "xcode_object.cc",
+    "xcode_object.h",
+    "xcode_writer.cc",
+    "xcode_writer.h",
+    "xml_element_writer.cc",
+    "xml_element_writer.h",
+  ]
+
+  deps = [
+    "//base",
+    "//base/third_party/dynamic_annotations",
+  ]
+}
+
+action("last_commit_position") {
+  script = "last_commit_position.py"
+
+  # This dependency forces a re-run when the code is synced.
+  inputs = [
+    "//build/util/LASTCHANGE",
+  ]
+
+  outfile = "$target_gen_dir/last_commit_position.h"
+  outputs = [
+    outfile,
+  ]
+
+  args = [
+    rebase_path("//", root_build_dir),
+    rebase_path(outfile, root_build_dir),
+    "TOOLS_GN_LAST_COMMIT_POSITION_H_",
+  ]
+}
+
+# Note for Windows debugging: GN is super-multithreaded and uses a lot of STL.
+# Iterator debugging on Windows does locking for every access, which ends up
+# slowing down debug runtime from 0:36 to 9:40. If you want to run debug builds
+# of GN over the large Chrome build, you will want to set the arg:
+#   enable_iterator_debugging = false
+executable("gn") {
+  sources = [
+    "gn_main.cc",
+  ]
+
+  deps = [
+    ":gn_lib",
+    ":last_commit_position",
+    "//base",
+    "//build/config:exe_and_shlib_deps",
+    "//build/win:default_exe_manifest",
+  ]
+}
+
+test("gn_unittests") {
+  deps = [
+    ":gn_unittests_sources",
+  ]
+
+  data = [
+    "format_test_data/",
+  ]
+}
+
+jumbo_source_set("gn_unittests_sources") {
+  testonly = true
+
+  sources = [
+    "action_target_generator_unittest.cc",
+    "analyzer_unittest.cc",
+    "args_unittest.cc",
+    "builder_unittest.cc",
+    "c_include_iterator_unittest.cc",
+    "command_format_unittest.cc",
+    "config_unittest.cc",
+    "config_values_extractors_unittest.cc",
+    "escape_unittest.cc",
+    "exec_process_unittest.cc",
+    "filesystem_utils_unittest.cc",
+    "function_foreach_unittest.cc",
+    "function_forward_variables_from_unittest.cc",
+    "function_get_label_info_unittest.cc",
+    "function_get_path_info_unittest.cc",
+    "function_get_target_outputs_unittest.cc",
+    "function_process_file_template_unittest.cc",
+    "function_rebase_path_unittest.cc",
+    "function_template_unittest.cc",
+    "function_toolchain_unittest.cc",
+    "function_write_file_unittest.cc",
+    "functions_target_unittest.cc",
+    "functions_unittest.cc",
+    "header_checker_unittest.cc",
+    "inherited_libraries_unittest.cc",
+    "input_conversion_unittest.cc",
+    "label_pattern_unittest.cc",
+    "label_unittest.cc",
+    "loader_unittest.cc",
+    "ninja_action_target_writer_unittest.cc",
+    "ninja_binary_target_writer_unittest.cc",
+    "ninja_build_writer_unittest.cc",
+    "ninja_bundle_data_target_writer_unittest.cc",
+    "ninja_copy_target_writer_unittest.cc",
+    "ninja_create_bundle_target_writer_unittest.cc",
+    "ninja_group_target_writer_unittest.cc",
+    "ninja_target_writer_unittest.cc",
+    "ninja_toolchain_writer_unittest.cc",
+    "operators_unittest.cc",
+    "parse_tree_unittest.cc",
+    "parser_unittest.cc",
+    "path_output_unittest.cc",
+    "pattern_unittest.cc",
+    "runtime_deps_unittest.cc",
+    "scope_per_file_provider_unittest.cc",
+    "scope_unittest.cc",
+    "source_dir_unittest.cc",
+    "source_file_unittest.cc",
+    "string_utils_unittest.cc",
+    "substitution_pattern_unittest.cc",
+    "substitution_writer_unittest.cc",
+    "target_unittest.cc",
+    "template_unittest.cc",
+    "test_with_scheduler.cc",
+    "test_with_scheduler.h",
+    "test_with_scope.cc",
+    "test_with_scope.h",
+    "tokenizer_unittest.cc",
+    "unique_vector_unittest.cc",
+    "value_unittest.cc",
+    "visibility_unittest.cc",
+    "visual_studio_utils_unittest.cc",
+    "visual_studio_writer_unittest.cc",
+    "xcode_object_unittest.cc",
+    "xml_element_writer_unittest.cc",
+  ]
+
+  public_deps = [
+    ":gn_lib",
+    "//base/test:run_all_unittests",
+    "//base/test:test_support",
+    "//testing/gtest",
+  ]
+}
+
+fuzzer_test("gn_parser_fuzzer") {
+  sources = [
+    "parser_fuzzer.cc",
+  ]
+  deps = [
+    ":gn_lib",
+  ]
+}
diff -Naur chromium-67.0.3396.87/tools/gn/gn_main.cc chromium-67.0.3396.87-patched/tools/gn/gn_main.cc
--- chromium-67.0.3396.87/tools/gn/gn_main.cc	2018-06-13 01:11:08.000000000 +0300
+++ chromium-67.0.3396.87-patched/tools/gn/gn_main.cc	2018-07-06 16:13:44.011191336 +0300
@@ -19,13 +19,7 @@
 #include "tools/gn/standard_out.h"
 #include "tools/gn/switches.h"
 
-// Only the GN-generated build makes this header for now.
-// TODO(brettw) consider adding this if we need it in GYP.
-#if defined(GN_BUILD)
-#include "tools/gn/last_commit_position.h"
-#else
 #define LAST_COMMIT_POSITION "UNKNOWN"
-#endif
 
 namespace {
 
diff -Naur chromium-67.0.3396.87/tools/gn/gn_main.cc.orig chromium-67.0.3396.87-patched/tools/gn/gn_main.cc.orig
--- chromium-67.0.3396.87/tools/gn/gn_main.cc.orig	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/tools/gn/gn_main.cc.orig	2018-06-13 01:11:08.000000000 +0300
@@ -0,0 +1,144 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <algorithm>
+#include <string>
+
+#include "base/at_exit.h"
+#include "base/command_line.h"
+#include "base/message_loop/message_loop.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/sys_info.h"
+#include "base/task_scheduler/task_scheduler.h"
+#include "build/build_config.h"
+#include "tools/gn/commands.h"
+#include "tools/gn/err.h"
+#include "tools/gn/location.h"
+#include "tools/gn/standard_out.h"
+#include "tools/gn/switches.h"
+
+// Only the GN-generated build makes this header for now.
+// TODO(brettw) consider adding this if we need it in GYP.
+#if defined(GN_BUILD)
+#include "tools/gn/last_commit_position.h"
+#else
+#define LAST_COMMIT_POSITION "UNKNOWN"
+#endif
+
+namespace {
+
+std::vector<std::string> GetArgs(const base::CommandLine& cmdline) {
+  base::CommandLine::StringVector in_args = cmdline.GetArgs();
+#if defined(OS_WIN)
+  std::vector<std::string> out_args;
+  for (const auto& arg : in_args)
+    out_args.push_back(base::WideToUTF8(arg));
+  return out_args;
+#else
+  return in_args;
+#endif
+}
+
+int GetThreadCount() {
+  std::string thread_count =
+      base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
+          switches::kThreads);
+
+  // See if an override was specified on the command line.
+  int result;
+  if (!thread_count.empty() && base::StringToInt(thread_count, &result) &&
+      result >= 1) {
+    return result;
+  }
+
+  // Base the default number of worker threads on number of cores in the
+  // system. When building large projects, the speed can be limited by how fast
+  // the main thread can dispatch work and connect the dependency graph. If
+  // there are too many worker threads, the main thread can be starved and it
+  // will run slower overall.
+  //
+  // One less worker thread than the number of physical CPUs seems to be a
+  // good value, both theoretically and experimentally. But always use at
+  // least some workers to prevent us from being too sensitive to I/O latency
+  // on low-end systems.
+  //
+  // The minimum thread count is based on measuring the optimal threads for the
+  // Chrome build on a several-year-old 4-core MacBook.
+  // Almost all CPUs now are hyperthreaded.
+  int num_cores = base::SysInfo::NumberOfProcessors() / 2;
+  return std::max(num_cores - 1, 8);
+}
+
+void StartTaskScheduler() {
+  constexpr base::TimeDelta kSuggestedReclaimTime =
+      base::TimeDelta::FromSeconds(30);
+
+  constexpr int kBackgroundMaxThreads = 1;
+  constexpr int kBackgroundBlockingMaxThreads = 2;
+  const int kForegroundMaxThreads =
+      std::max(1, base::SysInfo::NumberOfProcessors());
+  const int foreground_blocking_max_threads = GetThreadCount();
+
+  base::TaskScheduler::Create("gn");
+  base::TaskScheduler::GetInstance()->Start(
+      {{kBackgroundMaxThreads, kSuggestedReclaimTime},
+       {kBackgroundBlockingMaxThreads, kSuggestedReclaimTime},
+       {kForegroundMaxThreads, kSuggestedReclaimTime},
+       {foreground_blocking_max_threads, kSuggestedReclaimTime}});
+}
+
+}  // namespace
+
+int main(int argc, char** argv) {
+  base::AtExitManager at_exit;
+#if defined(OS_WIN)
+  base::CommandLine::set_slash_is_not_a_switch();
+#endif
+  base::CommandLine::Init(argc, argv);
+
+  const base::CommandLine& cmdline = *base::CommandLine::ForCurrentProcess();
+  std::vector<std::string> args = GetArgs(cmdline);
+
+  std::string command;
+  if (cmdline.HasSwitch("help") || cmdline.HasSwitch("h")) {
+    // Make "-h" and "--help" default to help command.
+    command = commands::kHelp;
+  } else if (cmdline.HasSwitch(switches::kVersion)) {
+    // Make "--version" print the version and exit.
+    OutputString(std::string(LAST_COMMIT_POSITION) + "\n");
+    exit(0);
+  } else if (args.empty()) {
+    // No command, print error and exit.
+    Err(Location(), "No command specified.",
+        "Most commonly you want \"gn gen <out_dir>\" to make a build dir.\n"
+        "Or try \"gn help\" for more commands.").PrintToStdout();
+    return 1;
+  } else {
+    command = args[0];
+    args.erase(args.begin());
+  }
+
+  const commands::CommandInfoMap& command_map = commands::GetCommands();
+  commands::CommandInfoMap::const_iterator found_command =
+      command_map.find(command);
+
+  int retval;
+  if (found_command != command_map.end()) {
+    base::MessageLoop message_loop;
+    StartTaskScheduler();
+    retval = found_command->second.runner(args);
+    base::TaskScheduler::GetInstance()->Shutdown();
+  } else {
+    Err(Location(), "Command \"" + command + "\" unknown.").PrintToStdout();
+    OutputString(
+        "Available commands (type \"gn help <command>\" for more details):\n");
+    for (const auto& cmd : commands::GetCommands())
+      PrintShortHelp(cmd.second.help_short);
+
+    retval = 1;
+  }
+
+  exit(retval);  // Don't free memory, it can be really slow!
+}
diff -Naur chromium-67.0.3396.87/ui/events/devices/x11/device_data_manager_x11.cc chromium-67.0.3396.87-patched/ui/events/devices/x11/device_data_manager_x11.cc
--- chromium-67.0.3396.87/ui/events/devices/x11/device_data_manager_x11.cc	2018-06-13 01:11:10.000000000 +0300
+++ chromium-67.0.3396.87-patched/ui/events/devices/x11/device_data_manager_x11.cc	2018-07-06 16:13:44.017858001 +0300
@@ -785,15 +785,6 @@
   DCHECK(deviceid >= 0 && deviceid < kMaxDeviceNum);
   ScrollInfo& info = scroll_data_[deviceid];
 
-  bool legacy_scroll_available =
-      (scroll_class_info->flags & XIScrollFlagNoEmulation) == 0;
-  // If the device's highest resolution is lower than the resolution of xinput1
-  // then use xinput1's events instead (ie. don't configure smooth scrolling).
-  if (legacy_scroll_available &&
-      std::abs(scroll_class_info->increment) <= 1.0) {
-    return;
-  }
-
   switch (scroll_class_info->scroll_type) {
     case XIScrollTypeVertical:
       info.vertical.number = scroll_class_info->number;
diff -Naur chromium-67.0.3396.87/ui/events/devices/x11/device_data_manager_x11.cc.orig chromium-67.0.3396.87-patched/ui/events/devices/x11/device_data_manager_x11.cc.orig
--- chromium-67.0.3396.87/ui/events/devices/x11/device_data_manager_x11.cc.orig	1970-01-01 03:00:00.000000000 +0300
+++ chromium-67.0.3396.87-patched/ui/events/devices/x11/device_data_manager_x11.cc.orig	2018-06-13 01:11:10.000000000 +0300
@@ -0,0 +1,903 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/events/devices/x11/device_data_manager_x11.h"
+
+#include <stddef.h>
+
+#include <utility>
+
+#include "base/bind.h"
+#include "base/bind_helpers.h"
+#include "base/command_line.h"
+#include "base/logging.h"
+#include "base/macros.h"
+#include "base/memory/singleton.h"
+#include "base/sys_info.h"
+#include "build/build_config.h"
+#include "ui/display/display.h"
+#include "ui/events/devices/x11/device_list_cache_x11.h"
+#include "ui/events/devices/x11/touch_factory_x11.h"
+#include "ui/events/event_constants.h"
+#include "ui/events/event_switches.h"
+#include "ui/events/keycodes/keyboard_code_conversion_x.h"
+#include "ui/gfx/geometry/point3_f.h"
+#include "ui/gfx/x/x11.h"
+#include "ui/gfx/x/x11_atom_cache.h"
+
+// XIScrollClass was introduced in XI 2.1 so we need to define it here
+// for backward-compatibility with older versions of XInput.
+#if !defined(XIScrollClass)
+#define XIScrollClass 3
+#endif
+
+// Multi-touch support was introduced in XI 2.2. Add XI event types here
+// for backward-compatibility with older versions of XInput.
+#if !defined(XI_TouchBegin)
+#define XI_TouchBegin  18
+#define XI_TouchUpdate 19
+#define XI_TouchEnd    20
+#endif
+
+// Copied from xserver-properties.h
+#define AXIS_LABEL_PROP_REL_HWHEEL "Rel Horiz Wheel"
+#define AXIS_LABEL_PROP_REL_WHEEL "Rel Vert Wheel"
+
+// CMT specific timings
+#define AXIS_LABEL_PROP_ABS_DBL_START_TIME "Abs Dbl Start Timestamp"
+#define AXIS_LABEL_PROP_ABS_DBL_END_TIME   "Abs Dbl End Timestamp"
+
+// Ordinal values
+#define AXIS_LABEL_PROP_ABS_DBL_ORDINAL_X   "Abs Dbl Ordinal X"
+#define AXIS_LABEL_PROP_ABS_DBL_ORDINAL_Y   "Abs Dbl Ordinal Y"
+
+// Fling properties
+#define AXIS_LABEL_PROP_ABS_DBL_FLING_VX   "Abs Dbl Fling X Velocity"
+#define AXIS_LABEL_PROP_ABS_DBL_FLING_VY   "Abs Dbl Fling Y Velocity"
+#define AXIS_LABEL_PROP_ABS_FLING_STATE   "Abs Fling State"
+
+#define AXIS_LABEL_PROP_ABS_FINGER_COUNT   "Abs Finger Count"
+
+// Cros metrics gesture from touchpad
+#define AXIS_LABEL_PROP_ABS_METRICS_TYPE      "Abs Metrics Type"
+#define AXIS_LABEL_PROP_ABS_DBL_METRICS_DATA1 "Abs Dbl Metrics Data 1"
+#define AXIS_LABEL_PROP_ABS_DBL_METRICS_DATA2 "Abs Dbl Metrics Data 2"
+
+// Touchscreen multi-touch
+#define AXIS_LABEL_ABS_MT_TOUCH_MAJOR "Abs MT Touch Major"
+#define AXIS_LABEL_ABS_MT_TOUCH_MINOR "Abs MT Touch Minor"
+#define AXIS_LABEL_ABS_MT_ORIENTATION "Abs MT Orientation"
+#define AXIS_LABEL_ABS_MT_PRESSURE    "Abs MT Pressure"
+#define AXIS_LABEL_ABS_MT_POSITION_X  "Abs MT Position X"
+#define AXIS_LABEL_ABS_MT_POSITION_Y  "Abs MT Position Y"
+#define AXIS_LABEL_ABS_MT_TRACKING_ID "Abs MT Tracking ID"
+#define AXIS_LABEL_TOUCH_TIMESTAMP    "Touch Timestamp"
+
+// When you add new data types, please make sure the order here is aligned
+// with the order in the DataType enum in the header file because we assume
+// they are in sync when updating the device list (see UpdateDeviceList).
+constexpr const char* kCachedAtoms[] = {
+    AXIS_LABEL_PROP_REL_HWHEEL,
+    AXIS_LABEL_PROP_REL_WHEEL,
+    AXIS_LABEL_PROP_ABS_DBL_ORDINAL_X,
+    AXIS_LABEL_PROP_ABS_DBL_ORDINAL_Y,
+    AXIS_LABEL_PROP_ABS_DBL_START_TIME,
+    AXIS_LABEL_PROP_ABS_DBL_END_TIME,
+    AXIS_LABEL_PROP_ABS_DBL_FLING_VX,
+    AXIS_LABEL_PROP_ABS_DBL_FLING_VY,
+    AXIS_LABEL_PROP_ABS_FLING_STATE,
+    AXIS_LABEL_PROP_ABS_METRICS_TYPE,
+    AXIS_LABEL_PROP_ABS_DBL_METRICS_DATA1,
+    AXIS_LABEL_PROP_ABS_DBL_METRICS_DATA2,
+    AXIS_LABEL_PROP_ABS_FINGER_COUNT,
+    AXIS_LABEL_ABS_MT_TOUCH_MAJOR,
+    AXIS_LABEL_ABS_MT_TOUCH_MINOR,
+    AXIS_LABEL_ABS_MT_ORIENTATION,
+    AXIS_LABEL_ABS_MT_PRESSURE,
+    AXIS_LABEL_ABS_MT_POSITION_X,
+    AXIS_LABEL_ABS_MT_POSITION_Y,
+    AXIS_LABEL_ABS_MT_TRACKING_ID,
+    AXIS_LABEL_TOUCH_TIMESTAMP,
+};
+
+// Make sure the sizes of enum and |kCachedAtoms| are aligned.
+static_assert(arraysize(kCachedAtoms) ==
+                  ui::DeviceDataManagerX11::DT_LAST_ENTRY,
+              "kCachedAtoms count / enum mismatch");
+
+// Constants for checking if a data type lies in the range of CMT/Touch data
+// types.
+const int kCMTDataTypeStart = ui::DeviceDataManagerX11::DT_CMT_SCROLL_X;
+const int kCMTDataTypeEnd = ui::DeviceDataManagerX11::DT_CMT_FINGER_COUNT;
+const int kTouchDataTypeStart = ui::DeviceDataManagerX11::DT_TOUCH_MAJOR;
+const int kTouchDataTypeEnd = ui::DeviceDataManagerX11::DT_TOUCH_RAW_TIMESTAMP;
+
+namespace ui {
+
+namespace {
+
+template <typename Iterator>
+Iterator FindDeviceWithId(Iterator begin, Iterator end, int id) {
+  for (auto it = begin; it != end; ++it) {
+    if (it->id == id)
+      return it;
+  }
+  return end;
+}
+
+// Disables high precision scrolling in X11
+const char kDisableHighPrecisionScrolling[] =
+    "disable-high-precision-scrolling";
+
+bool IsHighPrecisionScrollingDisabled() {
+  return base::CommandLine::ForCurrentProcess()->HasSwitch(
+      kDisableHighPrecisionScrolling);
+}
+
+}  // namespace
+
+bool DeviceDataManagerX11::IsCMTDataType(const int type) {
+  return (type >= kCMTDataTypeStart) && (type <= kCMTDataTypeEnd);
+}
+
+bool DeviceDataManagerX11::IsTouchDataType(const int type) {
+  return (type >= kTouchDataTypeStart) && (type <= kTouchDataTypeEnd);
+}
+
+// static
+void DeviceDataManagerX11::CreateInstance() {
+  if (HasInstance())
+    return;
+
+  DeviceDataManagerX11* device_data_manager = new DeviceDataManagerX11();
+
+  // TODO(bruthig): Replace the DeleteInstance callbacks with explicit calls.
+  base::AtExitManager::RegisterTask(
+      base::Bind(DeviceDataManager::DeleteInstance));
+
+  set_instance(device_data_manager);
+}
+
+// static
+DeviceDataManagerX11* DeviceDataManagerX11::GetInstance() {
+  return static_cast<DeviceDataManagerX11*>(DeviceDataManager::GetInstance());
+}
+
+DeviceDataManagerX11::DeviceDataManagerX11()
+    : xi_opcode_(-1),
+      high_precision_scrolling_disabled_(IsHighPrecisionScrollingDisabled()),
+      button_map_count_(0) {
+  CHECK(gfx::GetXDisplay());
+  InitializeXInputInternal();
+
+  UpdateDeviceList(gfx::GetXDisplay());
+  UpdateButtonMap();
+}
+
+DeviceDataManagerX11::~DeviceDataManagerX11() {
+}
+
+bool DeviceDataManagerX11::InitializeXInputInternal() {
+  // Check if XInput is available on the system.
+  xi_opcode_ = -1;
+  int opcode, event, error;
+  if (!XQueryExtension(
+      gfx::GetXDisplay(), "XInputExtension", &opcode, &event, &error)) {
+    VLOG(1) << "X Input extension not available: error=" << error;
+    return false;
+  }
+
+  // Check the XInput version.
+  int major = 2, minor = 2;
+  if (XIQueryVersion(gfx::GetXDisplay(), &major, &minor) == BadRequest) {
+    VLOG(1) << "XInput2 not supported in the server.";
+    return false;
+  }
+  if (major < 2 || (major == 2 && minor < 2)) {
+    DVLOG(1) << "XI version on server is " << major << "." << minor << ". "
+            << "But 2.2 is required.";
+    return false;
+  }
+
+  xi_opcode_ = opcode;
+  CHECK_NE(-1, xi_opcode_);
+
+  // Possible XI event types for XIDeviceEvent. See the XI2 protocol
+  // specification.
+  xi_device_event_types_[XI_KeyPress] = true;
+  xi_device_event_types_[XI_KeyRelease] = true;
+  xi_device_event_types_[XI_ButtonPress] = true;
+  xi_device_event_types_[XI_ButtonRelease] = true;
+  xi_device_event_types_[XI_Motion] = true;
+  // Multi-touch support was introduced in XI 2.2.
+  if (minor >= 2) {
+    xi_device_event_types_[XI_TouchBegin] = true;
+    xi_device_event_types_[XI_TouchUpdate] = true;
+    xi_device_event_types_[XI_TouchEnd] = true;
+  }
+  return true;
+}
+
+bool DeviceDataManagerX11::IsXInput2Available() const {
+  return xi_opcode_ != -1;
+}
+
+void DeviceDataManagerX11::UpdateDeviceList(Display* display) {
+  cmt_devices_.reset();
+  touchpads_.reset();
+  master_pointers_.clear();
+  for (int i = 0; i < kMaxDeviceNum; ++i) {
+    valuator_count_[i] = 0;
+    valuator_lookup_[i].clear();
+    data_type_lookup_[i].clear();
+    scroll_data_[i].horizontal.number = -1;
+    scroll_data_[i].horizontal.seen = false;
+    scroll_data_[i].vertical.number = -1;
+    scroll_data_[i].vertical.seen = false;
+    for (int j = 0; j < kMaxSlotNum; j++)
+      last_seen_valuator_[i][j].clear();
+  }
+
+  // Find all the touchpad devices.
+  const XDeviceList& dev_list =
+      ui::DeviceListCacheX11::GetInstance()->GetXDeviceList(display);
+  Atom xi_touchpad = gfx::GetAtom(XI_TOUCHPAD);
+  for (int i = 0; i < dev_list.count; ++i)
+    if (dev_list[i].type == xi_touchpad)
+      touchpads_[dev_list[i].id] = true;
+
+  if (!IsXInput2Available())
+    return;
+
+  // Update the structs with new valuator information
+  const XIDeviceList& info_list =
+      ui::DeviceListCacheX11::GetInstance()->GetXI2DeviceList(display);
+  Atom atoms[DT_LAST_ENTRY];
+  for (int data_type = 0; data_type < DT_LAST_ENTRY; ++data_type)
+    atoms[data_type] = gfx::GetAtom(kCachedAtoms[data_type]);
+
+  for (int i = 0; i < info_list.count; ++i) {
+    const XIDeviceInfo& info = info_list[i];
+
+    if (info.use == XIMasterPointer)
+      master_pointers_.push_back(info.deviceid);
+
+    // We currently handle only slave, non-keyboard devices
+    if (info.use != XISlavePointer && info.use != XIFloatingSlave)
+      continue;
+
+    bool possible_cmt = false;
+    bool not_cmt = false;
+    const int deviceid = info.deviceid;
+
+    for (int j = 0; j < info.num_classes; ++j) {
+      if (info.classes[j]->type == XIValuatorClass)
+        ++valuator_count_[deviceid];
+      else if (info.classes[j]->type == XIScrollClass)
+        not_cmt = true;
+    }
+
+    // Skip devices that don't use any valuator
+    if (!valuator_count_[deviceid])
+      continue;
+
+    valuator_lookup_[deviceid].resize(DT_LAST_ENTRY);
+    data_type_lookup_[deviceid].resize(
+        valuator_count_[deviceid], DT_LAST_ENTRY);
+    for (int j = 0; j < kMaxSlotNum; j++)
+      last_seen_valuator_[deviceid][j].resize(DT_LAST_ENTRY, 0);
+    for (int j = 0; j < info.num_classes; ++j) {
+      if (info.classes[j]->type == XIValuatorClass) {
+        if (UpdateValuatorClassDevice(
+                reinterpret_cast<XIValuatorClassInfo*>(info.classes[j]), atoms,
+                deviceid))
+          possible_cmt = true;
+      } else if (info.classes[j]->type == XIScrollClass) {
+        UpdateScrollClassDevice(
+            reinterpret_cast<XIScrollClassInfo*>(info.classes[j]), deviceid);
+      }
+    }
+
+    if (possible_cmt && !not_cmt)
+      cmt_devices_[deviceid] = true;
+  }
+}
+
+bool DeviceDataManagerX11::GetSlotNumber(const XIDeviceEvent* xiev, int* slot) {
+  ui::TouchFactory* factory = ui::TouchFactory::GetInstance();
+  if (!factory->IsMultiTouchDevice(xiev->sourceid)) {
+    *slot = 0;
+    return true;
+  }
+  return factory->QuerySlotForTrackingID(xiev->detail, slot);
+}
+
+void DeviceDataManagerX11::GetEventRawData(const XEvent& xev, EventData* data) {
+  if (xev.type != GenericEvent)
+    return;
+
+  XIDeviceEvent* xiev = static_cast<XIDeviceEvent*>(xev.xcookie.data);
+  CHECK_GE(xiev->sourceid, 0);
+  CHECK_GE(xiev->deviceid, 0);
+  if (xiev->sourceid >= kMaxDeviceNum || xiev->deviceid >= kMaxDeviceNum)
+    return;
+  data->clear();
+  const int sourceid = xiev->sourceid;
+  double* valuators = xiev->valuators.values;
+  for (int i = 0; i <= valuator_count_[sourceid]; ++i) {
+    if (XIMaskIsSet(xiev->valuators.mask, i)) {
+      int type = data_type_lookup_[sourceid][i];
+      if (type != DT_LAST_ENTRY) {
+        (*data)[type] = *valuators;
+        if (IsTouchDataType(type)) {
+          int slot = -1;
+          if (GetSlotNumber(xiev, &slot) && slot >= 0 && slot < kMaxSlotNum)
+            last_seen_valuator_[sourceid][slot][type] = *valuators;
+        }
+      }
+      valuators++;
+    }
+  }
+}
+
+bool DeviceDataManagerX11::GetEventData(const XEvent& xev,
+    const DataType type, double* value) {
+  if (xev.type != GenericEvent)
+    return false;
+
+  XIDeviceEvent* xiev = static_cast<XIDeviceEvent*>(xev.xcookie.data);
+  CHECK_GE(xiev->sourceid, 0);
+  CHECK_GE(xiev->deviceid, 0);
+  if (xiev->sourceid >= kMaxDeviceNum || xiev->deviceid >= kMaxDeviceNum)
+    return false;
+  const int sourceid = xiev->sourceid;
+  if (valuator_lookup_[sourceid].empty())
+    return false;
+
+  if (type == DT_TOUCH_TRACKING_ID) {
+    // With XInput2 MT, Tracking ID is provided in the detail field for touch
+    // events.
+    if (xiev->evtype == XI_TouchBegin ||
+        xiev->evtype == XI_TouchEnd ||
+        xiev->evtype == XI_TouchUpdate) {
+      *value = xiev->detail;
+    } else {
+      *value = 0;
+    }
+    return true;
+  }
+
+  int val_index = valuator_lookup_[sourceid][type].number;
+  int slot = 0;
+  if (val_index >= 0) {
+    if (XIMaskIsSet(xiev->valuators.mask, val_index)) {
+      double* valuators = xiev->valuators.values;
+      while (val_index--) {
+        if (XIMaskIsSet(xiev->valuators.mask, val_index))
+          ++valuators;
+      }
+      *value = *valuators;
+      if (IsTouchDataType(type)) {
+        if (GetSlotNumber(xiev, &slot) && slot >= 0 && slot < kMaxSlotNum)
+          last_seen_valuator_[sourceid][slot][type] = *value;
+      }
+      return true;
+    } else if (IsTouchDataType(type)) {
+      if (GetSlotNumber(xiev, &slot) && slot >= 0 && slot < kMaxSlotNum)
+        *value = last_seen_valuator_[sourceid][slot][type];
+    }
+  }
+
+  return false;
+}
+
+bool DeviceDataManagerX11::IsXIDeviceEvent(const XEvent& xev) const {
+  if (xev.type != GenericEvent || xev.xcookie.extension != xi_opcode_)
+    return false;
+  return xi_device_event_types_[xev.xcookie.evtype];
+}
+
+bool DeviceDataManagerX11::IsTouchpadXInputEvent(const XEvent& xev) const {
+  if (xev.type != GenericEvent)
+    return false;
+
+  XIDeviceEvent* xievent = static_cast<XIDeviceEvent*>(xev.xcookie.data);
+  CHECK_GE(xievent->sourceid, 0);
+  if (xievent->sourceid >= kMaxDeviceNum)
+    return false;
+  return touchpads_[xievent->sourceid];
+}
+
+bool DeviceDataManagerX11::IsCMTDeviceEvent(const XEvent& xev) const {
+  if (xev.type != GenericEvent)
+    return false;
+
+  XIDeviceEvent* xievent = static_cast<XIDeviceEvent*>(xev.xcookie.data);
+  CHECK_GE(xievent->sourceid, 0);
+  if (xievent->sourceid >= kMaxDeviceNum)
+    return false;
+  return cmt_devices_[xievent->sourceid];
+}
+
+int DeviceDataManagerX11::GetScrollClassEventDetail(const XEvent& xev) const {
+  if (xev.type != GenericEvent)
+    return SCROLL_TYPE_NO_SCROLL;
+
+  XIDeviceEvent* xievent = static_cast<XIDeviceEvent*>(xev.xcookie.data);
+  if (xievent->sourceid >= kMaxDeviceNum)
+    return SCROLL_TYPE_NO_SCROLL;
+  int horizontal_id = scroll_data_[xievent->sourceid].horizontal.number;
+  int vertical_id = scroll_data_[xievent->sourceid].vertical.number;
+  return (horizontal_id != -1 &&
+                  XIMaskIsSet(xievent->valuators.mask, horizontal_id)
+              ? SCROLL_TYPE_HORIZONTAL
+              : 0) |
+         (vertical_id != -1 && XIMaskIsSet(xievent->valuators.mask, vertical_id)
+              ? SCROLL_TYPE_VERTICAL
+              : 0);
+}
+
+int DeviceDataManagerX11::GetScrollClassDeviceDetail(const XEvent& xev) const {
+  if (xev.type != GenericEvent)
+    return SCROLL_TYPE_NO_SCROLL;
+
+  XIDeviceEvent* xiev = static_cast<XIDeviceEvent*>(xev.xcookie.data);
+  if (xiev->sourceid >= kMaxDeviceNum || xiev->deviceid >= kMaxDeviceNum)
+    return SCROLL_TYPE_NO_SCROLL;
+  const int sourceid = xiev->sourceid;
+  const ScrollInfo& device_data = scroll_data_[sourceid];
+  return (device_data.vertical.number >= 0 ? SCROLL_TYPE_VERTICAL : 0) |
+         (device_data.horizontal.number >= 0 ? SCROLL_TYPE_HORIZONTAL : 0);
+}
+
+bool DeviceDataManagerX11::IsCMTGestureEvent(const XEvent& xev) const {
+  return (IsScrollEvent(xev) || IsFlingEvent(xev) || IsCMTMetricsEvent(xev));
+}
+
+bool DeviceDataManagerX11::HasEventData(
+    const XIDeviceEvent* xiev, const DataType type) const {
+  CHECK_GE(xiev->sourceid, 0);
+  if (xiev->sourceid >= kMaxDeviceNum)
+    return false;
+  if (type >= valuator_lookup_[xiev->sourceid].size())
+    return false;
+  const int idx = valuator_lookup_[xiev->sourceid][type].number;
+  return (idx >= 0) && XIMaskIsSet(xiev->valuators.mask, idx);
+}
+
+bool DeviceDataManagerX11::IsScrollEvent(const XEvent& xev) const {
+  if (!IsCMTDeviceEvent(xev))
+    return false;
+
+  XIDeviceEvent* xiev = static_cast<XIDeviceEvent*>(xev.xcookie.data);
+  return (HasEventData(xiev, DT_CMT_SCROLL_X) ||
+          HasEventData(xiev, DT_CMT_SCROLL_Y));
+}
+
+bool DeviceDataManagerX11::IsFlingEvent(const XEvent& xev) const {
+  if (!IsCMTDeviceEvent(xev))
+    return false;
+
+  XIDeviceEvent* xiev = static_cast<XIDeviceEvent*>(xev.xcookie.data);
+  return (HasEventData(xiev, DT_CMT_FLING_X) &&
+          HasEventData(xiev, DT_CMT_FLING_Y) &&
+          HasEventData(xiev, DT_CMT_FLING_STATE));
+}
+
+bool DeviceDataManagerX11::IsCMTMetricsEvent(const XEvent& xev) const {
+  if (!IsCMTDeviceEvent(xev))
+    return false;
+
+  XIDeviceEvent* xiev = static_cast<XIDeviceEvent*>(xev.xcookie.data);
+  return (HasEventData(xiev, DT_CMT_METRICS_TYPE) &&
+          HasEventData(xiev, DT_CMT_METRICS_DATA1) &&
+          HasEventData(xiev, DT_CMT_METRICS_DATA2));
+}
+
+bool DeviceDataManagerX11::HasGestureTimes(const XEvent& xev) const {
+  if (!IsCMTDeviceEvent(xev))
+    return false;
+
+  XIDeviceEvent* xiev = static_cast<XIDeviceEvent*>(xev.xcookie.data);
+  return (HasEventData(xiev, DT_CMT_START_TIME) &&
+          HasEventData(xiev, DT_CMT_END_TIME));
+}
+
+void DeviceDataManagerX11::GetScrollOffsets(const XEvent& xev,
+                                            float* x_offset,
+                                            float* y_offset,
+                                            float* x_offset_ordinal,
+                                            float* y_offset_ordinal,
+                                            int* finger_count) {
+  *x_offset = 0;
+  *y_offset = 0;
+  *x_offset_ordinal = 0;
+  *y_offset_ordinal = 0;
+  *finger_count = 2;
+
+  EventData data;
+  GetEventRawData(xev, &data);
+
+  if (data.find(DT_CMT_SCROLL_X) != data.end())
+    *x_offset = data[DT_CMT_SCROLL_X];
+  if (data.find(DT_CMT_SCROLL_Y) != data.end())
+    *y_offset = data[DT_CMT_SCROLL_Y];
+  if (data.find(DT_CMT_ORDINAL_X) != data.end())
+    *x_offset_ordinal = data[DT_CMT_ORDINAL_X];
+  if (data.find(DT_CMT_ORDINAL_Y) != data.end())
+    *y_offset_ordinal = data[DT_CMT_ORDINAL_Y];
+  if (data.find(DT_CMT_FINGER_COUNT) != data.end())
+    *finger_count = static_cast<int>(data[DT_CMT_FINGER_COUNT]);
+}
+
+void DeviceDataManagerX11::GetScrollClassOffsets(const XEvent& xev,
+                                                 double* x_offset,
+                                                 double* y_offset) {
+  DCHECK_NE(SCROLL_TYPE_NO_SCROLL, GetScrollClassDeviceDetail(xev));
+
+  *x_offset = 0;
+  *y_offset = 0;
+
+  if (xev.type != GenericEvent)
+    return;
+
+  XIDeviceEvent* xiev = static_cast<XIDeviceEvent*>(xev.xcookie.data);
+  if (xiev->sourceid >= kMaxDeviceNum || xiev->deviceid >= kMaxDeviceNum)
+    return;
+  const int sourceid = xiev->sourceid;
+  double* valuators = xiev->valuators.values;
+
+  ScrollInfo* info = &scroll_data_[sourceid];
+
+  const int horizontal_number = info->horizontal.number;
+  const int vertical_number = info->vertical.number;
+
+  for (int i = 0; i <= valuator_count_[sourceid]; ++i) {
+    if (!XIMaskIsSet(xiev->valuators.mask, i))
+      continue;
+    if (i == horizontal_number) {
+      *x_offset = ExtractAndUpdateScrollOffset(&info->horizontal, *valuators);
+    } else if (i == vertical_number) {
+      *y_offset = ExtractAndUpdateScrollOffset(&info->vertical, *valuators);
+    }
+    valuators++;
+  }
+}
+
+void DeviceDataManagerX11::InvalidateScrollClasses(int device_id) {
+  if (device_id == kAllDevices) {
+    for (int i = 0; i < kMaxDeviceNum; i++) {
+      scroll_data_[i].horizontal.seen = false;
+      scroll_data_[i].vertical.seen = false;
+    }
+  } else {
+    CHECK(device_id >= 0 && device_id < kMaxDeviceNum);
+    scroll_data_[device_id].horizontal.seen = false;
+    scroll_data_[device_id].vertical.seen = false;
+  }
+}
+
+void DeviceDataManagerX11::GetFlingData(const XEvent& xev,
+                                        float* vx,
+                                        float* vy,
+                                        float* vx_ordinal,
+                                        float* vy_ordinal,
+                                        bool* is_cancel) {
+  *vx = 0;
+  *vy = 0;
+  *vx_ordinal = 0;
+  *vy_ordinal = 0;
+  *is_cancel = false;
+
+  EventData data;
+  GetEventRawData(xev, &data);
+
+  if (data.find(DT_CMT_FLING_X) != data.end())
+    *vx = data[DT_CMT_FLING_X];
+  if (data.find(DT_CMT_FLING_Y) != data.end())
+    *vy = data[DT_CMT_FLING_Y];
+  if (data.find(DT_CMT_FLING_STATE) != data.end())
+    *is_cancel = !!static_cast<unsigned int>(data[DT_CMT_FLING_STATE]);
+  if (data.find(DT_CMT_ORDINAL_X) != data.end())
+    *vx_ordinal = data[DT_CMT_ORDINAL_X];
+  if (data.find(DT_CMT_ORDINAL_Y) != data.end())
+    *vy_ordinal = data[DT_CMT_ORDINAL_Y];
+}
+
+void DeviceDataManagerX11::GetMetricsData(const XEvent& xev,
+                                          GestureMetricsType* type,
+                                          float* data1,
+                                          float* data2) {
+  *type = kGestureMetricsTypeUnknown;
+  *data1 = 0;
+  *data2 = 0;
+
+  EventData data;
+  GetEventRawData(xev, &data);
+
+  if (data.find(DT_CMT_METRICS_TYPE) != data.end()) {
+    int val = static_cast<int>(data[DT_CMT_METRICS_TYPE]);
+    if (val == 0)
+      *type = kGestureMetricsTypeNoisyGround;
+    else
+      *type = kGestureMetricsTypeUnknown;
+  }
+  if (data.find(DT_CMT_METRICS_DATA1) != data.end())
+    *data1 = data[DT_CMT_METRICS_DATA1];
+  if (data.find(DT_CMT_METRICS_DATA2) != data.end())
+    *data2 = data[DT_CMT_METRICS_DATA2];
+}
+
+int DeviceDataManagerX11::GetMappedButton(int button) {
+  return button > 0 && button <= button_map_count_ ? button_map_[button - 1] :
+                                                     button;
+}
+
+void DeviceDataManagerX11::UpdateButtonMap() {
+  button_map_count_ = XGetPointerMapping(gfx::GetXDisplay(),
+                                         button_map_,
+                                         arraysize(button_map_));
+}
+
+void DeviceDataManagerX11::GetGestureTimes(const XEvent& xev,
+                                           double* start_time,
+                                           double* end_time) {
+  *start_time = 0;
+  *end_time = 0;
+
+  EventData data;
+  GetEventRawData(xev, &data);
+
+  if (data.find(DT_CMT_START_TIME) != data.end())
+    *start_time = data[DT_CMT_START_TIME];
+  if (data.find(DT_CMT_END_TIME) != data.end())
+    *end_time = data[DT_CMT_END_TIME];
+}
+
+bool DeviceDataManagerX11::NormalizeData(int deviceid,
+                                         const DataType type,
+                                         double* value) {
+  double max_value;
+  double min_value;
+  if (GetDataRange(deviceid, type, &min_value, &max_value)) {
+    *value = (*value - min_value) / (max_value - min_value);
+    DCHECK(*value >= 0.0 && *value <= 1.0);
+    return true;
+  }
+  return false;
+}
+
+bool DeviceDataManagerX11::GetDataRange(int deviceid,
+                                        const DataType type,
+                                        double* min,
+                                        double* max) {
+  CHECK_GE(deviceid, 0);
+  if (deviceid >= kMaxDeviceNum)
+    return false;
+  if (valuator_lookup_[deviceid].empty())
+    return false;
+  if (valuator_lookup_[deviceid][type].number >= 0) {
+    *min = valuator_lookup_[deviceid][type].min;
+    *max = valuator_lookup_[deviceid][type].max;
+    return true;
+  }
+  return false;
+}
+
+void DeviceDataManagerX11::SetDeviceListForTest(
+    const std::vector<int>& touchscreen,
+    const std::vector<int>& cmt_devices,
+    const std::vector<int>& other_devices) {
+  for (int i = 0; i < kMaxDeviceNum; ++i) {
+    valuator_count_[i] = 0;
+    valuator_lookup_[i].clear();
+    data_type_lookup_[i].clear();
+    for (int j = 0; j < kMaxSlotNum; j++)
+      last_seen_valuator_[i][j].clear();
+  }
+
+  for (int deviceid : touchscreen) {
+    InitializeValuatorsForTest(deviceid, kTouchDataTypeStart, kTouchDataTypeEnd,
+                               0, 1000);
+  }
+
+  cmt_devices_.reset();
+  for (int deviceid : cmt_devices) {
+    cmt_devices_[deviceid] = true;
+    touchpads_[deviceid] = true;
+    InitializeValuatorsForTest(deviceid, kCMTDataTypeStart, kCMTDataTypeEnd,
+                               -1000, 1000);
+  }
+
+  for (int deviceid : other_devices) {
+    InitializeValuatorsForTest(deviceid, kCMTDataTypeStart, kCMTDataTypeEnd,
+                               -1000, 1000);
+  }
+}
+
+void DeviceDataManagerX11::SetValuatorDataForTest(XIDeviceEvent* xievent,
+                                                  DataType type,
+                                                  double value) {
+  int index = valuator_lookup_[xievent->deviceid][type].number;
+  CHECK(!XIMaskIsSet(xievent->valuators.mask, index));
+  CHECK(index >= 0 && index < valuator_count_[xievent->deviceid]);
+  XISetMask(xievent->valuators.mask, index);
+
+  double* valuators = xievent->valuators.values;
+  for (int i = 0; i < index; ++i) {
+    if (XIMaskIsSet(xievent->valuators.mask, i))
+      valuators++;
+  }
+  for (int i = DT_LAST_ENTRY - 1; i > valuators - xievent->valuators.values;
+       --i)
+    xievent->valuators.values[i] = xievent->valuators.values[i - 1];
+  *valuators = value;
+}
+
+void DeviceDataManagerX11::InitializeValuatorsForTest(int deviceid,
+                                                      int start_valuator,
+                                                      int end_valuator,
+                                                      double min_value,
+                                                      double max_value) {
+  valuator_lookup_[deviceid].resize(DT_LAST_ENTRY);
+  data_type_lookup_[deviceid].resize(DT_LAST_ENTRY, DT_LAST_ENTRY);
+  for (int j = 0; j < kMaxSlotNum; j++)
+    last_seen_valuator_[deviceid][j].resize(DT_LAST_ENTRY, 0);
+  for (int j = start_valuator; j <= end_valuator; ++j) {
+    auto& valuator_info = valuator_lookup_[deviceid][j];
+    valuator_info.number = valuator_count_[deviceid];
+    valuator_info.min = min_value;
+    valuator_info.max = max_value;
+    data_type_lookup_[deviceid][valuator_count_[deviceid]] = j;
+    valuator_count_[deviceid]++;
+  }
+}
+
+bool DeviceDataManagerX11::UpdateValuatorClassDevice(
+    XIValuatorClassInfo* valuator_class_info,
+    Atom* atoms,
+    int deviceid) {
+  DCHECK(deviceid >= 0 && deviceid < kMaxDeviceNum);
+  Atom* label =
+      std::find(atoms, atoms + DT_LAST_ENTRY, valuator_class_info->label);
+  if (label == atoms + DT_LAST_ENTRY) {
+    return false;
+  }
+  int data_type = label - atoms;
+  DCHECK_GE(data_type, 0);
+  DCHECK_LT(data_type, DT_LAST_ENTRY);
+
+  auto& valuator_info = valuator_lookup_[deviceid][data_type];
+  valuator_info.number = valuator_class_info->number;
+  valuator_info.min = valuator_class_info->min;
+  valuator_info.max = valuator_class_info->max;
+  data_type_lookup_[deviceid][valuator_class_info->number] = data_type;
+  return IsCMTDataType(data_type);
+}
+
+void DeviceDataManagerX11::UpdateScrollClassDevice(
+    XIScrollClassInfo* scroll_class_info,
+    int deviceid) {
+  if (high_precision_scrolling_disabled_)
+    return;
+
+  DCHECK(deviceid >= 0 && deviceid < kMaxDeviceNum);
+  ScrollInfo& info = scroll_data_[deviceid];
+
+  bool legacy_scroll_available =
+      (scroll_class_info->flags & XIScrollFlagNoEmulation) == 0;
+  // If the device's highest resolution is lower than the resolution of xinput1
+  // then use xinput1's events instead (ie. don't configure smooth scrolling).
+  if (legacy_scroll_available &&
+      std::abs(scroll_class_info->increment) <= 1.0) {
+    return;
+  }
+
+  switch (scroll_class_info->scroll_type) {
+    case XIScrollTypeVertical:
+      info.vertical.number = scroll_class_info->number;
+      info.vertical.increment = scroll_class_info->increment;
+      info.vertical.position = 0;
+      info.vertical.seen = false;
+      break;
+    case XIScrollTypeHorizontal:
+      info.horizontal.number = scroll_class_info->number;
+      info.horizontal.increment = scroll_class_info->increment;
+      info.horizontal.position = 0;
+      info.horizontal.seen = false;
+      break;
+  }
+}
+
+double DeviceDataManagerX11::ExtractAndUpdateScrollOffset(
+    ScrollInfo::AxisInfo* axis,
+    double valuator) const {
+  double offset = 0;
+  if (axis->seen)
+    offset = axis->position - valuator;
+  axis->seen = true;
+  axis->position = valuator;
+  return offset / axis->increment;
+}
+
+void DeviceDataManagerX11::SetDisabledKeyboardAllowedKeys(
+    std::unique_ptr<std::set<KeyboardCode>> excepted_keys) {
+  DCHECK(!excepted_keys.get() ||
+         !blocked_keyboard_allowed_keys_.get());
+  blocked_keyboard_allowed_keys_ = std::move(excepted_keys);
+}
+
+void DeviceDataManagerX11::DisableDevice(int deviceid) {
+  blocked_devices_.set(deviceid, true);
+  // TODO(rsadam@): Support blocking touchscreen devices.
+  std::vector<InputDevice> keyboards = GetKeyboardDevices();
+  std::vector<InputDevice>::iterator it =
+      FindDeviceWithId(keyboards.begin(), keyboards.end(), deviceid);
+  if (it != std::end(keyboards)) {
+    blocked_keyboard_devices_.insert(
+        std::pair<int, InputDevice>(deviceid, *it));
+    keyboards.erase(it);
+    DeviceDataManager::OnKeyboardDevicesUpdated(keyboards);
+  }
+}
+
+void DeviceDataManagerX11::EnableDevice(int deviceid) {
+  blocked_devices_.set(deviceid, false);
+  std::map<int, InputDevice>::iterator it =
+      blocked_keyboard_devices_.find(deviceid);
+  if (it != blocked_keyboard_devices_.end()) {
+    std::vector<InputDevice> devices = GetKeyboardDevices();
+    // Add device to current list of active devices.
+    devices.push_back((*it).second);
+    blocked_keyboard_devices_.erase(it);
+    DeviceDataManager::OnKeyboardDevicesUpdated(devices);
+  }
+}
+
+bool DeviceDataManagerX11::IsDeviceEnabled(int device_id) const {
+  return blocked_devices_.test(device_id);
+}
+
+bool DeviceDataManagerX11::IsEventBlocked(const XEvent& xev) {
+  // Only check XI2 events which have a source device id.
+  if (xev.type != GenericEvent)
+    return false;
+
+  XIDeviceEvent* xievent = static_cast<XIDeviceEvent*>(xev.xcookie.data);
+  // Allow any key events from blocked_keyboard_allowed_keys_.
+  if (blocked_keyboard_allowed_keys_ &&
+      (xievent->evtype == XI_KeyPress || xievent->evtype == XI_KeyRelease) &&
+      blocked_keyboard_allowed_keys_->find(KeyboardCodeFromXKeyEvent(&xev)) !=
+          blocked_keyboard_allowed_keys_->end()) {
+    return false;
+  }
+
+  return blocked_devices_.test(xievent->sourceid);
+}
+
+void DeviceDataManagerX11::OnKeyboardDevicesUpdated(
+    const std::vector<InputDevice>& devices) {
+  std::vector<InputDevice> keyboards(devices);
+  for (std::map<int, InputDevice>::iterator blocked_iter =
+           blocked_keyboard_devices_.begin();
+       blocked_iter != blocked_keyboard_devices_.end();) {
+    // Check if the blocked device still exists in list of devices.
+    int device_id = blocked_iter->first;
+    std::vector<InputDevice>::iterator it =
+        FindDeviceWithId(keyboards.begin(), keyboards.end(), device_id);
+    // If the device no longer exists, unblock it, else filter it out from our
+    // active list.
+    if (it == keyboards.end()) {
+      blocked_devices_.set((*blocked_iter).first, false);
+      blocked_keyboard_devices_.erase(blocked_iter++);
+    } else {
+      keyboards.erase(it);
+      ++blocked_iter;
+    }
+  }
+  // Notify base class of updated list.
+  DeviceDataManager::OnKeyboardDevicesUpdated(keyboards);
+}
+
+}  // namespace ui
