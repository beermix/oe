--- chromium-63.0.3239.108/third_party/webrtc/p2p/base/port.cc.gcc7	2017-12-15 02:05:40.000000000 +0100
+++ chromium-63.0.3239.108/third_party/webrtc/p2p/base/port.cc	2017-12-29 07:24:01.248851177 +0100
@@ -12,6 +12,7 @@
 
 #include <algorithm>
 #include <vector>
+#include <cmath>
 
 #include "p2p/base/common.h"
 #include "p2p/base/portallocator.h"
--- chromium-63.0.3239.108/third_party/WebKit/Source/core/animation/EffectInput.cpp.gcc7	2017-12-15 02:04:44.000000000 +0100
+++ chromium-63.0.3239.108/third_party/WebKit/Source/core/animation/EffectInput.cpp	2017-12-29 10:53:32.679607021 +0100
@@ -264,13 +264,6 @@
         continue;
       }
 
-      Vector<String> values;
-      if (DictionaryHelper::Get(keyframe_dictionary, property, values)) {
-        exception_state.ThrowTypeError(
-            "Lists of values not permitted in array-form list of keyframes");
-        return CreateEmptyEffectModel(composite);
-      }
-
       String value;
       DictionaryHelper::Get(keyframe_dictionary, property, value);
 
@@ -294,8 +287,8 @@
   DCHECK(result.IsEmpty());
 
   // Array of strings.
-  if (DictionaryHelper::Get(keyframe_dictionary, property, result))
-    return true;
+//  if (DictionaryHelper::Get(keyframe_dictionary, property, result))
+//    return true;
 
   Dictionary values_dictionary;
   if (!keyframe_dictionary.Get(property, values_dictionary) ||
--- chromium-63.0.3239.108/third_party/WebKit/Source/core/events/TouchEvent.cpp.gcc7	2017-12-15 02:04:45.000000000 +0100
+++ chromium-63.0.3239.108/third_party/WebKit/Source/core/events/TouchEvent.cpp	2017-12-29 14:02:17.811274595 +0100
@@ -262,7 +262,6 @@
   // A common developer error is to wait too long before attempting to stop
   // scrolling by consuming a touchmove event. Generate a warning if this
   // event is uncancelable.
-  MessageSource message_source = kJSMessageSource;
   String warning_message;
   switch (HandlingPassive()) {
     case PassiveMode::kNotPassive:
@@ -285,7 +284,6 @@
                 WebFeature::
                     kUncancelableTouchEventDueToMainThreadResponsivenessPreventDefaulted);
           }
-          message_source = kInterventionMessageSource;
           warning_message =
               "Ignored attempt to cancel a " + type() +
               " event with cancelable=false. This event was forced to be "
@@ -305,7 +303,6 @@
       // an author may use touch action but call preventDefault for interop with
       // browsers that don't support touch-action.
       if (current_touch_action_ == TouchAction::kTouchActionAuto) {
-        message_source = kInterventionMessageSource;
         warning_message =
             "Unable to preventDefault inside passive event listener due to "
             "target being treated as passive. See "
--- chromium-63.0.3239.108/chrome/browser/ui/libgtkui/app_indicator_icon.cc.gcc7	2017-12-15 02:04:11.000000000 +0100
+++ chromium-63.0.3239.108/chrome/browser/ui/libgtkui/app_indicator_icon.cc	2017-12-29 14:50:07.374508338 +0100
@@ -98,6 +98,7 @@
     case base::nix::DESKTOP_ENVIRONMENT_XFCE:
       return false;
   }
+  return false;
 }
 
 void EnsureMethodsLoaded() {
--- chromium-63.0.3239.108/third_party/WebKit/Source/core/page/FocusController.cpp.gcc7	2017-12-15 02:04:46.000000000 +0100
+++ chromium-63.0.3239.108/third_party/WebKit/Source/core/page/FocusController.cpp	2017-12-29 16:48:59.462554676 +0100
@@ -217,9 +217,6 @@
   static ScopedFocusNavigation OwnedByIFrame(const HTMLFrameOwnerElement&,
                                              FocusController::OwnerMap&);
   static HTMLSlotElement* FindFallbackScopeOwnerSlot(const Element&);
-  static bool IsSlotFallbackScoped(const Element&);
-  static bool IsSlotFallbackScopedForThisSlot(const HTMLSlotElement&,
-                                              const Element&);
 
  private:
   ScopedFocusNavigation(ContainerNode& scoping_root_node,
@@ -361,25 +358,6 @@
   return nullptr;
 }
 
-bool ScopedFocusNavigation::IsSlotFallbackScoped(const Element& element) {
-  return ScopedFocusNavigation::FindFallbackScopeOwnerSlot(element);
-}
-
-bool ScopedFocusNavigation::IsSlotFallbackScopedForThisSlot(
-    const HTMLSlotElement& slot,
-    const Element& current) {
-  Element* parent = current.parentElement();
-  while (parent) {
-    if (IsHTMLSlotElement(parent) &&
-        ToHTMLSlotElement(parent)->AssignedNodes().IsEmpty()) {
-      return !SlotScopedTraversal::IsSlotScoped(current) &&
-             ToHTMLSlotElement(parent) == slot;
-    }
-    parent = parent->parentElement();
-  }
-  return false;
-}
-
 inline void DispatchBlurEvent(const Document& document,
                               Element& focused_element) {
   focused_element.DispatchBlurEvent(nullptr, kWebFocusTypePage);
