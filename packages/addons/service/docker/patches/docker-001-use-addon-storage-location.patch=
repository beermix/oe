diff --git a/components/cli/docs/extend/plugin_api.md b/components/cli/docs/extend/plugin_api.md
index 2a317f953a..1b3e98e7ea 100644
--- a/components/cli/docs/extend/plugin_api.md
+++ b/components/cli/docs/extend/plugin_api.md
@@ -51,7 +51,7 @@ Plugins with UNIX domain socket files must run on the same docker host, whereas
 plugins with spec or json files can run on a different host if a remote URL is specified.
 
 UNIX domain socket files must be located under `/run/docker/plugins`, whereas
-spec files can be located either under `/etc/docker/plugins` or `/usr/lib/docker/plugins`.
+spec files can be located either under `/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins` or `/usr/lib/docker/plugins`.
 
 The name of the file (excluding the extension) determines the plugin name.
 
@@ -63,7 +63,7 @@ For example, you can create the `flocker` socket under `/run/docker/plugins/floc
 mount `/run/docker/plugins/flocker` inside the `flocker` container.
 
 Docker always searches for unix sockets in `/run/docker/plugins` first. It checks for spec or json files under
-`/etc/docker/plugins` and `/usr/lib/docker/plugins` if the socket doesn't exist. The directory scan stops as
+`/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins` and `/usr/lib/docker/plugins` if the socket doesn't exist. The directory scan stops as
 soon as it finds the first plugin definition with the given name.
 
 ### JSON specification
diff --git a/components/cli/docs/reference/commandline/build.md b/components/cli/docs/reference/commandline/build.md
index 21220c631d..b147cc32da 100644
--- a/components/cli/docs/reference/commandline/build.md
+++ b/components/cli/docs/reference/commandline/build.md
@@ -558,7 +558,7 @@ To enable experimental mode, users need to restart the docker daemon with the ex
 
 #### Enable Docker experimental
 
-Experimental features are now included in the standard Docker binaries as of version 1.13.0. For enabling experimental features, you need to start the Docker daemon with `--experimental` flag. You can also enable the daemon flag via /etc/docker/daemon.json. e.g.
+Experimental features are now included in the standard Docker binaries as of version 1.13.0. For enabling experimental features, you need to start the Docker daemon with `--experimental` flag. You can also enable the daemon flag via /storage/.kodi/userdata/addon_data/service.system.docker/config/daemon.json. e.g.
 
 ```json
 {
diff --git a/components/cli/docs/reference/commandline/dockerd.md b/components/cli/docs/reference/commandline/dockerd.md
index 29427c4149..15165ddb96 100644
--- a/components/cli/docs/reference/commandline/dockerd.md
+++ b/components/cli/docs/reference/commandline/dockerd.md
@@ -32,7 +32,7 @@ Options:
       --cluster-advertise string              Address or interface name to advertise
       --cluster-store string                  URL of the distributed storage backend
       --cluster-store-opt map                 Set cluster store options (default map[])
-      --config-file string                    Daemon configuration file (default "/etc/docker/daemon.json")
+      --config-file string                    Daemon configuration file (default "/storage/.kodi/userdata/addon_data/service.system.docker/config/daemon.json")
       --containerd string                     Path to containerd socket
       --cpu-rt-period int                     Limit the CPU real-time period in microseconds
       --cpu-rt-runtime int                    Limit the CPU real-time runtime in microseconds
@@ -1031,11 +1031,11 @@ this section, *registry* is used for *private registry*, and `myregistry:5000`
 is a placeholder example for a private registry.
 
 A secure registry uses TLS and a copy of its CA certificate is placed on the
-Docker host at `/etc/docker/certs.d/myregistry:5000/ca.crt`. An insecure
+Docker host at `/storage/.kodi/userdata/addon_data/service.system.docker/config/certs.d/myregistry:5000/ca.crt`. An insecure
 registry is either not using TLS (i.e., listening on plain text HTTP), or is
 using TLS with a CA certificate not known by the Docker daemon. The latter can
 happen when the certificate was not found under
-`/etc/docker/certs.d/myregistry:5000/`, or if the certificate verification
+`/storage/.kodi/userdata/addon_data/service.system.docker/config/certs.d/myregistry:5000/`, or if the certificate verification
 failed (i.e., wrong CA).
 
 By default, Docker assumes all, but local (see local registries below),
@@ -1289,7 +1289,7 @@ Options that are not present in the file are ignored when the daemon starts.
 ##### On Linux
 
 The default location of the configuration file on Linux is
-`/etc/docker/daemon.json`. The `--config-file` flag can be used to specify a
+`/storage/.kodi/userdata/addon_data/service.system.docker/config/daemon.json`. The `--config-file` flag can be used to specify a
  non-default location.
 
 This is a full example of the allowed configuration options on Linux:
@@ -1514,7 +1514,7 @@ The following daemon options must be configured for each daemon:
 -p, --pidfile=/var/run/docker.pid      Path to use for daemon PID file
 -H, --host=[]                          Daemon socket(s) to connect to
 --iptables=true                        Enable addition of iptables rules
---config-file=/etc/docker/daemon.json  Daemon configuration file
+--config-file=/storage/.kodi/userdata/addon_data/service.system.docker/config/daemon.json  Daemon configuration file
 --tlscacert="~/.docker/ca.pem"         Trust certs signed only by this CA
 --tlscert="~/.docker/cert.pem"         Path to TLS certificate file
 --tlskey="~/.docker/key.pem"           Path to TLS key file
@@ -1541,7 +1541,7 @@ iptables rules, Docker will also not add IP masquerading rules, even if you set
 `--ip-masq` to `true`. Without IP masquerading rules, Docker containers will not be
 able to connect to external hosts or the internet when using network other than
 default bridge.
-- `--config-file=/etc/docker/daemon.json` is the path where configuration file is stored. You can use it instead of
+- `--config-file=/storage/.kodi/userdata/addon_data/service.system.docker/config/daemon.json` is the path where configuration file is stored. You can use it instead of
 daemon flags. Specify the path for each daemon.
 - `--tls*` Docker daemon supports `--tlsverify` mode that enforces encrypted and authenticated remote connections.
 The `--tls*` options enable use of specific certificates for individual daemons.
diff --git a/components/cli/experimental/README.md b/components/cli/experimental/README.md
index 63e676e3f7..edac5ab23f 100644
--- a/components/cli/experimental/README.md
+++ b/components/cli/experimental/README.md
@@ -15,7 +15,7 @@ Experimental features are now included in the standard Docker binaries as of
 version 1.13.0.
 To enable experimental features, start the Docker daemon with the
 `--experimental` flag or enable the daemon flag in the
-`/etc/docker/daemon.json` configuration file:
+`/storage/.kodi/userdata/addon_data/service.system.docker/config/daemon.json` configuration file:
 
 ```json
 {
diff --git a/components/cli/man/dockerd.8.md b/components/cli/man/dockerd.8.md
index 0224035970..475bbebc6c 100644
--- a/components/cli/man/dockerd.8.md
+++ b/components/cli/man/dockerd.8.md
@@ -16,7 +16,7 @@ dockerd - Enable daemon mode
 [**--cluster-store**[=*[]*]]
 [**--cluster-advertise**[=*[]*]]
 [**--cluster-store-opt**[=*map[]*]]
-[**--config-file**[=*/etc/docker/daemon.json*]]
+[**--config-file**[=*/storage/.kodi/userdata/addon_data/service.system.docker/config/daemon.json*]]
 [**--containerd**[=*SOCKET-PATH*]]
 [**--data-root**[=*/var/lib/docker*]]
 [**-D**|**--debug**]
@@ -163,7 +163,7 @@ $ sudo dockerd --add-runtime runc=runc --add-runtime custom=/usr/local/bin/my-ru
 **--cluster-store-opt**=""
   Specifies options for the Key/Value store.
 
-**--config-file**="/etc/docker/daemon.json"
+**--config-file**="/storage/.kodi/userdata/addon_data/service.system.docker/config/daemon.json"
   Specifies the JSON file path to load the configuration from.
 
 **--containerd**=""
diff --git a/components/cli/vendor/github.com/docker/docker/registry/config_unix.go b/components/cli/vendor/github.com/docker/docker/registry/config_unix.go
index 20fb47bcae..a023df7895 100644
--- a/components/cli/vendor/github.com/docker/docker/registry/config_unix.go
+++ b/components/cli/vendor/github.com/docker/docker/registry/config_unix.go
@@ -4,7 +4,7 @@ package registry // import "github.com/docker/docker/registry"
 
 var (
 	// CertsDir is the directory where certificates are stored
-	CertsDir = "/etc/docker/certs.d"
+	CertsDir = "/storage/.kodi/userdata/addon_data/service.system.docker/config/certs.d"
 )
 
 // cleanPath is used to ensure that a directory name is valid on the target
diff --git a/components/cli/vendor/github.com/docker/docker/registry/endpoint_v1.go b/components/cli/vendor/github.com/docker/docker/registry/endpoint_v1.go
index 832fdb95a4..606ddfaf96 100644
--- a/components/cli/vendor/github.com/docker/docker/registry/endpoint_v1.go
+++ b/components/cli/vendor/github.com/docker/docker/registry/endpoint_v1.go
@@ -49,7 +49,7 @@ func validateEndpoint(endpoint *V1Endpoint) error {
 		if endpoint.IsSecure {
 			// If registry is secure and HTTPS failed, show user the error and tell them about `--insecure-registry`
 			// in case that's what they need. DO NOT accept unknown CA certificates, and DO NOT fallback to HTTP.
-			return fmt.Errorf("invalid registry endpoint %s: %v. If this private registry supports only HTTP or HTTPS with an unknown CA certificate, please add `--insecure-registry %s` to the daemon's arguments. In the case of HTTPS, if you have access to the registry's CA certificate, no need for the flag; simply place the CA certificate at /etc/docker/certs.d/%s/ca.crt", endpoint, err, endpoint.URL.Host, endpoint.URL.Host)
+			return fmt.Errorf("invalid registry endpoint %s: %v. If this private registry supports only HTTP or HTTPS with an unknown CA certificate, please add `--insecure-registry %s` to the daemon's arguments. In the case of HTTPS, if you have access to the registry's CA certificate, no need for the flag; simply place the CA certificate at /storage/.kodi/userdata/addon_data/service.system.docker/config/certs.d/%s/ca.crt", endpoint, err, endpoint.URL.Host, endpoint.URL.Host)
 		}
 
 		// If registry is insecure and HTTPS failed, fallback to HTTP.
diff --git a/components/engine/cmd/dockerd/daemon_unix.go b/components/engine/cmd/dockerd/daemon_unix.go
index 2500260028..4e9f7ce46a 100644
--- a/components/engine/cmd/dockerd/daemon_unix.go
+++ b/components/engine/cmd/dockerd/daemon_unix.go
@@ -25,7 +25,7 @@ import (
 
 func getDefaultDaemonConfigDir() (string, error) {
 	if !honorXDG {
-		return "/etc/docker", nil
+		return "/storage/.kodi/userdata/addon_data/service.system.docker/config", nil
 	}
 	// NOTE: CLI uses ~/.docker while the daemon uses ~/.config/docker, because
 	// ~/.docker was not designed to store daemon configurations.
diff --git a/components/engine/daemon/config/config_test.go b/components/engine/daemon/config/config_test.go
index ec7820b3f3..3a3dd2a924 100644
--- a/components/engine/daemon/config/config_test.go
+++ b/components/engine/daemon/config/config_test.go
@@ -475,7 +475,7 @@ func TestReloadSetConfigFileNotExist(t *testing.T) {
 func TestReloadDefaultConfigNotExist(t *testing.T) {
 	skip.If(t, os.Getuid() != 0, "skipping test that requires root")
 	reloaded := false
-	configFile := "/etc/docker/daemon.json"
+	configFile := "/storage/.kodi/userdata/addon_data/service.system.docker/config/daemon.json"
 	flags := pflag.NewFlagSet("test", pflag.ContinueOnError)
 	flags.String("config-file", configFile, "")
 	err := Reload(configFile, flags, func(c *Config) {
diff --git a/components/engine/integration-cli/docker_cli_daemon_test.go b/components/engine/integration-cli/docker_cli_daemon_test.go
index ab26c2e77b..ea2dccbe00 100644
--- a/components/engine/integration-cli/docker_cli_daemon_test.go
+++ b/components/engine/integration-cli/docker_cli_daemon_test.go
@@ -552,11 +552,11 @@ func (s *DockerDaemonSuite) TestDaemonAllocatesListeningPort(c *check.C) {
 
 func (s *DockerDaemonSuite) TestDaemonKeyGeneration(c *check.C) {
 	// TODO: skip or update for Windows daemon
-	os.Remove("/etc/docker/key.json")
+	os.Remove("/storage/.kodi/userdata/addon_data/service.system.docker/config/key.json")
 	s.d.Start(c)
 	s.d.Stop(c)
 
-	k, err := libtrust.LoadKeyFile("/etc/docker/key.json")
+	k, err := libtrust.LoadKeyFile("/storage/.kodi/userdata/addon_data/service.system.docker/config/key.json")
 	if err != nil {
 		c.Fatalf("Error opening key file")
 	}
@@ -1201,12 +1201,12 @@ func (s *DockerDaemonSuite) TestDaemonWithWrongkey(c *check.C) {
 		Y   string `json:"y"`
 	}
 
-	os.Remove("/etc/docker/key.json")
+	os.Remove("/storage/.kodi/userdata/addon_data/service.system.docker/config/key.json")
 	s.d.Start(c)
 	s.d.Stop(c)
 
 	config := &Config{}
-	bytes, err := ioutil.ReadFile("/etc/docker/key.json")
+	bytes, err := ioutil.ReadFile("/storage/.kodi/userdata/addon_data/service.system.docker/config/key.json")
 	if err != nil {
 		c.Fatalf("Error reading key.json file: %s", err)
 	}
@@ -1226,11 +1226,11 @@ func (s *DockerDaemonSuite) TestDaemonWithWrongkey(c *check.C) {
 	}
 
 	// write back
-	if err := ioutil.WriteFile("/etc/docker/key.json", newBytes, 0400); err != nil {
+	if err := ioutil.WriteFile("/storage/.kodi/userdata/addon_data/service.system.docker/config/key.json", newBytes, 0400); err != nil {
 		c.Fatalf("Error ioutil.WriteFile: %s", err)
 	}
 
-	defer os.Remove("/etc/docker/key.json")
+	defer os.Remove("/storage/.kodi/userdata/addon_data/service.system.docker/config/key.json")
 
 	if err := s.d.StartWithError(); err == nil {
 		c.Fatalf("It should not be successful to start daemon with wrong key: %v", err)
diff --git a/components/engine/integration-cli/docker_cli_external_volume_driver_unix_test.go b/components/engine/integration-cli/docker_cli_external_volume_driver_unix_test.go
index e9e92d4372..5269d0731c 100644
--- a/components/engine/integration-cli/docker_cli_external_volume_driver_unix_test.go
+++ b/components/engine/integration-cli/docker_cli_external_volume_driver_unix_test.go
@@ -268,10 +268,10 @@ func newVolumePlugin(c *check.C, name string) *volumePlugin {
 		send(w, `{"Capabilities": { "Scope": "global" }}`)
 	})
 
-	err := os.MkdirAll("/etc/docker/plugins", 0755)
+	err := os.MkdirAll("/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins", 0755)
 	assert.NilError(c, err)
 
-	err = ioutil.WriteFile("/etc/docker/plugins/"+name+".spec", []byte(s.Server.URL), 0644)
+	err = ioutil.WriteFile("/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins/"+name+".spec", []byte(s.Server.URL), 0644)
 	assert.NilError(c, err)
 	return s
 }
@@ -279,7 +279,7 @@ func newVolumePlugin(c *check.C, name string) *volumePlugin {
 func (s *DockerExternalVolumeSuite) TearDownSuite(c *check.C) {
 	s.volumePlugin.Close()
 
-	err := os.RemoveAll("/etc/docker/plugins")
+	err := os.RemoveAll("/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins")
 	assert.NilError(c, err)
 }
 
@@ -372,7 +372,7 @@ func hostVolumePath(name string) string {
 
 // Make sure a request to use a down driver doesn't block other requests
 func (s *DockerExternalVolumeSuite) TestExternalVolumeDriverLookupNotBlocked(c *check.C) {
-	specPath := "/etc/docker/plugins/down-driver.spec"
+	specPath := "/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins/down-driver.spec"
 	err := ioutil.WriteFile(specPath, []byte("tcp://127.0.0.7:9999"), 0644)
 	assert.NilError(c, err)
 	defer os.RemoveAll(specPath)
diff --git a/components/engine/integration-cli/docker_cli_network_unix_test.go b/components/engine/integration-cli/docker_cli_network_unix_test.go
index a071edd3f6..4bedb30937 100644
--- a/components/engine/integration-cli/docker_cli_network_unix_test.go
+++ b/components/engine/integration-cli/docker_cli_network_unix_test.go
@@ -209,14 +209,14 @@ func setupRemoteNetworkDrivers(c *check.C, mux *http.ServeMux, url, netDrv, ipam
 		}
 	})
 
-	err := os.MkdirAll("/etc/docker/plugins", 0755)
+	err := os.MkdirAll("/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins", 0755)
 	assert.NilError(c, err)
 
-	fileName := fmt.Sprintf("/etc/docker/plugins/%s.spec", netDrv)
+	fileName := fmt.Sprintf("/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins/%s.spec", netDrv)
 	err = ioutil.WriteFile(fileName, []byte(url), 0644)
 	assert.NilError(c, err)
 
-	ipamFileName := fmt.Sprintf("/etc/docker/plugins/%s.spec", ipamDrv)
+	ipamFileName := fmt.Sprintf("/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins/%s.spec", ipamDrv)
 	err = ioutil.WriteFile(ipamFileName, []byte(url), 0644)
 	assert.NilError(c, err)
 }
@@ -228,7 +228,7 @@ func (s *DockerNetworkSuite) TearDownSuite(c *check.C) {
 
 	s.server.Close()
 
-	err := os.RemoveAll("/etc/docker/plugins")
+	err := os.RemoveAll("/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins")
 	assert.NilError(c, err)
 }
 
diff --git a/components/engine/integration-cli/docker_cli_swarm_test.go b/components/engine/integration-cli/docker_cli_swarm_test.go
index 0eca47cd09..a82650c3de 100644
--- a/components/engine/integration-cli/docker_cli_swarm_test.go
+++ b/components/engine/integration-cli/docker_cli_swarm_test.go
@@ -788,14 +788,14 @@ func setupRemoteGlobalNetworkPlugin(c *check.C, mux *http.ServeMux, url, netDrv,
 		}
 	})
 
-	err := os.MkdirAll("/etc/docker/plugins", 0755)
+	err := os.MkdirAll("/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins", 0755)
 	assert.NilError(c, err)
 
-	fileName := fmt.Sprintf("/etc/docker/plugins/%s.spec", netDrv)
+	fileName := fmt.Sprintf("/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins/%s.spec", netDrv)
 	err = ioutil.WriteFile(fileName, []byte(url), 0644)
 	assert.NilError(c, err)
 
-	ipamFileName := fmt.Sprintf("/etc/docker/plugins/%s.spec", ipamDrv)
+	ipamFileName := fmt.Sprintf("/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins/%s.spec", ipamDrv)
 	err = ioutil.WriteFile(ipamFileName, []byte(url), 0644)
 	assert.NilError(c, err)
 }
@@ -807,7 +807,7 @@ func (s *DockerSwarmSuite) TestSwarmNetworkPlugin(c *check.C) {
 	setupRemoteGlobalNetworkPlugin(c, mux, s.server.URL, globalNetworkPlugin, globalIPAMPlugin)
 	defer func() {
 		s.server.Close()
-		err := os.RemoveAll("/etc/docker/plugins")
+		err := os.RemoveAll("/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins")
 		assert.NilError(c, err)
 	}()
 
diff --git a/components/engine/integration/plugin/authz/authz_plugin_test.go b/components/engine/integration/plugin/authz/authz_plugin_test.go
index 108cb837e8..7d01b0c097 100644
--- a/components/engine/integration/plugin/authz/authz_plugin_test.go
+++ b/components/engine/integration/plugin/authz/authz_plugin_test.go
@@ -56,15 +56,15 @@ func setupTestV1(t *testing.T) func() {
 	ctrl = &authorizationController{}
 	teardown := setupTest(t)
 
-	err := os.MkdirAll("/etc/docker/plugins", 0755)
+	err := os.MkdirAll("/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins", 0755)
 	assert.NilError(t, err)
 
-	fileName := fmt.Sprintf("/etc/docker/plugins/%s.spec", testAuthZPlugin)
+	fileName := fmt.Sprintf("/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins/%s.spec", testAuthZPlugin)
 	err = ioutil.WriteFile(fileName, []byte(server.URL), 0644)
 	assert.NilError(t, err)
 
 	return func() {
-		err := os.RemoveAll("/etc/docker/plugins")
+		err := os.RemoveAll("/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins")
 		assert.NilError(t, err)
 
 		teardown()
diff --git a/components/engine/integration/plugin/graphdriver/external_test.go b/components/engine/integration/plugin/graphdriver/external_test.go
index c89f9961d1..ff80b146a0 100644
--- a/components/engine/integration/plugin/graphdriver/external_test.go
+++ b/components/engine/integration/plugin/graphdriver/external_test.go
@@ -79,7 +79,7 @@ func TestExternalGraphDriver(t *testing.T) {
 
 	sserver.Close()
 	jserver.Close()
-	err := os.RemoveAll("/etc/docker/plugins")
+	err := os.RemoveAll("/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins")
 	assert.NilError(t, err)
 }
 
@@ -344,10 +344,10 @@ func setupPlugin(t *testing.T, ec map[string]*graphEventsCounter, ext string, mu
 		respond(w, &graphDriverResponse{Size: size})
 	})
 
-	err = os.MkdirAll("/etc/docker/plugins", 0755)
+	err = os.MkdirAll("/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins", 0755)
 	assert.NilError(t, err)
 
-	specFile := "/etc/docker/plugins/" + name + "." + ext
+	specFile := "/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins/" + name + "." + ext
 	err = ioutil.WriteFile(specFile, b, 0644)
 	assert.NilError(t, err)
 }
diff --git a/components/engine/pkg/plugins/discovery_unix.go b/components/engine/pkg/plugins/discovery_unix.go
index 58058f2828..a7b449ca25 100644
--- a/components/engine/pkg/plugins/discovery_unix.go
+++ b/components/engine/pkg/plugins/discovery_unix.go
@@ -2,4 +2,4 @@
 
 package plugins // import "github.com/docker/docker/pkg/plugins"
 
-var specsPaths = []string{"/etc/docker/plugins", "/usr/lib/docker/plugins"}
+var specsPaths = []string{"/storage/.kodi/userdata/addon_data/service.system.docker/config/plugins", "/usr/lib/docker/plugins"}
diff --git a/components/engine/pkg/plugins/plugins.go b/components/engine/pkg/plugins/plugins.go
index 2371e92101..4c7a16a9a5 100644
--- a/components/engine/pkg/plugins/plugins.go
+++ b/components/engine/pkg/plugins/plugins.go
@@ -4,7 +4,7 @@
 // Docker discovers plugins by looking for them in the plugin directory whenever
 // a user or container tries to use one by name. UNIX domain socket files must
 // be located under /run/docker/plugins, whereas spec files can be located
-// either under /etc/docker/plugins or /usr/lib/docker/plugins. This is handled
+// either under /storage/.kodi/userdata/addon_data/service.system.docker/config/plugins or /usr/lib/docker/plugins. This is handled
 // by the Registry interface, which lets you list all plugins or get a plugin by
 // its name if it exists.
 //
diff --git a/components/engine/registry/config_unix.go b/components/engine/registry/config_unix.go
index 20fb47bcae..a023df7895 100644
--- a/components/engine/registry/config_unix.go
+++ b/components/engine/registry/config_unix.go
@@ -4,7 +4,7 @@ package registry // import "github.com/docker/docker/registry"
 
 var (
 	// CertsDir is the directory where certificates are stored
-	CertsDir = "/etc/docker/certs.d"
+	CertsDir = "/storage/.kodi/userdata/addon_data/service.system.docker/config/certs.d"
 )
 
 // cleanPath is used to ensure that a directory name is valid on the target
diff --git a/components/engine/registry/endpoint_v1.go b/components/engine/registry/endpoint_v1.go
index 832fdb95a4..606ddfaf96 100644
--- a/components/engine/registry/endpoint_v1.go
+++ b/components/engine/registry/endpoint_v1.go
@@ -49,7 +49,7 @@ func validateEndpoint(endpoint *V1Endpoint) error {
 		if endpoint.IsSecure {
 			// If registry is secure and HTTPS failed, show user the error and tell them about `--insecure-registry`
 			// in case that's what they need. DO NOT accept unknown CA certificates, and DO NOT fallback to HTTP.
-			return fmt.Errorf("invalid registry endpoint %s: %v. If this private registry supports only HTTP or HTTPS with an unknown CA certificate, please add `--insecure-registry %s` to the daemon's arguments. In the case of HTTPS, if you have access to the registry's CA certificate, no need for the flag; simply place the CA certificate at /etc/docker/certs.d/%s/ca.crt", endpoint, err, endpoint.URL.Host, endpoint.URL.Host)
+			return fmt.Errorf("invalid registry endpoint %s: %v. If this private registry supports only HTTP or HTTPS with an unknown CA certificate, please add `--insecure-registry %s` to the daemon's arguments. In the case of HTTPS, if you have access to the registry's CA certificate, no need for the flag; simply place the CA certificate at /storage/.kodi/userdata/addon_data/service.system.docker/config/certs.d/%s/ca.crt", endpoint, err, endpoint.URL.Host, endpoint.URL.Host)
 		}
 
 		// If registry is insecure and HTTPS failed, fallback to HTTP.
