Description: correct some typos
Author: Jörg Frings-Fürst <debian@jff-webhosting.net>
Last-Update: 2016-10-11
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
Index: trunk/spectro/dispcal.c
===================================================================
--- trunk.orig/spectro/dispcal.c
+++ trunk/spectro/dispcal.c
@@ -1942,7 +1942,7 @@ int main(int argc, char *argv[]) {
 			/* Serial port flow control */
 			} else if (argv[fa][1] == 'W') {
 				fa = nfa;
-				if (na == NULL) usage(0,"Paramater expected following -W");
+				if (na == NULL) usage(0,"Parameter expected following -W");
 				if (na[0] == 'n' || na[0] == 'N')
 					fc = fc_None;
 				else if (na[0] == 'h' || na[0] == 'H')
@@ -1965,13 +1965,13 @@ int main(int argc, char *argv[]) {
 			/* Black point correction amount */
 			} else if (argv[fa][1] == 'k') {
 				fa = nfa;
-				if (na == NULL) usage(0,"Paramater expected following -k");
+				if (na == NULL) usage(0,"Parameter expected following -k");
 				bkcorrect = atof(na);
 				if (bkcorrect < 0.0 || bkcorrect > 1.0) usage(0,"-k parameter must be between 0.0 and 1.0");
 			/* Neutral blend rate (power) */
 			} else if (argv[fa][1] == 'A') {
 				fa = nfa;
-				if (na == NULL) usage(0,"Paramater expected following -A");
+				if (na == NULL) usage(0,"Parameter expected following -A");
 				x.nbrate = atof(na);
 				if (x.nbrate < 0.05 || x.nbrate > 20.0) usage(0,"-A parameter must be between 0.05 and 20.0");
 			/* Black brightness */
@@ -2004,7 +2004,7 @@ int main(int argc, char *argv[]) {
 			/* COM port  */
 			} else if (argv[fa][1] == 'c') {
 				fa = nfa;
-				if (na == NULL) usage(0,"Paramater expected following -c");
+				if (na == NULL) usage(0,"Parameter expected following -c");
 				comport = atoi(na);
 				if (comport < 1 || comport > 50) usage(0,"-c parameter %d out of range",comport);
 
@@ -3068,7 +3068,7 @@ int main(int argc, char *argv[]) {
 			/* Black level adjustment */
 			/* Due to the possibility of the channel offsets not being even, */
 			/* we use the largest of the XYZ values after they have been */
-			/* scaled to be even acording to the white XYZ balance. */
+			/* scaled to be even according to the white XYZ balance. */
 			/* It's safer to set the black level a bit low, and then the */
 			/* calibration curves can bump the low ones up. */
 			if (c == '1') {
Index: trunk/spectro/spotread.c
===================================================================
--- trunk.orig/spectro/spotread.c
+++ trunk/spectro/spotread.c
@@ -497,7 +497,7 @@ int main(int argc, char *argv[]) {
 			/* COM port  */
 			} else if (argv[fa][1] == 'c') {
 				fa = nfa;
-				if (na == NULL) usage("Paramater expected following -c");
+				if (na == NULL) usage("Parameter expected following -c");
 				{
 					comport = atoi(na);
 					if (comport < 1 || comport > 40) usage("-c parameter %d out of range",comport);
@@ -506,7 +506,7 @@ int main(int argc, char *argv[]) {
 			/* Display type */
 			} else if (argv[fa][1] == 'y') {
 				fa = nfa;
-				if (na == NULL) usage("Paramater expected following -y");
+				if (na == NULL) usage("Parameter expected following -y");
 				dtype = na[0];
 
 #ifndef SALONEINSTLIB
@@ -514,7 +514,7 @@ int main(int argc, char *argv[]) {
 			} else if (argv[fa][1] == 'I') {
 
 				fa = nfa;
-				if (na == NULL) usage("Paramater expected following -I");
+				if (na == NULL) usage("Parameter expected following -I");
 				if (strcmp(na, "A") == 0
 				 || strcmp(na, "M0") == 0) {
 					tillum_set = spec = 1;
@@ -562,7 +562,7 @@ int main(int argc, char *argv[]) {
 			/* Spectral Illuminant type for XYZ computation */
 			} else if (argv[fa][1] == 'i') {
 				fa = nfa;
-				if (na == NULL) usage("Paramater expected following -i");
+				if (na == NULL) usage("Parameter expected following -i");
 				if (strcmp(na, "A") == 0) {
 					illum_set = spec = 1;
 					illum = icxIT_A;
@@ -611,7 +611,7 @@ int main(int argc, char *argv[]) {
 			/* Spectral Observer type */
 			} else if (argv[fa][1] == 'Q') {
 				fa = nfa;
-				if (na == NULL) usage("Paramater expected following -Q");
+				if (na == NULL) usage("Parameter expected following -Q");
 				if (strcmp(na, "1931_2") == 0) {			/* Classic 2 degree */
 					obType = icxOT_CIE_1931_2;
 				} else if (strcmp(na, "1964_10") == 0) {	/* Classic 10 degree */
@@ -693,7 +693,7 @@ int main(int argc, char *argv[]) {
 			/* Filter configuration */
 			} else if (argv[fa][1] == 'F') {
 				fa = nfa;
-				if (na == NULL) usage("Paramater expected following -F");
+				if (na == NULL) usage("Parameter expected following -F");
 				if (na[0] == 'n' || na[0] == 'N')
 					fe = inst_opt_filter_none;
 				else if (na[0] == 'p' || na[0] == 'P')
@@ -708,13 +708,13 @@ int main(int argc, char *argv[]) {
 			/* Extra filter compensation file */
 			} else if (argv[fa][1] == 'E') {
 				fa = nfa;
-				if (na == NULL) usage("Paramater expected following -E");
+				if (na == NULL) usage("Parameter expected following -E");
 				strncpy(filtername,na,MAXNAMEL-1); filtername[MAXNAMEL-1] = '\000';
 
 			/* XRGA conversion */
 			} else if (argv[fa][1] == 'A') {
 				fa = nfa;
-				if (na == NULL) usage("Paramater expected following -A");
+				if (na == NULL) usage("Parameter expected following -A");
 				if (na[0] == 'N')
 					calstd = xcalstd_none;
 				else if (na[0] == 'A')
@@ -724,7 +724,7 @@ int main(int argc, char *argv[]) {
 				else if (na[0] == 'G')
 					calstd = xcalstd_gmdi;
 				else
-					usage("Paramater after -A '%c' not recognized",na[0]);
+					usage("Parameter after -A '%c' not recognized",na[0]);
 
 			/* Show Yxy */
 			} else if (argv[fa][1] == 'x') {
@@ -1432,7 +1432,7 @@ int main(int argc, char *argv[]) {
 
 		/* Or something is wrong with instrument capabilities */
 		} else {
-			printf("\nNo reasonable trigger mode avilable for this instrument\n");
+			printf("\nNo reasonable trigger mode available for this instrument\n");
 			it->del(it);
 			return -1;
 		}
Index: trunk/spectro/colorhug.c
===================================================================
--- trunk.orig/spectro/colorhug.c
+++ trunk/spectro/colorhug.c
@@ -212,7 +212,7 @@ colorhug_command(colorhug *p,
 
 	a1logd(p->log,8,"colorhug_command: Read %d bytes and %d read\n",xrbytes,rbytes);
 	if (rbytes >= 2) {
-		a1logd(p->log,6,"colorhug_command: recieved cmd '%s' error '%s' args '%s'\n",
+		a1logd(p->log,6,"colorhug_command: received cmd '%s' error '%s' args '%s'\n",
 				inst_desc(buf[1]),
 				colorhug_interp_error((inst *) p, buf[0]),
 				icoms_tohex(buf, rbytes - 2));
Index: trunk/spectro/dispwin.c
===================================================================
--- trunk.orig/spectro/dispwin.c
+++ trunk/spectro/dispwin.c
@@ -2766,7 +2766,7 @@ int dispwin_install_profile(dispwin *p,
 
 /* Un-Install a display profile */
 /* Return nz if failed, */
-/* 1 if not sucessfully deleted */
+/* 1 if not successfully deleted */
 /* 2 if profile not found */
 int dispwin_uninstall_profile(dispwin *p, char *fname, p_scope scope) {
 	debugr2((errout,"dispwin_uninstall_profile '%s'\n", fname));
@@ -5038,7 +5038,7 @@ int ddebug						/* >0 to print debug sta
 		vinfo = XGetVisualInfo(p->mydisplay, VisualIDMask, &template, &nitems); 
 
 		if (nitems < 1) {
-			debugr2((errout,"new_dispwin: Failed to get XGetVisualInfo of defalt Visual\n"));
+			debugr2((errout,"new_dispwin: Failed to get XGetVisualInfo of default Visual\n"));
 			dispwin_del(p);
 			return NULL;
 		}
@@ -5630,7 +5630,7 @@ int ddebug						/* >0 to print debug sta
 		p->native = native &= ~2;
 	}
 
-	debugr("new_dispwin: return sucessfully\n");
+	debugr("new_dispwin: return successfully\n");
 	return p;
 }
 
Index: trunk/spectro/dtp51.c
===================================================================
--- trunk.orig/spectro/dtp51.c
+++ trunk/spectro/dtp51.c
@@ -680,7 +680,7 @@ dtp51_interp_error(inst *pp, int ec) {
 		case DTP51_INVALID_STEP:
 			return "Invalid step";
 		case DTP51_NO_DATA_AVAILABLE:
-			return "No data availble";
+			return "No data available";
 		case DTP51_LAMP_MARGINAL:
 			return "Lamp marginal";
 		case DTP51_LAMP_FAILURE:
Index: trunk/spectro/dtp92.c
===================================================================
--- trunk.orig/spectro/dtp92.c
+++ trunk/spectro/dtp92.c
@@ -357,7 +357,7 @@ dtp92_init_coms(inst *pp, baud_rate br,
 					if ((ev = dtp92_command(p, tbuf, buf, MAX_MES_SIZE, 6.0)) != inst_ok)
 						error("Writing offset drift value failed");
 					else
-						printf("Writing offset drift value suceeded!\n");
+						printf("Writing offset drift value succeeded!\n");
 				} else {
 					printf("No command written\n");
 				}
@@ -371,7 +371,7 @@ dtp92_init_coms(inst *pp, baud_rate br,
 		return inst_coms_fail;
 	}
 
-	a1logd(p->log, 2, "dtp92_init_coms: init coms has suceeded\n");
+	a1logd(p->log, 2, "dtp92_init_coms: init coms has succeeded\n");
 
 	p->gotcoms = 1;
 	return inst_ok;
@@ -941,7 +941,7 @@ dtp92_interp_error(inst *pp, int ec) {
 		case DTP92_NO_DATA_AVAILABLE:
 			return "No data available";
 		case DTP92_MISSING_PARAMETER:
-			return "Paramter is missing";
+			return "Parameter is missing";
 		case DTP92_CALIBRATION_DENIED:
 			return "Invalid calibration enable code";
 		case DTP92_NEEDS_OFFSET_CAL:
Index: trunk/spectro/hidio.c
===================================================================
--- trunk.orig/spectro/hidio.c
+++ trunk/spectro/hidio.c
@@ -739,7 +739,7 @@ icoms_hid_read(icoms *p,
 	{
 		unsigned char *rbuf2;
 
-		/* Create a copy of the data recieved with one more byte */
+		/* Create a copy of the data received with one more byte */
 		if ((rbuf2 = malloc(bsize + 1)) == NULL) {
 			a1loge(p->log, ICOM_SYS, "icoms_hid_read: malloc failed\n");
 			return ICOM_SYS;
Index: trunk/spectro/huey.c
===================================================================
--- trunk.orig/spectro/huey.c
+++ trunk/spectro/huey.c
@@ -81,7 +81,7 @@ static int icoms2huey_err(int se, int to
 /* i1Display command codes */
 /* B = byte (8bit), S = short (16bit), W = word (32bit), A = string */
 /* U = unused byte, - = no arguments/results */
-/* The is a 7 byte command buffer and 6 response recieve buffer. */
+/* The is a 7 byte command buffer and 6 response receive buffer. */
 /* :2 means the read is from a second 8 byte ep x81 read. */
 /* cbuf[-] is command byte */
 /* rbuf[-2] is continuation byte */
Index: trunk/spectro/i1pro_imp.c
===================================================================
--- trunk.orig/spectro/i1pro_imp.c
+++ trunk/spectro/i1pro_imp.c
@@ -2700,7 +2700,7 @@ int *pinstmsec) {	/* Return instrument l
 			break;
 	}
 
-	a1logd(p->log, 2, "i1pro_meas_delay: stoped at sample %d time %f\n",i,samp[i].sec);
+	a1logd(p->log, 2, "i1pro_meas_delay: stopped at sample %d time %f\n",i,samp[i].sec);
 
 	/* Compute overall delay */
 	dispmsec = (int)(samp[i].sec * 1000.0 + 0.5);				/* Display update time */
@@ -3815,7 +3815,7 @@ i1pro_code i1pro_imp_meas_refrate(
 			}
 		}
 	} else {
-		a1logd(p->log, 3, "Not enough tries suceeded to determine refresh rate\n");
+		a1logd(p->log, 3, "Not enough tries succeeded to determine refresh rate\n");
 	}
 
 	return I1PRO_RD_NOREFR_FOUND; 
@@ -3910,7 +3910,7 @@ i1pro_code i1pro_restore_refspot_cal(i1p
 		return I1PRO_OK;
 	}
 
-	/* We've sucessfully restored the dark calibration */
+	/* We've successfully restored the dark calibration */
 	s->dark_valid = 1;
 	s->ddate = m->caldate;
 
@@ -3955,7 +3955,7 @@ i1pro_code i1pro_restore_refspot_cal(i1p
 		return I1PRO_OK;
 	}
 
-	/* We've sucessfully restored the calibration */
+	/* We've successfully restored the calibration */
 	s->cal_valid = 1;
 	s->cfdate = m->caldate;
 
Index: trunk/spectro/madvrwin.c
===================================================================
--- trunk.orig/spectro/madvrwin.c
+++ trunk/spectro/madvrwin.c
@@ -603,7 +603,7 @@ int ii = 0;
 	}
 #endif
 
-	debugr("new_madvrwin: return sucessfully\n");
+	debugr("new_madvrwin: return successfully\n");
 
 	return p;
 }
Index: trunk/spectro/ss.c
===================================================================
--- trunk.orig/spectro/ss.c
+++ trunk/spectro/ss.c
@@ -374,7 +374,7 @@ ss_init_coms(inst *pp, baud_rate br, flo
 
 	p->gotcoms = 1;
 
-	a1logd(p->log, 2, "ss_init_coms: init coms has suceeded\n");
+	a1logd(p->log, 2, "ss_init_coms: init coms has succeeded\n");
 
 	return inst_ok;
 }
@@ -1743,7 +1743,7 @@ ss_interp_error(inst *pp, int ec) {
 		case ss_et_FilterOutOfPos:
 			return "Filter wheel out of position";
 		case ss_et_SendTimeout:
-			return "Data transmission timout";
+			return "Data transmission timeout";
 		case ss_et_DriveError:
 			return "Data drive defect";
 		case ss_et_MeasDisabled:
@@ -1863,7 +1863,7 @@ ss_interp_error(inst *pp, int ec) {
 		case ss_et_BadHexEncoding:
 			return "Message received from instrument has bad Hex encoding";
 		case ss_et_RecBufferOverun:
-			return "Message received from instrument would overflow recieve buffer";
+			return "Message received from instrument would overflow receive buffer";
 		default:
 			return "Unknown error code";
 	}
Index: trunk/spectro/ss_imp.c
===================================================================
--- trunk.orig/spectro/ss_imp.c
+++ trunk/spectro/ss_imp.c
@@ -216,7 +216,7 @@ static int h2b(ss *p, char c) {
 	return 0;
 }
 
-/* Return the first enum from the recieve buffer without removing it. */
+/* Return the first enum from the receive buffer without removing it. */
 int ss_peek_ans(ss *p) {
 	int rv;
 
Index: trunk/spectro/webwin.c
===================================================================
--- trunk.orig/spectro/webwin.c
+++ trunk/spectro/webwin.c
@@ -411,7 +411,7 @@ int ddebug						/* >0 to print debug sta
 		msec_sleep(50);
 	}
 
-	debugr("new_webwin: return sucessfully\n");
+	debugr("new_webwin: return successfully\n");
 
 	return p;
 }
Index: trunk/xicc/cv.c
===================================================================
--- trunk.orig/xicc/cv.c
+++ trunk/xicc/cv.c
@@ -101,7 +101,7 @@ main(int argc, char *argv[]) {
 
 	printf("There are %d parameters:\n",np); fflush(stdout);
 	for (i = 0; i < np; i++) {
-		printf("Paramter %d = %f\n",i, params[i]); fflush(stdout);
+		printf("Parameter %d = %f\n",i, params[i]); fflush(stdout);
 	}
 
 	/* Display the result */
Index: trunk/spectro/ss_imp.h
===================================================================
--- trunk.orig/spectro/ss_imp.h
+++ trunk/spectro/ss_imp.h
@@ -723,7 +723,7 @@ void ss_add_string(struct _ss *p, char *
 /* - - - - - - - - - - - - - - - - - - - - - */
 /* ANSWER: */
 
-/* Return the first enum from the recieve buffer without removing it. */
+/* Return the first enum from the receive buffer without removing it. */
 int ss_peek_ans(struct _ss *p);
 
 /* Remove a Spectrolino answer enum from the revieve buffer, */
Index: trunk/imdi/cctiff.c
===================================================================
--- trunk.orig/imdi/cctiff.c
+++ trunk/imdi/cctiff.c
@@ -36,7 +36,7 @@
 	Add flag to ignore inkname mismatches.
 
 
-	Should add support for transfering any extra alpha
+	Should add support for transferring any extra alpha
 	planes from input to output, rather than simply ignoring them.
 
 
@@ -1952,11 +1952,11 @@ main(int argc, char *argv[]) {
 
 		if (wh != NULL) {
 			printf("Output TIFF file '%s'\n",out_name);
-			printf("Ouput raster file ICC colorspace is %s\n",icm2str(icmColorSpaceSignature,su.outs));
+			printf("Output raster file ICC colorspace is %s\n",icm2str(icmColorSpaceSignature,su.outs));
 			printf("Output TIFF file photometric is %s\n",Photometric2str(wphotometric));
 		} else {
 			printf("Output JPEG file '%s'\n",out_name);
-			printf("Ouput raster file ICC colorspace is %s\n",icm2str(icmColorSpaceSignature,su.outs));
+			printf("Output raster file ICC colorspace is %s\n",icm2str(icmColorSpaceSignature,su.outs));
 			printf("Output JPEG file colorspace is %s\n",JPEG_cspace2str(wj.jpeg_color_space));
 			if (wdesc != NULL)
 				printf("Output raster file description: '%s'\n",wdesc);
Index: trunk/imdi/imdi.h
===================================================================
--- trunk.orig/imdi/imdi.h
+++ trunk/imdi/imdi.h
@@ -38,7 +38,7 @@ struct _imdi {
 
 	/* Note that once an imdi is created, multiple can call interp() without */
 	/* interfering with each other, allowing parallel execution. */
-	void (*interp)(struct _imdi *s, void **outp, int outst,		/* Ouput pointers and stride */
+	void (*interp)(struct _imdi *s, void **outp, int outst,		/* Output pointers and stride */
 	                                void **inp, int inst,		/* Input pointers and stride */
 	                                unsigned int npixels);		/* Number of pixels */
 
Index: trunk/spectro/munki_imp.c
===================================================================
--- trunk.orig/spectro/munki_imp.c
+++ trunk/spectro/munki_imp.c
@@ -1904,7 +1904,7 @@ int *pinstmsec) {    /* Return instrumen
 			break;
 	}
 
-	a1logd(p->log, 2, "munki_meas_delay: stoped at sample %d time %f\n",i,samp[i].sec);
+	a1logd(p->log, 2, "munki_meas_delay: stopped at sample %d time %f\n",i,samp[i].sec);
 
 	/* Compute overall delay and subtract patch change delay */
 	dispmsec = (int)(samp[i].sec * 1000.0 + 0.5);
@@ -3046,7 +3046,7 @@ munki_code munki_imp_meas_refrate(
 			}
 		}
 	} else {
-		a1logd(p->log, 3, "Not enough tries suceeded to determine refresh rate\n");
+		a1logd(p->log, 3, "Not enough tries succeeded to determine refresh rate\n");
 	}
 
 	return MUNKI_RD_NOREFR_FOUND; 
@@ -6425,7 +6425,7 @@ munki_code munki_create_hr(munki *p, int
 	int i, j, jj, k, cx, sx;
 	munki_fc coeff[40][16];	/* Existing filter cooefficients */
 	int nwav1;					/* Number of filters */
-	double wl_short1, wl_long1;	/* Ouput wavelength of first and last filters */
+	double wl_short1, wl_long1;	/* Output wavelength of first and last filters */
 	double wl_step1;
 	munki_xp xp[41];			/* Crossover points each side of filter */
 	munki_code ev = MUNKI_OK;
@@ -8733,7 +8733,7 @@ munki_readmeasurement(
 
 	top = extra + m->c_inttime * nmeas;
 
-	a1logd(p->log,2,"munki_readmeasurement: inummeas %d, scanflag %d, address %p bsize 0x%x, timout %f\n",inummeas, scanflag, buf, bsize, top);
+	a1logd(p->log,2,"munki_readmeasurement: inummeas %d, scanflag %d, address %p bsize 0x%x, timeout %f\n",inummeas, scanflag, buf, bsize, top);
 
 	for (;;) {
 		int size;		/* number of bytes to read */
Index: trunk/target/printtarg.c
===================================================================
--- trunk.orig/target/printtarg.c
+++ trunk/target/printtarg.c
@@ -345,7 +345,7 @@ static	void ps_setcolor(trend *ss, xcal
 		} else if (c->altrep == 6) {	/* DeviceN */
 			gen_ncolor(s, c);
 		} else {
-			error("Device white encoding not approproate!");
+			error("Device white encoding not appropriate!");
 		}
 
 	} else if (c->nmask == ICX_K) {
@@ -362,7 +362,7 @@ static	void ps_setcolor(trend *ss, xcal
 		} else if (c->altrep == 3) {	/* DeviceN */
 			gen_ncolor(s, c);
 		} else {
-			error("Device black encoding not approproate!");
+			error("Device black encoding not appropriate!");
 		}
 
 	} else if (c->nmask == ICX_CMY) {
@@ -377,7 +377,7 @@ static	void ps_setcolor(trend *ss, xcal
 		} else if (c->altrep == 8) {	/* DeviceN */
 			gen_ncolor(s, c);
 		} else {
-			error("Device CMY encoding not approproate!");
+			error("Device CMY encoding not appropriate!");
 		}
 
 	} else if (c->nmask == ICX_RGB || c->nmask == ICX_IRGB) {
@@ -749,7 +749,7 @@ static	void tiff_setcolor(trend *ss, xca
 		} else if (c->altrep == 6) {	/* DeviceN single channel */
 			s->c[0] = cdev[0];
 		} else {
-			error("Device white encoding not approproate!");
+			error("Device white encoding not appropriate!");
 		}
 
 	} else if (c->nmask == ICX_K) {
@@ -765,7 +765,7 @@ static	void tiff_setcolor(trend *ss, xca
 		} else if (c->altrep == 3) {	/* DeviceN single channel */
 			s->c[0] = cdev[0];
 		} else {
-			error("Device black encoding not approproate!");
+			error("Device black encoding not appropriate!");
 		}
 
 	} else if (c->nmask == ICX_CMY) {
@@ -783,7 +783,7 @@ static	void tiff_setcolor(trend *ss, xca
 			s->c[1] = cdev[1];
 			s->c[2] = cdev[2];
 		} else {
-			error("Device CMY encoding not approproate!");
+			error("Device CMY encoding not appropriate!");
 		}
 
 	} else {
@@ -968,7 +968,7 @@ static trend *new_tiff_trend(
 			nc = icx_noofinks(nmask);
 			nc = 1;
 		} else {
-			error("Device white encoding not approproate");
+			error("Device white encoding not appropriate");
 		}
 
 	} else if (nmask == ICX_K) {
@@ -984,7 +984,7 @@ static trend *new_tiff_trend(
 			nc = icx_noofinks(nmask);
 			nc = 1;
 		} else {
-			error("Device black encoding not approproate");
+			error("Device black encoding not appropriate");
 		}
 
 	} else if (nmask == ICX_RGB || nmask == ICX_IRGB) {
@@ -1002,7 +1002,7 @@ static trend *new_tiff_trend(
 			csp = ncol_2d;
 			nc = icx_noofinks(nmask);
 		} else {
-			error("Device CMY encoding not approproate");
+			error("Device CMY encoding not appropriate");
 		}
 
 	} else if (nmask == ICX_CMYK) {
@@ -2209,7 +2209,7 @@ int *p_npat			/* Return number of patche
 
 
 	} else {
-		error("Unsupported intrument type");
+		error("Unsupported instrument type");
 	}
 	
 	/* Compute page limits */
@@ -2255,7 +2255,7 @@ int *p_npat			/* Return number of patche
 	tidpad = (pprow - tidminp)/2;	/* Center TID */
 
 	if (pprow < (1+nextrap))
-		error("Paper size not long enought for a single patch per row!");
+		error("Paper size not long enough for a single patch per row!");
 
 	*ptpprow = tpprow = pprow - nextrap;	/* Test sample patches per row */
 
@@ -2953,7 +2953,7 @@ char *argv[];
 	double sscale = 1.0;	/* Spacer size scale */
 	int rand = 1;
 	int qbits = 0;			/* Quantization bits */
-	int oft = 0;			/* Ouput File type, 0 = PS, 1 = EPS , 2 = TIFF */
+	int oft = 0;			/* Output File type, 0 = PS, 1 = EPS , 2 = TIFF */
 	int nocups = 0;			/* Supress CUPS PS/EPS job ticket */
 	depth2d tiffdpth = bpc8_2d;	/* TIFF pixel depth */
 	double tiffres = 100.0;	/* TIFF resolution in DPI */
Index: trunk/gamut/nearsmth.c
===================================================================
--- trunk.orig/gamut/nearsmth.c
+++ trunk/gamut/nearsmth.c
@@ -263,7 +263,7 @@ double dxratio		/* Depth expansion ratio
 	double va, vr, vd, vv = 0.0;
 
 	/* Absolute, Delta E^2 between test point and destination closest */
-	/* aodv is already positioned acording to the LCh weights, */
+	/* aodv is already positioned according to the LCh weights, */
 	/* so weight as per average of these */
 	a_o = w->a.o;
 	va = wdesq(dtp, aodv, a_o, a_o, a_o, SUM_POW);
@@ -4067,7 +4067,7 @@ static void create_influence_plot(nearsm
 	swdiag = new_rspl(RSPL_NOFLAGS, 3, 3);	/* Allocate 3D -> 3D */
 	swdiag->fit_rspl(swdiag, RSPL_NOFLAGS, fpnts, nmpts, NULL, NULL, gres, NULL, NULL, 1.0, avgdev, NULL);
 
-	/* Now create a plot of the sci_gam with the vertexes colored acording to the */
+	/* Now create a plot of the sci_gam with the vertexes colored according to the */
 	/* diagnostic map. */
 	if ((wrl = new_vrml("sci_gam_wt", 1, vrml_lab)) == NULL) {
 		fprintf(stderr,"gamut map: new_vrml failed for '%s%s'\n","sci_gam_wt",vrm_ext());
Index: trunk/gamut/nearsmth.h
===================================================================
--- trunk.orig/gamut/nearsmth.h
+++ trunk/gamut/nearsmth.h
@@ -294,7 +294,7 @@ gammapweights *src2, double wgt2,
 gammapweights *src3, double wgt3
 );
 
-/* Tweak weights acording to extra cmy cusp flags or rel override */
+/* Tweak weights according to extra cmy cusp flags or rel override */
 void tweak_weights(gammapweights out[14], int dst_cmymap, int rel_oride);
 
 #endif /* NEARSMTH_H */
Index: trunk/imdi/cctiffo.c
===================================================================
--- trunk.orig/imdi/cctiffo.c
+++ trunk/imdi/cctiffo.c
@@ -307,7 +307,7 @@ int pmtc
 		case PHOTOMETRIC_LOGLUV:
 			return "CIELog2Luv";
 	}
-	sprintf(buf,"Unknonw Tag %d",pmtc);
+	sprintf(buf,"Unknown Tag %d",pmtc);
 	return buf;
 }
 
Index: trunk/imdi/greytiff.c
===================================================================
--- trunk.orig/imdi/greytiff.c
+++ trunk/imdi/greytiff.c
@@ -131,7 +131,7 @@ int pmtc
 		case PHOTOMETRIC_LOGLUV:
 			return "CIELog2Luv";
 	}
-	sprintf(buf,"Unknonw Tag %d",pmtc);
+	sprintf(buf,"Unknown Tag %d",pmtc);
 	return buf;
 }
 
Index: trunk/link/collink.c
===================================================================
--- trunk.orig/link/collink.c
+++ trunk/link/collink.c
@@ -1110,7 +1110,7 @@ void devip_devop(void *cntx, double *out
 			}
 			/* We've got the input profile PCS' at this point. */
 
-			/* If we're transfering the K value from the input profile to the */
+			/* If we're transferring the K value from the input profile to the */
 			/* output, copy it into locus[], which will be given to the inverse */
 			/* lookup function, else the inverse lookup will generate a K using */
 			/* the curve parameters. */  
@@ -1192,7 +1192,7 @@ void devip_devop(void *cntx, double *out
 			if (p->verb)
 #endif
 			{
-				printf("White point hack mapped %f %f %f to %f %f %f, hit withing %f\n",
+				printf("White point hack mapped %f %f %f to %f %f %f, hit within %f\n",
     		    p->in.wp[0],p->in.wp[1],p->in.wp[2],pcsv[0], pcsv[1], pcsv[2],dd);
 				fflush(stdout);
 			}
@@ -1242,7 +1242,7 @@ void devip_devop(void *cntx, double *out
 		if (p->nhack == 2) {
 			/* Ideally we would create a 4D PCSK -> PCSK gamut mapping */
 			/* to smoothly and accurately cope with the changing source */
-			/* and destination gamuts acording to their degree of "K onlyness". */
+			/* and destination gamuts according to their degree of "K onlyness". */
 			/* In practice we're going to simply interpolated between */
 			/* two extremes: unrestricted gamut and K only black gamut. */
 			double map0[3], map1[3];
@@ -4737,7 +4737,7 @@ main(int argc, char *argv[]) {
 		}
 
 		if (li.verb)
-			printf("Finished verfication\n");
+			printf("Finished verification\n");
 
 		printf("Average error = %f%%, peak error = %f%%\n",aerr * 100.0/nerr, perr * 100.0);
 		printf("Input %f %f %f %f\n",pin[0], pin[1], pin[2], pin[3]);
Index: trunk/profile/printcal.c
===================================================================
--- trunk.orig/profile/printcal.c
+++ trunk/profile/printcal.c
@@ -1294,7 +1294,7 @@ int main(int argc, char *argv[]) {
 				icmXYZ2Lab(&wht, wp->Lab, wp->XYZ);
 			}
 
-			/* Sort the channel acording to device value */ 
+			/* Sort the channel according to device value */
 			/* For a consistent result for identical device values, */
 			/* secondary sort by inverse CIE value */
 //#define HEAP_COMPARE(A,B) ((A).dev < (B).dev)
Index: trunk/spectro/dispsup.c
===================================================================
--- trunk.orig/spectro/dispsup.c
+++ trunk/spectro/dispsup.c
@@ -719,7 +719,7 @@ static int disprd_read_imp(
 		scb->serno = p->serno++;
 		scb->msec = msec_time();
 
-		a1logd(p->log,1, "got reading %f %f %f, transfering to col\n",
+		a1logd(p->log,1, "got reading %f %f %f, transferring to col\n",
 		                val.XYZ[0], val.XYZ[1], val.XYZ[2]);
 
 		scb->mtype = val.mtype;
@@ -1239,7 +1239,7 @@ int disprd_ambient(
 
 	/* Or something is wrong with instrument capabilities */
 	} else {
-		printf("No reasonable trigger mode avilable for this instrument\n");
+		printf("No reasonable trigger mode available for this instrument\n");
 		return 2;
 	}
 
@@ -2342,7 +2342,7 @@ static int config_inst_displ(disprd *p)
 	/* Reset key meanings */
 	inst_reset_uih();
 
-	a1logd(p->log,1,"config_inst_displ suceeded\n");
+	a1logd(p->log,1,"config_inst_displ succeeded\n");
 	return 0;
 }
 
Index: trunk/gamut/gammap.c
===================================================================
--- trunk.orig/gamut/gammap.c
+++ trunk/gamut/gammap.c
@@ -859,7 +859,7 @@ gammap *new_gammap(
 #endif
 			if (gmi->bph == gmm_clipBP) {
 
-				/* Extend the target black point to accomodate the */
+				/* Extend the target black point to accommodate the */
 				/* bent or clipped destination space L* range */
 				if (fabp[0] < dr_cs_bp[0]) {
 					t = (fabp[0] - dr_cs_wp[0])/(dr_cs_bp[0] - dr_cs_wp[0]);
Index: trunk/profile/profout.c
===================================================================
--- trunk.orig/profile/profout.c
+++ trunk/profile/profout.c
@@ -1103,7 +1103,7 @@ make_output_icc(
 		if (iccver < icmVersion2_4) {
 			iccver = icmVersion2_4;		/* Need 2.4.0 for Display intents */
 			if (verb)
-				fprintf(verbo,"Bumped ICC version to 2.4.0 to accomodate multiple Display intents\n");
+				fprintf(verbo,"Bumped ICC version to 2.4.0 to accommodate multiple Display intents\n");
 		}
 	}
 	if (wr_icco->set_version(wr_icco, iccver) != 0)
Index: trunk/render/thscreen.c
===================================================================
--- trunk.orig/render/thscreen.c
+++ trunk/render/thscreen.c
@@ -636,7 +636,7 @@ thscreen *new_thscreen(
 	mrang = 65535.0/(t->oelev - 1.0); 
 	DBG(("new_thscreen() raw modulation rande = %f\n",mrang));
 
-	/* Modify the modulation range to accomodate any level overlap */
+	/* Modify the modulation range to accommodate any level overlap */
 	if (olap > 0.0 && t->oelev > 2) {
 		mrang = ((t->oelev - 2.0) * olap * mrang + 65535.0)/(t->oelev - 1.0);
 		DBG(("new_thscreen() modulation adjusted for overlap = %f\n",mrang));
Index: trunk/xicc/xspect.c
===================================================================
--- trunk.orig/xicc/xspect.c
+++ trunk/xicc/xspect.c
@@ -4530,7 +4530,7 @@ void xspect_plot10(xspect *sp, int n) {
 /* Given an emission spectrum, set the UV output to the given level. */
 /* The shape of the UV is taken from FWA1_stim, and the level is */
 /* with respect to the Y of the input spectrum. */
-/* The output range is extended to accomodate the UV wavelengths */
+/* The output range is extended to accommodate the UV wavelengths */
 void xsp_setUV(xspect *out, xspect *in, double uvlevel) {
 	int i, xs, xe;
 	double ww, avg;
Index: trunk/spectro/ccxxmake.c
===================================================================
--- trunk.orig/spectro/ccxxmake.c
+++ trunk/spectro/ccxxmake.c
@@ -398,7 +398,7 @@ int main(int argc, char *argv[]) {
 			/* COM port  */
 			} else if (argv[fa][1] == 'c') {
 				fa = nfa;
-				if (na == NULL) usage(0,"Paramater expected following -c");
+				if (na == NULL) usage(0,"Parameter expected following -c");
 				comno = atoi(na);
 				if (comno < 1 || comno > 40) usage(0,"-c parameter %d out of range",comno);
 
@@ -498,7 +498,7 @@ int main(int argc, char *argv[]) {
 			/* Serial port flow control */
 			} else if (argv[fa][1] == 'W') {
 				fa = nfa;
-				if (na == NULL) usage(0,"Paramater expected following -W");
+				if (na == NULL) usage(0,"Parameter expected following -W");
 				if (na[0] == 'n' || na[0] == 'N')
 					fc = fc_None;
 				else if (na[0] == 'h' || na[0] == 'H')
@@ -587,7 +587,7 @@ int main(int argc, char *argv[]) {
 		strcat(outname, doccss ? ".ccss" : ".ccmx");
 
 	if (fakeseq && doccss)
-		error("Fake CCSS test not implemeted");
+		error("Fake CCSS test not implemented");
 
 	printf("\n");
 
@@ -803,7 +803,7 @@ int main(int argc, char *argv[]) {
 						refs[i][2] = cols[i][2];
 					}
 					gotref = 1;
-					warning("Got two colorimetric files - assuming '%s' is the refrence",innames[0]);
+					warning("Got two colorimetric files - assuming '%s' is the reference",innames[0]);
 					refrmode = -1;
 					cbid = 0;
 
Index: trunk/spectro/dispread.c
===================================================================
--- trunk.orig/spectro/dispread.c
+++ trunk/spectro/dispread.c
@@ -413,7 +413,7 @@ int main(int argc, char *argv[]) {
 			/* COM port  */
 			} else if (argv[fa][1] == 'c') {
 				fa = nfa;
-				if (na == NULL) usage(0,"Paramater expected following -c");
+				if (na == NULL) usage(0,"Parameter expected following -c");
 				comport = atoi(na);
 				if (comport < 1 || comport > 50) usage(0,"-c parameter %d out of range",comport);
 
Index: trunk/spectro/fakeread.c
===================================================================
--- trunk.orig/spectro/fakeread.c
+++ trunk/spectro/fakeread.c
@@ -814,7 +814,7 @@ int main(int argc, char *argv[])
 
 		/* We're assuming that the input space has a perfect black point... */
 
-		/* Lookup the ouput black point in XYZ PCS. We're assuming monotonicity.. */
+		/* Lookup the output black point in XYZ PCS. We're assuming monotonicity.. */
 		bp[0] = bp[1] = bp[2] = 0.0;
 		oluo->lookup(oluo, bp, bp);
 
@@ -827,7 +827,7 @@ int main(int argc, char *argv[])
 		             bt1886 == 1 ? egamma : tgamma, bt1886 == 1 ? 1 : 0);
 
 		if (verb)
-			printf("Gamma Curve: Using ouput black offset proportion %f\n",outoprop);
+			printf("Gamma Curve: Using output black offset proportion %f\n",outoprop);
 
 		if (bt1886 == 1) {		/* Using effective gamma */
 			if (verb)
@@ -980,7 +980,7 @@ int main(int argc, char *argv[])
 			else if (nmask == ICX_K && sep_ins == icSigCmykData)
 				gfudge = 2;
 			else if (icx_colorant_comb_match_icc(nmask, sep_ins) == 0) {
-				error("Separation ICC device space '%s' dosen't match TI1 '%s'",
+				error("Separation ICC device space '%s' doesn't match TI1 '%s'",
 				       icm2str(icmColorSpaceSignature, sep_ins),
 				       ident);	/* Should free(). */
 			}
@@ -989,7 +989,7 @@ int main(int argc, char *argv[])
 			if (icc_luo != NULL) {
 				/* Check if icc is compatible with .ti1 */
 				if (sep_outs != ins)
-					error("ICC device space '%s' dosen't match Separation ICC '%s'",
+					error("ICC device space '%s' doesn't match Separation ICC '%s'",
 					       icm2str(icmColorSpaceSignature, ins),
 					       icm2str(icmColorSpaceSignature, sep_outs));
 			} else if (mlu != NULL) {
@@ -1014,12 +1014,12 @@ int main(int argc, char *argv[])
 			else {
 				if (!revlookup) {
 					if (icx_colorant_comb_match_icc(nmask, ins) == 0)
-						error("ICC device space '%s' dosen't match TI1 '%s'",
+						error("ICC device space '%s' doesn't match TI1 '%s'",
 						       icm2str(icmColorSpaceSignature, ins),
 						       ident);	// Should free().
 				} else {
 					if (icx_colorant_comb_match_icc(nmask, outs) == 0)
-						error("ICC device space '%s' dosen't match TI1 '%s'",
+						error("ICC device space '%s' doesn't match TI1 '%s'",
 						       icm2str(icmColorSpaceSignature, ins),
 						       ident);	// Should free().
 
Index: trunk/profile/invprofcheck.c
===================================================================
--- trunk.orig/profile/invprofcheck.c
+++ trunk/profile/invprofcheck.c
@@ -98,7 +98,7 @@ void usage(void) {
 	fprintf(stderr," -k           Show CIEDE2000 delta E values\n");
 	fprintf(stderr," -w           create %s visualisation (profile%s)\n",vrml_format(),vrml_ext());
 	fprintf(stderr," -x           Use %s axes\n",vrml_format());
-	fprintf(stderr," -e           Color vectors acording to delta E\n");
+	fprintf(stderr," -e           Color vectors according to delta E\n");
 	fprintf(stderr," profile.icm  Profile to check\n");
 	exit(1);
 }
Index: trunk/profile/profcheck.c
===================================================================
--- trunk.orig/profile/profcheck.c
+++ trunk/profile/profcheck.c
@@ -59,7 +59,7 @@ usage(void) {
 	fprintf(stderr," -w              create %s visualisation (iccprofile%s)\n",vrml_format(),vrml_ext());
 	fprintf(stderr," -x              Use %s axes\n",vrml_format());
 	fprintf(stderr," -m              Make %s lines a minimum of 0.5\n",vrml_format());
-	fprintf(stderr," -e              Color vectors acording to delta E\n");
+	fprintf(stderr," -e              Color vectors according to delta E\n");
 	fprintf(stderr," -h              Plot a histogram of delta E's\n");
 	fprintf(stderr," -s              Sort output by delta E\n");
 	fprintf(stderr," -P N.NN         Create a pruned .ti3 with points less or equal to N.NN delta E\n");
Index: trunk/spectro/ccwin.c
===================================================================
--- trunk.orig/spectro/ccwin.c
+++ trunk/spectro/ccwin.c
@@ -830,7 +830,7 @@ int ddebug						/* >0 to print debug sta
 		return NULL;
 	}
 
-	debugr2((errout,"new_ccwin: return sucessfully\n"));
+	debugr2((errout,"new_ccwin: return successfully\n"));
 
 	return p;
 }
Index: trunk/profile/colverify.c
===================================================================
--- trunk.orig/profile/colverify.c
+++ trunk/profile/colverify.c
@@ -69,7 +69,7 @@ usage(void) {
 	fprintf(stderr," -D              Use D50 100.0 as L*a*b* white reference\n");
 	fprintf(stderr," -c              Show CIE94 delta E values\n");
 	fprintf(stderr," -k              Show CIEDE2000 delta E values\n");
-	fprintf(stderr," -h [hist.txt]   Plot a histogram of delta E's [Optionaly save points to .txt]\n");
+	fprintf(stderr," -h [hist.txt]   Plot a histogram of delta E's [Optionally save points to .txt]\n");
 	fprintf(stderr," -s              Sort patch values by error\n");
 	fprintf(stderr," -w              create PCS %s vector visualisation (measured%s)\n",vrml_format(),vrml_ext());
 	fprintf(stderr," -W              create PCS %s marker visualisation (measured%s)\n",vrml_format(),vrml_ext());
Index: trunk/spectro/ex1.c
===================================================================
--- trunk.orig/spectro/ex1.c
+++ trunk/spectro/ex1.c
@@ -188,7 +188,7 @@ ex1_init_coms(inst *pp, baud_rate br, fl
 
 	p->gotcoms = 1;
 
-	a1logd(p->log, 2, "ex1_init_coms: init coms has suceeded\n");
+	a1logd(p->log, 2, "ex1_init_coms: init coms has succeeded\n");
 
 	return inst_ok;
 }
@@ -1466,7 +1466,7 @@ static void dump_command(ex1 *p, ORD8 *b
 	if (flags & EX1_FLAG_NACK)
 		a1logd(p->log, 0, "   Negative acknowldgement response\n");
 	if (flags & EX1_FLAG_EXPTN)
-		a1logd(p->log, 0, "   Exception occured\n");
+		a1logd(p->log, 0, "   Exception occurred\n");
 	if (flags & EX1_FLAG_PVDEP)
 		a1logd(p->log, 0, "   Protocol version is deprecated request\n");
 
@@ -1752,7 +1752,7 @@ int nd				/* nz to disable debug message
 	}
 
 	if (p->log->debug >= 8) { 
-		a1logd(p->log,1,"\nex1_command: RECIEVING:\n");
+		a1logd(p->log,1,"\nex1_command: RECEIVING:\n");
 		dump_command(p, buf, rwbytes, p->log->debug);
 	}
 
Index: trunk/ccast/ccmes.c
===================================================================
--- trunk.orig/ccast/ccmes.c
+++ trunk/ccast/ccmes.c
@@ -85,7 +85,7 @@ char *ccmessv_emes(ccmessv_err rv) {
 			return "ccmes: connection has been closed";
 	}
 
-	return "Uknown ccmessv error";
+	return "Unknown ccmessv error";
 }
 
 #if defined(LOWVERBTRACE) || defined(DEBUG)
Index: trunk/ccast/ccpacket.c
===================================================================
--- trunk.orig/ccast/ccpacket.c
+++ trunk/ccast/ccpacket.c
@@ -133,7 +133,7 @@ char *ccpacket_emes(ccpacket_err rv) {
 			return "Packet: failed to read message";
 	}
 
-	return "Uknown ccpacket error";
+	return "Unknown ccpacket error";
 }
 
 /* Establish an ccpacket connection - implementation */
@@ -187,13 +187,13 @@ static ccpacket_err connect_ccpacket_imp
 #endif
 		if ((rv = setsockopt(p->sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&tv,
 			                                                   sizeof(tv))) < 0) {
-			DBG((g_log,0,"setsockopt timout failed with %d, errno %d",rv,ERRNO))
+			DBG((g_log,0,"setsockopt timeout failed with %d, errno %d",rv,ERRNO))
 			return ccpacket_connect;
 		}
 		tv = 2000;
 		if ((rv = setsockopt(p->sock, SOL_SOCKET, SO_SNDTIMEO, (const char*)&tv,
 			                                                    sizeof(tv))) < 0) {
-			DBG((g_log,0,"setsockopt timout failed with %d, errno %d",rv,ERRNO))
+			DBG((g_log,0,"setsockopt timeout failed with %d, errno %d",rv,ERRNO))
 			return ccpacket_connect;
 		}
 #else
@@ -207,14 +207,14 @@ static ccpacket_err connect_ccpacket_imp
 #endif
 		if ((rv = setsockopt(p->sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&tv,
 			                                                    sizeof(tv))) < 0) {
-			DBG((g_log,0,"setsockopt timout failed with %d, errno %d",rv,ERRNO))
+			DBG((g_log,0,"setsockopt timeout failed with %d, errno %d",rv,ERRNO))
 			return ccpacket_connect;
 		}
 		tv.tv_sec = 2;
 		tv.tv_usec = 0;
 		if ((rv = setsockopt(p->sock, SOL_SOCKET, SO_SNDTIMEO, (const char*)&tv,
 			                                                    sizeof(tv))) < 0) {
-			DBG((g_log,0,"setsockopt timout failed with %d, errno %d",rv,ERRNO))
+			DBG((g_log,0,"setsockopt timeout failed with %d, errno %d",rv,ERRNO))
 			return ccpacket_connect;
 		}
 #endif
@@ -224,7 +224,7 @@ static ccpacket_err connect_ccpacket_imp
 		ling.l_linger = 2;	/* Two seconds */
 		if ((rv = setsockopt(p->sock, SOL_SOCKET, SO_LINGER, (const char*)&ling,
 			                                                    sizeof(ling))) < 0) {
-			DBG((g_log,0,"setsockopt timout failed with %d, errno %d",rv,ERRNO))
+			DBG((g_log,0,"setsockopt timeout failed with %d, errno %d",rv,ERRNO))
 			return ccpacket_connect;
 		}
 #endif /* NEVER */
Index: trunk/spectro/xdg_bds.c
===================================================================
--- trunk.orig/spectro/xdg_bds.c
+++ trunk/spectro/xdg_bds.c
@@ -873,7 +873,7 @@ char *xdg_errstr(xdg_error er) {
 		case xdg_nohome:
 			return "There is no $HOME";
 		case xdg_noalluserprofile:
-			return "Theres no $ALLUSERSPROFILE is no $ALLUSERSPROFILE";
+			return "There's no $ALLUSERSPROFILE is no $ALLUSERSPROFILE";
 		case xdg_nopath:
 			return "There is no resulting path";
 		case xdg_mallformed:
Index: trunk/icc/icc.c
===================================================================
--- trunk.orig/icc/icc.c
+++ trunk/icc/icc.c
@@ -1472,7 +1472,7 @@ static const char *string_TagSignature(i
 		case icSigViewingCondDescTag:
 			return "Viewing Condition Description";
 		case icSigViewingConditionsTag:
-			return "Viewing Condition Paramaters";
+			return "Viewing Condition Parameters";
 
 		/* ArgyllCMS private tag: */
 		case icmSigAbsToRelTransSpace:
Index: trunk/gamut/isecvol.c
===================================================================
--- trunk.orig/gamut/isecvol.c
+++ trunk/gamut/isecvol.c
@@ -174,7 +174,7 @@ printf("~1 doing triangle %d from %s gam
 					inout[i] = 0;
 			}
 
-printf("~1 verticies outside = %d\n",nout);
+printf("~1 vertices outside = %d\n",nout);
 
 			/* If none are in, skip this triangle */
 			if (nout == 3)
Index: trunk/gamut/viewgam.c
===================================================================
--- trunk.orig/gamut/viewgam.c
+++ trunk/gamut/viewgam.c
@@ -355,7 +355,7 @@ main(int argc, char *argv[]) {
 			error("Input file doesn't contain exactly two tables");
 
 		if ((nverts = pp->t[0].nsets) <= 0)
-			error("No verticies");
+			error("No vertices");
 		if ((ntris = pp->t[1].nsets) <= 0)
 			error("No triangles");
 
Index: trunk/gamut/gamut.c
===================================================================
--- trunk.orig/gamut/gamut.c
+++ trunk/gamut/gamut.c
@@ -2152,8 +2152,8 @@ static void check_triangulation(gamut *s
 			for (j = i+1; j < 3; j++) {
 				if (tp->v[i] == tp->v[j]) {
 					failed = 1;
-	printf("Validation failed - duplicate verticies:\n");
-	printf("Triangle %d, has verticies %d %d %d\n", tp->n, tp->v[0]->n, tp->v[1]->n, tp->v[2]->n);
+	printf("Validation failed - duplicate vertices:\n");
+	printf("Triangle %d, has vertices %d %d %d\n", tp->n, tp->v[0]->n, tp->v[1]->n, tp->v[2]->n);
 	fflush(stdout);
 				}
 			}
@@ -2165,7 +2165,7 @@ static void check_triangulation(gamut *s
 				if (tp->e[i] == tp->e[j]) {
 					failed = 1;
 	printf("Validation failed - duplicate connectivity:\n");
-	printf("Triangle %d, has verticies %d %d %d\n", tp->n, tp->v[0]->n, tp->v[1]->n, tp->v[2]->n);
+	printf("Triangle %d, has vertices %d %d %d\n", tp->n, tp->v[0]->n, tp->v[1]->n, tp->v[2]->n);
 	printf("Triangle %d, has edges %d %d %d\n", tp->n, tp->e[0]->n, tp->e[1]->n, tp->e[2]->n);
 	fflush(stdout);
 				}
@@ -2187,7 +2187,7 @@ static void check_triangulation(gamut *s
 			/* for this triangle is correct */
 			if (ei1 != i) {
 				failed = 1;
-	printf("Validation failed - triangle edge index doesn't match record withing edge:\n");
+	printf("Validation failed - triangle edge index doesn't match record within edge:\n");
 	printf("Triangle %d, edge index %d edge %d has record %d\n", tp->n, i, e->n, ei1);
 	fflush(stdout);
 			}
@@ -2206,9 +2206,9 @@ static void check_triangulation(gamut *s
 			if ((e->v[0] != tp->v[i] || e->v[1] != tp->v[(i+1) % 3])
 			 && (e->v[1] != tp->v[i] || e->v[0] != tp->v[(i+1) % 3])) {
 				failed = 1;
-	printf("Validation failed - edge doesn't have same verticies as triangle expects:\n");
-	printf("Triangle %d, has verticies %d %d\n", tp->n, tp->v[i]->n, tp->v[(i+1) % 3]->n);
-	printf("Edge     %d, has verticies %d %d\n", e->n, e->v[0]->n, e->v[1]->n);
+	printf("Validation failed - edge doesn't have same vertices as triangle expects:\n");
+	printf("Triangle %d, has vertices %d %d\n", tp->n, tp->v[i]->n, tp->v[(i+1) % 3]->n);
+	printf("Edge     %d, has vertices %d %d\n", e->n, e->v[0]->n, e->v[1]->n);
 	fflush(stdout);
 			}
 
@@ -2690,7 +2690,7 @@ gamut *s
 			ff[1] = fsz * foffs[i][0] + s->cent[1];
 			ff[2] = fsz * foffs[i][1] + s->cent[2];
 			if ((tvs[j++] = expand_gamut(s, ff)) == NULL) {
-				fprintf(stderr,"gamut: internal error - failed to register a fake initial verticies!\n");
+				fprintf(stderr,"gamut: internal error - failed to register a fake initial vertices!\n");
 				exit (-1);
 			}
 		}
@@ -2699,7 +2699,7 @@ gamut *s
 		s->doingfake = 0;
 
 #ifdef NEVER
-		printf("Initial verticies:\n");
+		printf("Initial vertices:\n");
 		for (i = 0; i < 4; i++) {
 			printf(" %d: %f %f %f\n",tvs[i]->n, tvs[i]->p[0], tvs[i]->p[1], tvs[i]->p[2]);
 		}
@@ -6427,7 +6427,7 @@ char *filename
 
 
 	if ((nverts = gam->t[0].nsets) <= 0) {
-		fprintf(stderr,"No verticies");
+		fprintf(stderr,"No vertices");
 		return 1;
 	}
 	if ((ntris = gam->t[1].nsets) <= 0) {
Index: trunk/rspl/rev.c
===================================================================
--- trunk.orig/rspl/rev.c
+++ trunk/rspl/rev.c
@@ -5868,7 +5868,7 @@ int sdi						/* Sub-simplex dimensionali
 			x->face = 0;
 
 #ifdef DEBUG
-		printf("Verticies   = ");
+		printf("vertices   = ");
 		for (i = 0; i <= sdi; i++)
 			printf("%d ",vcmb[i]);
 		printf("\n");
@@ -9733,7 +9733,7 @@ rspl *s
 				vc.nilist = 0;
 				xlist = NULL;
 
-				DBG(("deleting verticies in all bxcells\n"));
+				DBG(("deleting vertices in all bxcells\n"));
 
 				/* The thinning may have deleted verticies from bxcell's that */
 				/* were not involved in the thinning, so go though all bxcells */
@@ -9873,7 +9873,7 @@ rspl *s
 //printf("~1 deleting vtx %d\n",vx->ix);
 								del_vtxrec_hash(&vc, vx->ix);
 								if (get_vtxrec(&vc, vx->ix) != NULL)
-									error("get_vtxrec suceeded after del_vtxrec_hash!");
+									error("get_vtxrec succeeded after del_vtxrec_hash!");
 							}
 #else /* !DELETE_SHAD */
 							/* Keep track of deleted verticies that are in this bx, */
@@ -10554,7 +10554,7 @@ rspl *s
 				}
 			}
 			printf("%d crossed triangles tested\n",notverts);
-			printf("%d hidden verticies retained for crossed triangles\n",nopreserved);
+			printf("%d hidden vertices retained for crossed triangles\n",nopreserved);
 			printf("Took %f secs to preserving crossing triangless\n",0.001 * (msec_time()-lmsec));
 #endif
 		}	/* End of preserve shadowed triangles */
Index: trunk/spectro/munki.c
===================================================================
--- trunk.orig/spectro/munki.c
+++ trunk/spectro/munki.c
@@ -113,7 +113,7 @@ munki_init_coms(inst *pp, baud_rate br,
 		return munki_interp_code(p, icoms2munki_err(se));
 	}
 
-	a1logd(p->log, 2, "munki_init_coms: init coms has suceeded\n");
+	a1logd(p->log, 2, "munki_init_coms: init coms has succeeded\n");
 
 	p->gotcoms = 1;
 	return inst_ok;
@@ -525,7 +525,7 @@ munki_interp_error(inst *pp, munki_code
 		case MUNKI_INT_CREATE_EEPROM_STORE:
 			return "Error in creating EEProm store";
 		case MUNKI_INT_NEW_RSPL_FAILED:
-			return "Creating RSPL object faild";
+			return "Creating RSPL object failed";
 		case MUNKI_INT_CAL_SAVE:
 			return "Unable to save calibration to file";
 		case MUNKI_INT_CAL_RESTORE:
Index: trunk/spectro/i1pro.c
===================================================================
--- trunk.orig/spectro/i1pro.c
+++ trunk/spectro/i1pro.c
@@ -119,7 +119,7 @@ i1pro_init_coms(inst *pp, baud_rate br,
 		return i1pro_interp_code(p, icoms2i1pro_err(se));
 	}
 
-	a1logd(p->log, 2, "i1pro_init_coms: init coms has suceeded\n");
+	a1logd(p->log, 2, "i1pro_init_coms: init coms has succeeded\n");
 
 	p->gotcoms = 1;
 	return inst_ok;
@@ -508,7 +508,7 @@ i1pro_interp_error(inst *pp, i1pro_code
 		case I1PRO_INT_EEPROM_DATA_MISSING:
 			return "EEProm data is missing";
 		case I1PRO_INT_NEW_RSPL_FAILED:
-			return "Creating RSPL object faild";
+			return "Creating RSPL object failed";
 		case I1PRO_INT_CAL_SAVE:
 			return "Unable to save calibration to file";
 		case I1PRO_INT_CAL_RESTORE:
Index: trunk/xicc/mpp.c
===================================================================
--- trunk.orig/xicc/mpp.c
+++ trunk/xicc/mpp.c
@@ -733,7 +733,7 @@ int           use_fwa			/* NZ to involke
 			error ("mpp->set_ilob, instrument doesn't have an FWA illuminent");
 
 		if (p->spc->set_fwa(p->spc, &inst, NULL, &white))
-			error ("mpp->set_ilob, set_fwa faild");
+			error ("mpp->set_ilob, set_fwa failed");
 	}
 
 	return 0;
Index: trunk/plot/vrml.c
===================================================================
--- trunk.orig/plot/vrml.c
+++ trunk/plot/vrml.c
@@ -642,7 +642,7 @@ double cc[3]	/* Surface color, cc == NUL
 		fprintf(s->fp,"            ]\n");
 		fprintf(s->fp,"          }\n");
 		fprintf(s->fp,"\n");
-		fprintf(s->fp,"          coordIndex [ 		# Indexes of %s Verticies \n",
+		fprintf(s->fp,"          coordIndex [ 		# Indexes of %s Vertices \n",
 		                                                  lines ? "line" : "polygon");
 	
 		/* Spit out the lines/triangles/quads */
Index: trunk/target/ofps.c
===================================================================
--- trunk.orig/target/ofps.c
+++ trunk/target/ofps.c
@@ -2612,7 +2612,7 @@ static int position_vtx(
 					if (tries > s->maxretries)
 						s->maxretries = tries;
 #ifdef DEBUG
-					printf(" - comb %s suceeded on retry %d (max %d)\n",pcomb(di,vv->nix),tries,s->maxretries);
+					printf(" - comb %s succeeded on retry %d (max %d)\n",pcomb(di,vv->nix),tries,s->maxretries);
 					printf("       oog = %f, eperr = %f, ceperr = %f\n",vv->oog,vv->eperr,vv->ceperr);
 #endif
 //if (tries > 10)
@@ -2627,7 +2627,7 @@ static int position_vtx(
 
 #ifdef DUMP_FERR 		/* Create .tiff of dnsq function error */
 					if (tries >= DUMP_FERR) {
-						printf("Suceeded on retry %d, dumping debug rasters\n",tries);
+						printf("Succeeded on retry %d, dumping debug rasters\n",tries);
 
 						/* Re-run the last unsucessful dnsq, to trace the path */
 						pcx.debug = 1;
@@ -6221,7 +6221,7 @@ static int ofps_findhit_vtxs(ofps *s, no
 	int hit = 0;
 
 	if (nn->ix < 0)
-		error("ofps_findhit_vtxs given gamut boudary node ix %d",nn->ix);
+		error("ofps_findhit_vtxs given gamut boundary node ix %d",nn->ix);
 
 #ifdef DEBUG
 	if (s->agrid_init == 0)
@@ -8023,7 +8023,7 @@ ofps *s
 			warning("Verify of incremental vertexes failed!");
 			printf("Verify of incremental vertexes failed!\n");
 		} else {
-			warning("Verify of incremental vertexes suceeded!");
+			warning("Verify of incremental vertexes succeeded!");
 		}
 #ifdef DUMP_STRUCTURE
 		dump_node_vtxs(s, 1);
Index: trunk/spectro/synthread.c
===================================================================
--- trunk.orig/spectro/synthread.c
+++ trunk/spectro/synthread.c
@@ -487,14 +487,14 @@ printf("~1 omax = %f %f %f\n", md.omax[0
 			else if (nmask == ICX_K && sep_ins == icSigCmykData)
 				gfudge = 2;
 			else if (icx_colorant_comb_match_icc(nmask, sep_ins) == 0) {
-				error("Separation ICC device space '%s' dosen't match TI1 '%s'",
+				error("Separation ICC device space '%s' doesn't match TI1 '%s'",
 				       icm2str(icmColorSpaceSignature, sep_ins),
 				       ident);	/* Should free(). */
 			}
 
 			/* Check if separation ICC output is compatible with ICC/MPP/TI3 conversion */ 
 			if (sep_outs != ins)
-				error("Synthetic device space '%s' dosen't match Separation ICC '%s'",
+				error("Synthetic device space '%s' doesn't match Separation ICC '%s'",
 				       icm2str(icmColorSpaceSignature, ins),
 				       icm2str(icmColorSpaceSignature, sep_outs));
 		} else {
@@ -504,7 +504,7 @@ printf("~1 omax = %f %f %f\n", md.omax[0
 			else if (nmask == ICX_K && ins == icSigCmykData)
 				gfudge = 2;		/* Should allow for other colorant combo's that include black */
 			else if (icx_colorant_comb_match_icc(nmask, ins) == 0) {
-				error("Synthetic device space '%s' dosen't match TI1 '%s'",
+				error("Synthetic device space '%s' doesn't match TI1 '%s'",
 				       icm2str(icmColorSpaceSignature, ins),
 				       ident);	// Should free().
 			}
Index: trunk/spectro/smcube.c
===================================================================
--- trunk.orig/spectro/smcube.c
+++ trunk/spectro/smcube.c
@@ -292,7 +292,7 @@ smcube_init_coms(inst *pp, baud_rate br,
 		}
 		amutex_unlock(p->lock);
 	}
-	a1logd(p->log, 2, "smcube_init_coms: init coms has suceeded\n");
+	a1logd(p->log, 2, "smcube_init_coms: init coms has succeeded\n");
 
 	p->gotcoms = 1;
 
@@ -1247,7 +1247,7 @@ smcube_get_idle_time(smcube *p, int *pit
 	itime = read_ORD16_be(buf + 4);
 
 	if (!nd)
-		a1logd(p->log, 2, "smcube_get_idle_time: returing %d\n",itime);
+		a1logd(p->log, 2, "smcube_get_idle_time: returning %d\n",itime);
 
 	if (pitime != NULL)
 		*pitime = itime;
@@ -1292,11 +1292,11 @@ smcube_fact_measure(smcube *p, double *X
 	XYZ[0] = IEEE754todouble(read_ORD32_be(buf + 4));
 	XYZ[1] = IEEE754todouble(read_ORD32_be(buf + 8));
 	XYZ[2] = IEEE754todouble(read_ORD32_be(buf + 12));
-	a1logd(p->log, 2, "smcube_fact_measure: returing L*a*b* %f %f %f\n",XYZ[0], XYZ[1], XYZ[2]);
+	a1logd(p->log, 2, "smcube_fact_measure: returning L*a*b* %f %f %f\n",XYZ[0], XYZ[1], XYZ[2]);
 
 	icmLab2XYZ(&icmD50_100, XYZ, XYZ);
 
-	a1logd(p->log, 2, "smcube_fact_measure: returing XYZ %f %f %f\n",XYZ[0], XYZ[1], XYZ[2]);
+	a1logd(p->log, 2, "smcube_fact_measure: returning XYZ %f %f %f\n",XYZ[0], XYZ[1], XYZ[2]);
 
 	return inst_ok;
 }
@@ -1338,7 +1338,7 @@ smcube_poll_measure(smcube *p, double to
 	p->XYZ[0] = IEEE754todouble(read_ORD32_be(buf + 4));
 	p->XYZ[1] = IEEE754todouble(read_ORD32_be(buf + 8));
 	p->XYZ[2] = IEEE754todouble(read_ORD32_be(buf + 12));
-	if (!nd) a1logd(p->log, 2, "smcube_poll_measure: returing L*a*b* %f %f %f\n",p->XYZ[0], p->XYZ[1], p->XYZ[2]);
+	if (!nd) a1logd(p->log, 2, "smcube_poll_measure: returning L*a*b* %f %f %f\n",p->XYZ[0], p->XYZ[1], p->XYZ[2]);
 
 	icmLab2XYZ(&icmD50_100, p->XYZ, p->XYZ);
 
Index: trunk/spectro/kleink10.c
===================================================================
--- trunk.orig/spectro/kleink10.c
+++ trunk/spectro/kleink10.c
@@ -728,7 +728,7 @@ int ix					/* Klein calibration index 1
 
 	if (buf[0] != 'D' || buf[1] != '1') {
 		amutex_unlock(p->lock);
-		a1logd(p->log, 1, "k10_read_cal_matrix: didn't get echo'd commad D1\n");
+		a1logd(p->log, 1, "k10_read_cal_matrix: didn't get echo'd command D1\n");
 		return inst_protocol_error;
 	}
 
@@ -2067,7 +2067,7 @@ int *pinstmsec) {	/* Return instrument r
 			break;
 	}
 
-	a1logd(p->log, 2, "k10_meas_delay: stoped at sample %d time %f\n",i,samp[i].sec);
+	a1logd(p->log, 2, "k10_meas_delay: stopped at sample %d time %f\n",i,samp[i].sec);
 
 	/* Compute overall delay */
 	dispmsec = (int)(samp[i].sec * 1000.0 + 0.5);
Index: trunk/spectro/i1d3.c
===================================================================
--- trunk.orig/spectro/i1d3.c
+++ trunk/spectro/i1d3.c
@@ -2503,7 +2503,7 @@ i1d3_init_coms(inst *pp, baud_rate br, f
 		a1logd(p->log, 1, "i1d3_init_coms: failed with rv = 0x%x\n",ev);
 		return ev;
 	}
-	a1logd(p->log, 2, "i1d3_init_coms: suceeded\n");
+	a1logd(p->log, 2, "i1d3_init_coms: succeeded\n");
 
 	p->gotcoms = 1;
 	return inst_ok;
@@ -3179,7 +3179,7 @@ int *pinstmsec) {    /* Return instrumen
 			break;
 	}
 
-	a1logd(p->log, 2, "i1d3_meas_delay: stoped at sample %d time %f\n",i,samp[i].sec);
+	a1logd(p->log, 2, "i1d3_meas_delay: stopped at sample %d time %f\n",i,samp[i].sec);
 
 	/* Compute overall delay */
 	dispmsec = (int)(samp[i].sec * 1000.0 + 0.5);
Index: trunk/spectro/i1disp.c
===================================================================
--- trunk.orig/spectro/i1disp.c
+++ trunk/spectro/i1disp.c
@@ -1359,7 +1359,7 @@ i1disp_read_refrate(
 			*ref_rate = rrate;
 		return inst_ok;
 	} else {
-		a1logd(p->log, 3, "No discernable refresh frequency measured\n");
+		a1logd(p->log, 3, "No discernible refresh frequency measured\n");
 		if (ref_rate != NULL)
 			*ref_rate = 0.0;
 		return inst_misread;
Index: trunk/ccast/ccmdns.c
===================================================================
--- trunk.orig/ccast/ccmdns.c
+++ trunk/ccast/ccmdns.c
@@ -458,7 +458,7 @@ static int init_receive_mDNS(SOCKET *pso
 		DWORD tv;
 		tv = 100;
 		if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&tv, sizeof(tv)) < 0) {
-			DBG((g_log,0,"setsockopt timout failed with %d\n",ERRNO))
+			DBG((g_log,0,"setsockopt timeout failed with %d\n",ERRNO))
 			closesocket(sock);
 			return 1;
 		}
@@ -469,7 +469,7 @@ static int init_receive_mDNS(SOCKET *pso
 		tv.tv_sec = 0;
 		tv.tv_usec = 100 * 1000;
 		if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&tv, sizeof(tv)) < 0) {
-			DBG((g_log,0,"setsockopt timout failed with %d\n",ERRNO))
+			DBG((g_log,0,"setsockopt timeout failed with %d\n",ERRNO))
 			closesocket(sock);
 			return 1;
 		}
Index: trunk/spectro/spyd2.c
===================================================================
--- trunk.orig/spectro/spyd2.c
+++ trunk/spectro/spyd2.c
@@ -2915,7 +2915,7 @@ spyd2_init_coms(inst *pp, baud_rate br,
 		return spyd2_interp_code((inst *)p, icoms2spyd2_err(se));
 	}
 
-	a1logd(p->log, 2, "spyd2_init_coms: suceeded\n");
+	a1logd(p->log, 2, "spyd2_init_coms: succeeded\n");
 
 	p->gotcoms = 1;
 	return inst_ok;
@@ -3372,9 +3372,9 @@ spyd2_interp_error(inst *pp, int ec) {
 		case SPYD2_BADREADSIZE:
 			return "Didn't read expected amount of data";
 		case SPYD2_TRIGTIMEOUT:
-			return "Trigger timout";
+			return "Trigger timeout";
 		case SPYD2_OVERALLTIMEOUT:
-			return "Overall timout";
+			return "Overall timeout";
 		case SPYD2_BAD_EE_CRC:
 			return "Serial EEProm CRC failed";
 
Index: trunk/spectro/specbos.c
===================================================================
--- trunk.orig/spectro/specbos.c
+++ trunk/spectro/specbos.c
@@ -340,7 +340,7 @@ specbos_init_coms(inst *pp, baud_rate br
 		a1logd(p->log, 2, "specbos_init_coms: unrecognised model %04d\n",p->model);
 		return inst_unknown_model;
 	}
-	a1logd(p->log, 2, "specbos_init_coms: init coms has suceeded\n");
+	a1logd(p->log, 2, "specbos_init_coms: init coms has succeeded\n");
 
 	p->gotcoms = 1;
 
@@ -1559,7 +1559,7 @@ char id[CALIDLEN]		/* Condition identifi
 	if ((ev = specbos_get_n_a_cals((inst *)p, &needed, &available)) != inst_ok)
 		return ev;
 
-	a1logd(p->log,4,"specbos_calibrate: needed 0x%x, avaialble 0x%x\n",needed, available);
+	a1logd(p->log,4,"specbos_calibrate: needed 0x%x, available 0x%x\n",needed, available);
 
 	/* Translate inst_calt_all/needed into something specific */
 	if (*calt == inst_calt_all
Index: trunk/plot/plot.c
===================================================================
--- trunk.orig/plot/plot.c
+++ trunk/plot/plot.c
@@ -2434,7 +2434,7 @@ static void dprintf(char *fmt, ...) {
 printf("~1 found NtQueryInformationProcess\n"); fflush(stdout);
 			if(NtQueryInformationProcess(GetCurrentProcess(), 0,
 			    &pbi, sizeof(pbi), &ulSize) >= 0 && ulSize == sizeof(pbi)) {
-printf("~1 NtQueryInformationProcess suceeded\n"); fflush(stdout);
+printf("~1 NtQueryInformationProcess succeeded\n"); fflush(stdout);
 
 				*(FARPROC *)&AttachConsole = 
 		          GetProcAddress(LoadLibraryA("kernel32.dll"), "AttachConsole");
Index: trunk/spectro/dtp22.c
===================================================================
--- trunk.orig/spectro/dtp22.c
+++ trunk/spectro/dtp22.c
@@ -277,7 +277,7 @@ dtp22_init_coms(inst *pp, baud_rate br,
 		return inst_coms_fail;
 	}
 
-	a1logd(p->log, 2, "dtp22_init_coms: init coms has suceeded\n");
+	a1logd(p->log, 2, "dtp22_init_coms: init coms has succeeded\n");
 
 	p->gotcoms = 1;
 	return inst_ok;
Index: trunk/spectro/dtp41.c
===================================================================
--- trunk.orig/spectro/dtp41.c
+++ trunk/spectro/dtp41.c
@@ -255,7 +255,7 @@ dtp41_init_coms(inst *pp, baud_rate br,
 		return inst_coms_fail;
 	}
 
-	a1logd(p->log, 2, "dtp41_init_coms: init coms has suceeded\n");
+	a1logd(p->log, 2, "dtp41_init_coms: init coms has succeeded\n");
 
 	p->gotcoms = 1;
 	return inst_ok;
Index: trunk/xicc/xutils.c
===================================================================
--- trunk.orig/xicc/xutils.c
+++ trunk/xicc/xutils.c
@@ -147,7 +147,7 @@ icc *read_embedded_icc(char *file_name)
 		TIFFSetWarningHandler(oldwarnh);
 		TIFFSetErrorHandlerExt(olderrhx);
 		TIFFSetWarningHandlerExt(oldwarnhx);
-		debug("TIFFOpen suceeded\n");
+		debug("TIFFOpen succeeded\n");
 
 		if (TIFFGetField(rh, TIFFTAG_ICCPROFILE, &size, &tag) == 0 || size == 0) {
 			debug2((errout,"no ICC profile found in '%s'\n",file_name));
Index: trunk/spectro/rspec.c
===================================================================
--- trunk.orig/spectro/rspec.c
+++ trunk/spectro/rspec.c
@@ -955,7 +955,7 @@ int calf_open(calf *x, a1log *log, char
 	}
 	xdg_free(cal_paths, no_paths);
 
-	a1logd(x->log,2,"calf_open: suceeded\n");
+	a1logd(x->log,2,"calf_open: succeeded\n");
 
 	return 0;
 }
Index: trunk/spectro/chartread.c
===================================================================
--- trunk.orig/spectro/chartread.c
+++ trunk/spectro/chartread.c
@@ -1172,7 +1172,7 @@ printf("~1 using emis mode\n");
 
 		/* Or something is wrong with instrument capabilities */
 		} else {
-			printf("\nNo reasonable trigger mode avilable for this instrument\n");
+			printf("\nNo reasonable trigger mode available for this instrument\n");
 			it->del(it);
 			return -1;
 		}
@@ -1685,7 +1685,7 @@ printf("~1 using emis mode\n");
 	
 			/* Or something is wrong with instrument capabilities */
 			} else {
-				printf("\nNo reasonable trigger mode avilable for this instrument\n");
+				printf("\nNo reasonable trigger mode available for this instrument\n");
 				it->del(it);
 				return -1;
 			}
Index: trunk/spectro/illumread.c
===================================================================
--- trunk.orig/spectro/illumread.c
+++ trunk/spectro/illumread.c
@@ -663,7 +663,7 @@ int main(int argc, char *argv[])
 
 			/* Or something is wrong with instrument capabilities */
 			} else {
-				printf("!!! No reasonable trigger mode avilable for this instrument !!!\n");
+				printf("!!! No reasonable trigger mode available for this instrument !!!\n");
 				continue;
 			}
 			if ((rv = it->get_set_opt(it, trigmode)) != inst_ok) {
