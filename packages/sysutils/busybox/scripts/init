#!/bin/sh

# SPDX-License-Identifier: GPL-2.0-or-later
# Copyright (C) 2010-2011 Roman Weber (roman@openelec.tv)
# Copyright (C) 2012 Yann CÃ©zard (eesprit@free.fr)
# Copyright (C) 2009-2014 Stephan Raue (stephan@openelec.tv)
# Copyright (C) 2016-present Team LibreELEC (https://libreelec.tv)

# set needed variables
MODULE_DIR=/usr/lib/modules

UPDATE_ROOT=/storage/.update
UPDATE_DIR="$UPDATE_ROOT"

UPDATE_KERNEL="KERNEL"
UPDATE_SYSTEM="SYSTEM"
IMAGE_KERNEL="@KERNEL_NAME@"
IMAGE_SYSTEM="SYSTEM"

BOOT_STEP="start"
MD5_FAILED="0"
RUN_FSCK="yes"
RUN_FSCK_DISKS=""
SYSLINUX_DEFAULT=""
GRUB_DEFAULT=""

NBD_DEVS="0"
FLASH_FREE_MIN="5"

INSTALLED_MEMORY=$(cat /proc/meminfo | grep 'MemTotal:' | awk '{print $2}')
SYSTEM_TORAM_LIMIT=1024000

LIVE="no"

BREAK_TRIPPED="no"

# Get a serial number if present (eg. RPi) otherwise use MAC address from eth0
MACHINE_UID="$(cat /proc/cpuinfo | awk '/^Serial/{s=$3; gsub ("^0*","",s); print s}')"
[ -z "$MACHINE_UID" ] && MACHINE_UID="$(cat /sys/class/net/eth0/address 2>/dev/null | tr -d :)"

# common functions
. /usr/lib/functions

# script functions
progress() {
  if test "$PROGRESS" = "yes"; then
    echo "### $1 ###" >&2
  fi
}

debug_msg() {
  echo "$1" >&$SILENT_OUT
}

debug_shell() {
  echo "### Starting debugging shell for boot step: $BOOT_STEP... type  exit  to quit ###"

  showcursor

  setsid cttyhack sh
}

error() {
  # Display fatal error message
  # $1:action which caused error, $2:message
  # Send debug_shell output to stderr, in case caller is redirecting/consuming stdout
  # Return exitcode=1 so that called may detect when an error has occurred
  echo "*** Error in $BOOT_STEP: $1: $2 ***" >&2
  debug_shell >&2
  return 1
}

break_after() {
  # Start debug shell after boot step $1, and all subsequent steps
  if [ $BREAK_TRIPPED == yes ]; then
    debug_shell
  else
    case $BREAK in
      all|*$1*)
        BREAK_TRIPPED=yes
        debug_shell
        ;;
    esac
  fi
}

# Mount handlers
# All handlers take the following parameters:
# $1:target, $2:mountpoint, $3:mount options, [$4:fs type]
mount_common() {
  # Common mount handler, handles block devices and filesystem images
  MOUNT_OPTIONS="-o $3"
  [ -n "$4" ] && MOUNT_OPTIONS="-t $4 $MOUNT_OPTIONS"

  for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15; do
    ERR_ENV=1

    mount $MOUNT_OPTIONS $1 $2 >&$SILENT_OUT 2>&1
    [ "$?" -eq "0" ] && ERR_ENV=0 && break

    usleep 1000000
  done
  [ "$ERR_ENV" -eq "0" ] && return 0
  error "mount_common" "Could not mount $1"
}

get_iscsistart_options() {
  # Convert kernel commandline ISCSI= options to iscsistart options
  IFS_SAVE="$IFS"
  IFS=,

  for arg in $1; do
    val="${arg#*=}"
    case "$arg" in
      iscsi_initiator=*)
        option="-i"
        ;;
      iscsi_target_name=*)
        option="-t"
        ;;
      iscsi_target_ip=*)
        option="-a"
        ;;
      iscsi_target_port=*)
        option="-p"
        ;;
      iscsi_target_group=*)
        option="-g"
        ;;
      iscsi_username=*)
        option="-u"
        ;;
      iscsi_password=*)
        option="-w"
        ;;
      iscsi_in_username=*)
        option="-U"
        ;;
      iscsi_in_password=*)
        option="-W"
        ;;
    esac
    echo "$option $val"
  done

  IFS="$IFS_SAVE"
}

mount_iscsi() {
  # Mount iSCSI target
  ISCSI_DEV="${1##*,}"
  ISCSI_OPTIONS="${1%,*}"

  if [ ! -f "/usr/sbin/iscsistart" ]; then
    error "iscsistart" "iSCSI support not available"
  fi

  if [ "$ISCSI_OPTIONS" = "auto" ]; then
    progress "Network configuration based on iBFT"
    /usr/sbin/iscsistart -N >&$SILENT_OUT 2>&1 || error "iscsistart" "Unable to configure network"
    progress "iSCSI auto connect based on iBFT"
    /usr/sbin/iscsistart -b >&$SILENT_OUT 2>&1 || error "iscsistart" "Unable to auto connect"
  else
    /usr/sbin/iscsistart $(get_iscsistart_options "$ISCSI_OPTIONS") >&$SILENT_OUT 2>&1 || error "iscsistart" "Unable to connect to ISCSI target"
  fi

  mount_common "$ISCSI_DEV" "$2" "$3" "$4"
}

mount_nbd() {
# Mount NBD device
  NBD_SERVER="${1%%:*}"
  NBD_PORT="${1#*:}"
  NBD_DEV="/dev/nbd$NBD_DEVS"

  nbd-client $NBD_SERVER $NBD_PORT $NBD_DEV >&$SILENT_OUT 2>&1 || error "nbd-client" "Could not connect to NBD server $1"

  mount_common "$NBD_DEV" "$2" "$3" "$4"

  NBD_DEVS=$(( NBD_DEVS + 1 ))
}

mount_nfs() {
  # Mount NFS export
  NFS_EXPORT="${1%%,*}"
  NFS_OPTIONS="${1#*,}"

  [ "$NFS_OPTIONS" = "$1" ] && NFS_OPTIONS=

  mount_common "$NFS_EXPORT" "$2" "$3,nolock,soft,timeo=3,retrans=2,rsize=32768,wsize=32768,$NFS_OPTIONS" "nfs"
}

mount_ubifs() {
  mount_common "$1" "$2" "$3" "ubifs"
}

mount_part() {
  # Mount a local or network filesystem
  # $1:[TYPE=]target, $2:mountpoint, $3:mount options, [$4:fs type]
  progress "mount filesystem $1 ..."

  MOUNT_TARGET="${1#*=}"
  case $1 in
    /dev/ubi*)
      MOUNT_CMD="mount_ubifs"
      MOUNT_TARGET="$1"
      RUN_FSCK="no"
      ;;
    LABEL=*|UUID=*|/*)
      MOUNT_CMD="mount_common"
      MOUNT_TARGET="$1"
      ;;
    ISCSI=*)
      MOUNT_CMD="mount_iscsi"
      ;;
    NBD=*)
      MOUNT_CMD="mount_nbd"
      ;;
    NFS=*)
      MOUNT_CMD="mount_nfs"
      ;;
    *)
      error "mount_part" "Unknown filesystem $1"
      ;;
  esac

  # Substitute unique identifier if available or remove placeholder
  MOUNT_TARGET="${MOUNT_TARGET//@UID@/$MACHINE_UID}"

  $MOUNT_CMD "$MOUNT_TARGET" "$2" "$3" "$4"
}

# mount the specified SYSTEM file and output arch from /etc/os-release
get_project_arch() {
  mount_part "$1" "/sysroot" "ro,loop" || return

  if [ -f /sysroot/etc/os-release ]; then
    . /sysroot/etc/os-release
    echo "${OPENELEC_ARCH:-${LIBREELEC_ARCH}}"
  fi

  umount /sysroot
}

# If the project/arch of current matches the upgrade, then it is considered compatible.
# Otherwise, mount the upgrade SYSTEM partition and, if canupdate.sh is available,
# call the script to determine if the current upgrade file can be applied on to the
# current system - 0 means it is compatible, non-zero that it is not compatible.
is_compatible() {
  local result=1

  if [ "${2}" = "${3}" ]; then
    result=0
  else
    mount_part "$1" "/sysroot" "ro,loop"

    if [ -f /sysroot/usr/share/bootloader/canupdate.sh ]; then
      sh /sysroot/usr/share/bootloader/canupdate.sh "${2}" "${3}" && result=0
    fi

    umount /sysroot
  fi

  return ${result}
}

# determine if the new SYSTEM file is compatible with the current SYSTEM file
check_is_compatible() {
  local update_filename="${1}"
  local old_system="${2}"
  local new_system="${3}"
  local old_project_arch new_project_arch

  old_project_arch="$(get_project_arch "${old_system}")" || return
  new_project_arch="$(get_project_arch "${new_system}")" || return

  # If old or new project/arch isn't available then could be very old (pre-/etc/os-release) build - have to trust it
  if [ -n "${old_project_arch}" -a -n "${new_project_arch}" ]; then
    # If the old project/arch is not compatible with the new project/arch then abort...
    if ! is_compatible "${new_system}" "${old_project_arch}" "${new_project_arch}"; then
      echo ""
      echo "ERROR: $(basename "${update_filename}") is not compatible with ${old_project_arch} hardware - update cancelled."
      echo ""
      echo "Current system: ${old_project_arch}"
      echo "Update  system: ${new_project_arch}"
      echo ""
      echo "Create $UPDATE_ROOT/.nocompat to disable compatibility checks and risk a non-booting system."
      echo ""
      return 1
    fi
  fi

  return 0
}

update_file() {
  if [ -f "$UPDATE_DIR/$2" -a -f "$3" ]; then
    mount -o remount,rw /flash

    StartProgress percent "Updating $1... " "$3" $(stat -t "$UPDATE_DIR/$2" | awk '{print $2}')
      # use dd here with conv=fsync so that all writes are non-buffered
      # ensuring accurate progress - take the sync hit during the
      # transfer, rather than when flushing file buffers after the progress
      # meter declares the transfer already complete
      dd if=$UPDATE_DIR/$2 of=$3 bs=1M conv=fsync 2>/dev/null
      StopProgress

    # loopback file needs writable /flash all the time
    if [ "${disk%%=*}" != "FILE" ]; then
      mount -o remount,ro /flash
    fi
    sync
  fi
}

update_partition() {
  local result

  if [ -f "$UPDATE_DIR/$2" -a -b "$3" ]; then
    StartProgress spinner "Updating $1... "
      result="$(dd if="$UPDATE_DIR/$2" of="$3" 2>&1)"
      StopProgress "done"
    echo "${result}"
  fi
}

update_bootloader() {
  local result

  export BOOT_ROOT="/flash"
  export SYSTEM_ROOT="/sysroot"

  mount_part "/flash/$IMAGE_SYSTEM" "/sysroot" "ro,loop"

  if [ -f $SYSTEM_ROOT/usr/share/bootloader/update.sh ]; then
    StartProgress spinner "Updating Boot Files... "
      result="$(sh $SYSTEM_ROOT/usr/share/bootloader/update.sh 2>&1)"
      sync
      StopProgress "done"
    [ -n "${result}" ] && echo "${result}"
  fi

  umount /sysroot
}

do_reboot() {
  echo "System reboots now..."

  # syncing filesystem
  sync

  # unmount filesystems
  if /usr/bin/busybox mountpoint -q /flash ; then
    /usr/bin/busybox umount /flash
  fi

  if /usr/bin/busybox mountpoint -q /storage ; then
    /usr/bin/busybox umount /storage
  fi

  usleep 2000000
  /usr/bin/busybox reboot
}

force_fsck() {
  echo "Filesystem corruption has been detected!"
  echo "To prevent an automatic repair attempt continuing,"
  echo "press any key or power off your system within the next 120 seconds"
  echo ""
  read -t120 -n1
  # The exit status is 0 if input is available
  # The exit status is greater than 128 if the timeout is exceeded
  if [ $? -ne 0 -o $? -gt 128 ]; then
    echo "Repairing filesystem..."
    echo ""
    /usr/sbin/fsck -T -M -y $RUN_FSCK_DISKS
    FSCK_RET=$?
    if [ $(( $FSCK_RET & 8 )) -eq 8 ]; then
      # fubar
      echo "Forced fsck failed. Your system is broken beyond repair"
      echo "Please re-install @DISTRONAME@"
      echo ""
      echo "Press enter to shutdown now"
      echo ""
      read fubar
      poweroff
    fi
    do_reboot
  else
    echo "Shutting down..."
    sleep 5
    sync
    poweroff
  fi
}

wakeonlan() {
  if [ "$STORAGE_NETBOOT" = "yes" ]; then
    wol_ip=${disk%:*}
    wol_ip=${wol_ip#*=}
  elif [ "$FLASH_NETBOOT" = "yes" ]; then
    wol_ip=${boot%:*}
    wol_ip=${wol_ip#*=}
  else
    return 0
  fi

  if [ -n "$wol_ip" -a -n "$wol_mac" -a -n "$wol_wait" ]; then
    progress "Sending Magic Packet (WOL) if needed"

    if ! ping -q -c 2 "$wol_ip" &>/dev/null; then
      ether-wake "$wol_mac"
      StartProgress countdown "WOL magic packet sent to $wol_ip, waiting $wol_wait seconds... " $wol_wait "done"
    fi
  fi
}

mount_flash() {
  progress "Mounting flash"

  mount_part "$boot" "/flash" "ro,noatime"
}

mount_storage() {
  progress "Mounting storage"

  # mount tmpfs and exit early. disk=xx is not allowed in live mode
  mount -t tmpfs none /storage
}

check_out_of_space() {
  if [ "$(df /storage | awk '/[0-9]%/{print $4}')" -eq "0" ]; then
    echo ""
    echo "The $1 is corrupt, or there is not enough"
    echo "free space on /storage to complete the upgrade!"
    echo ""
    echo "Please free up space on your /storage partition"
    echo "by deleting unecessary files, then try again."
    echo ""
    return 0
  else
    echo ""
    echo "The $1 is corrupt/invalid!"
    echo ""
    return 1
  fi
}

do_cleanup() {
  StartProgress spinner "Cleaning up... "

  if [ -d $UPDATE_ROOT/.tmp/mnt ]; then
    if mountpoint -q $UPDATE_ROOT/.tmp/mnt ; then
      # busybox umount deletes loop device automatically
      umount $UPDATE_ROOT/.tmp/mnt
    fi

    [ -n $LOOP ] && losetup -d $LOOP &>/dev/null
  fi

  [ -f "$UPDATE_TAR" ] && rm -f "$UPDATE_TAR" &>/dev/null
  [ -f "$UPDATE_IMG_GZ" ] && rm -f "$UPDATE_IMG_GZ" &>/dev/null
  [ -f "$UPDATE_IMG" ] && rm -f "$UPDATE_IMG" &>/dev/null

  rm -rf $UPDATE_ROOT/.tmp &>/dev/null
  rm -rf $UPDATE_ROOT/[0-9a-zA-Z]* &>/dev/null
  rm -f  $UPDATE_ROOT/.nocheck $UPDATE_ROOT/.nocompat &>/dev/null

  sync

  StopProgress "done"
}

prepare_sysroot() {
  progress "Preparing system"

  if [ "$SYSTEM_TORAM" = "no" -o "$INSTALLED_MEMORY" -lt "$SYSTEM_TORAM_LIMIT" ]; then
    mount_part "/flash/$IMAGE_SYSTEM" "/sysroot" "ro,loop"
  else
    cp /flash/$IMAGE_SYSTEM /dev/$IMAGE_SYSTEM
    mount_part "/dev/$IMAGE_SYSTEM" "/sysroot" "ro,loop"
  fi

  if [ ! -d "/sysroot/usr/lib/kernel-overlays/base/lib/modules/$(uname -r)/" -a -f "/sysroot/usr/lib/systemd/systemd" ]; then
    echo ""
    echo "NEVER TOUCH boot= in syslinux.conf / cmdline.txt!"
    echo "If you don't know what you are doing,"
    echo "your installation is now broken."
    echo ""
    StartProgress countdown "Normal startup in 60s... " 60 "NOW"
  fi

  [ -f "/sysroot/usr/lib/systemd/systemd" ] || error "final_check" "Could not find systemd!"
}

# Do init tasks to bring up system

# hide kernel log messages on console
echo '1 4 1 7' > /proc/sys/kernel/printk

# set ondemand up_threshold
if [ -e /sys/devices/system/cpu/cpufreq/ondemand/up_threshold ]; then
  echo 50 > /sys/devices/system/cpu/cpufreq/ondemand/up_threshold
else
  for f in $(ls /sys/devices/system/cpu/cpufreq/policy*/ondemand/up_threshold 2>/dev/null) ; do
    echo 50 > $f
  done
fi

# run platform_init script if exists
if [ -f "./platform_init" ]; then
  ./platform_init
fi

# parse command line arguments
for arg in $(cat /proc/cmdline); do
  case $arg in
    BOOT_IMAGE=*)
      IMAGE_KERNEL="${arg#*=}"
      [ "${IMAGE_KERNEL:0:1}" = "/" ] && IMAGE_KERNEL="${IMAGE_KERNEL:1}"
      ;;
    SYSTEM_IMAGE=*)
      IMAGE_SYSTEM="${arg#*=}"
      [ "${IMAGE_SYSTEM:0:1}" = "/" ] && IMAGE_SYSTEM="${IMAGE_SYSTEM:1}"
      ;;
    boot=*)
      boot="${arg#*=}"
      case $boot in
        ISCSI=*|NBD=*|NFS=*)
          UPDATE_DISABLED=yes
          FLASH_NETBOOT=yes
          ;;
        /dev/*|LABEL=*|UUID=*)
          RUN_FSCK_DISKS="$RUN_FSCK_DISKS $boot"
          ;;
      esac
      ;;
    disk=*)
      disk="${arg#*=}"
      case $disk in
        ISCSI=*|NBD=*|NFS=*)
          STORAGE_NETBOOT=yes
          ;;
        /dev/*|LABEL=*|UUID=*)
          RUN_FSCK_DISKS="$RUN_FSCK_DISKS $disk"
          ;;
      esac
      ;;
    wol_mac=*)
      wol_mac="${arg#*=}"
      ;;
    wol_wait=*)
      wol_wait="${arg#*=}"
      ;;
    textmode)
      INIT_UNIT="--unit=textmode.target"
      ;;
    installer)
      INIT_UNIT="--unit=installer.target"
      SYSLINUX_DEFAULT="installer"
      ;;
    debugging)
      DEBUG=yes
      ;;
    progress)
      PROGRESS=yes
      INIT_ARGS="$INIT_ARGS --show-status=1"
      ;;
    nofsck)
      RUN_FSCK=no
      ;;
    nosplash)
      SPLASH=no
      ;;
    noram)
      SYSTEM_TORAM=no
      ;;
    ramlimit=*)
      SYSTEM_TORAM_LIMIT="${arg#*=}"
      ;;
    live)
      LIVE=yes
      SYSLINUX_DEFAULT="live"
      ;;
    portable)
      SYSLINUX_DEFAULT="run"
      ;;
    grub_live)
      LIVE=yes
      GRUB_DEFAULT="Live"
      ;;
    grub_portable)
      GRUB_DEFAULT="Run"
      ;;
    overlay)
      OVERLAY=yes
      ;;
    setfbres=*)
      SWITCH_FRAMEBUFFER="${arg#*=}"
      SWITCH_FRAMEBUFFER="${SWITCH_FRAMEBUFFER//,/ }"
      ;;
    break=*)
      BREAK="${arg#*=}"
      ;;
  esac
done

if test "$DEBUG" = "yes"; then
  exec 3>&1
else
  exec 3>/dev/null
fi
SILENT_OUT=3

# If the network is up (due to the use of the "ip" kernel parameter) and a DNS
# server is known, allow the libc resolver to use it
grep '^\(nameserver\|domain\) ' /proc/net/pnp | grep -v '^nameserver 0\.0\.0\.0$' > /etc/resolv.conf

if [ "${boot%%=*}" = "FILE" ]; then
  error "check arguments" "boot argument can't be FILE type..."
fi

debug_msg "Unique identifier for this client: ${MACHINE_UID:-NOT AVAILABLE}"

# main boot sequence
for BOOT_STEP in \
    mount_flash \
    prepare_sysroot; do
  $BOOT_STEP
  [ -n "$DEBUG" ] && break_after $BOOT_STEP
done
